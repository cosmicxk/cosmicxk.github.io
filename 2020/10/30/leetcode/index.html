<!DOCTYPE html>





<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/houselove32.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/houselove16.png?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css">
  <script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.3.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    save_scroll: false,
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    }
  };



</script>

  <meta name="description" content="Fighting LeetCode Record!!!">
<meta name="keywords" content="C++">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode">
<meta property="og:url" content="https://space.bilibili.com/34033362/#/bangumi/2020/10/30/leetcode/index.html">
<meta property="og:site_name" content="xingkong">
<meta property="og:description" content="Fighting LeetCode Record!!!">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://space.bilibili.com/pictrues/Offer/7_1.png">
<meta property="og:image" content="https://space.bilibili.com/pictrues/Offer/14-1.png">
<meta property="og:image" content="https://space.bilibili.com/pictrues/Offer/16.png">
<meta property="og:image" content="https://space.bilibili.com/pictrues/Offer/19.png">
<meta property="og:image" content="https://space.bilibili.com/pictrues/Offer/26.png">
<meta property="og:image" content="https://space.bilibili.com/pictrues/Offer/26-1.png">
<meta property="og:image" content="https://space.bilibili.com/pictrues/Offer/35.png">
<meta property="og:image" content="https://space.bilibili.com/pictrues/Offer/43.png">
<meta property="og:image" content="https://space.bilibili.com/pictrues/Offer/51.png">
<meta property="og:image" content="https://space.bilibili.com/pictrues/Offer/55-2.png">
<meta property="og:image" content="https://space.bilibili.com/pictrues/Offer/56-1.png">
<meta property="og:image" content="https://space.bilibili.com/pictrues/Offer/56-2.png">
<meta property="og:image" content="https://space.bilibili.com/pictrues/11.png">
<meta property="og:image" content="https://space.bilibili.com/pictrues/bit.png">
<meta property="og:image" content="https://space.bilibili.com/pictrues/149_2.png">
<meta property="og:image" content="https://space.bilibili.com/pictrues/max.png">
<meta property="og:image" content="https://space.bilibili.com/pictrues/maxmin.png">
<meta property="og:image" content="https://space.bilibili.com/pictrues/198.png">
<meta property="og:image" content="https://space.bilibili.com/pictrues/218.png">
<meta property="og:image" content="https://space.bilibili.com/pictrues/220.png">
<meta property="og:image" content="https://space.bilibili.com/pictrues/220_1.png">
<meta property="og:image" content="https://space.bilibili.com/pictrues/284.png">
<meta property="og:image" content="https://space.bilibili.com/pictrues/287.png">
<meta property="og:image" content="https://space.bilibili.com/pictrues/287_1.png">
<meta property="og:image" content="https://space.bilibili.com/pictrues/287_2.png">
<meta property="og:image" content="https://space.bilibili.com/pictrues/list.png">
<meta property="og:image" content="https://space.bilibili.com/pictrues/3.jpg">
<meta property="og:image" content="https://space.bilibili.com/pictrues/5.jpg">
<meta property="og:image" content="https://space.bilibili.com/pictrues/Z%E5%BD%A2.png">
<meta property="og:image" content="https://space.bilibili.com/pictrues/Z%E5%BD%A21.png">
<meta property="og:image" content="https://space.bilibili.com/pictrues/Z.jpg">
<meta property="og:image" content="https://space.bilibili.com/pictrues/mul.png">
<meta property="og:image" content="https://space.bilibili.com/pictrues/dp.png">
<meta property="og:image" content="https://space.bilibili.com/pictrues/65.png">
<meta property="og:image" content="https://space.bilibili.com/pictrues/65_1.png">
<meta property="og:image" content="https://space.bilibili.com/pictrues/224.png">
<meta property="og:image" content="https://space.bilibili.com/pictrues/%E4%BA%8C%E5%8F%89%E6%A0%911.png">
<meta property="og:image" content="https://space.bilibili.com/pictrues/%E4%BA%8C%E5%8F%89%E6%A0%912.png">
<meta property="og:image" content="https://space.bilibili.com/pictrues/222.png">
<meta property="og:image" content="https://space.bilibili.com/pictrues/236.png">
<meta property="og:image" content="https://space.bilibili.com/pictrues/233.png">
<meta property="og:image" content="https://space.bilibili.com/pictrues/264.png">
<meta property="og:image" content="https://space.bilibili.com/pictrues/156.png">
<meta property="og:updated_time" content="2022-01-12T13:15:04.861Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeetCode">
<meta name="twitter:description" content="Fighting LeetCode Record!!!">
<meta name="twitter:image" content="https://space.bilibili.com/pictrues/Offer/7_1.png">
  <link rel="canonical" href="https://space.bilibili.com/34033362/#/bangumi/2020/10/30/leetcode/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>LeetCode | xingkong</title>
  <meta name="generator" content="Hexo 3.9.0">
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

  <script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css"/>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  <div class="container sidebar-position-left">
    <div class="headband"></div>
    <a href="https://github.com/cosmicxk" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">xingkong</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger">
        
          <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
      </li>
    
  </ul>

</nav>
  <div class="site-search">
    
  <div class="popup search-popup">
  <div class="search-header">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <div class="search-input-wrapper">
      <input autocomplete="off" autocorrect="off" autocapitalize="none"
             placeholder="搜索..." spellcheck="false"
             type="text" id="search-input">
    </div>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>
  <div id="search-result"></div>
</div>


  </div>
</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content page-post-detail">
            

  <div id="posts" class="posts-expand">
    

  <article class="post" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://space.bilibili.com/34033362/#/bangumi/2020/10/30/leetcode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xingkang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/2.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xingkong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">LeetCode

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-10-30 20:45:39" itemprop="dateCreated datePublished" datetime="2020-10-30T20:45:39+08:00">2020-10-30</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-12 21:15:04" itemprop="dateModified" datetime="2022-01-12T21:15:04+08:00">2022-01-12</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a></span>

                
                
              
            </span>
          

          
            <span class="post-meta-item" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
        
      
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/10/30/leetcode/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2020/10/30/leetcode/" itemprop="commentCount"></span></a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Fighting LeetCode Record!!!</p>
<a id="more"></a>

<h1 id="剑指-Offer"><a href="#剑指-Offer" class="headerlink" title="剑指 Offer"></a>剑指 Offer</h1><blockquote>
<p>2021.6.22 启动。<br>这个系列就不在 <code>Clion</code> 写了，直接看书和 <code>LeetCode</code> 上写。</p>
</blockquote>
<h2 id="1-赋值运算符函数"><a href="#1-赋值运算符函数" class="headerlink" title="1_赋值运算符函数"></a>1_赋值运算符函数</h2><ul>
<li><p>力扣上没有第一第二道 剑指 Offer 题，为了保持一致性，这里按照书上，加上去</p>
</li>
<li><p>考点</p>
<ul>
<li>返回类型为引用 —— 这样就可以连续赋值</li>
<li>参数为常量引用 —— 减小无谓消耗</li>
<li>释放实例自身的内存</li>
<li>判断是否是自赋值</li>
</ul>
</li>
<li><p><a href="https://github.com/zhedahht/CodingInterviewChinese2/" target="_blank" rel="noopener">代码链接</a></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CMyString(<span class="keyword">char</span>* pData = <span class="literal">nullptr</span>);</span><br><span class="line">    CMyString(<span class="keyword">const</span> CMyString&amp; str);</span><br><span class="line">    ~CMyString(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line">    CMyString&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> CMyString&amp; str);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span>;</span><br><span class="line">      </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* m_pData;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CMyString::CMyString(<span class="keyword">char</span> *pData)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(pData == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_pData = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">        m_pData[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="built_in">strlen</span>(pData);</span><br><span class="line">        m_pData = <span class="keyword">new</span> <span class="keyword">char</span>[length + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(m_pData, pData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CMyString::CMyString(<span class="keyword">const</span> CMyString &amp;str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="built_in">strlen</span>(str.m_pData);</span><br><span class="line">    m_pData = <span class="keyword">new</span> <span class="keyword">char</span>[length + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(m_pData, str.m_pData);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CMyString::~CMyString()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] m_pData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值运算符</span></span><br><span class="line">CMyString&amp; CMyString::<span class="keyword">operator</span> = (<span class="keyword">const</span> CMyString&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;str)</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> []m_pData;</span><br><span class="line">    m_pData = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    m_pData = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str.m_pData) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(m_pData, str.m_pData);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面是应届生以及初级程序员的要求——高级的看这儿<ul>
<li>上面<code>new</code>字符串，不知道能不能成功分配，就把原来的内存释放掉，这样很危险</li>
<li>两种方法——先分配在释放——直接创建新的参数对象，调用构造函数（完整的构造一遍，而不是只构造字符串），交换对应的指针，赋值结束，临时对象调用析构函数，会释放掉原来的内存！！</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CMyString&amp; CMyString::<span class="keyword">operator</span> = (<span class="keyword">const</span> CMyString&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;str)&#123;</span><br><span class="line">		<span class="comment">//这里在构造的时候，会用new，如果出现异常，不会影响到已有的实例</span></span><br><span class="line">		CMyString tmp(str);</span><br><span class="line">		<span class="keyword">char</span>* ptmp = tmp.m_pData;</span><br><span class="line">		tmp.m_pData = m_pData;</span><br><span class="line">		m_pData = ptmp;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-实现Singleton模式"><a href="#2-实现Singleton模式" class="headerlink" title="2_实现Singleton模式"></a>2_实现Singleton模式</h2><ul>
<li>这是单例模式！设计模式还没怎么看呢…</li>
</ul>
<h2 id="3-数组中重复的数字"><a href="#3-数组中重复的数字" class="headerlink" title="3_数组中重复的数字"></a>3_数组中重复的数字</h2><ul>
<li>单例模式那题先跳过！</li>
<li>这题之前做的那个链表找环——也是找重复数，不知道在这儿好不好使</li>
<li>先哈希一遍！但是时间消耗不怎么好看——因为元素范围固定，也可以用数组，判断当前位置是否已经出现过，代码就不放了<ul>
<li>书上和题解大佬评论里出现了不同的方法，先整理下大佬的思路，再剖析书上的</li>
<li>一个小注意点——如果在循环里就返回值了，最后可以返回-1之类的，根据返回类型，<code>return -1;</code></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//会修改数组内容</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> k = nums[i];</span><br><span class="line">            <span class="comment">//这里要打打草稿，要不然看不懂!</span></span><br><span class="line">            <span class="keyword">if</span>(k &lt; <span class="number">0</span>) k += n;</span><br><span class="line">            <span class="comment">//这里如果之前遇到一次k，那么就会出现已经是负的</span></span><br><span class="line">            <span class="keyword">if</span>(nums[k] &lt; <span class="number">0</span>) <span class="keyword">return</span> k;</span><br><span class="line">            nums[k] -= n;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>书上思路，修改数组、不修改数组<ul>
<li>先判断下标与对应的数字是否相等，若不等，再和数字作为下标的元素相比较！</li>
<li>修改数组是不停地交换数字直到对应的下标与元素相等；前提就是长度为<code>n</code>，数字都在<code>0 ~ n-1</code>之间</li>
<li>下次遇到重复的数字时，就会发现不同的下标出现了相同的数字</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//书上交换——自己手撕版本</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findRepeatNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        //会修改数组内容</span><br><span class="line">        for(int i = 0; i &lt; nums.size(); ++i)&#123;</span><br><span class="line">            //先判断i与nums[i]是否相等</span><br><span class="line">            int m = nums[i];</span><br><span class="line">            if(i == m)&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                //再判断nums[i]与nums[nums[i]]是否相等</span><br><span class="line">                if(m == nums[m])&#123;</span><br><span class="line">                    //这里m重复</span><br><span class="line">                    return m;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    //一直交换，直到下标i与这个位置上的数字相等</span><br><span class="line">                    while(m != i)&#123;</span><br><span class="line">                        swap(nums[i], nums[m]);</span><br><span class="line">                        m = nums[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>不修改数组，但是这个方法有点繁琐，因为每次都要遍历一遍数组查看元素范围出现的总次数，就不粘贴代码了</li>
</ul>
<h2 id="4-二维数组中的查找"><a href="#4-二维数组中的查找" class="headerlink" title="4_二维数组中的查找"></a>4_二维数组中的查找</h2><ul>
<li>这题做过，印象比较深刻<ul>
<li>但当时比较稀里糊涂，没有理解透彻，今天再好好琢磨下</li>
<li>还是一开始想用二分，但是二分有横坐标、纵坐标，然后想着想着——搜索二叉树，从左下角开始，脑海里渐渐浮出了当时看题解的印象</li>
<li>除了一开始就比较最小和最大的元素，看目标值是否在二维数组内，但是在这之前，要先判断数组是否为空</li>
<li>二维数组——要判断两次是否为空</li>
</ul>
</li>
<li>但是最后显示错误——无符号溢出？？下标出现了小于0的数字-1，可是我在<code>while</code>循环里加了条件啊？<ul>
<li>测试了以下，之前写的是连续3个<code>if</code>语句，改成<code>if else</code>之后就可以了！！！这是为什么呢</li>
<li>嗷！因为之前小标减小后小于1，又在最后一个<code>if</code>语句比较了一遍！怪不得</li>
</ul>
</li>
<li>书上也是类似的思路——从右上角开始的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//自己手撕版本</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool findNumberIn2DArray(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123;</span><br><span class="line">        if(matrix.empty() || matrix[0].empty() || target &lt; matrix[0][0] || target &gt; matrix.back().back())&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int r = matrix.size(), c = matrix[0].size();</span><br><span class="line">        int i = r - 1, j = 0;</span><br><span class="line">        while(i &gt;= 0 &amp;&amp; j &lt; c)&#123;</span><br><span class="line">            if(matrix[i][j] == target)&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else if(matrix[i][j] &gt; target)&#123;</span><br><span class="line">                --i;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="5-替换空格"><a href="#5-替换空格" class="headerlink" title="5_替换空格"></a>5_替换空格</h2><ul>
<li>这题看起来很简单嘛，看看有没有什么坑在里面，这应该考察的是各个编程语言的字符串</li>
<li>如果使用字符数组，那就得考虑长度了<ul>
<li>这题考察的是合并两个数组！</li>
<li>书上是直接在原数组后面加长，一个空格就会变长2格，之后双指针（从后往前），其中一个一次移动一格，另一个在对方遇到空格时，移动三格，在移动的过程中，都要复制原来的字符或者要替换的字符</li>
<li>这题比较简单，再做一题吧</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string replaceSpace(string s) &#123;</span><br><span class="line">        if(s.empty()) return string();</span><br><span class="line">        //不知道这题有啥好的方法，先遍历吧</span><br><span class="line">        string ans;</span><br><span class="line">        for(auto ch : s)&#123;</span><br><span class="line">            if(ch == &apos; &apos;)&#123;</span><br><span class="line">                ans += &quot;%20&quot;;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                ans.push_back(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="6-从尾到头打印链表"><a href="#6-从尾到头打印链表" class="headerlink" title="6_从尾到头打印链表"></a>6_从尾到头打印链表</h2><ul>
<li>看了之前的引言，如果是要删除某个特定值的节点，那最后要<code>delete</code>一下，并置空</li>
<li>这题应该先反转，最后再顺序输出——出了点问题，没有一次性过，看来迭代反转链表还要再巩固下<ul>
<li><code>cur</code>明明在条件里判断不为空了，为空就会结束循环，为什么还会无限循环呢？</li>
<li>嗷，原来是输出数组的时候，忘记加<code>pre = pre-&gt;next;</code>了，难怪！</li>
<li>题解也用了栈，甚至有大佬直接用递归，厉害！因为题目可能不准修改原链表，所以这个鲁棒性好</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"> //反转链表</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; reversePrint(ListNode* head) &#123;</span><br><span class="line">        if(!head) return vector&lt;int&gt;();</span><br><span class="line"></span><br><span class="line">        ListNode* pre = nullptr;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line"></span><br><span class="line">        while(cur != nullptr)&#123;</span><br><span class="line">            ListNode* tmp = cur-&gt;next;</span><br><span class="line"></span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        //pre是新的头节点</span><br><span class="line">        vector&lt;int&gt; ans;</span><br><span class="line">        while(pre != nullptr)&#123;</span><br><span class="line">            ans.emplace_back(pre-&gt;val);</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//递归</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; reversePrint(ListNode* head) &#123;</span><br><span class="line">        if(!head) return vector&lt;int&gt;();</span><br><span class="line">        vector&lt;int&gt; a = reversePrint(head-&gt;next);</span><br><span class="line">        //这里递归返回后是最后一个不为空的元素</span><br><span class="line">        a.emplace_back(head-&gt;val);</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="7-重建二叉树"><a href="#7-重建二叉树" class="headerlink" title="7_重建二叉树"></a>7_重建二叉树</h2><ul>
<li>给出前序遍历、中序遍历，然后恢复二叉树，之前师兄的面试题有这个，但那是填空题<ul>
<li>而且这居然是105题，果然不巩固就会忘</li>
<li>想起来了，当时应该用的是分治</li>
</ul>
</li>
<li>把这两个数组都分为三个部分——根节点、左子树、右子树，应该先构建根节点，再递归返回左右两边的节点<ul>
<li>这样应该要标记下下标，从哪儿到哪儿</li>
<li><code>vector</code>没有<code>find</code>函数，要找目标数字只能循环了吗</li>
<li>要不直接重新生成新的数组吧</li>
<li>用<code>copy</code>之前，要先将数组声明成一定大小，但是一直提示长度错误，那就换一种方法，用<code>copy(preorder.begin() + i + 1, preorder.end(), back_inserter(p2));</code>其中<code>p2</code>为空</li>
<li>再做的时候果然有好多问题，比如划分的时候；两个数组都是<code>[1,2]</code>，那么就没有左子树，而右子树是2，但是我的代码有漏洞，连右子树都没有了…而且递归的时候会出现一个数组有数字，另一个没有数字的情况！导致之后创建新节点的时候下标越界！</li>
<li>自己的代码就不放了，emmmm，那为什么我第一次做出来了？？</li>
</ul>
</li>
<li>题解用的是标记法，而且在这儿之前，用了哈希表来迅速定位根节点的位置，妙啊！</li>
<li>书上写的使用循环找到根节点的值</li>
</ul>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    unordered_map&lt;int, int&gt; index;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    TreeNode* myBuildTree(const vector&lt;int&gt;&amp; preorder, const vector&lt;int&gt;&amp; inorder, int preorder_left, int preorder_right, int inorder_left, int inorder_right) &#123;</span><br><span class="line">        if (preorder_left &gt; preorder_right) &#123;</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 前序遍历中的第一个节点就是根节点——下标</span><br><span class="line">        int preorder_root = preorder_left;</span><br><span class="line">        // 在中序遍历中定位根节点——下标</span><br><span class="line">        int inorder_root = index[preorder[preorder_root]];</span><br><span class="line">        </span><br><span class="line">        // 先把根节点建立出来</span><br><span class="line">        TreeNode* root = new TreeNode(preorder[preorder_root]);</span><br><span class="line">        // 得到左子树中的节点数目</span><br><span class="line">        int size_left_subtree = inorder_root - inorder_left;</span><br><span class="line">        // 递归地构造左子树，并连接到根节点</span><br><span class="line">        // 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素</span><br><span class="line">        root-&gt;left = myBuildTree(preorder, inorder, preorder_left + 1, preorder_left + size_left_subtree, inorder_left, inorder_root - 1);</span><br><span class="line">        // 递归地构造右子树，并连接到根节点</span><br><span class="line">        // 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素</span><br><span class="line">        root-&gt;right = myBuildTree(preorder, inorder, preorder_left + size_left_subtree + 1, preorder_right, inorder_root + 1, inorder_right);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;</span><br><span class="line">        int n = preorder.size();</span><br><span class="line">        // 构造哈希映射，帮助我们快速定位根节点</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            index[inorder[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        return myBuildTree(preorder, inorder, 0, n - 1, 0, n - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><ul>
<li>学习下迭代<ul>
<li>迭代——与栈联系紧密，栈中存放的应该是<code>TreeNode*</code>类型</li>
<li>言简意赅说一下步骤吧；将<code>preorder</code>遍历并且入栈，直到栈顶元素与<code>inorder</code>的初始指针0位置元素相等<ul>
<li>栈顶节点 4，也就是说 4 没有左儿子，那么 10 必须为栈中某个节点的右儿子。</li>
</ul>
</li>
<li>若<code>inorder</code>的指针指向的元素与栈顶元素相等，栈顶弹出，指针加一</li>
<li>直到不相等，将<code>inorder</code>的指针指向的元素10作为最后弹出的节点 8 的右儿子，并将 10 （<code>preorder</code>）入栈</li>
<li>10 入栈后与<code>inorder</code>的指针指向的元素10相等，继续弹，加一——指针只是起到加一的作用，入栈的还是<code>preorder</code>的数字</li>
<li>还有之后再次遍历的时候，若与指针指向的元素不等，要一直遍历入栈，直到相等</li>
<li>最后结束遍历，栈也为空</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/Offer/7_1.png" alt title="例子"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;</span><br><span class="line">        if (!preorder.size()) &#123;</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* root = new TreeNode(preorder[0]);</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        stk.push(root);</span><br><span class="line">        int inorderIndex = 0;</span><br><span class="line">        for (int i = 1; i &lt; preorder.size(); ++i) &#123;</span><br><span class="line">            //因为根节点已经入栈，所以从1开始</span><br><span class="line">            int preorderVal = preorder[i];</span><br><span class="line">            TreeNode* node = stk.top();</span><br><span class="line">            //这里比较的是栈顶节点与指针，而不是preorder[i]与指针</span><br><span class="line">            if (node-&gt;val != inorder[inorderIndex]) &#123;</span><br><span class="line">                node-&gt;left = new TreeNode(preorderVal);</span><br><span class="line">                stk.push(node-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                while (!stk.empty() &amp;&amp; stk.top()-&gt;val == inorder[inorderIndex]) &#123;</span><br><span class="line">                    //这里更新最后弹出的栈顶元素</span><br><span class="line">                    node = stk.top();</span><br><span class="line">                    stk.pop();</span><br><span class="line">                    ++inorderIndex;</span><br><span class="line">                &#125;</span><br><span class="line">                node-&gt;right = new TreeNode(preorderVal);</span><br><span class="line">                stk.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="8-二叉树的下一个节点"><a href="#8-二叉树的下一个节点" class="headerlink" title="8_二叉树的下一个节点"></a>8_二叉树的下一个节点</h2><ul>
<li><p>这题力扣上没有</p>
</li>
<li><p>题目的意思是，给一个二叉树，给定一个节点，然后写出按中序遍历原则的下一个节点</p>
<ul>
<li>分析——将给的节点当成根节点，然后下一个就是它的右子树的最左子节点！</li>
<li>如果没有右子树，那就看它的父节点是左还是右（这里的左右是参考本节点与父节点的位置）<ul>
<li>父节点为左：按照中序遍历原则，下一个节点就是父节点本身</li>
<li>父节点为右：这里要向上回溯，找到第一个节点（其父节点为左）</li>
</ul>
</li>
</ul>
</li>
<li><p>当然这个二叉树有三个指针——左、右、父</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">struct BinaryTreeNode</span><br><span class="line">&#123;</span><br><span class="line">    int                    m_nValue;</span><br><span class="line">    BinaryTreeNode*        m_pLeft;</span><br><span class="line">    BinaryTreeNode*        m_pRight;</span><br><span class="line">    BinaryTreeNode*        m_pParent;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">BinaryTreeNode* GetNext(BinaryTreeNode* pNode)</span><br><span class="line">&#123;</span><br><span class="line">    if(pNode == nullptr)</span><br><span class="line">        return nullptr;</span><br><span class="line">    //先声明为空</span><br><span class="line">    BinaryTreeNode* pNext = nullptr;</span><br><span class="line">    //有右子树——找到最左子节点</span><br><span class="line">    if(pNode-&gt;m_pRight != nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        BinaryTreeNode* pRight = pNode-&gt;m_pRight;</span><br><span class="line">        while(pRight-&gt;m_pLeft != nullptr)</span><br><span class="line">            pRight = pRight-&gt;m_pLeft;</span><br><span class="line"></span><br><span class="line">        pNext = pRight;</span><br><span class="line">    &#125;//没有右子树、并且父节点不为空</span><br><span class="line">    else if(pNode-&gt;m_pParent != nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        BinaryTreeNode* pCurrent = pNode;</span><br><span class="line">        BinaryTreeNode* pParent = pNode-&gt;m_pParent;</span><br><span class="line">        //一直找到第一个节点（其父节点为左）</span><br><span class="line">        while(pParent != nullptr &amp;&amp; pCurrent == pParent-&gt;m_pRight)</span><br><span class="line">        &#123;</span><br><span class="line">            pCurrent = pParent;</span><br><span class="line">            pParent = pParent-&gt;m_pParent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pNext = pParent;</span><br><span class="line">    &#125;</span><br><span class="line">    return pNext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-用两个栈实现队列"><a href="#9-用两个栈实现队列" class="headerlink" title="9_用两个栈实现队列"></a>9_用两个栈实现队列</h2><ul>
<li>印象深刻，记得当时是两个栈来回倒，一看题解发现，不需要来回倒，看看自己能不能再实现下<ul>
<li>专门用一个来当辅助（因为倒过去之后顺序是相反的）</li>
<li>可以，一次过</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//手撕</span><br><span class="line">class CQueue &#123;</span><br><span class="line">public:</span><br><span class="line">    CQueue() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void appendTail(int value) &#123;</span><br><span class="line">        stk.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int deleteHead() &#123;</span><br><span class="line">        if(stk.empty() &amp;&amp; stk_tmp.empty())&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;else if(!stk_tmp.empty())&#123;</span><br><span class="line">            int d = stk_tmp.top();</span><br><span class="line">            stk_tmp.pop();</span><br><span class="line">            return d;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            //stk_tmp为空、stk不为空</span><br><span class="line">            while(!stk.empty())&#123;</span><br><span class="line">                stk_tmp.push(stk.top());</span><br><span class="line">                stk.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            int d = stk_tmp.top();</span><br><span class="line">            stk_tmp.pop();</span><br><span class="line">            return d;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    stack&lt;int&gt; stk, stk_tmp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//题解——若stk_tmp为空，那么不管stk空不空，都倒进stk_tmp，若stk_tmp还是空，直接返回-1</span><br><span class="line">//这里就不放了</span><br></pre></td></tr></table></figure>

<ul>
<li>书差点忘记看了…<ul>
<li>思路是一样的，另外还提到了双队列实现栈，而这里面的双队列就是等价的了</li>
</ul>
</li>
</ul>
<h2 id="10-1-斐波那契数列"><a href="#10-1-斐波那契数列" class="headerlink" title="10-1_斐波那契数列"></a>10-1_斐波那契数列</h2><ul>
<li>递归就只有两三行代码，但我估计会溢出<ul>
<li>试了下，四十几就溢出了</li>
<li>因为每次都有两个递归，然后就会不停的重复，指数级别的重复！！</li>
</ul>
</li>
<li>试下动态规划！也就是循环，速度很快！——这题没有官方题解，看会儿书<ul>
<li>书上还提到了数学方法，也就是矩阵运算，但是需要自己实现矩阵运算</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//动规——也可以是循环</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int fib(int n) &#123;</span><br><span class="line">        if(n &lt; 2) return n;</span><br><span class="line">        //这里突然想到滚动数组的思想</span><br><span class="line">        int n2 = 0, n1 = 1;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        for(int i = 2; i &lt;= n; ++i)&#123;</span><br><span class="line">            ans = (n1 + n2) % 1000000007;</span><br><span class="line">            n2 = n1 % 1000000007;</span><br><span class="line">            n1 = ans;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="10-2-青蛙跳台阶问题"><a href="#10-2-青蛙跳台阶问题" class="headerlink" title="10-2_青蛙跳台阶问题"></a>10-2_青蛙跳台阶问题</h2><ul>
<li>这题也有点印象，记得当时是排列组合算出来的！</li>
<li>这次用动态规划看看、<ul>
<li><code>f(n)</code>是到当前台阶的跳法zongshu</li>
<li>那么<code>f(n)</code>与<code>f(n-1)</code>的关系就是<code>f(n)=f(n-1)</code></li>
<li>么<code>f(n)</code>与<code>f(n-2)</code>的关系就是两倍关系？不对，一步一步跳会与<code>f(n-1)</code>重复，所以只能两步跳</li>
<li>那么这一题与上一题就是初始状态不一样</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int numWays(int n) &#123;</span><br><span class="line">        //当前状态和前两个状态有关</span><br><span class="line">        if(n &lt; 2) return 1;</span><br><span class="line"></span><br><span class="line">        int ans = 0, n1 = 1, n2 = 1;</span><br><span class="line">        for(int i = 2; i &lt;= n; ++i)&#123;</span><br><span class="line">            ans = (n1 + n2) % 1000000007;</span><br><span class="line">            n2 = n1;</span><br><span class="line">            n1 = ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="11-旋转数组的最小数字"><a href="#11-旋转数组的最小数字" class="headerlink" title="11_旋转数组的最小数字"></a>11_旋转数组的最小数字</h2><ul>
<li><p>与154一样</p>
<ul>
<li>这题数字是可以重复的，但为什么这题简单，力扣154就是困难呢</li>
<li>有重复的，应该找二分法找左右边界？</li>
<li>最小数字的左边要是边界，要么比它大</li>
</ul>
</li>
<li><p>记得当时，没有绕明白，现在再理一遍</p>
<ul>
<li>一开始<code>l</code>在最左边，<code>r</code>在末尾（<code>end()</code>），左闭右开——等等，这里应该都是闭区间比较好写</li>
<li>最小值一定在两者之间，这种情况下，若<code>numbers[l] == numbers[r]</code>，就让<code>r--</code>；</li>
<li>至于加一还是减一，就看这个数是否判断过了</li>
<li>这题好难啊——最外层又套了个<code>if else</code>总算过了！！！</li>
</ul>
</li>
<li><p>题解记录</p>
<ul>
<li><code>l</code>和<code>r</code>都是闭区间</li>
<li><code>while</code>循环是<code>l &lt; r</code></li>
<li><code>if (numbers[m] &lt; numbers[r] r = m;</code> 这里没有减一，因为这个数字还没有判断，跟我写的不一样</li>
<li><code>else if (numbers[m] &gt; numbers[r]) l = m + 1;</code> 这里加一没问题</li>
<li><code>else --r;</code> 这么一写，妙到家了！相等的情况也考虑进去了！</li>
</ul>
</li>
<li><p>总结，我写的判断条件太多，比较乱！</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">//手撕</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minArray(vector&lt;int&gt;&amp; numbers) &#123;</span><br><span class="line">        if(numbers.empty()) return -1;</span><br><span class="line">        int l = 0, r = numbers.size();</span><br><span class="line">        --r;</span><br><span class="line">        //这里的等于好像可以不加，因为就剩一个数了，只能是这个数？</span><br><span class="line">        while(l &lt; r)&#123;</span><br><span class="line">            if(numbers[l] == numbers[r])&#123;</span><br><span class="line">                --r;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                int m = (r - l) / 2 + l;</span><br><span class="line">                //这里的m == 0 有个条件</span><br><span class="line">                if((m == 0 &amp;&amp; numbers[m] &lt; numbers[r]) || (m != 0 &amp;&amp; numbers[m] &lt; numbers[m - 1]))&#123;</span><br><span class="line">                    return numbers[m];</span><br><span class="line">                    //numbers[m] == numbers[l]也有前提条件的</span><br><span class="line">                &#125;else if(numbers[m] &gt; numbers[r])&#123;</span><br><span class="line">                    //这里不管与左边是否相等，只要大于右边，那最小值就在右边；这里加一是因为判断过了？</span><br><span class="line">                    l = m + 1;</span><br><span class="line">                &#125;else if(numbers[m] &lt;= numbers[r])&#123;</span><br><span class="line">                    r = m - 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return numbers[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//题解</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minArray(vector&lt;int&gt;&amp; numbers) &#123;</span><br><span class="line">        int low = 0;</span><br><span class="line">        int high = numbers.size() - 1;</span><br><span class="line">        while (low &lt; high) &#123;</span><br><span class="line">            int pivot = low + (high - low) / 2;</span><br><span class="line">            if (numbers[pivot] &lt; numbers[high]) &#123;</span><br><span class="line">                high = pivot;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (numbers[pivot] &gt; numbers[high]) &#123;</span><br><span class="line">                low = pivot + 1;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                high -= 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return numbers[low];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>书上的条件是比较两个元素的大小<code>while(numbers[l] &gt;= numbers[r])</code>；这里前提是大于等于，若是小于则直接返回第一个数字<ul>
<li>当两个指针距离为1时，返回第二个指针指向的数字</li>
<li>之后更新中间指针时，左右两个指针都没有进行加减1</li>
<li>但是这里有个漏洞，当三个指针的元素都一样时，这时得用顺序查找（书上另外创建了函数），这点力扣写的比较清晰明了</li>
</ul>
</li>
</ul>
<h2 id="12-矩阵中的路径"><a href="#12-矩阵中的路径" class="headerlink" title="12_矩阵中的路径"></a>12_矩阵中的路径</h2><ul>
<li>79题</li>
<li>再次做的时候有几个注意点<ul>
<li>首先字母不能重复利用，也就是要生成另一个数组用来标记</li>
<li>上下左右可以用一个二维数组来表示加减一，之后循环，在循环内要判断新的坐标，是否符合多个条件，只有符合才能继续递归</li>
<li>若全局变量<code>ans</code>为真，那就直接返回，这个条件也加入递归出口里</li>
<li>也可以直接在原数组上改，改之前要先保存原字符</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; tmp, vector&lt;vector&lt;char&gt;&gt;&amp; board, string&amp; word, int x, int y, int p, int n)&#123;</span><br><span class="line">        if(p == n) ans = true;</span><br><span class="line">        if(ans) return;</span><br><span class="line">        //没有被标记、并且相等</span><br><span class="line">        for(auto&amp; os : pos)&#123;</span><br><span class="line">            int i = x + os[0], j = y + os[1];</span><br><span class="line">            //这里的条件应该是i、j</span><br><span class="line">            if(i &gt;= 0 &amp;&amp; i &lt; board.size() &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; board[0].size() &amp;&amp; board[i][j] == word[p] &amp;&amp; tmp[i][j] == 0)&#123;</span><br><span class="line">                tmp[i][j] = 1;</span><br><span class="line">                dfs(tmp, board, word, i, j, p + 1, n);</span><br><span class="line">                tmp[i][j] = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            if(ans) break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123;</span><br><span class="line">        if(board.empty() || board[0].empty() || word.empty()) return false;</span><br><span class="line">        int row = board.size(), col = board[0].size(), n = word.size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; tmp(row, vector&lt;int&gt;(col, 0));</span><br><span class="line">        for(int i = 0; i &lt; row; ++i)&#123;</span><br><span class="line">            for(int j = 0; j &lt; col; ++j)&#123;</span><br><span class="line">                if(board[i][j] == word[0])&#123;</span><br><span class="line">                    //标记</span><br><span class="line">                    tmp[i][j] = 1;</span><br><span class="line">                    //cout &lt;&lt; &quot;board[&quot; &lt;&lt; i &lt;&lt; &quot;][&quot; &lt;&lt; j &lt;&lt; &quot;] = &quot; &lt;&lt; board[i][j] &lt;&lt; endl;</span><br><span class="line">                    dfs(tmp, board, word, i, j, 1, n);</span><br><span class="line">                    if(ans) return ans;</span><br><span class="line">                    tmp[i][j] = 0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    bool ans = false;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; pos = &#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="13-机器人的运动范围"><a href="#13-机器人的运动范围" class="headerlink" title="13_机器人的运动范围"></a>13_机器人的运动范围</h2><ul>
<li><p>如果这个格子可以到达，那么全局变量加一</p>
<ul>
<li>这题递归前无需遍历整个二维数组？<ul>
<li>不对，从<code>(0,0)</code>开始确实有好多格子可以走，但不一定能走到最后</li>
<li>所以走过的格子要标记，这里就用哈希表了，这样，遍历的格子都标记，不然不能走的格子还是要判断</li>
</ul>
</li>
<li>标记之后再判断这个格子能不能走！</li>
<li>递归的出口就是四个方向都走过了</li>
<li>编译出错？？——看构造函数，是否所有的变量都初始化，没有初始化化就会报出样的错误<ul>
<li>这里错了<code>unordered_set&lt;pair&lt;int, int&gt;&gt; set;</code>，C++中没有给<code>pair</code>做Hash的函数，所以不能用<code>pair</code>作为<code>unordered_map</code>的key。<code>unordered_set</code>也是同理吧，改成<code>set</code>看看，可以了</li>
</ul>
</li>
</ul>
</li>
<li><p>提交之后发现报错了…</p>
<ul>
<li>我一度以为用例的答案错了？</li>
<li>我知道了，因为机器人是从<code>(0,0)</code>开始走的，所以只能从<code>(0,0)</code>递归！！，不能遍历二维数组！成功了</li>
<li>代码有点慢，看看题解<ul>
<li>广度优先似乎比深度优先快点儿</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">//手撕</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int mysum(int i, int j)&#123;</span><br><span class="line">        //这里优化下</span><br><span class="line">        int sum = 0;</span><br><span class="line">        while(i &gt; 0)&#123;</span><br><span class="line">            sum += (i % 10);</span><br><span class="line">            i /= 10;</span><br><span class="line">        &#125;</span><br><span class="line">        while(j &gt; 0)&#123;</span><br><span class="line">            sum += (j % 10);</span><br><span class="line">            j /= 10;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void dfs(int x, int y, int k, int m, int n)&#123;</span><br><span class="line">        //遍历上下左右</span><br><span class="line">        for(auto&amp; p : pos)&#123;</span><br><span class="line">            int i = x + p[0], j = y + p[1];</span><br><span class="line">            if(i &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; n &amp;&amp; set.find(make_pair(i, j)) == set.end())&#123;</span><br><span class="line">                //先标记</span><br><span class="line">                set.insert(make_pair(i, j));</span><br><span class="line">                //再判断能不能走</span><br><span class="line">                if(mysum(i, j) &lt;= k)&#123;</span><br><span class="line">                    //这里递归</span><br><span class="line">                    ++ans;</span><br><span class="line">                    dfs(i, j, k, m, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int movingCount(int m, int n, int k) &#123;</span><br><span class="line">        if(k &lt; 0 || m &lt; 0 || n &lt; 0) return 0;</span><br><span class="line">        //(0,0)肯定可以走</span><br><span class="line">        set.insert(make_pair(0, 0));</span><br><span class="line">        ++ans;</span><br><span class="line">        dfs(0, 0, k, m, n);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int ans = 0;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; pos = &#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;;</span><br><span class="line">    set&lt;pair&lt;int, int&gt;&gt; set;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//题解</span><br><span class="line">class Solution &#123;</span><br><span class="line">    // 计算 x 的数位之和</span><br><span class="line">    int get(int x) &#123;</span><br><span class="line">        int res=0;</span><br><span class="line">        for (; x; x /= 10) &#123;</span><br><span class="line">            res += x % 10;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    int movingCount(int m, int n, int k) &#123;</span><br><span class="line">        if (!k) return 1;</span><br><span class="line">        queue&lt;pair&lt;int,int&gt; &gt; Q;</span><br><span class="line">        // 向右和向下的方向数组</span><br><span class="line">        int dx[2] = &#123;0, 1&#125;;</span><br><span class="line">        int dy[2] = &#123;1, 0&#125;;</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; vis(m, vector&lt;int&gt;(n, 0));</span><br><span class="line">        Q.push(make_pair(0, 0));</span><br><span class="line">        vis[0][0] = 1;</span><br><span class="line">        int ans = 1;</span><br><span class="line">        while (!Q.empty()) &#123;</span><br><span class="line">            auto [x, y] = Q.front();</span><br><span class="line">            Q.pop();</span><br><span class="line">            for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">                int tx = dx[i] + x;</span><br><span class="line">                int ty = dy[i] + y;</span><br><span class="line">                if (tx &lt; 0 || tx &gt;= m || ty &lt; 0 || ty &gt;= n || vis[tx][ty] || get(tx) + get(ty) &gt; k) continue;</span><br><span class="line">                Q.push(make_pair(tx, ty));</span><br><span class="line">                vis[tx][ty] = 1;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="14-1-剪绳子"><a href="#14-1-剪绳子" class="headerlink" title="14-1_剪绳子"></a>14-1_剪绳子</h2><ul>
<li><p>似乎有点难，343题还没有做到</p>
<ul>
<li>好好理解下动态规划</li>
<li>把一个绳子剪成两段，要是乘积最大，就要使这两段绳子的本身的乘积最大？</li>
<li>不对，要是只剪一刀呢，让这两段长度相等？若长度为奇数，那就相差为1</li>
<li>之后再减一刀，就是取其中一段（或者取长的一段？），就变成了子问题</li>
<li>手撕试一下<ul>
<li>数组定义很重要！</li>
</ul>
</li>
</ul>
</li>
<li><p>这题没做出来！总感觉隔了那么一层窗户纸！</p>
<ul>
<li>看了书才知道，一维数组就行，长度的绳子的长度（+1）！</li>
<li>然后，由下至上，长度为2，就只能在位置1剪，之后长度为3，就要<code>max(位置1剪，位置2剪)</code>了，不用二维数组</li>
<li>初始边界有点乱，<code>dp[0]=0;dp[1]=0;dp[2]=1;dp[3]=2</code></li>
<li>返回值和边界条件不太一致，因为边界条件是方便状态转移的</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int cuttingRope(int n) &#123;</span><br><span class="line">        if(n &lt; 2) return 0;</span><br><span class="line">        if(n == 2) return 1;</span><br><span class="line">        if(n == 3) return 2;</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt; dp(n + 1, 0);</span><br><span class="line">        //边界</span><br><span class="line">        dp[1] = 1;dp[2] = 2;</span><br><span class="line">        //dp[3]应该写成2</span><br><span class="line">        dp[3] = 3;</span><br><span class="line"></span><br><span class="line">        for(int i = 4; i &lt; n + 1; ++i)&#123;</span><br><span class="line">            //记录最大值，每个位置都剪</span><br><span class="line">            int m = 0;</span><br><span class="line">            for(int j = 1; j &lt; i; ++j)&#123;</span><br><span class="line">                m = max(m, dp[j] * dp[i - j]);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = m;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>贪心算法，<ul>
<li>在数学上，大佬证明比较繁琐，书上的比较清晰明了——尽可能多的剪成长度为3的一段段</li>
<li>前提<code>n&gt;=5</code>，<code>2(n-2)&gt;n</code>、<code>3(n-3)&gt;n</code>，当绳子长度大于等于5的时候，剪成长度为3或者2</li>
<li>又因为<code>3(n-3)&gt;=2(n-2)</code>，所以尽可能剪成长度为3的一段</li>
<li>最后也有特例</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/Offer/14-1.png" alt title="切分规则"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//贪心</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int cuttingRope(int n) &#123;</span><br><span class="line">        if(n &lt; 1) return 0;</span><br><span class="line">        if(n &lt; 4) return n - 1;</span><br><span class="line">        //计算商和余数</span><br><span class="line">        int a = n / 3, b = n % 3;</span><br><span class="line">        if(b == 0)&#123;</span><br><span class="line">            return static_cast&lt;int&gt;(pow(3, a));</span><br><span class="line">        &#125;else if(b == 1)&#123;</span><br><span class="line">            return static_cast&lt;int&gt;(pow(3, a - 1) * 4);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return static_cast&lt;int&gt;(pow(3, a) * 2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>真正的大佬只需要一行代码！</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int cuttingRope(int n) &#123;</span><br><span class="line">    return n &lt;= 3? n - 1 : pow(3, n / 3) * 4 / (4 - n % 3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="14-2-剪绳子-ll"><a href="#14-2-剪绳子-ll" class="headerlink" title="14-2_剪绳子_ll"></a>14-2_剪绳子_ll</h2><ul>
<li>看了题目之后，我甚至一度以为这不是一模一样吗<ul>
<li>后来才发现，绳子的长度范围变大了，最后可能的最大乘积需要取模！</li>
<li>那么动态规划可能会超时！</li>
<li>求幂都超出了<code>long long</code>的范围，有点牛皮！1000有333个3，而3^19次方就超过了1000000007</li>
<li>有点投机取巧了，应该一大于1000000007就取模，所以应该循环！</li>
<li>看下评论优化下！——循环求余！</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int cuttingRope(int n) &#123;</span><br><span class="line">        if(n &lt; 1) return 0;</span><br><span class="line">        if(n &lt; 4) return n - 1;</span><br><span class="line">        long long ans = 1;</span><br><span class="line">        int p = (int)1e9+7;</span><br><span class="line">        while(n &gt; 4)&#123;</span><br><span class="line">            ans = ans * 3 % p;</span><br><span class="line">            n -= 3;</span><br><span class="line">        &#125;</span><br><span class="line">        //最后还剩，2，3，4</span><br><span class="line">        return ans * n % p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="15-二进制中1的个数"><a href="#15-二进制中1的个数" class="headerlink" title="15_二进制中1的个数"></a>15_二进制中1的个数</h2><ul>
<li>这题之前做过几次，印象最深的就是那个不用循环、位移就能得出结果的算法，这里好好总结下<ul>
<li>如果是负数呢！发现剑指Offer的题看似简单，但都很有深度！！</li>
<li>书上详细介绍了三种——可能引起死循环、常规、惊喜的——算法</li>
<li>当然，也有大佬直接调库<code>__builtin_popcount()</code></li>
</ul>
</li>
<li>死循环是直接将数字<code>n</code>右移，依次判断最后一位是否位1，如果遇到负数，左移时，还是负数，但是最高位会逐渐变成1，从而引起死循环</li>
<li>常规方法时用1来左移，然后与<code>n</code>相与，这样就算是负数，依次判断也不会影响</li>
<li>惊喜的算法就是下面的代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int hammingWeight(uint32_t n) &#123;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        while(n != 0)&#123;</span><br><span class="line">            n &amp;= (n - 1);</span><br><span class="line">            ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="16-数值的整数次方"><a href="#16-数值的整数次方" class="headerlink" title="16_数值的整数次方"></a>16_数值的整数次方</h2><ul>
<li>50题<ul>
<li>印象比较深，一个一个乘太慢，每次都得翻倍，快一点</li>
<li>循环得仔细琢磨琢磨，还有正数边界问题<ul>
<li>我用了两个循环，却发现我第一次居然写的递归？？还写的贼好看，应该是参考的:)</li>
<li>这题明天再琢磨琢磨！！</li>
<li>递归没有写出来！<ul>
<li>首先，递归的话，应该写成<code>double y = quickMul(x, N / 2);</code>，之后再<code>y * y : y * y * x;</code>，这样可以省去一部分时间，而不是<code>ans *= (1 / double(x, n / 2)) * (1 / double(x, n / 2));</code></li>
<li>但是这样写会报错，<code>excess elements in scalar initializer</code>？？，难道是要自己写个递归函数么</li>
<li>这个一般是初始化数组忘了初始化大小了</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/Offer/16.png" alt title="报错"></p>
<ul>
<li>还是老老实实用<code>long long</code>吧</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">//两个while循环</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    double myPow(double x, int n) &#123;</span><br><span class="line">        if(n == 0) return 1;</span><br><span class="line">        bool flag = n &lt; 0 ? true : false;</span><br><span class="line">        //无需考虑大数，那就都转为正数，话是这么说，但是范围还是给出了正数边界，应该都转为负数！！！</span><br><span class="line">        if(!flag) n *= -1;</span><br><span class="line">        //n为负数</span><br><span class="line"></span><br><span class="line">        int tmp = -1;</span><br><span class="line">        double ans = 1;</span><br><span class="line">        while(n &lt; 0)&#123;</span><br><span class="line">            //这里要定义个临时变量</span><br><span class="line">            double a = 1 / x;</span><br><span class="line">            //这里乘以2会超出正数边界！</span><br><span class="line">            while(tmp &gt;= n / 2)&#123;</span><br><span class="line">                a *= a;</span><br><span class="line">                tmp *= 2;</span><br><span class="line">            &#125;</span><br><span class="line">            //这里tmp再乘以2就大于n</span><br><span class="line">            n -= tmp;</span><br><span class="line">            //初始化tmp</span><br><span class="line">            tmp = -1;</span><br><span class="line">            //这里是乘，而不是加</span><br><span class="line">            ans *= a;</span><br><span class="line">        &#125;</span><br><span class="line">        return flag ? ans : 1 / ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//试下递归</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    double myPow(double x, int n) &#123;</span><br><span class="line">        //这里是都转为正数n，会报错，应该都转为负数，或者写成long long的形式</span><br><span class="line">        long long N = n;</span><br><span class="line">        return N &lt; 0 ? 1.0 / quickPow(x, -N) : quickPow(x, N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    double quickPow(double x, long long n)&#123;</span><br><span class="line">        if(n == 0) return 1.0;</span><br><span class="line">        double y = quickPow(x, n / 2);</span><br><span class="line">        return n % 2 == 0 ? y * y : x * y * y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="17-打印从1到最大的n位数"><a href="#17-打印从1到最大的n位数" class="headerlink" title="17_打印从1到最大的n位数"></a>17_打印从1到最大的n位数</h2><ul>
<li>看看这题有啥坑<ul>
<li>n很大，可能会超出整型、长整型的范围！书上用的是字符串</li>
<li>第二种方法用了递归全排列，每一位都可能是0~9的数字，出口条件是最后一位</li>
<li>这两中方法在输出的时候，都要将数前面的0去掉！</li>
<li>但是力扣上是<code>vector&lt;int&gt;</code>返回值，所以考虑大数又有点鸡肋，直接循环了</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//遍历</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; printNumbers(int n) &#123;</span><br><span class="line">        if(n &lt; 1) return vector&lt;int&gt;();</span><br><span class="line">        //范围10^n - 1，一次循环吧</span><br><span class="line">        long long tmp = static_cast&lt;long long&gt;(pow(10, n));</span><br><span class="line">        vector&lt;int&gt; ans;</span><br><span class="line">        for(int i = 1; i &lt; tmp; ++i)&#123;</span><br><span class="line">            ans.emplace_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="18-删除链表的节点"><a href="#18-删除链表的节点" class="headerlink" title="18_删除链表的节点"></a>18_删除链表的节点</h2><ul>
<li>这个我应该挺熟的<ul>
<li>在头节点再加个伪头节点，这样比较方便</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* deleteNode(ListNode* head, int val) &#123;</span><br><span class="line">        //给的值在节点内，就不判断是否为空了</span><br><span class="line">        //小技巧，添加伪头节点</span><br><span class="line">        ListNode* myHead = new ListNode(-1);</span><br><span class="line">        myHead-&gt;next = head;</span><br><span class="line">        auto carry = myHead;</span><br><span class="line">        while(carry-&gt;next != nullptr &amp;&amp; carry-&gt;next-&gt;val != val)&#123;</span><br><span class="line">            carry = carry-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        //carry-&gt;next-&gt;val == val</span><br><span class="line">        auto tmp = carry-&gt;next-&gt;next;</span><br><span class="line">        carry-&gt;next = tmp;</span><br><span class="line">        return myHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="19-正则表达式匹配"><a href="#19-正则表达式匹配" class="headerlink" title="19_正则表达式匹配"></a>19_正则表达式匹配</h2><ul>
<li><p>当时做的时候感觉这一题好难</p>
<ul>
<li>识别三日、当刮目相看</li>
<li>一个一个字符比较的话似乎会出现问题——<code>&quot;.*&quot;</code>出现在一起怎么办？不知道我的判断条件能不能处理</li>
<li>有问题，应该以<code>p.size()&gt;=2</code>来划分，因为考虑后一个字符是<code>&#39;*&#39;</code>、还是<code>&#39;.&#39;</code>；而不是<code>p[0]</code>为特殊字符再去找前一个字符是啥！</li>
<li>有个注意点应该是<code>isalnum(p[0])</code>而不是<code>isdigit(p[0])</code></li>
<li>还有注意点，如果字母后跟着<code>&#39;*&#39;</code>，比如<code>&quot;c*&quot;</code>，那么<code>&quot;c*&quot;</code>可以直接跳过</li>
<li>我写的好乱，打补丁容易出错！还是得以<code>p.size()&gt;=2</code>来划分，而不是在<code>if else</code>条件内再划分<ul>
<li>字母+<code>&#39;*&#39;</code>可有可无</li>
<li>若遇到<code>&#39;*&#39;</code>，该怎么判断呢，应该不会遇到<code>&#39;*&#39;</code>，除非<code>s</code>为空！或者<code>p[1] == &#39;*&#39;</code></li>
<li>总感觉对<code>&#39;*&#39;</code>的处理不够周全，但是最后也过了！</li>
</ul>
</li>
</ul>
</li>
<li><p>总结</p>
<ul>
<li>难点在<code>&#39;*&#39;</code>，而不是点，因为星号要跟前一个字符组成一个整体</li>
<li>第一遍看的大佬写的真好，再温习一遍，先粘贴下自己臃肿的代码</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">//手撕版本</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isMatch(string s, string p) &#123;</span><br><span class="line">        //两个字符串，应该不停的用递归！每次递归都比较第一个字符</span><br><span class="line">        //既然用递归，那就得设置出口条件</span><br><span class="line">        if(s.empty() &amp;&amp; p.empty())&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;else if(!s.empty() &amp;&amp; p.empty())&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //接下来p不为空，s有可能为空</span><br><span class="line">        if(p.size() &lt; 2)&#123;</span><br><span class="line">            if(s.empty())&#123;</span><br><span class="line">                return p[0] == &apos;*&apos;;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                if(p[0] == s[0] || p[0] == &apos;.&apos;)&#123;</span><br><span class="line">                    return isMatch(s.substr(1), p.substr(1));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            if(s.empty())&#123;</span><br><span class="line">                //这里也要考虑*</span><br><span class="line">                return (p[0] == &apos;*&apos; &amp;&amp; isMatch(s, p.substr(1))) || (p[1] == &apos;*&apos; &amp;&amp; isMatch(s, p.substr(2)));</span><br><span class="line">            &#125;else if(!s.empty())&#123;</span><br><span class="line">                bool flag1 = (s[0] == p[0] || p[0] == &apos;.&apos;) &amp;&amp; isMatch(s.substr(1), p.substr(1));</span><br><span class="line">                bool flag2 = false;</span><br><span class="line">                if(p[1] == &apos;*&apos;)&#123;</span><br><span class="line">                    flag2 = isMatch(s, p.substr(2)) || ((s[0] == p[0] || p[0] == &apos;.&apos;) &amp;&amp; isMatch(s.substr(1), p));</span><br><span class="line">                &#125;</span><br><span class="line">                return flag1 || flag2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//大佬版本</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isMatch(string s, string p) &#123;</span><br><span class="line">		//这里就一句代码，非常简洁</span><br><span class="line">        if(p.empty()) return s.empty();</span><br><span class="line">		//第一个是否匹配！同时考虑了s是否为空</span><br><span class="line">        bool firstmatch = !s.empty() &amp;&amp; (s[0] == p[0] || p[0] == &apos;.&apos;);</span><br><span class="line">		//这里按长度来划分，并且明确p[1] == &apos;*&apos;的情况！</span><br><span class="line">        if(p.size() &gt;= 2 &amp;&amp; p[1] == &apos;*&apos;)&#123;</span><br><span class="line">			//要么0个，要么1个</span><br><span class="line">            return isMatch(s, p.substr(2, p.size() - 2)) || (firstmatch &amp;&amp; isMatch(s.substr(1, s.size() - 1), p));</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">			//这里也非常简洁，没有把p[0]分开讨论，因为firstmatch就已经讨论过了</span><br><span class="line">            return firstmatch &amp;&amp; isMatch(s.substr(1, s.size() - 1), p.substr(1, p.size() - 1));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>动态规划<ul>
<li>处理两个字符串，经常会用到</li>
<li><code>dp[m+1][n+1]</code>布尔值</li>
<li>初始化的时候，星号很重要，初始化为用0次</li>
<li>刚刚试了下，样例中并没有以’*’开头的字符串p，所以初始化边界的时候从<code>i = 1</code>开始（字符串的下标）</li>
<li>但是这里报了错<code>dp[i][j] = dp[i]dp[j - 1];</code>不知道为什么，以前没出现这种情况</li>
<li>我是傻子！！应该写成<code>dp[i][j] = dp[i][j - 1];</code></li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">assigning to &apos;__gnu_cxx::__alloc_traits&lt;std::allocator&lt;int&gt;, int&gt;::value_type&apos; (aka &apos;int&apos;) from incompatible type &apos;__gnu_cxx::__alloc_traits&lt;std::allocator&lt;std::vector&lt;int, std::allocator&lt;int&gt;&gt;&gt;, std::vector&lt;int, std::allocator&lt;int&gt;&gt;&gt;::value_type&apos; (aka &apos;std::vector&lt;int, std::allocator&lt;int&gt;&gt;&apos;)</span><br><span class="line">         dp[i][j] = dp[i]dp[j - 1];</span><br></pre></td></tr></table></figure>

<p><img src="/pictrues/Offer/19.png" alt title="动态规划"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">//手撕动态规划</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isMatch(string s, string p) &#123;</span><br><span class="line">        //动态规划似乎不需要这行代码了？</span><br><span class="line">        //if(p.empty()) return s.empty();</span><br><span class="line">        int n = s.size(), m = p.size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(m + 1, 0));</span><br><span class="line">        //边界条件</span><br><span class="line">        dp[0][0] = 1;</span><br><span class="line">        //行是字符串s，列是字符串p，列里面才有&apos;*&apos;</span><br><span class="line">        for(int i = 1; i &lt; m; ++i)&#123;</span><br><span class="line">            //aa</span><br><span class="line">            //a*</span><br><span class="line">            if(p[i] == &apos;*&apos;)&#123;</span><br><span class="line">                //为什么第一维是0呢，表示字符串s前0个字符，初始化为0个*前面的字符</span><br><span class="line">                dp[0][i + 1] = dp[0][i - 1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //状态转移——这里是二维数组的下标，转为字符串的下标要减一</span><br><span class="line">        for(int i = 1; i &lt; n + 1; ++i)&#123;</span><br><span class="line">            for(int j = 1; j &lt; m + 1; ++j)&#123;</span><br><span class="line"></span><br><span class="line">                if(s[i - 1] == p[j - 1] || p[j - 1] == &apos;.&apos;)&#123;</span><br><span class="line">                    //对应字母匹配，各往前退一个（传递），而不是直接赋值1</span><br><span class="line">                    dp[i][j] = dp[i - 1][j - 1];</span><br><span class="line">                &#125;else if(p[j - 1] == &apos;*&apos;)&#123;</span><br><span class="line">                    //这里不能拿前面的来赋值，而是要分情况，用还是不用</span><br><span class="line">                    if(dp[i][j - 2])&#123;</span><br><span class="line">                        dp[i][j] = 1;</span><br><span class="line">                    &#125;else if(s[i - 1] == p[j - 2] || p[j - 2] == &apos;.&apos;)&#123;</span><br><span class="line">                        //这里是要传递，并且是s往前一个，而不是p</span><br><span class="line">                        dp[i][j] = dp[i - 1][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="20-表示数值的字符串"><a href="#20-表示数值的字符串" class="headerlink" title="20_表示数值的字符串"></a>20_表示数值的字符串</h2><ul>
<li>再来复习一遍！！<ul>
<li>当时题解是用了有限状态自动机！</li>
<li>这题多了空格，更复杂点，还有其他的字母！</li>
<li>还是错了几次才过，关键点在于出现e之后，其余的正负号、数字、小数点都要初始化下！！</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isNumber(string s) &#123;</span><br><span class="line">        //先对字符串处理空格</span><br><span class="line">        while(!s.empty() &amp;&amp; s.back() == &apos; &apos;)&#123;</span><br><span class="line">            s.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        if(s.empty()) return false;</span><br><span class="line"></span><br><span class="line">        int pos = 0;</span><br><span class="line">        while(pos &lt; s.size() &amp;&amp; s[pos] == &apos; &apos;)&#123;</span><br><span class="line">            ++pos;</span><br><span class="line">        &#125;</span><br><span class="line">        s = s.substr(pos);</span><br><span class="line"></span><br><span class="line">        //一次遍历，根据已出现或者没有出现的数字、小数点、正负号、E/e来判断是否有效</span><br><span class="line">        bool numSeen = false;</span><br><span class="line">        bool dotSeen = false;</span><br><span class="line">        bool signSeen = false;</span><br><span class="line">        bool eSeen = false;</span><br><span class="line"></span><br><span class="line">        for(int i = 0; i &lt; s.size(); ++i)&#123;</span><br><span class="line">            //字符串里面还有空格</span><br><span class="line">            if(s[i] == &apos;-&apos; || s[i] == &apos;+&apos;)&#123;</span><br><span class="line">                //正负号（数字、小数点）会在e出现后初始化，没有出现就不会；还有前面不能有数字（以e分两段）</span><br><span class="line">                //也不能有小数点，那么这里的小数点就要在e之后初始化了</span><br><span class="line">                if(signSeen || numSeen || dotSeen) return false;</span><br><span class="line">                signSeen = true;</span><br><span class="line">            &#125;else if(isdigit(s[i]))&#123;</span><br><span class="line">                //这里数字应该没有什么情况会返回false</span><br><span class="line">                numSeen = true;</span><br><span class="line">            &#125;else if(s[i] == &apos;.&apos;)&#123;</span><br><span class="line">                //小数点只能出现在e前边，e之后会初始化，所以也不能出现e；还有小数点左右两边至少要有一个数字！！</span><br><span class="line">                //或者小数点在e出现不初始化eSeen必须得加上</span><br><span class="line">                if(dotSeen || eSeen) return false;</span><br><span class="line">                dotSeen = true;</span><br><span class="line">            &#125;else if(s[i] == &apos;e&apos; || s[i] == &apos;E&apos;)&#123;</span><br><span class="line">                //若前面没有数字、已经出现e</span><br><span class="line">                if(!numSeen || eSeen) return false;</span><br><span class="line">                eSeen = true;</span><br><span class="line">                signSeen = false;</span><br><span class="line">                numSeen = false;</span><br><span class="line">                dotSeen = false;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                //空格或者其他字符</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        //最后要看是否出现数字</span><br><span class="line">        return numSeen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>有限状态自动机——题解<ul>
<li>自动机的消耗更长一点儿</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	//enum是枚举类型！</span><br><span class="line">    enum State &#123;</span><br><span class="line">        STATE_INITIAL, 		//初始状态</span><br><span class="line">        STATE_INT_SIGN, 	//符号</span><br><span class="line">        STATE_INTEGER, 		//整数</span><br><span class="line">        STATE_POINT,</span><br><span class="line">        STATE_POINT_WITHOUT_INT,</span><br><span class="line">        STATE_FRACTION,</span><br><span class="line">        STATE_EXP,</span><br><span class="line">        STATE_EXP_SIGN,</span><br><span class="line">        STATE_EXP_NUMBER,</span><br><span class="line">        STATE_END</span><br><span class="line">    &#125;;</span><br><span class="line">	//这里也声明了枚举类型，这里对应的是内容</span><br><span class="line">    enum CharType &#123;</span><br><span class="line">        CHAR_NUMBER,</span><br><span class="line">        CHAR_EXP,</span><br><span class="line">        CHAR_POINT,</span><br><span class="line">        CHAR_SIGN,</span><br><span class="line">        CHAR_SPACE,</span><br><span class="line">        CHAR_ILLEGAL</span><br><span class="line">    &#125;;</span><br><span class="line">	//这里定义了一个对象？——自定义类型，只能赋值已经声明的，而不能赋值其余类型，返回类型是CharType，也就是自定义类型</span><br><span class="line">    CharType toCharType(char ch) &#123;</span><br><span class="line">        if (ch &gt;= &apos;0&apos; &amp;&amp; ch &lt;= &apos;9&apos;) &#123;</span><br><span class="line">            return CHAR_NUMBER;</span><br><span class="line">        &#125; else if (ch == &apos;e&apos; || ch == &apos;E&apos;) &#123;</span><br><span class="line">            return CHAR_EXP;</span><br><span class="line">        &#125; else if (ch == &apos;.&apos;) &#123;</span><br><span class="line">            return CHAR_POINT;</span><br><span class="line">        &#125; else if (ch == &apos;+&apos; || ch == &apos;-&apos;) &#123;</span><br><span class="line">            return CHAR_SIGN;</span><br><span class="line">        &#125; else if (ch == &apos; &apos;) &#123;</span><br><span class="line">            return CHAR_SPACE;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return CHAR_ILLEGAL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool isNumber(string s) &#123;</span><br><span class="line">		//这里用了双层unordered_map，有点像图，或者把所有的状态都罗列了出来，每一个状态的下一个状态是什么</span><br><span class="line">        unordered_map&lt;State, unordered_map&lt;CharType, State&gt;&gt; transfer&#123;</span><br><span class="line">            &#123;</span><br><span class="line">				//例如初始状态——可能有空格、数字、小数点、正负号</span><br><span class="line">                STATE_INITIAL, &#123;</span><br><span class="line">                    &#123;CHAR_SPACE, STATE_INITIAL&#125;,</span><br><span class="line">                    &#123;CHAR_NUMBER, STATE_INTEGER&#125;,</span><br><span class="line">                    &#123;CHAR_POINT, STATE_POINT_WITHOUT_INT&#125;,</span><br><span class="line">                    &#123;CHAR_SIGN, STATE_INT_SIGN&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                STATE_INT_SIGN, &#123;</span><br><span class="line">                    &#123;CHAR_NUMBER, STATE_INTEGER&#125;,</span><br><span class="line">                    &#123;CHAR_POINT, STATE_POINT_WITHOUT_INT&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                STATE_INTEGER, &#123;</span><br><span class="line">                    &#123;CHAR_NUMBER, STATE_INTEGER&#125;,</span><br><span class="line">                    &#123;CHAR_EXP, STATE_EXP&#125;,</span><br><span class="line">                    &#123;CHAR_POINT, STATE_POINT&#125;,</span><br><span class="line">                    &#123;CHAR_SPACE, STATE_END&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                STATE_POINT, &#123;</span><br><span class="line">                    &#123;CHAR_NUMBER, STATE_FRACTION&#125;,</span><br><span class="line">                    &#123;CHAR_EXP, STATE_EXP&#125;,</span><br><span class="line">                    &#123;CHAR_SPACE, STATE_END&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                STATE_POINT_WITHOUT_INT, &#123;</span><br><span class="line">                    &#123;CHAR_NUMBER, STATE_FRACTION&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                STATE_FRACTION,</span><br><span class="line">                &#123;</span><br><span class="line">                    &#123;CHAR_NUMBER, STATE_FRACTION&#125;,</span><br><span class="line">                    &#123;CHAR_EXP, STATE_EXP&#125;,</span><br><span class="line">                    &#123;CHAR_SPACE, STATE_END&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                STATE_EXP,</span><br><span class="line">                &#123;</span><br><span class="line">                    &#123;CHAR_NUMBER, STATE_EXP_NUMBER&#125;,</span><br><span class="line">                    &#123;CHAR_SIGN, STATE_EXP_SIGN&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                STATE_EXP_SIGN, &#123;</span><br><span class="line">                    &#123;CHAR_NUMBER, STATE_EXP_NUMBER&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                STATE_EXP_NUMBER, &#123;</span><br><span class="line">                    &#123;CHAR_NUMBER, STATE_EXP_NUMBER&#125;,</span><br><span class="line">                    &#123;CHAR_SPACE, STATE_END&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                STATE_END, &#123;</span><br><span class="line">                    &#123;CHAR_SPACE, STATE_END&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        int len = s.length();</span><br><span class="line">        State st = STATE_INITIAL;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">			//这里返回字符对应的名字——自定义的类型</span><br><span class="line">            CharType typ = toCharType(s[i]);</span><br><span class="line">			//st是初始状态，之后不停的迭代，总有一种情况是对应的，若没有就直接返回false;</span><br><span class="line">            if (transfer[st].find(typ) == transfer[st].end()) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                st = transfer[st][typ];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		//最后返回看是不是几种状态的一种</span><br><span class="line">        return st == STATE_INTEGER || st == STATE_POINT || st == STATE_FRACTION || st == STATE_EXP_NUMBER || st == STATE_END;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>感觉书上写的很精简<ul>
<li>就是有两个函数不太容易搞懂</li>
<li>指针的指针，在函数内对指针进行解引用可以对主函数的指针进行移动操作<ul>
<li>嗯，也可以直接用<code>while</code></li>
</ul>
</li>
<li>先判断正负号，在来判断若干数字（函数调用函数，一个是整数，一个是无符号整数），返回布尔值<code>numeric</code></li>
<li>返回之后，判断小数点，若是则继续判断数字，更新<code>numeric</code></li>
<li>之后判断<code>&#39;e&#39;、&#39;E&#39;</code>，再次更新<code>numeric</code></li>
<li>最后判断是不是末尾，以及<code>numeric</code>是否为真</li>
<li>感觉书上的思路跟第一种有点像！！！</li>
</ul>
</li>
</ul>
<h2 id="21-调整数组顺序使奇数位于偶数前面"><a href="#21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="21_调整数组顺序使奇数位于偶数前面"></a>21_调整数组顺序使奇数位于偶数前面</h2><ul>
<li>双指针是不是更快一点儿——第一个指针指向偶数，第二个指针指向奇数，就交换；为什么这是初级解法？<ul>
<li>我用的类似于冒泡算法，确切的说应该是快慢指针！</li>
<li>书上用了函数指针<ul>
<li>函数指针就是个名字，在主函数参数填入函数名，才是要调用的函数！</li>
<li>这样写具有鲁棒性</li>
<li>因为只需修改，函数指针指向的函数规则即可，而无需修改主函数，或者添加额外的函数，更容易重用</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; exchange(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        //我看看能不能一行代码解决，谓词好像要两个参数！</span><br><span class="line">        if(nums.empty()) return vector&lt;int&gt;();</span><br><span class="line">        //老老实实写交换</span><br><span class="line">        int pos = -1;</span><br><span class="line">        for(int i = 0; i &lt; nums.size(); ++i)&#123;</span><br><span class="line">            //这里写反了</span><br><span class="line">            if(nums[i] % 2 == 1)&#123;</span><br><span class="line">                //奇数，开始交换</span><br><span class="line">                ++pos;</span><br><span class="line">                //若不相等则交换</span><br><span class="line">                if(i &gt; pos)&#123;</span><br><span class="line">                    swap(nums[pos], nums[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="22-链表中倒数第k个节点"><a href="#22-链表中倒数第k个节点" class="headerlink" title="22_链表中倒数第k个节点"></a>22_链表中倒数第k个节点</h2><ul>
<li>这个返回的是节点而不是节点的数字，所以就不能在原链表进行修改了<ul>
<li>没想到什么好的方法，用数组保存了下！然后考虑边界，最后返回对应的下标</li>
<li>快慢指针！！！又把这个方法忘了！</li>
<li>最近几题主要讲的是鲁棒性<ul>
<li>输入为空、k大于链表长度、k为0（若是无符号整数，减一就变成了0xFFFFFFFF）</li>
<li>这样得先<code>for</code>循环后<code>while</code>方便点</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//快慢指针</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* getKthFromEnd(ListNode* head, int k) &#123;</span><br><span class="line">        if(!head || k == 0) return nullptr;</span><br><span class="line">        auto pre = head, cur = pre;</span><br><span class="line">        int t = 0;</span><br><span class="line">        while(cur != nullptr)&#123;</span><br><span class="line">            //这里是等于，因为初始值为0</span><br><span class="line">            if(t &gt;= k) pre = pre-&gt;next;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            ++t; </span><br><span class="line">        &#125;</span><br><span class="line">        return pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="23-链表中环的入口节点"><a href="#23-链表中环的入口节点" class="headerlink" title="23_链表中环的入口节点"></a>23_链表中环的入口节点</h2><ul>
<li><p>这题力扣上也没有！！</p>
<ul>
<li>那就总结下书上的思路，之前也做过这道题</li>
<li>在慢指针追上快指针的时候，慢指针要从头开始，之后两指针一次走一步理由如下<ul>
<li>如果环中有n个节点，那么快慢指针都从头开始，然后快指针先走n步，之后两个指针虚度相同地向前移动</li>
<li>这样好理解点</li>
</ul>
</li>
</ul>
</li>
<li><p>代码就不放了！</p>
</li>
</ul>
<h2 id="24-反转链表"><a href="#24-反转链表" class="headerlink" title="24_反转链表"></a>24_反转链表</h2><ul>
<li>在做一题吧<ul>
<li>再试下迭代，可以一次成功</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">        if(!head || !head-&gt;next) return head;</span><br><span class="line"></span><br><span class="line">        ListNode* pre = nullptr;</span><br><span class="line">        while(head != nullptr)&#123;</span><br><span class="line">            //先保存下一个节点</span><br><span class="line">            auto tmp = head-&gt;next;</span><br><span class="line">            head-&gt;next = pre;</span><br><span class="line">            pre = head;</span><br><span class="line">            head = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        return pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>我居然忘了递归也可以！！</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//递归</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">        if(!head || !head-&gt;next) return head;</span><br><span class="line">        //递归就是先假设后面的部分已经反转好，这样有利于理解</span><br><span class="line">        ListNode* nHead = reverseList(head-&gt;next);</span><br><span class="line">        auto tmp = head-&gt;next;</span><br><span class="line">        head-&gt;next = nullptr;</span><br><span class="line">        tmp-&gt;next = head;</span><br><span class="line">        return nHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="25-合并两个排序的链表"><a href="#25-合并两个排序的链表" class="headerlink" title="25_合并两个排序的链表"></a>25_合并两个排序的链表</h2><ul>
<li>21题相同</li>
<li>这应该类似于归并排序<ul>
<li>就看是直接在原链表修改还是生成一个新的链表</li>
<li>直接在原链表修改，好不容易写完了，通过！！<ul>
<li>这里如果不注意，会报错——没判断是不是空指针，就写出其<code>val</code></li>
</ul>
</li>
<li>看看题解和书，能不能优化下</li>
<li>等等，是不是可以用递归啊，试一下，书上用的就是递归！！<ul>
<li>递归是真的厉害！第一次的第二种原来是迭代，无论是循环还是条件判断都比我写的好多了</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">//手撕，原链表修改</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;</span><br><span class="line">        //注意这里链表长度可能为空</span><br><span class="line">        if(!l1) return l2;</span><br><span class="line">        if(!l2) return l1;</span><br><span class="line">        //至此两者都不为空，&lt;=</span><br><span class="line">        auto head = l1-&gt;val &lt;= l2-&gt;val ? l1 : l2;</span><br><span class="line">        while(l1 != nullptr || l2 != nullptr)&#123;</span><br><span class="line">            if(l1 != nullptr &amp;&amp; l2 != nullptr)&#123;</span><br><span class="line">                ListNode* pre = nullptr;</span><br><span class="line">                //&lt;=保持一致</span><br><span class="line">                while(l1 != nullptr &amp;&amp; l1-&gt;val &lt;= l2-&gt;val)&#123;</span><br><span class="line">                    pre = l1;</span><br><span class="line">                    l1 = l1-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                //这里出来l1有可能为空或者l1的值大于l2的值</span><br><span class="line">                if(pre != nullptr)&#123;</span><br><span class="line">                    pre-&gt;next = l2;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if(l1 != nullptr)&#123;</span><br><span class="line">                    pre = nullptr;</span><br><span class="line">                    while(l2 != nullptr &amp;&amp; l2-&gt;val &lt; l1-&gt;val)&#123;</span><br><span class="line">                        pre = l2;</span><br><span class="line">                        l2 = l2-&gt;next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //这里出来有可能为空或者l2的值大于等于l1的值，这里要互补</span><br><span class="line">                    if(pre != nullptr) pre-&gt;next = l1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                //这里两个中必有一个为空——可以直接break？</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//递归</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;</span><br><span class="line">        //注意这里链表长度可能为空</span><br><span class="line">        if(!l1) return l2;</span><br><span class="line">        if(!l2) return l1;</span><br><span class="line">        //至此两者都不为空</span><br><span class="line">        ListNode* head = nullptr;</span><br><span class="line">        if(l1-&gt;val &lt; l2-&gt;val)&#123;</span><br><span class="line">            head = l1;</span><br><span class="line">            head-&gt;next = mergeTwoLists(l1-&gt;next, l2);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            head = l2;</span><br><span class="line">            head-&gt;next = mergeTwoLists(l1, l2-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="26-树的子结构"><a href="#26-树的子结构" class="headerlink" title="26_树的子结构"></a>26_树的子结构</h2><ul>
<li>都按前序遍历，化成字符串，最后再看看是不是子字符串，应该没问题，就是最后一个样例没有通过，不知道为啥<ul>
<li>后来试了一次BFS成功了！！最后一个例子也成功了，贴下代码</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">//BFS</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isSub(TreeNode* node, TreeNode* B)&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; qa, qb;</span><br><span class="line">        qa.push(node);</span><br><span class="line">        qb.push(B);</span><br><span class="line">        while(!qb.empty() &amp;&amp; !qa.empty())&#123;</span><br><span class="line">            //若qa为空了，qb不为空，那不是子结构</span><br><span class="line">            int n = qb.size();</span><br><span class="line">            int na = qa.size();</span><br><span class="line">            if(n &gt; na) return false;</span><br><span class="line">            while(n &gt; 0)&#123;</span><br><span class="line">                auto b = qb.front();</span><br><span class="line">                qb.pop();</span><br><span class="line">                auto a = qa.front();</span><br><span class="line">                qa.pop();</span><br><span class="line">                if(a-&gt;val != b-&gt;val) return false;</span><br><span class="line">                if(a-&gt;left != nullptr) qa.push(a-&gt;left);</span><br><span class="line">                if(a-&gt;right != nullptr) qa.push(a-&gt;right);</span><br><span class="line">                if(b-&gt;left != nullptr) qb.push(b-&gt;left);</span><br><span class="line">                if(b-&gt;right != nullptr) qb.push(b-&gt;right);</span><br><span class="line">                --n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return qb.empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool isSubStructure(TreeNode* A, TreeNode* B) &#123;</span><br><span class="line">        //先找到相同的根节点，然后再判断是否是子节点</span><br><span class="line">        //用递归还是BFS？用递归感觉有点绕，先用队列吧</span><br><span class="line">        if(!B || !A) return false;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(A);</span><br><span class="line">        bool ans = false;</span><br><span class="line">        while(!q.empty() &amp;&amp; !ans)&#123;</span><br><span class="line">            int n = q.size();</span><br><span class="line">            while(n &gt; 0)&#123;</span><br><span class="line">                auto node = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                if(node-&gt;val == B-&gt;val)&#123;</span><br><span class="line">                    ans = isSub(node, B);</span><br><span class="line">                &#125;</span><br><span class="line">                if(ans) break;</span><br><span class="line">                if(node-&gt;left != nullptr) q.push(node-&gt;left);</span><br><span class="line">                if(node-&gt;right != nullptr) q.push(node-&gt;right);</span><br><span class="line">                --n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>递归有个地方没弄懂，看到大佬的题解懂了<ul>
<li>递归函数是有返回值的（布尔类型）</li>
<li>若是B为空，是返回真还是假，我一直一位得把B都递归到最右边的节点才为真，其实不是，只要为空，就说明之前的已经匹配完成</li>
<li>还是递归更容易看懂</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/Offer/26.png" alt title="recur函数"></p>
<p><img src="/pictrues/Offer/26-1.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//递归</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isSubStructure(TreeNode* A, TreeNode* B) &#123;</span><br><span class="line">        if(!A || !B) return false;</span><br><span class="line">        return (recur(A, B) || isSubStructure(A-&gt;left, B) || isSubStructure(A-&gt;right, B));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool recur(TreeNode* A, TreeNode* B) &#123;</span><br><span class="line">        if(B == nullptr) return true;</span><br><span class="line">        if(A == nullptr || A-&gt;val != B-&gt;val) return false;</span><br><span class="line">        //这里是与运算，因为只要一个错误，就为假</span><br><span class="line">        return recur(A-&gt;left, B-&gt;left) &amp;&amp; recur(A-&gt;right, B-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>书上也是两个递归函数！</li>
</ul>
<h2 id="27-二叉树的镜像"><a href="#27-二叉树的镜像" class="headerlink" title="27_二叉树的镜像"></a>27_二叉树的镜像</h2><ul>
<li>输出镜像<ul>
<li>BFS走起——还是dfs，但是报错了<code>heap-use-after-free on address</code><ul>
<li>这个报错一般是数组指针，<code>delete</code>之后，就不能通过下标来读取了</li>
</ul>
</li>
<li>要先保存！！！！</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* mirrorTree(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return nullptr;</span><br><span class="line">        //似乎不需要创建一个新的二叉树！用递归修改指针试试</span><br><span class="line">        //原来如此！！怪不得会报错！要先保存左子树</span><br><span class="line">        TreeNode* tmp = root-&gt;left;</span><br><span class="line">        root-&gt;left = mirrorTree(root-&gt;right);</span><br><span class="line">        root-&gt;right = mirrorTree(tmp);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="28-对称的二叉树"><a href="#28-对称的二叉树" class="headerlink" title="28_对称的二叉树"></a>28_对称的二叉树</h2><ul>
<li>101题相同<ul>
<li>这次和101都用了递归，既然递归可以，那么BFS应该也可以，不过不太好写，应该把一层的节点的数值都放入字符串了，然后判断回文数？</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//dfs</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isSymmetric(TreeNode* node1, TreeNode* node2)&#123;</span><br><span class="line">        if(!node1 &amp;&amp; !node2)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;else if(!node1 || !node2 || node1-&gt;val != node2-&gt;val)&#123;</span><br><span class="line">            //若一个为空，另一个不为空；或者数值不等</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        //最终结果应该是与</span><br><span class="line">        return isSymmetric(node1-&gt;left, node2-&gt;right) &amp;&amp; isSymmetric(node1-&gt;right, node2-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool isSymmetric(TreeNode* root) &#123;</span><br><span class="line">        //试试递归</span><br><span class="line">        if(!root) return true;</span><br><span class="line"></span><br><span class="line">        //再看左右子树是否是镜像的</span><br><span class="line">        return isSymmetric(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>学习下迭代<ul>
<li>不必判断回文数，而是入队两次？</li>
<li>根节点入队两次！然后每次提取两个节点！<code>node1</code>、<code>node2</code>，若这两个节点值相等，那么就把<code>node1-&gt;left</code>、<code>node2-&gt;right</code>放入队尾，厉害厉害</li>
<li>手撕下<ul>
<li>一直在报错！</li>
<li>思考了半天，终于知道为什么了！！！！因为每次取出两个节点！所以长度<code>n</code>要减去2，而不是减1</li>
</ul>
</li>
<li>题解写的比我好，没有用到队列的长度！我也再优化下</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">//bfs，手撕</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isSymmetric(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return true;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        q.push(root);</span><br><span class="line">        </span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            int n = q.size();</span><br><span class="line">            while(n &gt; 0)&#123;</span><br><span class="line">                //每次取出两个节点</span><br><span class="line">                TreeNode* node1 = q.front(); q.pop();</span><br><span class="line"></span><br><span class="line">                //if(q.empty()) return false;  //如果确保下面每次都是两个两个放，那这里可以不要</span><br><span class="line">                TreeNode* node2 = q.front(); q.pop();</span><br><span class="line"></span><br><span class="line">                if(node1-&gt;val != node2-&gt;val)&#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                //这里不用判断两边是否都为空等等，下次迭代自然会不等</span><br><span class="line">                if(node1-&gt;left != nullptr &amp;&amp; node2-&gt;right != nullptr)&#123;</span><br><span class="line">                    q.push(node1-&gt;left);</span><br><span class="line">                    q.push(node2-&gt;right);</span><br><span class="line">                &#125;else if(!node1-&gt;left &amp;&amp; !node2-&gt;right)&#123;</span><br><span class="line">                    ;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if(node1-&gt;right != nullptr &amp;&amp; node2-&gt;left != nullptr)&#123;</span><br><span class="line">                    q.push(node1-&gt;right);</span><br><span class="line">                    q.push(node2-&gt;left);</span><br><span class="line">                &#125;else if(!node1-&gt;right &amp;&amp; !node2-&gt;left)&#123;</span><br><span class="line">                    ;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                n -= 2;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//优化</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isSymmetric(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return true;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        q.push(root);</span><br><span class="line">        </span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            TreeNode* n1 = q.front(); q.pop();</span><br><span class="line">            //这里题解是把空指针也放入了队列，所以下面要判断下</span><br><span class="line">            TreeNode* n2 = q.front(); q.pop();</span><br><span class="line">            //为了简便，这里还加了个两者都为空</span><br><span class="line">            if(!n1 &amp;&amp; !n2) continue;</span><br><span class="line"></span><br><span class="line">            if(!n1 || !n2 || n1-&gt;val != n2-&gt;val)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            q.push(n1-&gt;left);</span><br><span class="line">            q.push(n2-&gt;right);</span><br><span class="line"></span><br><span class="line">            q.push(n1-&gt;right);</span><br><span class="line">            q.push(n2-&gt;left);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>书上也是用的递归，看到前面我还以为是序列化二叉树呢！！！</li>
</ul>
<h2 id="29-顺时针打印矩阵"><a href="#29-顺时针打印矩阵" class="headerlink" title="29_顺时针打印矩阵"></a>29_顺时针打印矩阵</h2><ul>
<li>这次写的比第一次要好很多<ul>
<li>乍看以为是递归，其实两个循环或者一个循环就够了</li>
<li>我是将数字的总个数不等于0为<code>while</code>条件，每次放入一个数，就减一；而题解是对总数字进行<code>for</code>循环，好处是不用再套一个循环！</li>
<li>同样都需要另一个数组来进行标记</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">//手撕</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void print(vector&lt;vector&lt;int&gt;&gt;&amp; tmp, vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int&amp; total, int row, int col)&#123;</span><br><span class="line">        //终止条件</span><br><span class="line">        int i = 0, j = 0;</span><br><span class="line">        //方便循环，这里先放(0,0)</span><br><span class="line">        ans.emplace_back(matrix[i][j]);</span><br><span class="line">        //这里不要忘了标记</span><br><span class="line">        tmp[0][0] = 1;</span><br><span class="line">        --total;</span><br><span class="line"></span><br><span class="line">        while(total &gt; 0)&#123;</span><br><span class="line">            //遍历四个方向</span><br><span class="line">            //cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; &quot; j = &quot; &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">            for(auto&amp; dir : direction)&#123;</span><br><span class="line">                //这里是某个方向的第一格，因为新的循环，本身所在的数字已经放过了</span><br><span class="line">                int x = i + dir[0], y = j + dir[1];</span><br><span class="line">                //首先是向右，若没有路，那就向下，依次往后推，这里不仅要小于边界，还要大于等于0</span><br><span class="line">                if(x &lt; 0 || x == row || y &lt; 0 || y == col || tmp[x][y] == 1) continue;</span><br><span class="line"></span><br><span class="line">                while(x &gt;= 0 &amp;&amp; x &lt; row &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; col &amp;&amp; tmp[x][y] != 1)&#123;</span><br><span class="line">                    ans.emplace_back(matrix[x][y]);</span><br><span class="line">                    --total;</span><br><span class="line">                    tmp[x][y] = 1;</span><br><span class="line">                    x += dir[0];</span><br><span class="line">                    y += dir[1];</span><br><span class="line">                &#125;</span><br><span class="line">                //这里x，y不符合条件了，要回退上一个状态</span><br><span class="line">                i = x - dir[0];</span><br><span class="line">                j = y - dir[1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        //右、下、左、上这四个顺序——一直到无路可走，或者要打印的字符都打完了</span><br><span class="line">        if(matrix.empty() || matrix[0].empty()) return vector&lt;int&gt;();</span><br><span class="line"></span><br><span class="line">        int row = matrix.size(), col = matrix[0].size();</span><br><span class="line">        int total = row * col;</span><br><span class="line">        //用来标记已经打印的数字</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; tmp(row, vector&lt;int&gt;(col, 0));</span><br><span class="line">        //怎样用递归写的好看点</span><br><span class="line">        print(tmp, matrix, total, row, col);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; direction = &#123;&#123;0,1&#125;, &#123;1,0&#125;, &#123;0,-1&#125;, &#123;-1,0&#125;&#125;;</span><br><span class="line">    vector&lt;int&gt; ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>看看书上有没有什么好的思路<ul>
<li>书上是用了左上角的坐标，因为是一圈一圈的打印，所以横纵坐标相等，只要满足列数、行数都大于两倍的它，就还有剩余没有打印的数字</li>
<li>之后的函数，是根据起点的坐标，来完成打印一圈的功能</li>
<li>这个方法不太喜欢，还是喜欢四个方向整合在一起比较方便</li>
</ul>
</li>
</ul>
<h2 id="30-包含min函数的栈"><a href="#30-包含min函数的栈" class="headerlink" title="30_包含min函数的栈"></a>30_包含min函数的栈</h2><ul>
<li>155题<ul>
<li>让我想想当时的思路是什么来着——当时用了优先级队列嘛？<ul>
<li>先试试，注意默认是降序的——和一般的队列操作相同，升序队列是<code>priority_queue &lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q;</code></li>
</ul>
</li>
<li>不太好弄，因为栈的<code>push</code>、<code>pop</code>也保留了，因此顺序不应该变，试试<code>multiset</code></li>
<li><code>multiset</code>在删除的时候会将所有相同值都删除，应该只删除一个，加上补丁，居然过了…</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//手撕版本</span><br><span class="line">class MinStack &#123;</span><br><span class="line">public:</span><br><span class="line">    /** initialize your data structure here. */</span><br><span class="line">    MinStack() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    void push(int x) &#123;</span><br><span class="line">        stk.push(x);</span><br><span class="line">        set.insert(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void pop() &#123;</span><br><span class="line">        auto tmp = stk.top();</span><br><span class="line">        stk.pop();</span><br><span class="line">        //看看能不能加个补丁</span><br><span class="line">        auto count = set.count(tmp);</span><br><span class="line">        set.erase(tmp);</span><br><span class="line">        while(count &gt; 1)&#123;</span><br><span class="line">            set.insert(tmp);</span><br><span class="line">            --count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int top() &#123;</span><br><span class="line">        return stk.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int min() &#123;</span><br><span class="line">        return *set.begin();</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    //第二个参数默认是vector...第三个是less</span><br><span class="line">    //priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;</span><br><span class="line">    stack&lt;int&gt; stk;</span><br><span class="line">    multiset&lt;int&gt; set;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>还是题解写的好，每个元素与最小元素一一对应<ul>
<li>手写一遍，加深印象</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//手撕题解</span><br><span class="line">class MinStack &#123;</span><br><span class="line">public:</span><br><span class="line">    MinStack() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    void push(int x) &#123;</span><br><span class="line">        stk.push(x);</span><br><span class="line">        //如果放入的数字比最小值大，那栈顶元素还是最小值，等于也可以，只有当x小于最小值，才放入x</span><br><span class="line">        //这里一开始为空</span><br><span class="line">        if(!min_stk.empty() &amp;&amp; x &gt;= min_stk.top())&#123;</span><br><span class="line">            min_stk.push(min_stk.top());</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            min_stk.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void pop() &#123;</span><br><span class="line">        stk.pop();</span><br><span class="line">        min_stk.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int top() &#123;</span><br><span class="line">        return stk.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int min() &#123;</span><br><span class="line">        return min_stk.top();</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    stack&lt;int&gt; stk;</span><br><span class="line">    stack&lt;int&gt; min_stk;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="31-栈的压入、弹出序列"><a href="#31-栈的压入、弹出序列" class="headerlink" title="31_栈的压入、弹出序列"></a>31_栈的压入、弹出序列</h2><ul>
<li>946题…<ul>
<li>用栈来直接模拟流程，一次通过</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool validateStackSequences(vector&lt;int&gt;&amp; pushed, vector&lt;int&gt;&amp; popped) &#123;</span><br><span class="line">        //试试递归</span><br><span class="line">        //分析下，第一个弹出的数字是4，那么pushed里4前面的数字都要先入栈；那么pushed只剩5了，，，，</span><br><span class="line">        //可以直接用栈来模拟这个流程</span><br><span class="line">        if(pushed.empty() &amp;&amp; popped.empty()) return true;</span><br><span class="line">        if(pushed.size() != popped.size()) return false;</span><br><span class="line">        </span><br><span class="line">        int pos = 0, n = pushed.size();</span><br><span class="line">        stack&lt;int&gt; stk;</span><br><span class="line">        for(auto num : popped)&#123;</span><br><span class="line">            if(stk.empty() || num != stk.top())&#123;</span><br><span class="line">                //将num之前的数字都入栈，再来个指针指向起点，只不过有个条件，必须是后面的数字</span><br><span class="line">                while(pos &lt; n)&#123;</span><br><span class="line">                    if(pushed[pos] == num)&#123;</span><br><span class="line">                        ++pos;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    stk.push(pushed[pos]);</span><br><span class="line">                    ++pos;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                //这里与栈顶元素相等</span><br><span class="line">                stk.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return stk.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>看了题解，emmmm，还可以再优化下代码<ul>
<li>遍历一个<code>pushed</code>，就入栈一个数，再看看是否与<code>popped</code>相等</li>
<li>说是优化，代码简练点，执行用时低了几毫秒</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//优化</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool validateStackSequences(vector&lt;int&gt;&amp; pushed, vector&lt;int&gt;&amp; popped) &#123;</span><br><span class="line">        if(pushed.empty() &amp;&amp; popped.empty()) return true;</span><br><span class="line">        if(pushed.size() != popped.size()) return false;</span><br><span class="line">        </span><br><span class="line">        int pos = 0, n = pushed.size();</span><br><span class="line">        stack&lt;int&gt; stk;</span><br><span class="line">        for(auto num : pushed)&#123;</span><br><span class="line">            stk.push(num);</span><br><span class="line">            while(!stk.empty() &amp;&amp; pos &lt; n &amp;&amp; stk.top() == popped[pos])&#123;</span><br><span class="line">                stk.pop();</span><br><span class="line">                ++pos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return stk.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="32-1-从上到下打印二叉树"><a href="#32-1-从上到下打印二叉树" class="headerlink" title="32-1_从上到下打印二叉树"></a>32-1_从上到下打印二叉树</h2><ul>
<li>层次遍历，但是空节点也要输出<ul>
<li>若只是简单的BFS，那么遇到空节点就自动忽略了…</li>
<li>等等，审题审错了，就是BFS吧？<ul>
<li>可以，一次过  </li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//BFS</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return vector&lt;int&gt;();</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        vector&lt;int&gt; ans;</span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            int n = q.size();</span><br><span class="line">            while(n &gt; 0)&#123;</span><br><span class="line">                auto tmp = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                ans.emplace_back(tmp-&gt;val);</span><br><span class="line">                if(tmp-&gt;left != nullptr) q.push(tmp-&gt;left);</span><br><span class="line">                if(tmp-&gt;right != nullptr) q.push(tmp-&gt;right);</span><br><span class="line">                --n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>其实可以不用<code>n</code>，每次<code>pop()</code>一个节点就行，没有影响</li>
</ul>
<h2 id="32-2-从上到下打印二叉树"><a href="#32-2-从上到下打印二叉树" class="headerlink" title="32-2_从上到下打印二叉树"></a>32-2_从上到下打印二叉树</h2><ul>
<li>102题</li>
<li>这里是一层一层的打印，就需要用到<code>n</code>了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//BFS</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return vector&lt;vector&lt;int&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line"></span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            vector&lt;int&gt; tmp;</span><br><span class="line">            int n = q.size();</span><br><span class="line">            while(n &gt; 0)&#123;</span><br><span class="line">                auto node = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                tmp.emplace_back(node-&gt;val);</span><br><span class="line">                if(node-&gt;left != nullptr) q.push(node-&gt;left);</span><br><span class="line">                if(node-&gt;right != nullptr) q.push(node-&gt;right);</span><br><span class="line">                --n;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.emplace_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="32-3-从上到下打印二叉树"><a href="#32-3-从上到下打印二叉树" class="headerlink" title="32-3_从上到下打印二叉树"></a>32-3_从上到下打印二叉树</h2><ul>
<li>这题应该做过，但是下面提示没有显示<ul>
<li>应该加一个变量，用来判断奇偶层</li>
<li>这里出错了！</li>
<li>判断奇偶层没有用，因为下一层的起始节点，是上一层队列里的最后一个节点，这时才应该考虑先放左还是右</li>
<li>既然要考虑头尾，应该使用双向适配器<ul>
<li>也可以简单的将某一层的数组反转，再添加到结果的二维数组里</li>
</ul>
</li>
<li>每一层都是从最后开始的，可以不用双向链表，用栈，哈哈哈，说笑了说笑了！</li>
<li>还是得翻转，因为放置的节点，与数组的元素是交替相反的</li>
<li>总算过了</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//BFS+翻转数组</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return vector&lt;vector&lt;int&gt;&gt;();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">        int lines = 0;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line"></span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            vector&lt;int&gt; tmp;</span><br><span class="line">            int n = q.size();</span><br><span class="line">            while(n &gt; 0)&#123;</span><br><span class="line">                auto node = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                tmp.emplace_back(node-&gt;val);</span><br><span class="line">                if(node-&gt;left != nullptr) q.push(node-&gt;left);</span><br><span class="line">                if(node-&gt;right != nullptr) q.push(node-&gt;right);</span><br><span class="line">                --n;</span><br><span class="line">            &#125;</span><br><span class="line">            ++lines;</span><br><span class="line">            if(lines % 2 == 0) reverse(tmp.begin(), tmp.end());</span><br><span class="line">            ans.emplace_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>书上用的是两个栈！先进后出，然后分先左后右还是先右后左入栈</li>
<li>评论里用的是Java，返回类型是一个双向链表，这样就要么放到最后，要么放到前面，不用翻转那么麻烦</li>
<li>手撕下双栈！<ul>
<li>咳咳，明天吧！今天就写好</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//双栈</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return vector&lt;vector&lt;int&gt;&gt;();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk1, stk2;</span><br><span class="line">        stk1.push(root);</span><br><span class="line">        while(!stk1.empty() || !stk2.empty())&#123;</span><br><span class="line">            //两个栈有一个不为空，需要根据层数来确定先放左子树还是右子树</span><br><span class="line">            vector&lt;int&gt; tmp;</span><br><span class="line">            if(!stk1.empty())&#123;</span><br><span class="line">                while(!stk1.empty())&#123;</span><br><span class="line">                    auto node = stk1.top();</span><br><span class="line">                    stk1.pop();</span><br><span class="line">                    tmp.emplace_back(node-&gt;val);</span><br><span class="line">                    //好像不需要记录层数，是不是stk1的节点都是奇数层的？</span><br><span class="line">                    //先放左节点</span><br><span class="line">                    if(node-&gt;left != nullptr) stk2.push(node-&gt;left);</span><br><span class="line">                    if(node-&gt;right != nullptr) stk2.push(node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                while(!stk2.empty())&#123;</span><br><span class="line">                    auto node = stk2.top();</span><br><span class="line">                    stk2.pop();</span><br><span class="line">                    tmp.emplace_back(node-&gt;val);</span><br><span class="line">                    //好像不需要记录层数，是不是stk1的节点都是奇数层的？</span><br><span class="line">                    //先放右节点</span><br><span class="line">                    if(node-&gt;right != nullptr) stk1.push(node-&gt;right);</span><br><span class="line">                    if(node-&gt;left != nullptr) stk1.push(node-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.emplace_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="33-二叉搜索树的后序遍历序列"><a href="#33-二叉搜索树的后序遍历序列" class="headerlink" title="33_二叉搜索树的后序遍历序列"></a>33_二叉搜索树的后序遍历序列</h2><ul>
<li><p>那这题也写下吧</p>
<ul>
<li>复习下，递归和迭代！！</li>
<li>又没有仔细审题…这题似乎是反着来的</li>
<li>二叉搜索树的性质<ul>
<li>左子节点小于根节点小于右子节点</li>
<li>放在数组里的话，若没有空节点，那么刚开始的三个数字，第一个是左节点最小，第二个是右节点最大，第三个是根节点大小在中间，之后这三个为一组，取最大值，与后面的两个数字又组成一个完整的二叉树</li>
<li>问题是，考虑了空节点，那么可能性就比较多</li>
<li>就拿三个完整的节点（最小二叉树结构）来说<ul>
<li>第一种，三个节点都在</li>
<li>第二种，有一个空节点，这里又细分为三种情况</li>
<li>第三种，有两个空节点，这里也细分为三种情况</li>
<li>第四种，都是空节点</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>这题比较麻烦，明天再做</p>
<ul>
<li>既然这么多种情况，那就用递归，递个遍！<ul>
<li>递归不了，还得用分治，因为后序遍历，最后一个节点一定是根节点，这也解释了为什么，只有两个数字时，必然正确，因为前一个数字可大可小，可左可右；</li>
</ul>
</li>
<li>还得用分治！！前面某一段连续的数字必然是小于最后一个数，剩下的必然大于最后一个数<ul>
<li>如果，满足上述条件，那就分成两段，继续递归；若不满足，就返回<code>false</code>，而且只要出现<code>false</code>，那么结果就是<code>false</code></li>
<li>这么一想，思路就打开了！</li>
<li>就是判断条件的时候，都要遍历一次嘛？</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>用分治出了点问题<ul>
<li><code>upper_bound</code>的问题，明明6比5大，为什么还是显示在最后呢？</li>
<li><code>auto pos = upper_bound(postorder.begin(), postorder.end() - 1, root);</code>报错（堆溢出），我就纳闷了，不减1不报错，减2也不报错！！</li>
<li>噢，前提是要排好序！！哈哈哈哈哈哈哈，用的二分法，循环判断终于搞定了！！</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//分治</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool verifyPostorder(vector&lt;int&gt;&amp; postorder) &#123;</span><br><span class="line">        //发现分治，可以不用重载</span><br><span class="line">        int n = postorder.size();</span><br><span class="line">        //假设输入的数组的任意两个数字都互不相同，那么小于3个数，应该都是对的</span><br><span class="line">        if(n &lt; 3) return true;</span><br><span class="line">        </span><br><span class="line">        int root = postorder.back();</span><br><span class="line">        auto pos = postorder.begin();</span><br><span class="line">        for(; pos != postorder.end(); ++pos)&#123;</span><br><span class="line">            if(*pos &gt; root) break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //若pos在end()，则说明前面的数字都在左子树</span><br><span class="line">        if(pos == postorder.end())&#123;</span><br><span class="line">            vector&lt;int&gt; tmp(postorder.begin(), postorder.end() - 1);</span><br><span class="line">            return verifyPostorder(tmp);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            //这里判断pos后面的数是不是都大于root</span><br><span class="line">            //注意，这里起始点pos可能在begin()</span><br><span class="line">            for(auto it = pos + 1; it != postorder.end() - 1; ++it)&#123;</span><br><span class="line">                if(*it &lt; root) return false;</span><br><span class="line">            &#125;</span><br><span class="line">            //这里再判断是否在begin()处</span><br><span class="line">            if(pos == postorder.begin())&#123;</span><br><span class="line">                //只有右子树</span><br><span class="line">                vector&lt;int&gt; tmp(postorder.begin(), postorder.end() - 1);</span><br><span class="line">                return verifyPostorder(tmp);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                vector&lt;int&gt; tmp1(pos, postorder.end() - 1);</span><br><span class="line">                vector&lt;int&gt; tmp2(postorder.begin(), pos);</span><br><span class="line">                return verifyPostorder(tmp1) &amp;&amp; verifyPostorder(tmp2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>知道用分治，可为什么大佬写的非常简洁！！<ul>
<li>再优化优化，首先不用重新生成数组，而是添加标记</li>
</ul>
</li>
</ul>
<h2 id="34-二叉树中和为某一值的路径"><a href="#34-二叉树中和为某一值的路径" class="headerlink" title="34_二叉树中和为某一值的路径"></a>34_二叉树中和为某一值的路径</h2><ul>
<li>113<ul>
<li>记得当时做这题比较难，用了递归，没怎么理解透</li>
<li>哦哦，好像不是这题，应该任意两个节点之间的路径和，这题用回溯加剪枝应该很容易！手撕下</li>
<li>这次的出口条件跟以往不太一样，或者说，有多种条件，每次条件都对应的下面的不同判断语句</li>
<li>还是有点小问题<ul>
<li>还是审题不清，从根节点必须到叶节点才行，而不是到中间就行！唉，33、34这两题跟我过不去</li>
<li>出口那儿，再加上判断叶节点的条件，还好</li>
<li>又报错了，因为还有负数？不能简单的比较大小了，得全部递归到底了，不能剪枝，那这样，待会用下BFS试试</li>
<li>力扣真垃圾，测试个代码测半天——又又报错了</li>
</ul>
</li>
<li>知道问题出在哪儿了<ul>
<li><code>target == root-&gt;val</code>是有可能的，但不是叶节点，所以去掉<code>target != root-&gt;val</code>判断条件</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void dfs(TreeNode* root, int target, vector&lt;int&gt;&amp; tmp)&#123;</span><br><span class="line">        //这个递归，是要递归所有可能性才结束，下面递归条件决定了，这里不会出现空节点</span><br><span class="line">        if(target == root-&gt;val &amp;&amp; !root-&gt;left &amp;&amp; !root-&gt;right)&#123;</span><br><span class="line">            //这里弹入弹出下，方便回溯</span><br><span class="line">            tmp.emplace_back(root-&gt;val);</span><br><span class="line">            ans.emplace_back(tmp);</span><br><span class="line">            tmp.pop_back();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //画画图就明白了，这里target == root-&gt;val是有可能的，所以去掉target != root-&gt;val</span><br><span class="line">        tmp.emplace_back(root-&gt;val);</span><br><span class="line">        //这里回溯的时候会有个问题，若左节点为空，那就不应该弹出，直接再递归右节点，那就再加个条件</span><br><span class="line">        if(root-&gt;left != nullptr) dfs(root-&gt;left, target - root-&gt;val, tmp);</span><br><span class="line">        if(root-&gt;right != nullptr) dfs(root-&gt;right, target - root-&gt;val, tmp);</span><br><span class="line">        </span><br><span class="line">        //若两个子树都为空，那显然root-&gt;val不符合</span><br><span class="line">        tmp.pop_back();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int target) &#123;</span><br><span class="line">        //这个是打印出所有路径</span><br><span class="line">        if(!root) return vector&lt;vector&lt;int&gt;&gt;();</span><br><span class="line">        vector&lt;int&gt; tmp;</span><br><span class="line">        dfs(root, target, tmp);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>题解优化的比较好<ul>
<li>把节点为空和满足条件的路径分开来了</li>
<li>这样做的好处就是<code>tmp</code>只需弹入弹出一次</li>
<li>用BFS的话，不是每一层都记录下所有的路径，而是用哈希表记录对应的父节点，这样到叶节点是若满足目标值，就向前迭代</li>
</ul>
</li>
</ul>
<h2 id="35-复杂链表的复制"><a href="#35-复杂链表的复制" class="headerlink" title="35_复杂链表的复制"></a>35_复杂链表的复制</h2><ul>
<li><p>138</p>
<ul>
<li>应该算是深度拷贝，要创建新的节点</li>
<li>这应该算作图了，不过当时拷贝的时候不尽人意，总会报错，这次再来试试</li>
<li>有重复的数字，不好区分重复的节点是哪一个…</li>
<li>这题不会</li>
</ul>
</li>
<li><p>看了题解之后</p>
<ul>
<li>原来是将 原节点 与 新节点 一一对应啊；这样在 <code>next</code> 、<code>random</code> 变化之后，也可以找到对应的节点</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    Node* copyRandomList(Node* head) &#123;</span><br><span class="line">        if(head == nullptr) return nullptr;</span><br><span class="line">        Node* cur = head;</span><br><span class="line">        unordered_map&lt;Node*, Node*&gt; map;</span><br><span class="line">        // 3. 复制各节点，并建立 “原节点 -&gt; 新节点” 的 Map 映射</span><br><span class="line">        while(cur != nullptr) &#123;</span><br><span class="line">            map[cur] = new Node(cur-&gt;val);</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head;</span><br><span class="line">        // 4. 构建新链表的 next 和 random 指向</span><br><span class="line">        while(cur != nullptr) &#123;</span><br><span class="line">            map[cur]-&gt;next = map[cur-&gt;next];</span><br><span class="line">            map[cur]-&gt;random = map[cur-&gt;random];</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        // 5. 返回新链表的头节点</span><br><span class="line">        return map[head];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>还有一种方法居然一点印象都没有了<ul>
<li>我感觉看了大佬的题解之后，就不需要看书了</li>
<li>直接在原链表上生成新的节点，之后再拆分，拆分的时候只需要拆分 <code>next</code> 指针就行，别忘了前节点也要拆分</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/Offer/35.png" alt title="拆分"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    Node* copyRandomList(Node* head) &#123;</span><br><span class="line">        if(head == nullptr) return nullptr;</span><br><span class="line">        Node* cur = head;</span><br><span class="line">        // 1. 复制各节点，并构建拼接链表</span><br><span class="line">        while(cur != nullptr) &#123;</span><br><span class="line">            Node* tmp = new Node(cur-&gt;val);</span><br><span class="line">            tmp-&gt;next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = tmp;</span><br><span class="line">            cur = tmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        // 2. 构建各新节点的 random 指向</span><br><span class="line">        cur = head;</span><br><span class="line">        while(cur != nullptr) &#123;</span><br><span class="line">            if(cur-&gt;random != nullptr)</span><br><span class="line">                cur-&gt;next-&gt;random = cur-&gt;random-&gt;next;</span><br><span class="line">            cur = cur-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        // 3. 拆分两链表</span><br><span class="line">        cur = head-&gt;next;</span><br><span class="line">        Node* pre = head, *res = head-&gt;next;</span><br><span class="line">        while(cur-&gt;next != nullptr) &#123;</span><br><span class="line">            pre-&gt;next = pre-&gt;next-&gt;next;</span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre-&gt;next = nullptr; // 单独处理原链表尾节点</span><br><span class="line">        return res;      // 返回新链表头节点</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="36-二叉搜索树与双向链表"><a href="#36-二叉搜索树与双向链表" class="headerlink" title="36_二叉搜索树与双向链表"></a>36_二叉搜索树与双向链表</h2><ul>
<li>426还没有做到<ul>
<li>用了递归，一次过</li>
<li>有些地方需要注意，因为是环形双向链表，所以在递归返回的时候，也是一个环形双向链表</li>
<li>不能只是简单的改变<code>root</code>的左右指针这么简单，还要改变别的，并且还要考虑空指针的情况</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    Node* treeToDoublyList(Node* root) &#123;</span><br><span class="line">        //每个节点都有两个指针，正好一前一后，left就当做前，right就当作后</span><br><span class="line">        //用递归比较方便，问题就是头尾不好确定，应该分别是最小、最大的数</span><br><span class="line">        if(!root) return nullptr;</span><br><span class="line"></span><br><span class="line">        //不太对，这里返回的是头节点，还需要再改改！！，应该很简单，明天画画图！把头转为尾即可！！</span><br><span class="line">        auto l = treeToDoublyList(root-&gt;left);</span><br><span class="line">        auto r = treeToDoublyList(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        //更改方向，注意这里是双向的——这里l就是头节点</span><br><span class="line">        if(l != nullptr &amp;&amp; r != nullptr)&#123;</span><br><span class="line">            //先连接root</span><br><span class="line">            l-&gt;left-&gt;right = root;</span><br><span class="line">            root-&gt;left = l-&gt;left;</span><br><span class="line">            root-&gt;right = r;</span><br><span class="line">            auto tail = r-&gt;left;</span><br><span class="line">            r-&gt;left = root;</span><br><span class="line">            //最后连接首尾</span><br><span class="line">            l-&gt;left = tail;</span><br><span class="line">            tail-&gt;right = l;</span><br><span class="line">            return l;</span><br><span class="line">        &#125;else if(l != nullptr)&#123;</span><br><span class="line">            //这里右边为空——先连接root</span><br><span class="line">            l-&gt;left-&gt;right = root;</span><br><span class="line">            root-&gt;left = l-&gt;left;</span><br><span class="line">            //连首尾</span><br><span class="line">            l-&gt;left = root;</span><br><span class="line">            root-&gt;right = l;</span><br><span class="line">            return l;</span><br><span class="line">        &#125;else if(r != nullptr)&#123;</span><br><span class="line">            //这里左边为空——先连接root，root为头节点</span><br><span class="line">            auto tail = r-&gt;left;</span><br><span class="line">            root-&gt;right = r;</span><br><span class="line">            r-&gt;left = root;</span><br><span class="line">            //连首尾</span><br><span class="line">            tail-&gt;right = root;</span><br><span class="line">            root-&gt;left = tail;</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">        //若两个都为空</span><br><span class="line">        root-&gt;left = root;</span><br><span class="line">        root-&gt;right = root;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>我写的还是有点繁琐了<ul>
<li>大佬的题解是根据中序遍历，然后记录前驱节点（相当于尾节点），头节点</li>
<li>中序遍历一次，之后就可以直接加上头尾节点的方向就行！</li>
<li>太方便了，不需要判断那么多<code>if else</code>条件，代码也非常简洁</li>
<li>但是自己写不出来，在递归的时候如何保存上一个节点呢</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//手撕大佬题解——参考</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void dfs(Node* node)&#123;</span><br><span class="line">        //套用中序遍历的模板，左，根，右</span><br><span class="line">        if(!node) return;</span><br><span class="line">        dfs(node-&gt;left);</span><br><span class="line">        //这里需要pre，这里一直遍历到最左边</span><br><span class="line">        if(pre != nullptr)</span><br><span class="line">            pre-&gt;right = node; //右子树不影响</span><br><span class="line">        else</span><br><span class="line">            head = node;</span><br><span class="line">        </span><br><span class="line">        node-&gt;left = pre; //这里右子树也不影响，因为递归右节点的时候，会一直递归到左节点</span><br><span class="line">        pre = node;</span><br><span class="line">        dfs(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node* treeToDoublyList(Node* root) &#123;</span><br><span class="line">        if(!root) return nullptr;</span><br><span class="line">        dfs(root);</span><br><span class="line">        head-&gt;left = pre;</span><br><span class="line">        pre-&gt;right = head;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    Node* pre;</span><br><span class="line">    Node* head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>这题需要好好琢磨琢磨</li>
</ul>
<h2 id="37-序列化二叉树"><a href="#37-序列化二叉树" class="headerlink" title="37_序列化二叉树"></a>37_序列化二叉树</h2><ul>
<li><p>297题一样，但还没做到</p>
<ul>
<li>审下题，序列化不限制逻辑，前序、中序、后序遍历都可以，关键是只有一个序列，怎么恢复二叉树</li>
<li>之前做的一题是一个前序一个中序来恢复二叉树，这里运用下？</li>
<li>所以格式到底是什么？这题怎么恢复呢</li>
<li>看了书——之前的方法，有两个缺点：数值不能重复、得全部读取数据才能进行反序列化</li>
<li>格式原来就是遇到空指针时，字符串添加特殊字符，比如<code>$</code>，力扣上的一些参数例子就是，层序遍历，空指针为<code>NULL</code>；书上是深度优先，待会儿这两个方法都试下！</li>
</ul>
</li>
<li><p>有个注意点</p>
<ul>
<li>书上是输出流，是引用，自己写参数的时候，也要写成引用的，因为回溯后，字符还是要向前推的</li>
<li>但是我写完运行出错，不知道错哪儿<ul>
<li>错误地方在于，并没有全部序列化或者反序列化，只是一部分？</li>
<li>输出的字符串发现有的乱码了，我知道了，有的数字是两位数，转成字符串就不能直接<code>+&#39;0&#39;</code>了</li>
<li>那么反序列化，也就不能一个个字符来了</li>
<li>嗷，数字也要隔开！！不然乱套了</li>
<li>还是没成功！——递归出口也要<code>++i;</code>，，，，，emmmmmmmmm</li>
<li>居然还有负数？？那<code>stoi</code>就没用了，有用是有用，就是判断负号比较烦？</li>
<li>啊，成功了</li>
</ul>
</li>
</ul>
</li>
<li><p>题解是将字符串转为双向链表<code>list&lt;string&gt; dataArray;</code>，之后递归的时候一直删第一个，这样省去了不少麻烦！</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">//手撕版本，双5%，哈哈哈哈</span><br><span class="line">class Codec &#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    // Encodes a tree to a single string.</span><br><span class="line">    string serialize(TreeNode* root) &#123;</span><br><span class="line">        //这里居然是由返回值的</span><br><span class="line">        if(!root)&#123;</span><br><span class="line">            //这里不加逗号，会出现nn连在一起</span><br><span class="line">            return &quot;n,&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        string s;</span><br><span class="line">        s += to_string(root-&gt;val);</span><br><span class="line">        s.push_back(&apos;,&apos;);</span><br><span class="line">        s += serialize(root-&gt;left);</span><br><span class="line">        s += serialize(root-&gt;right);</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Decodes your encoded data to tree.</span><br><span class="line">    TreeNode* deserialize(string data) &#123;</span><br><span class="line">        //因为参数i是引用，所以得有变量</span><br><span class="line">        int n = data.size();</span><br><span class="line">        int i = 0;</span><br><span class="line">        return deserialize(data, i, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode* deserialize(string data, int&amp; i, int n) &#123;</span><br><span class="line">        //这里再加一个补丁</span><br><span class="line">        if(data[i] == &apos;,&apos;) ++i;</span><br><span class="line"></span><br><span class="line">        //这里的i应该是引用，因为回溯后，i是往前进一位的</span><br><span class="line">        if(i == n || data[i] == &apos;n&apos;)&#123;</span><br><span class="line">            //想起来了，这里也要++i，！！！</span><br><span class="line">            ++i;</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //加上负号补丁</span><br><span class="line">        int sign = 1;</span><br><span class="line">        if(data[i] == &apos;-&apos;)&#123;</span><br><span class="line">            ++i;</span><br><span class="line">            sign = -1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //这里提取数字</span><br><span class="line">        int j = i;</span><br><span class="line">        while(isdigit(data[i]))&#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //这里的i应该指向&apos;,&apos;，并不是负号</span><br><span class="line">        int num = stoi(data.substr(j, i - j));</span><br><span class="line">        TreeNode* head = new TreeNode(num * sign);</span><br><span class="line">        head-&gt;left = deserialize(data, i, n);</span><br><span class="line">        head-&gt;right = deserialize(data, i, n);</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//题解</span><br><span class="line">class Codec &#123;</span><br><span class="line">public:</span><br><span class="line">    void rserialize(TreeNode* root, string&amp; str) &#123;</span><br><span class="line">        if (root == nullptr) &#123;</span><br><span class="line">            str += &quot;None,&quot;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            str += to_string(root-&gt;val) + &quot;,&quot;;</span><br><span class="line">            rserialize(root-&gt;left, str);</span><br><span class="line">            rserialize(root-&gt;right, str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string serialize(TreeNode* root) &#123;</span><br><span class="line">        string ret;</span><br><span class="line">        rserialize(root, ret);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode* rdeserialize(list&lt;string&gt;&amp; dataArray) &#123;</span><br><span class="line">        if (dataArray.front() == &quot;None&quot;) &#123;</span><br><span class="line">            dataArray.erase(dataArray.begin());</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode* root = new TreeNode(stoi(dataArray.front()));</span><br><span class="line">        dataArray.erase(dataArray.begin());</span><br><span class="line">        root-&gt;left = rdeserialize(dataArray);</span><br><span class="line">        root-&gt;right = rdeserialize(dataArray);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode* deserialize(string data) &#123;</span><br><span class="line">        list&lt;string&gt; dataArray;</span><br><span class="line">        string str;</span><br><span class="line">        for (auto&amp; ch : data) &#123;</span><br><span class="line">            if (ch == &apos;,&apos;) &#123;</span><br><span class="line">                dataArray.push_back(str);</span><br><span class="line">                str.clear();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                str.push_back(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!str.empty()) &#123;</span><br><span class="line">            dataArray.push_back(str);</span><br><span class="line">            str.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        return rdeserialize(dataArray);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="38-字符串的排列"><a href="#38-字符串的排列" class="headerlink" title="38_字符串的排列"></a>38_字符串的排列</h2><ul>
<li>这题得好好做下，之前看的一本书（不过那是元素不重复的排列），用了<code>swap</code>方法，比重新生成字符串或者标记好多了<ul>
<li>如果是交换的话，该如何去重呢</li>
</ul>
</li>
<li>每日一题做的时候，发现这上面已经有代码，可能之前做过一次——但是没有提交记录，我写的是用了<code>erase</code>方法，用了哪个就删除哪个；终止条件是临时字符串的长度是否等于源字符串的长度!——但是没有去重，得用哈希记录下已经出现（用过）的字符</li>
<li>再看看剑指Offer书<ul>
<li>也是交换；把一个一个字符串分成两个部分、第一部分就是第一个字符，第二部分就是剩下的字符串，然后一一交换！嗷，如果遇见一样的就不用交换？</li>
<li>但是去重后交换报错了，不知道错哪儿；例子只通过了一半</li>
<li>因为还是需要哈希去重！！另一种去重方法就是排序去重，遇到和之前一样的，就跳过！</li>
</ul>
</li>
<li>题解的31下一个排列，用了字典序（当然，也是先排序），之前做过的都忘光光了0.0</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">//之前的老版本</span><br><span class="line">/*class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void dfs(vector&lt;string&gt; &amp;res, string &amp;tmp, string s, int n)&#123;</span><br><span class="line">        if(tmp.size() == n)&#123;</span><br><span class="line">            res.emplace_back(tmp);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        unordered_set&lt;char&gt; set;</span><br><span class="line">        //这里是从0开始，并且每次递归字符串s的长度会逐渐减小</span><br><span class="line">        for(int i = 0; i &lt; s.size(); ++i)&#123;</span><br><span class="line">            //这里去重，不能全部去除，只要遇到一样的，就不能重复放在一个位置</span><br><span class="line">            //这里就相当于第一个位置</span><br><span class="line">            if(set.find(s[i]) != set.end())</span><br><span class="line">                continue;</span><br><span class="line">            set.insert(s[i]);</span><br><span class="line"></span><br><span class="line">            tmp.push_back(s[i]);</span><br><span class="line">            string s1 = s;</span><br><span class="line">            dfs(res, tmp, s1.erase(i, 1), n);</span><br><span class="line">            tmp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;string&gt; permutation(string s) &#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        string tmp;</span><br><span class="line">        int n = s.size();</span><br><span class="line">        dfs(res, tmp, s, n);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;*/</span><br><span class="line"></span><br><span class="line">//交换去重版本</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void dfs(string s, int pos, int n)&#123;</span><br><span class="line">        if(pos == n)&#123;</span><br><span class="line">            ans.emplace_back(s);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        unordered_set&lt;char&gt; set;</span><br><span class="line">        for(int i = pos; i &lt; n; ++i)&#123;</span><br><span class="line">            //这里还要考虑s[i]有没有出现重复的！！还是得用哈希表</span><br><span class="line">            if(set.find(s[i]) != set.end())</span><br><span class="line">                continue;</span><br><span class="line">            set.insert(s[i]);</span><br><span class="line">            swap(s[pos], s[i]);</span><br><span class="line">            dfs(s, pos + 1, n);</span><br><span class="line">            swap(s[pos], s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;string&gt; permutation(string s) &#123;</span><br><span class="line">        if(s.empty())</span><br><span class="line">            return vector&lt;string&gt;();</span><br><span class="line">        int n = s.size();</span><br><span class="line">        dfs(s, 0, n);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>这里再啰嗦下，下次就不容易忘了<ul>
<li>交换去重和回溯思路是完全一样的，都是先确定第一位，依次往下</li>
<li>若是第一位或者某一位，出现了重复，那就要跳过——因为之前（后面几位）已经交换好了——这样理解：第一位确定好之后，再次回溯到第一位时，说明后面所有的字符都已经排列好了</li>
<li><code>i = pos</code> 循环是没有问题的！不是负负得正，而是就应该这样！</li>
</ul>
</li>
</ul>
<h2 id="39-数组中出现次数超过一半的数字"><a href="#39-数组中出现次数超过一半的数字" class="headerlink" title="39_数组中出现次数超过一半的数字"></a>39_数组中出现次数超过一半的数字</h2><ul>
<li>169<ul>
<li>用了投票算法，一次过</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int majorityElement(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        // 这里题目是说必定存在一个数字次数超过一半？</span><br><span class="line">        if(nums.size() == 1) return nums[0];</span><br><span class="line">        // 用下投票算法</span><br><span class="line">        int candidate, count = 0;</span><br><span class="line">        for(auto num : nums)&#123;</span><br><span class="line">            if(count == 0)&#123;</span><br><span class="line">                // 这里更新候选人</span><br><span class="line">                candidate = num;</span><br><span class="line">            &#125;</span><br><span class="line">            // 这里不用 if else；因为还要更新 count</span><br><span class="line">            if(candidate == num)&#123;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                --count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return candidate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>题解还用了其他方法<ul>
<li>哈希表、排序、随机化、分治</li>
</ul>
</li>
</ul>
<h2 id="40-最小的k个数"><a href="#40-最小的k个数" class="headerlink" title="40_最小的k个数"></a>40_最小的k个数</h2><ul>
<li>难道是先排序嘛<ul>
<li>还有要注意 k 的范围</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// sort 排序</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; getLeastNumbers(vector&lt;int&gt;&amp; arr, int k) &#123;</span><br><span class="line">        // k 是个数，0 应该返回空</span><br><span class="line">        if(arr.empty() || k &lt; 1 || k &gt; arr.size()) return vector&lt;int&gt;();</span><br><span class="line">        sort(arr.begin(), arr.end());</span><br><span class="line">        return vector&lt;int&gt;(arr.begin(), arr.begin() + k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>学习下大根堆<ul>
<li>面试容易问到，在处理大数据的时候，内存不够用，用大根堆就比较好</li>
<li><code>priority_queue&lt;int&gt; Q;</code> 为大根堆 —— 第一个元素总是最大的</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 大根堆</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; getLeastNumbers(vector&lt;int&gt;&amp; arr, int k) &#123;</span><br><span class="line">        vector&lt;int&gt; vec(k, 0);</span><br><span class="line">        if (k == 0) &#123; // 排除 0 的情况</span><br><span class="line">            return vec;</span><br><span class="line">        &#125;</span><br><span class="line">        priority_queue&lt;int&gt; Q;</span><br><span class="line">        for (int i = 0; i &lt; k; ++i) &#123;</span><br><span class="line">            Q.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = k; i &lt; (int)arr.size(); ++i) &#123;</span><br><span class="line">            if (Q.top() &gt; arr[i]) &#123;</span><br><span class="line">                Q.pop();</span><br><span class="line">                Q.push(arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; k; ++i) &#123;</span><br><span class="line">            vec[i] = Q.top();</span><br><span class="line">            Q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        return vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>再复习下快排算法，之前 “剑指Offer” 有一题练习过<ul>
<li>只快排数组前 k 个数……</li>
<li>不是快排，而是快速选择算法？</li>
</ul>
</li>
</ul>
<h2 id="41-数据流中的中位数"><a href="#41-数据流中的中位数" class="headerlink" title="41_数据流中的中位数"></a>41_数据流中的中位数</h2><ul>
<li>295<ul>
<li>记得有一题是数字递增的，忘了是哪一题了；</li>
<li>这题当时做的的心累，没有想到大根堆、小根堆，这次来手撕下！！</li>
<li>平衡两个堆，注意一些坑！优先级队列的定义 <code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt;</code> 有三个参数！</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 手撕，一次过</span><br><span class="line">class MedianFinder &#123;</span><br><span class="line">public:</span><br><span class="line">    MedianFinder() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    void addNum(int num) &#123;</span><br><span class="line">        // 这里要先确保 大堆 的所有数字都比 小堆 的大</span><br><span class="line">        mi.push(num);</span><br><span class="line">        ma.push(mi.top());</span><br><span class="line">        mi.pop();</span><br><span class="line">        // 这里再平衡，要么相等、要么小于</span><br><span class="line">        while(ma.size() &gt; mi.size())&#123;</span><br><span class="line">            mi.push(ma.top());</span><br><span class="line">            ma.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    double findMedian() &#123;</span><br><span class="line">        if(ma.size() == mi.size())&#123;</span><br><span class="line">            return (double)(ma.top() + mi.top()) / 2;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return (double)(mi.top());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    // ma 是越来越大，头部是最小值</span><br><span class="line">    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt;  ma;</span><br><span class="line">    // mi 是越来越小，头部是最大值</span><br><span class="line">    priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt;  mi;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="42-连续子数组的最大和"><a href="#42-连续子数组的最大和" class="headerlink" title="42_连续子数组的最大和"></a>42_连续子数组的最大和</h2><ul>
<li>53没印象了<ul>
<li>不知道是不是用的动态规划，先手撕下</li>
<li>好像应该用前缀和+哈希表！！！动规和双循环都会超时？</li>
<li>有点乱，状态转移只需要考虑<code>dp[i - 1]</code>，因为子数组是连续的；那之前需要遍历前面最大值的是哪题来着？？？</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//手撕动规</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        //先把每日一题敲一遍 好像是用的动规</span><br><span class="line">        if(nums.empty()) return 0;</span><br><span class="line"></span><br><span class="line">        //dp[i]是以i为结尾的子数组的最大值</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        vector&lt;int&gt; dp(n, 0);</span><br><span class="line">        //边界</span><br><span class="line">        dp[0] = nums[0];</span><br><span class="line"></span><br><span class="line">        for(int i = 1; i &lt; n; ++i)&#123;</span><br><span class="line">            //以 i 为结尾，这里还不能初始化为0呢，乱了乱了，因为是连续的所以只需考虑dp[i - 1]？</span><br><span class="line">            </span><br><span class="line">            //这里不一定得加上前面的，而是取最大值</span><br><span class="line">            dp[i] = max(dp[i - 1] + nums[i], nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return *max_element(dp.begin(), dp.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>题解写的真简洁<ul>
<li>这里不放了，类似于滚动数组</li>
<li>但是得学下分治！</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// TODO</span><br></pre></td></tr></table></figure>

<h2 id="43-1～n-整数中-1-出现的次数"><a href="#43-1～n-整数中-1-出现的次数" class="headerlink" title="43_1～n 整数中 1 出现的次数"></a>43_1～n 整数中 1 出现的次数</h2><ul>
<li>233<ul>
<li>有点棘手</li>
<li>一时忘了当时是怎么磨出来的，题解又是怎么的简洁！</li>
<li>直接看题解还有大佬的思路<ul>
<li>每一位上 1 出现的次数相加，总结果就是 1 的总个数</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/Offer/43.png" alt></p>
<ul>
<li><p>位因子是 10 的幂</p>
<ul>
<li>难点在于需要考虑不能大于原来的数字，比如 1014 这个数字；要分为两部分，一是 0010 ~ 0919，二是 1010 ~ 1014</li>
<li>第一部分可以肆无忌惮的相乘，因为没有范围限制；但是后面就有了</li>
<li>有个变量整数溢出了，<code>int</code> 得改为 <code>long long</code> 类型<ul>
<li><code>long long num = 1</code></li>
</ul>
</li>
<li><code>TODO</code> 明天再来记录！</li>
</ul>
</li>
<li><p>过了不知多久，在每日一题看到了</p>
<ul>
<li>那么是时候来填坑了！</li>
</ul>
</li>
</ul>
<h2 id="44-数字序列中某一位的数字"><a href="#44-数字序列中某一位的数字" class="headerlink" title="44_数字序列中某一位的数字"></a>44_数字序列中某一位的数字</h2><ul>
<li>400 还没有做到<ul>
<li>结果是唯一确定的，要是按照某个公式直接输出就好了</li>
<li></li>
</ul>
</li>
</ul>
<h2 id="45-把数组排成最小的数"><a href="#45-把数组排成最小的数" class="headerlink" title="45_把数组排成最小的数"></a>45_把数组排成最小的数</h2><ul>
<li>写谓词写到一半才发现，比较数字的时候，3 比 30、31、32 都大，3 就相当于 33<ul>
<li>有点像按照个位数排序的那个排序算法</li>
<li>这题之前有点印象，因为当时好像就是把 3 当成 33 来着</li>
<li>唉，积压的题目越来越多！</li>
</ul>
</li>
</ul>
<h2 id="46-把数字翻译成字符串"><a href="#46-把数字翻译成字符串" class="headerlink" title="46_把数字翻译成字符串"></a>46_把数字翻译成字符串</h2><ul>
<li>这个题目有印象<ul>
<li>要考虑多种情况，比如数字前面有个 0，或者前后两个数字合在一起超过了表示范围</li>
<li>感觉这题适合用动规</li>
<li>提示给出了 <code>num</code> 的范围，状态转移的时候要注意点，这题跟之前一题不太一样，任何个位数都可以翻译，也就是说，答案至少为 1</li>
<li>状态转移方程终于给我试出来了，只有两种情况，既考虑前一位数字也考虑本身（这个就是类似于斐波那契数列，或者青蛙跳台阶），第二种情况只能考虑本身</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int translateNum(int num) &#123;</span><br><span class="line">        // 似乎可以大致分为两种，考虑前一个数字，不考虑前一个数字</span><br><span class="line">        // 先转为字符串</span><br><span class="line">        string s(to_string(num));</span><br><span class="line">        int n = s.size();</span><br><span class="line">        vector&lt;int&gt; dp(n + 1, 0);</span><br><span class="line">        // 第一个数字 0 ~ 9 都可以翻译</span><br><span class="line">        dp[0] = 1;</span><br><span class="line">        dp[1] = 1;</span><br><span class="line">        for(int i = 1; i &lt; n; ++i)&#123;</span><br><span class="line">            // 考虑前一个数字在不在范围内，这个是考虑两个数连在一起的情况，应该是相加才对</span><br><span class="line">            if(s[i - 1] == &apos;1&apos; || (s[i - 1] == &apos;2&apos; &amp;&amp; s[i] &lt; &apos;6&apos;))&#123;</span><br><span class="line">                // 这样写看看</span><br><span class="line">                dp[i + 1] = dp[i - 1] + dp[i];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                // 不考虑前一个数字，都可以翻译</span><br><span class="line">                dp[i + 1] = dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>试下滚动数组</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int translateNum(int num) &#123;</span><br><span class="line">        string s(to_string(num));</span><br><span class="line">        int n = s.size();</span><br><span class="line">        // 这里 p 也要初始化下</span><br><span class="line">        int p2 = 1, p1 = 1, p = 1;</span><br><span class="line"></span><br><span class="line">        for(int i = 1; i &lt; n; ++i)&#123;</span><br><span class="line">            if(s[i - 1] == &apos;1&apos; || (s[i - 1] == &apos;2&apos; &amp;&amp; s[i] &lt; &apos;6&apos;))&#123;</span><br><span class="line">                p = p2 + p1;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                p = p1;</span><br><span class="line">            &#125;</span><br><span class="line">            p2 = p1;</span><br><span class="line">            p1 = p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="47-礼物的最大价值"><a href="#47-礼物的最大价值" class="headerlink" title="47_礼物的最大价值"></a>47_礼物的最大价值</h2><ul>
<li>这题有印象<ul>
<li>这题之前应该是第一次摸索出的动规，这里再加深下印象，可以，一次过</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxValue(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        // 提示里显示不为空</span><br><span class="line">        int row = grid.size(), col = grid[0].size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(row, vector&lt;int&gt;(col, 0));</span><br><span class="line">        // 边界</span><br><span class="line">        dp[0][0] = grid[0][0];</span><br><span class="line">        for(int i = 1; i &lt; row; ++i)&#123;</span><br><span class="line">            dp[i][0] = dp[i - 1][0] + grid[i][0];</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j = 1; j &lt; col; ++j)&#123;</span><br><span class="line">            dp[0][j] = dp[0][j - 1] + grid[0][j];</span><br><span class="line">        &#125;</span><br><span class="line">        // 遍历</span><br><span class="line">        for(int i = 1; i &lt; row; ++i)&#123;</span><br><span class="line">            for(int j = 1; j &lt; col; ++j)&#123;</span><br><span class="line">                // 状态转移</span><br><span class="line">                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[row - 1][col - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>大佬题解是直接在原数组修改的<ul>
<li>还有大佬是直接多开一行一列，这样初始化边界就可以不用那两个一次循环了</li>
</ul>
</li>
</ul>
<h2 id="48-最长不含重复字符的子字符串"><a href="#48-最长不含重复字符的子字符串" class="headerlink" title="48_最长不含重复字符的子字符串"></a>48_最长不含重复字符的子字符串</h2><ul>
<li>3</li>
<li>再来复习下动态规划，说错了，应该是滑动窗口<ul>
<li>判断窗口里有没有重复的，最简单的应该是用哈希表</li>
<li>这次我想试试 数组 长度为 26，但是有个问题，题目中没有确保都是小写字母</li>
<li>用哈希后，栈溢出了……还有删除的时候有个坑，不是遇到重复的就删，而是一直删除前面的……</li>
<li>又溢出了，怎么回事</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLongestSubstring(string s) &#123;</span><br><span class="line">        // 就用哈希表</span><br><span class="line">        if(s.empty()) return 0;</span><br><span class="line">        int ans = 1;</span><br><span class="line">        int l = 0, r = 0;</span><br><span class="line">        // 哈希，用 set 不用 map 是因为遇到重复的就要缩短窗口来去除重复</span><br><span class="line">        unordered_set&lt;int&gt; set;</span><br><span class="line">        while(r &lt; s.size())&#123;</span><br><span class="line">            //cout &lt;&lt; &quot;r = &quot; &lt;&lt; r &lt;&lt; endl;</span><br><span class="line">            // 先拉长窗口，哦哦，这里应该写 ==</span><br><span class="line">            if(set.find(s[r]) == set.end())&#123;</span><br><span class="line">                set.insert(s[r]);</span><br><span class="line">                // 这里可能会直接结束了，外面还要再判断一次</span><br><span class="line">                ++r;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                // 先更新结果</span><br><span class="line">                ans = max(ans, r - l);</span><br><span class="line">                // 缩短窗口，这里还不能删呢，不对还是得删，不然没法进入第一个条件</span><br><span class="line">                set.erase(s[r]);</span><br><span class="line">                while(s[l] != s[r])&#123;</span><br><span class="line">                    set.erase(s[l]);</span><br><span class="line">                    ++l;</span><br><span class="line">                &#125;</span><br><span class="line">                ++l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 这里也可以直接初始化成字符串的长度</span><br><span class="line">        ans = max(ans, r - l);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>也可以用动态规划……<ul>
<li>也要用哈希来辅助 —— 主要来记录对应元素的下标</li>
<li>下标有什么用呢，在状态转移的时候会分类讨论，先手撕下，加深理解</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 动规</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLongestSubstring(string s) &#123;</span><br><span class="line">        if(s.empty()) return 0;</span><br><span class="line">        int n = s.size();</span><br><span class="line">        vector&lt;int&gt; dp(n, 0);</span><br><span class="line">        unordered_map&lt;char, int&gt; map;</span><br><span class="line">        int ans = 1;</span><br><span class="line">        // 边界初始化</span><br><span class="line">        dp[0] = 1;</span><br><span class="line">        map[s[0]] = 0;</span><br><span class="line">        for(int i = 1; i &lt; n; ++i)&#123;</span><br><span class="line">            if(map.find(s[i]) == map.end())&#123;</span><br><span class="line">                dp[i] = dp[i - 1] + 1;</span><br><span class="line">                // 这里的哈希类似于滚动数组</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                // 这里得分两种</span><br><span class="line">                int j = map[s[i]];</span><br><span class="line">                if(dp[i - 1] &lt; i - j)</span><br><span class="line">                    dp[i] = dp[i - 1] + 1;</span><br><span class="line">                else</span><br><span class="line">                    dp[i] = i - j;</span><br><span class="line">            &#125;</span><br><span class="line">            map[s[i]] = i;</span><br><span class="line">            ans = max(ans, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>我觉得我写的好啰嗦</li>
</ul>
<h2 id="49-丑数"><a href="#49-丑数" class="headerlink" title="49_丑数"></a>49_丑数</h2><ul>
<li>264<ul>
<li>老朋友了，但我忘了……</li>
<li>再学习下</li>
<li>最小堆永远的神！<code>priority_queue&lt;long, vector&lt;long&gt;, greater&lt;long&gt;&gt;</code></li>
<li>三个指针也牛皮</li>
</ul>
</li>
</ul>
<h2 id="50-第一个只出现一次的字符"><a href="#50-第一个只出现一次的字符" class="headerlink" title="50_第一个只出现一次的字符"></a>50_第一个只出现一次的字符</h2><ul>
<li>一种方法是遍历两次字符串，可以用哈希，也可以用数组</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    char firstUniqChar(string s) &#123;</span><br><span class="line">        // 简单吗，只包含小写字母，那就用计数排序</span><br><span class="line">        if(s.empty()) return &apos; &apos;;</span><br><span class="line">        vector&lt;int&gt; dp(26, 0);</span><br><span class="line">        for(auto ch : s)&#123;</span><br><span class="line">            dp[ch - &apos;a&apos;]++;</span><br><span class="line">        &#125;</span><br><span class="line">        // 遍历数组不对，会破坏原来的顺序，还是得遍历一遍字符串</span><br><span class="line">        for(auto ch : s)&#123;</span><br><span class="line">            if(dp[ch - &apos;a&apos;] == 1) return ch;</span><br><span class="line">        &#125;</span><br><span class="line">        return &apos; &apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>另一种改进的方法是，第一次遍历字符串，第二次遍历哈希表，若值为 下标 则不重复，若为 -1 则重复<ul>
<li>可是怎么确定这是第一个，哈希表不是无序的吗</li>
<li>又加了个变量 <code>first</code>，也就是说，要对哈希表完整遍历一次才能找出最小值</li>
<li>感觉比数组慢……</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    char firstUniqChar(string s) &#123;</span><br><span class="line">        unordered_map&lt;char, int&gt; position;</span><br><span class="line">        int n = s.size();</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            if (position.count(s[i])) &#123;</span><br><span class="line">                position[s[i]] = -1;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                position[s[i]] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int first = n;</span><br><span class="line">        for (auto [_, pos]: position) &#123;</span><br><span class="line">            if (pos != -1 &amp;&amp; pos &lt; first) &#123;</span><br><span class="line">                first = pos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return first == n ? &apos; &apos; : s[first];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="51-数组中的逆序对"><a href="#51-数组中的逆序对" class="headerlink" title="51_数组中的逆序对"></a>51_数组中的逆序对</h2><ul>
<li>归并排序<ul>
<li>与求逆序对的关系，在合并的过程中，最小的那个数（新的数组开头）对逆序对没有贡献</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/Offer/51.png" alt></p>
<h2 id="52-两个链表的第一个公共节点"><a href="#52-两个链表的第一个公共节点" class="headerlink" title="52_两个链表的第一个公共节点"></a>52_两个链表的第一个公共节点</h2><ul>
<li>160<ul>
<li>再来手撕下</li>
<li>这里有个问题，数字是可以重复的，那仅仅判断数字重复就断定交点是不是草率了，待会看看之前的解法</li>
<li><code>==</code> 存在漏洞，用了判断地址是否相同</li>
<li>之前是用的 <code>while (carry1 != carry2)</code> 这个条件，哈希表也可以存储节点</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;</span><br><span class="line">        // 交点可能有，也可能没有</span><br><span class="line">        if(!headA || !headB) return nullptr;</span><br><span class="line">        ListNode* carryA = headA;</span><br><span class="line">        ListNode* carryB = headB;</span><br><span class="line"></span><br><span class="line">        // 这里应该用或运算，只要两个节点都不为空即可</span><br><span class="line">        while(carryA != nullptr || carryB != nullptr)&#123;</span><br><span class="line">            // 这里判断相等 == 应该没有重载，但是数字也有可能是重复的</span><br><span class="line">            // 要写在后面，防止节点为空，不对，还是要加上不为空的条件，还得写在前面，第一个就是交点呢</span><br><span class="line">            if(carryA == carryB) break;</span><br><span class="line"></span><br><span class="line">            // 这里换个写法，如果都为空，是进不来的</span><br><span class="line">            if(!carryA) carryA = headB;</span><br><span class="line">            else carryA = carryA-&gt;next;</span><br><span class="line"></span><br><span class="line">            if(!carryB) carryB = headA;</span><br><span class="line">            else carryB = carryB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return carryA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="53-1-在排序数组中查找数字"><a href="#53-1-在排序数组中查找数字" class="headerlink" title="53-1_在排序数组中查找数字"></a>53-1_在排序数组中查找数字</h2><ul>
<li>34题一样，好像当时是找到一个，然后向左向右分别遍历的<ul>
<li>这个时候就体现出<code>upper_bound</code>、<code>lower_bound</code>的好处了</li>
<li>这两个函数也可以满足没有目标值的情况，一次通过！！</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int search(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        //运用两次二分，查找左右边界？</span><br><span class="line">        //第一个大于</span><br><span class="line">        auto r = upper_bound(nums.begin(), nums.end(), target);</span><br><span class="line">        //第一个不小于</span><br><span class="line">        auto l = lower_bound(nums.begin(), nums.end(), target);</span><br><span class="line"></span><br><span class="line">        return r - l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>这题的考点就是二分了<ul>
<li>题解是把左边界和右边界二分合在一起，再琢磨琢磨<ul>
<li>这里是精髓<code>if (nums[mid] &gt; target || (lower &amp;&amp; nums[mid] &gt;= target))</code></li>
<li>但是题解返回的是<code>ans</code>而不是<code>l</code>，我再改改</li>
<li>还是写成<code>l &lt; r</code>吧，左开右闭</li>
<li>二分法还是一生之敌啊</li>
<li>寻找左边界是指左边比<code>target</code>小的数有几个，也就是说，若<code>target</code>不在数组中，且存在小的数，<code>l</code>也是有解的</li>
<li>那么寻找右边界是指左边比<code>target</code>小于等于的数有几个，若最后答案减一，那就是下标，不减一就是个数，，，，说的我自己都有点乱！！</li>
</ul>
</li>
<li>也有大佬把<code>upper_bound</code>、<code>lower_bound</code>的模板写了一遍！</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//手撕题解</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int binarySearch(vector&lt;int&gt;&amp; nums, int target, bool lower, int n)&#123;</span><br><span class="line">        int l = 0, r = n;</span><br><span class="line">        while(l &lt; r)&#123;</span><br><span class="line">            int mid = (r - l) / 2 + l;</span><br><span class="line">            if(lower)&#123;</span><br><span class="line">                //左边界</span><br><span class="line">                if(nums[mid] &gt;= target)&#123;</span><br><span class="line">                    r = mid;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    l = mid + 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                //右边界，因为是有边界，最后是要返回l - 1的</span><br><span class="line">                if(nums[mid] &lt;= target)&#123;</span><br><span class="line">                    l = mid + 1;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    r = mid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int search(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        if(nums.empty() || target &lt; nums[0] || target &gt; nums.back()) return 0;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        //前提是这个数字在数组中</span><br><span class="line">        int l = binarySearch(nums, target, true, n);</span><br><span class="line">        //cout &lt;&lt; &quot;l = &quot; &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">        int r = binarySearch(nums, target, false, n);</span><br><span class="line">        //cout &lt;&lt; &quot;r = &quot; &lt;&lt; r &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        return r - l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>为什么不直接抄题解<ul>
<li>因为题解最后返回的不是<code>l</code>而是<code>ans</code>，与我之前的一贯思路不匹配，容易乱！</li>
<li>经过这次的洗礼，印象又加深了<ul>
<li>如<code>target</code>不在数组中，那么左边界——返回的是小于<code>target</code>的个数；右边界——也不能算作个数，而是第一个大于<code>target</code>数字的下标，有可能在<code>end()</code>处</li>
<li>那么左边界、右边界相等时（两者之差为0），说明<code>target</code>不在数组中！！！</li>
</ul>
</li>
<li>先告一段落！！</li>
</ul>
</li>
</ul>
<h2 id="53-2-0～n-1-中缺失的数字"><a href="#53-2-0～n-1-中缺失的数字" class="headerlink" title="53_2_0～n-1 中缺失的数字"></a>53_2_0～n-1 中缺失的数字</h2><ul>
<li>除了数学求和，看看还有没有其他方法<ul>
<li>雾草，怪不得都是 53 题，也是可以用二分的！</li>
<li>因为原数组排好序了，而且第一个数字又是从 0 开始，所以跟下标是一一对应的，若缺少一个数字，那么后面的数字跟下标就不对应了</li>
<li>技能点<ul>
<li>排序数组中的搜索问题，首先想到 二分法 解决</li>
<li>这题再手撕下</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// 数学求和</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int missingNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        // 之前应该用了数学求和的方法</span><br><span class="line">        // 从 0 开始，一共有 n 个数字（少一个），整数边界要注意</span><br><span class="line">        int sum = accumulate(nums.begin(), nums.end(), 0);</span><br><span class="line">        // 这里的 n 是少一个的，要注意</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        // 注意这里，不能先除</span><br><span class="line">        int allSum = n * (n + 1) / 2;</span><br><span class="line">        return allSum - sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 二分法</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int missingNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        // 找边界，还是用开区间吧</span><br><span class="line">        int l = 0, r = nums.size();</span><br><span class="line">        while(l &lt; r)&#123;</span><br><span class="line">            int mid = (r - l) / 2 + l;</span><br><span class="line">            // 左边界</span><br><span class="line">            if(nums[mid] == mid)&#123;</span><br><span class="line">                // 这里 +1 是因为 l = mid 不是最后要的结果</span><br><span class="line">                l = mid + 1;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="54-二叉搜索树的第-k-大节点"><a href="#54-二叉搜索树的第-k-大节点" class="headerlink" title="54_二叉搜索树的第 k 大节点"></a>54_二叉搜索树的第 k 大节点</h2><ul>
<li>这题用的递归<ul>
<li>算是巩固下，加深理解</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int ans, pos = 0;</span><br><span class="line">    // 第 k 大的节点，不能中序遍历，而是自定义的遍历，先右、根、再左</span><br><span class="line">    // 还是得自定义一个函数</span><br><span class="line">    void kth(TreeNode* root, int k)&#123;</span><br><span class="line">        if(pos == k || !root)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 先到最右边</span><br><span class="line">        kthLargest(root-&gt;right, k);</span><br><span class="line">        // 这里返回后，pos 已经等于 k 了，但是没有判断，再加一个判断；那开头是不是就不用加了呢</span><br><span class="line">        if(pos == k) return;</span><br><span class="line"></span><br><span class="line">        // 更新 pos、ans</span><br><span class="line">        pos++;</span><br><span class="line">        ans = root-&gt;val;</span><br><span class="line">        kthLargest(root-&gt;left, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int kthLargest(TreeNode* root, int k) &#123;</span><br><span class="line">        // if(k &lt; 1) return -1;</span><br><span class="line">        kth(root, k);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="55-1-二叉树的深度"><a href="#55-1-二叉树的深度" class="headerlink" title="55-1_二叉树的深度"></a>55-1_二叉树的深度</h2><ul>
<li>104<ul>
<li>之前应该都用的 BFS 不知道 DFS 行不行的通</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxDepth(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return 0;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        q.push(root);</span><br><span class="line"></span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            int n = q.size();</span><br><span class="line">            while(n &gt; 0)&#123;</span><br><span class="line">                auto node = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                if(node-&gt;left != nullptr) q.push(node-&gt;left);</span><br><span class="line">                if(node-&gt;right != nullptr) q.push(node-&gt;right);</span><br><span class="line">                --n;</span><br><span class="line">            &#125;</span><br><span class="line">            ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>DFS 原来更简单</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// DFS</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxDepth(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return 0;</span><br><span class="line">        int l = maxDepth(root-&gt;left);</span><br><span class="line">        int r = maxDepth(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        return max(l + 1, r + 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="55-2-平衡二叉树"><a href="#55-2-平衡二叉树" class="headerlink" title="55-2_平衡二叉树"></a>55-2_平衡二叉树</h2><ul>
<li>110<ul>
<li>这题应该用递归好一点！</li>
<li>应该再加一个 深度 参数，报错了……</li>
<li>递归求出来的是 最大长度 而题目要求必须是每个节点都要平衡！要不再加一行递归，那这两个函数都递归岂不是重复了好多……<ul>
<li>先看看能不能过吧</li>
<li>雾草，还真可以</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/Offer/55-2.png" alt title="提交记录"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    // 写个求深度的函数，然后主函数调用</span><br><span class="line">    int maxDepth(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return 0;</span><br><span class="line">        int l = maxDepth(root-&gt;left);</span><br><span class="line">        int r = maxDepth(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        return max(l + 1, r + 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool isBalanced(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return true;</span><br><span class="line">        int l = maxDepth(root-&gt;left);</span><br><span class="line">        int r = maxDepth(root-&gt;right);</span><br><span class="line">        bool flag = abs(l - r) &lt; 2 ? true : false;</span><br><span class="line">        // 这里除了根节点平衡，其余节点也要平衡！</span><br><span class="line">        return flag &amp;&amp; isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>大佬题解也是这个思路<ul>
<li>比我写的还要简洁</li>
</ul>
</li>
</ul>
<h2 id="56-1-数组中数字出现的次数"><a href="#56-1-数组中数字出现的次数" class="headerlink" title="56-1_数组中数字出现的次数"></a>56-1_数组中数字出现的次数</h2><ul>
<li><p>其余数字出现两次，有且仅有两个数字出现一次</p>
</li>
<li><p>时空复杂度……想不出来</p>
<ul>
<li>想排个序，但好像没有符合要求的</li>
<li>看了题解：两个只出现一次的数字在不同的组中；相同的数字会被分到相同的组中。</li>
<li>之后跟二进制前缀和有点像，按照 1 和 0 来进行区分<ul>
<li>是随便选一个位为 1，来进行划分</li>
</ul>
</li>
</ul>
</li>
<li><p>算法</p>
</li>
</ul>
<p><img src="/pictrues/Offer/56-1.png" alt title="算法"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; singleNumbers(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int ret = 0;</span><br><span class="line">        for (int n : nums)</span><br><span class="line">            ret ^= n;</span><br><span class="line">        int div = 1;</span><br><span class="line">        while ((div &amp; ret) == 0)</span><br><span class="line">            div &lt;&lt;= 1;</span><br><span class="line">        // 说是分组其实是分别与两个数进行异或</span><br><span class="line">        int a = 0, b = 0;</span><br><span class="line">        for (int n : nums)</span><br><span class="line">            if (div &amp; n)</span><br><span class="line">                a ^= n;</span><br><span class="line">            else</span><br><span class="line">                b ^= n;</span><br><span class="line">        return vector&lt;int&gt;&#123;a, b&#125;; // 初始化</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="56-2-数组中数字出现的次数"><a href="#56-2-数组中数字出现的次数" class="headerlink" title="56-2_数组中数字出现的次数"></a>56-2_数组中数字出现的次数</h2><ul>
<li><p>其余数字出现三次，有且仅有一个数字出现一次</p>
<ul>
<li>上一题可以分组，那么这一题呢</li>
<li>看了大佬的题解，不是想着如何去异或，而是从各个二进制位入手，出现三次的数字，其各个二进制位的出现次数都是 3 的倍数</li>
<li>主要是如何统计二进制 1 的总个数，咳咳，在这儿之前还是得先异或，不对，不知道咋算</li>
<li>有限状态自动机……数字逻辑、真值表，都忘得差不多了<ul>
<li>好难理解…</li>
</ul>
</li>
</ul>
</li>
<li><p>时隔几日，再看一遍</p>
<ul>
<li>只看状态转移表还是很容易理解的，当状态为 10 时，也就是余数是 2，无论再来一个二进制位 0 或 1 下一个状态不是 10（余数 2） 就是 00（余数 0），也就是 one = 0；</li>
<li>上面是计算 one 的，计算 two 的公式就有点难以理解……</li>
<li>两个公式都是一个二进制位 n 来计算的，可以推广到 int 32 位，来并行计算！所以最后的代码很简洁，主要就是公式，而且是计算 two 的公式</li>
</ul>
</li>
<li><p>就是这里看不懂</p>
<ul>
<li>n 为 0 的时候，状态不是不变么，这里应该是 n 为 1 的时候</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/Offer/56-2.png" alt title="？？？"></p>
<ul>
<li>因为只有一个 出现一次的 数字，所以最后结果（状态）不是 00 就是 01，不会出现余数为 2 的情况</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int ones = 0, twos = 0;</span><br><span class="line">        for(auto n : nums)&#123;</span><br><span class="line">            ones = ones ^ n &amp; ~ twos;</span><br><span class="line">            twos = twos ^ n &amp; ~ ones;</span><br><span class="line">        &#125;</span><br><span class="line">        return ones;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="57-1-和为-s-的两个数字"><a href="#57-1-和为-s-的两个数字" class="headerlink" title="57-1_和为 s 的两个数字"></a>57-1_和为 s 的两个数字</h2><ul>
<li>这题倒是做出来了<ul>
<li>遍历第一个数字，之后用二分查找另一个，遍历的时候可以缩小范围</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        // 递增、二分</span><br><span class="line">        vector&lt;int&gt; ans;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        for(int i = 0; (nums[i] &lt; (target &gt;&gt; 1) + 1) &amp;&amp; i &lt; n; ++i)&#123;</span><br><span class="line">            int tmp = target - nums[i];</span><br><span class="line">            // 用二分找 tmp</span><br><span class="line">            int l = i + 1, r = n - 1;</span><br><span class="line">            int pos = -1;</span><br><span class="line">            while(l &lt;= r)&#123;</span><br><span class="line">                int mid = (r - l) / 2 + l;</span><br><span class="line">                if(nums[mid] == tmp)&#123;</span><br><span class="line">                    pos = mid;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;else if(nums[mid] &lt; tmp)&#123;</span><br><span class="line">                    l = mid + 1;</span><br><span class="line">                &#125;else if(nums[mid] &gt; tmp)&#123;</span><br><span class="line">                    r = mid - 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(pos != -1)&#123;</span><br><span class="line">                ans.push_back(nums[i]);</span><br><span class="line">                ans.push_back(tmp);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="57-2-和为-s-的连续正数序列"><a href="#57-2-和为-s-的连续正数序列" class="headerlink" title="57-2_和为 s 的连续正数序列"></a>57-2_和为 s 的连续正数序列</h2><ul>
<li>这题为什么标记为简单？<ul>
<li>简单吗？</li>
<li>既然是连续的数字，那就标记左右两端的数字，之后计算总和，好像和上题差不多……</li>
<li>有个注意点，子序列必须至少为两个数！</li>
<li>有点绕，确定一个数字后，要根据目标值计算出另一个，这样用二分才比较好找，但是要判断存不存在</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; findContinuousSequence(int target) &#123;</span><br><span class="line">        if(target &lt; 3) return vector&lt;vector&lt;int&gt;&gt;();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">        for(int i = 1; i &lt; (target + 1) / 2; ++i)&#123;</span><br><span class="line">            // 还是个二元方程</span><br><span class="line">            // (i + n) * (n - i + 1) / 2 == target;</span><br><span class="line">            // 找 n </span><br><span class="line">            int l = i + 1, r = (target + 1) / 2;</span><br><span class="line">            bool flag = false;</span><br><span class="line">            // 这里二分，因为要至少两个数，所以不能等于，</span><br><span class="line">            while(l &lt;= r)&#123;</span><br><span class="line">                int mid = (r - l) / 2 + l;</span><br><span class="line">                int tmp = (i + mid) * (mid - i + 1);</span><br><span class="line">                if(tmp == target * 2)&#123;</span><br><span class="line">                    flag = true;</span><br><span class="line">                    l = mid;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;else if(tmp &lt; target * 2)&#123;</span><br><span class="line">                    l = mid + 1;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    r = mid - 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(flag)&#123;</span><br><span class="line">                vector&lt;int&gt; m;</span><br><span class="line">                for(int j = i; j &lt;= l; ++j)&#123;</span><br><span class="line">                    m.emplace_back(j);</span><br><span class="line">                &#125;ans.emplace_back(m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>但是上面的代码不够优化，看看题解<ul>
<li>若区间 [l, r] 的和等于 target 那么 [l + 1, r] 的区间和必然小于 target，二分要从 r + 1 开始！</li>
</ul>
</li>
</ul>
<h2 id="58-1-翻转单词顺序"><a href="#58-1-翻转单词顺序" class="headerlink" title="58-1_翻转单词顺序"></a>58-1_翻转单词顺序</h2><ul>
<li>151<ul>
<li>这次用栈试试，可以一次过</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string reverseWords(string s) &#123;</span><br><span class="line">        // 以空格为单位，很容易想到用栈！之后多个空格要变为一个空格</span><br><span class="line">        if(s.empty()) return s;</span><br><span class="line">        stack&lt;string&gt; stk;</span><br><span class="line">        int pos = 0, n = s.size();</span><br><span class="line">        while(pos &lt; n)&#123;</span><br><span class="line">            // 为空格直接跳过</span><br><span class="line">            if(s[pos] != &apos; &apos;)&#123;</span><br><span class="line">                int tmp = pos + 1;</span><br><span class="line">                while(tmp &lt; n &amp;&amp; s[tmp] != &apos; &apos;)&#123;</span><br><span class="line">                    ++tmp;</span><br><span class="line">                &#125;</span><br><span class="line">                // 这里要么在边界，要么为空格，但是长度总是 tmp - pos</span><br><span class="line">                if(!stk.empty()) stk.push(&quot; &quot;);</span><br><span class="line">                stk.push(s.substr(pos, tmp - pos));</span><br><span class="line">                // 更新下标</span><br><span class="line">                pos = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            ++pos;</span><br><span class="line">        &#125;</span><br><span class="line">        // 恢复字符串</span><br><span class="line">        string ans;</span><br><span class="line">        while(!stk.empty())&#123;</span><br><span class="line">            ans += stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>题解思路差不多，也可以直接从后往前遍历，也就是双指针，这样好像更快一点！</li>
</ul>
<h2 id="58-2-左旋转字符串"><a href="#58-2-左旋转字符串" class="headerlink" title="58-2_左旋转字符串"></a>58-2_左旋转字符串</h2><ul>
<li>这题用 <code>substr()</code> 函数是不是不太好<ul>
<li>如果面试不给用，那就用交换，对，不过得交换三次！</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string reverseLeftWords(string s, int n) &#123;</span><br><span class="line">        // 前面若干个字符</span><br><span class="line">        if(s.empty() || n &lt; 1 || n &gt;= s.size()) return s;</span><br><span class="line">        // 注意 n 是个数，而不是下标，只不过这里可以当成下标</span><br><span class="line">        string cur(s.substr(0, n));</span><br><span class="line">        string pre(s.substr(n));</span><br><span class="line">        return pre + cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="59-1-滑动窗口的最大值"><a href="#59-1-滑动窗口的最大值" class="headerlink" title="59-1_滑动窗口的最大值"></a>59-1_滑动窗口的最大值</h2><ul>
<li>239<ul>
<li>当时这题没有做出来，这次估计也比较悬</li>
<li>用优先级队列看看</li>
<li>踩了几个坑，一个是边界一个是顺序，好歹可以过</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        // 边界问题</span><br><span class="line">        if(nums.empty()) return vector&lt;int&gt;();</span><br><span class="line">        // k 是滑动窗口的长度</span><br><span class="line">        unordered_map&lt;int, int&gt; map;</span><br><span class="line">        priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; q;</span><br><span class="line">        // 初始化</span><br><span class="line">        for(int i = 0; i &lt; k; ++i)&#123;</span><br><span class="line">            q.push(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; ans&#123;q.top()&#125;;</span><br><span class="line">        int l = 0, r = k;</span><br><span class="line">        // 报错了，这里顺序有点问题</span><br><span class="line">        while(r &lt; nums.size())&#123;</span><br><span class="line">            q.push(nums[r]);</span><br><span class="line">            map[nums[l]]++;</span><br><span class="line">            ++l;</span><br><span class="line">            // 更新答案吧</span><br><span class="line">            while(map.find(q.top()) != map.end())&#123;</span><br><span class="line">                if(map[q.top()] == 1)&#123;</span><br><span class="line">                    map.erase(q.top());</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    map[q.top()]--;</span><br><span class="line">                &#125;</span><br><span class="line">                q.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(q.top());</span><br><span class="line">            // 更新</span><br><span class="line">            ++r;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>题解写的更好，学习下<ul>
<li>优先级队列通过下标来确定在不在滑动窗口内！</li>
<li>定义可以直接这样写 <code>priority_queue&lt;pair&lt;int, int&gt;&gt; q;</code></li>
</ul>
</li>
</ul>
<h2 id="59-2-队列的最大值"><a href="#59-2-队列的最大值" class="headerlink" title="59-2_队列的最大值"></a>59-2_队列的最大值</h2><ul>
<li>这题有点眼熟！<ul>
<li>之前好像是有一题是栈的最大值？这题应该也是双队列，然后另一个队列就是存放对应的最大值</li>
<li>不太对，这是队列，队列弹出一个，后面的最大值可能都会跟着变</li>
<li>试试用优先级队列，因为有重复数字，所以应该用 <code>unordered_map</code> 而不是 <code>unordered_set</code></li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class MaxQueue &#123;</span><br><span class="line">public:</span><br><span class="line">    MaxQueue() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    int max_value() &#123;</span><br><span class="line">        // 如果是已经删除的</span><br><span class="line">        while(!m.empty() &amp;&amp; map.find(m.top()) != map.end())&#123;</span><br><span class="line">            if(map[m.top()] == 1)&#123;</span><br><span class="line">                map.erase(m.top());</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                map[m.top()]--;</span><br><span class="line">            &#125;</span><br><span class="line">            m.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        if(m.empty()) return -1;</span><br><span class="line">        return m.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void push_back(int value) &#123;</span><br><span class="line">        q.push(value);</span><br><span class="line">        m.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int pop_front() &#123;</span><br><span class="line">        if(q.empty()) return -1;</span><br><span class="line">        auto tmp = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        map[tmp]++;</span><br><span class="line">        return tmp;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    queue&lt;int&gt; q;</span><br><span class="line">    priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; m;</span><br><span class="line">    // 这里数字会重复，应该用 map 好点</span><br><span class="line">    unordered_map&lt;int, int&gt; map;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="60-n-个骰子的点数"><a href="#60-n-个骰子的点数" class="headerlink" title="60_ n 个骰子的点数"></a>60_ n 个骰子的点数</h2><ul>
<li><p>每天刷题的时间感觉花的太多了，每晚十点开始刷是最好的，控制下时间，面试不过两小时四五道题</p>
<ul>
<li>若想多看看题解，那就提前半小时！</li>
<li>这题和的范围 1 * n ~ 6 * n（个数为 5 * n + 1 而不是 6 * n）</li>
<li>每个骰子都是独立同分布的并且是等概分布，关键在于 n 个</li>
</ul>
</li>
<li><p>看了评论，雾草这题面试会问到！</p>
<ul>
<li>看了答案才会！之后还得二刷，这里就不记录了</li>
</ul>
</li>
</ul>
<h2 id="61-扑克牌中的顺子"><a href="#61-扑克牌中的顺子" class="headerlink" title="61_扑克牌中的顺子"></a>61_扑克牌中的顺子</h2><ul>
<li>上一题暂时没做出来，先做这一题<ul>
<li>用了优先级队列，然后计算出需要几个 0 以及一共有几个 0</li>
<li>最后比较是否供大于需</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isStraight(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        // 这样吧，放入优先级队列，然后看差距，判断需要几个 0</span><br><span class="line">        priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; q;</span><br><span class="line">        for(auto num : nums)&#123;</span><br><span class="line">            q.push(num);</span><br><span class="line">        &#125;</span><br><span class="line">        // 初始化</span><br><span class="line">        int zeros = 0, pre = q.top(), need = 0;</span><br><span class="line">        q.pop();</span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            auto tmp = q.top();</span><br><span class="line">            q.pop();</span><br><span class="line">            if(tmp == 0)&#123;</span><br><span class="line">                zeros++;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if(tmp == pre)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                // 这里别忘了减一，因为不包括两边</span><br><span class="line">                if(pre - tmp != 1) need += (pre - tmp - 1);</span><br><span class="line">                // 这里别忘了更新 pre</span><br><span class="line">                pre = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // cout &lt;&lt; &quot;need = &quot; &lt;&lt; need &lt;&lt; &quot; zeros = &quot; &lt;&lt; zeros &lt;&lt; endl;</span><br><span class="line">        return need &lt;= zeros;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>看了题解，我觉得我想的有些复杂<ul>
<li>只需判断除 0 之外的最大值与最小值之间距离是不是小于 5 就行，当然遍历的时候还要判断是否重复</li>
</ul>
</li>
</ul>
<h2 id="62-圆圈中最后剩下的数字"><a href="#62-圆圈中最后剩下的数字" class="headerlink" title="62_圆圈中最后剩下的数字"></a>62_圆圈中最后剩下的数字</h2><ul>
<li>感觉我找不到规律……<ul>
<li>这真的是简单题嘛？</li>
</ul>
</li>
</ul>
<h2 id="63-股票的最大利润"><a href="#63-股票的最大利润" class="headerlink" title="63_股票的最大利润"></a>63_股票的最大利润</h2><ul>
<li>121<ul>
<li>这题堪称经典，这里只买卖一次，记得当时用的贪心或者动规</li>
<li>这题做完得复习下，买卖两次和三次的！</li>
<li>注意点，一天之内可以同时买卖</li>
<li>还有点进步，用了依次遍历 + 两个指标做出来了，第一次用的双重循环……</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        // 第一次买了还没卖、卖了，这里都初始化为 0 吧，不加负号了，有点绕</span><br><span class="line">        // buy 不能初始化为 0</span><br><span class="line">        int buy = INT32_MAX;</span><br><span class="line">        int sell = 0;</span><br><span class="line">        for(auto p : prices)&#123;</span><br><span class="line">            // 分别更新这两个指标</span><br><span class="line">            buy = min(buy, p);</span><br><span class="line">            sell = max(p - buy, sell);</span><br><span class="line">        &#125;</span><br><span class="line">        return sell;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="64-求-1-2-…-n"><a href="#64-求-1-2-…-n" class="headerlink" title="64_求 1 + 2 + … + n"></a>64_求 1 + 2 + … + n</h2><ul>
<li>还剩三题，连续好几天没看了</li>
<li>这题我？<ul>
<li>难道要用位运算吗</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int sumNums(int n) &#123;</span><br><span class="line">        // 这里递归很厉害，短路性质</span><br><span class="line">        n &amp;&amp; (n += sumNums(n-1));</span><br><span class="line">        return n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>方法二看不懂0.0</li>
</ul>
<h2 id="65-不用加减乘除做加法"><a href="#65-不用加减乘除做加法" class="headerlink" title="65_不用加减乘除做加法"></a>65_不用加减乘除做加法</h2><ul>
<li>这个学微机原理的时候，通过位运算来实现加法器，这题的思路应该就是这个了<ul>
<li>应该是取反码、补码进行位运算，然后再取补码的补码</li>
<li>补码是取反后加一</li>
<li>这里 C++ 负数不能左移应该是 LeetCode 环境的问题</li>
<li>关键点：如何取进位、若没有进位，直接异或、最后是循环进行</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    // 大佬的注释</span><br><span class="line">    int add(int a, int b) &#123;</span><br><span class="line">        // 因为不允许用 + 号，所以求出异或部分和进位部分依然不能用 + 号，所以只能循环到没有进位为止        </span><br><span class="line">        while(b != 0)&#123;</span><br><span class="line">            // 保存进位值，下次循环用</span><br><span class="line">            int c = (unsigned int)(a &amp; b) &lt;&lt; 1; // C++ 中负数不支持左移位，因为结果是不定的</span><br><span class="line">            // 保存不进位值，下次循环用，</span><br><span class="line">            a ^= b;</span><br><span class="line">            // 如果还有进位，再循环，如果没有，则直接输出没有进位部分即可。</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="66-构建乘积数组"><a href="#66-构建乘积数组" class="headerlink" title="66_构建乘积数组"></a>66_构建乘积数组</h2><ul>
<li>还可以，就是生成乘积前缀数组的时候要注意下标</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; constructArr(vector&lt;int&gt;&amp; a) &#123;</span><br><span class="line">        // 应该用乘积前缀，并且要有两个，一个从前往后，一个从后往前</span><br><span class="line">        int n = a.size();</span><br><span class="line">        vector&lt;int&gt; pre(n, 1);</span><br><span class="line">        vector&lt;int&gt; cur(n, 1);</span><br><span class="line"></span><br><span class="line">        for(int i = 1; i &lt; n; ++i)&#123;</span><br><span class="line">            pre[i] = pre[i - 1] * a[i - 1];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /*cout &lt;&lt; &quot;pre = &quot;;</span><br><span class="line">        copy(pre.begin(), pre.end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot;));</span><br><span class="line">        cout &lt;&lt; endl;*/</span><br><span class="line"></span><br><span class="line">        for(int i = n - 2; i &gt;= 0; --i)&#123;</span><br><span class="line">            cur[i] = cur[i + 1] * a[i + 1];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /*cout &lt;&lt; &quot;cur = &quot;;</span><br><span class="line">        copy(cur.begin(), cur.end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot;));</span><br><span class="line">        cout &lt;&lt; endl;*/</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt; b(n);</span><br><span class="line"></span><br><span class="line">        for(int i = 0; i &lt; n; ++i)&#123;</span><br><span class="line">            b[i] = pre[i] * cur[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>大佬写的很厉害<ul>
<li>分为上三角和下三角！</li>
</ul>
</li>
</ul>
<h2 id="67-把字符串转换成整数"><a href="#67-把字符串转换成整数" class="headerlink" title="67_把字符串转换成整数"></a>67_把字符串转换成整数</h2><ul>
<li>8<ul>
<li>怪不得似曾相识，这得考虑整数边界</li>
<li>这次处理的还行</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int strToInt(string&amp; str, int pos, int n, int sign) &#123;</span><br><span class="line">        long long ans = 0;</span><br><span class="line">        while(pos &lt; n &amp;&amp; isdigit(str[pos]))&#123;</span><br><span class="line">            ans = 10 * ans + (str[pos] - &apos;0&apos;);</span><br><span class="line">            if(ans * sign &gt;= INT32_MAX) return INT32_MAX;</span><br><span class="line">            if(ans * sign &lt;= INT32_MIN) return INT32_MIN;</span><br><span class="line">            ++pos;</span><br><span class="line">        &#125;</span><br><span class="line">        return static_cast&lt;int&gt;(sign * ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int strToInt(string str) &#123;</span><br><span class="line">        if(str.empty()) return 0;</span><br><span class="line">        int n = str.size();</span><br><span class="line">        int pos = 0;</span><br><span class="line">        while(pos &lt; n &amp;&amp; str[pos] == &apos; &apos;)&#123;</span><br><span class="line">            ++pos;</span><br><span class="line">        &#125;</span><br><span class="line">        if(pos == n) return 0;</span><br><span class="line"></span><br><span class="line">        // 这里开始提取有效数字</span><br><span class="line">        int sign = 1;</span><br><span class="line">        if(str[pos] == &apos;-&apos; || str[pos] == &apos;+&apos;)&#123;</span><br><span class="line">            sign = str[pos] == &apos;-&apos; ? -1 : 1;</span><br><span class="line">            return strToInt(str, pos + 1, n, sign);</span><br><span class="line">        &#125;else if(isdigit(str[pos]))&#123;</span><br><span class="line">            return strToInt(str, pos, n, sign);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>emmmmm，还可以再优化下！<ul>
<li>判断边界时，bndry = 2147483647 / 10 = 214748364</li>
<li>这里有个关键点，判断边界条件 <code>if(res &gt; bndry || res == bndry &amp;&amp; str[j] &gt; &#39;7&#39;)</code></li>
<li>直接根据符号位返回最大值还是最小值，这个 <code>&#39;7&#39;</code> 就很有灵性！</li>
</ul>
</li>
</ul>
<h2 id="68-1-二叉搜索树的最近公共祖先"><a href="#68-1-二叉搜索树的最近公共祖先" class="headerlink" title="68-1_二叉搜索树的最近公共祖先"></a>68-1_二叉搜索树的最近公共祖先</h2><ul>
<li>235<ul>
<li>愣是没看出来这题与下题的区别在哪儿，即使之前做过！</li>
<li>嗷嗷嗷，这是二叉搜索树！下一题是普通的二叉树</li>
<li>根据二叉搜索树的特性即可，递归很容易</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* ans;</span><br><span class="line"></span><br><span class="line">    void dfs(TreeNode* node, int p, int q)&#123;</span><br><span class="line">        // 这里应该不会遇见空节点，因为遇到 p 或者 q 就返回了</span><br><span class="line">        if(ans != nullptr) return;</span><br><span class="line">        if(node-&gt;val &gt;= p &amp;&amp; node-&gt;val &lt;= q)&#123;</span><br><span class="line">            ans = node;</span><br><span class="line">            return;</span><br><span class="line">        &#125;else if(node-&gt;val &gt; q)&#123;</span><br><span class="line">            dfs(node-&gt;left, p, q);</span><br><span class="line">        &#125;else if(node-&gt;val &lt; p)&#123;</span><br><span class="line">            dfs(node-&gt;right, p, q);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        // 这里要排下序</span><br><span class="line">        int a = p-&gt;val, b = q-&gt;val;</span><br><span class="line">        if(a &gt; b)&#123;</span><br><span class="line">            swap(a, b);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root, a, b);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>题解没有用递归也可以……<ul>
<li>二分查找！</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        // 这里没有比较大小，注意，这是一个技巧</span><br><span class="line">        TreeNode* ancestor = root;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            // 这里条件没有判断大小在两者之间</span><br><span class="line">            if (p-&gt;val &lt; ancestor-&gt;val &amp;&amp; q-&gt;val &lt; ancestor-&gt;val) &#123;</span><br><span class="line">                ancestor = ancestor-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (p-&gt;val &gt; ancestor-&gt;val &amp;&amp; q-&gt;val &gt; ancestor-&gt;val) &#123;</span><br><span class="line">                ancestor = ancestor-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ancestor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="68-2-二叉树的最近公共祖先"><a href="#68-2-二叉树的最近公共祖先" class="headerlink" title="68-2_二叉树的最近公共祖先"></a>68-2_二叉树的最近公共祖先</h2><ul>
<li>236<ul>
<li>这是普通的二叉树</li>
<li>似乎没有什么好的方法，分别记录到达这两个节点的路径，然后再找</li>
<li>这题存储父节点不能用 <code>vector</code>，因为谈出来的时候比较麻烦！</li>
<li>我去，我第一次是怎么做出来的？<ul>
<li>刷了这么多题，能力怎么下降了！</li>
<li>数组是全局变量，开头放入，最后弹出，不管左右子树中间！</li>
<li>改了一下，发现还是有问题！难受</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><ul>
<li>vector创建一个数组，要用<font color="#FF0000">大括号</font></li>
</ul>
<p><code>vector&lt;int&gt; nums = {2, 7, 11, 15};</code></p>
<h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1_两数之和"></a>1_两数之和</h2><ul>
<li>给定 nums = [2, 7, 11, 15], target = 9</li>
<li>返回 [0, 1]</li>
</ul>
<blockquote>
<p>C/C++</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int i,j;</span><br><span class="line">        for(i=0; i&lt;nums.size()-1; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(j=i+1;j&lt;nums.size();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(nums[i]+nums[j]==target)</span><br><span class="line">                &#123;</span><br><span class="line">                    return &#123;i,j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return &#123;&#125;;		//若没有答案返回空</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Solution s;</span><br><span class="line">    vector&lt;int&gt; nums = &#123;2, 7, 11, 15&#125;;</span><br><span class="line">    int target = 9;</span><br><span class="line">    std::cout &lt;&lt; s.twoSum(nums, target)[0] &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; s.twoSum(nums, target)[1] &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-正序数组中位数"><a href="#4-正序数组中位数" class="headerlink" title="4_正序数组中位数"></a>4_正序数组中位数</h2><ul>
<li>两个正序数组，找出中位数</li>
</ul>
<h3 id="归并法"><a href="#归并法" class="headerlink" title="归并法"></a>归并法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using  namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</span><br><span class="line">        // 归并</span><br><span class="line">        vector&lt;int&gt; num;</span><br><span class="line">        int i, j;</span><br><span class="line">        for(i = 0, j = 0; i &lt; nums1.size() &amp;&amp; j &lt; nums2.size();)&#123;</span><br><span class="line">            if(nums1[i] &gt; nums2[j])&#123;</span><br><span class="line">                num.push_back(nums2[j]);</span><br><span class="line">                j++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                num.push_back(nums1[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while (i &lt; nums1.size())&#123;</span><br><span class="line">            num.push_back(nums1[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        while (j &lt; nums2.size())&#123;</span><br><span class="line">            num.push_back(nums2[j]);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        int len = num.size();</span><br><span class="line">        if(len % 2 == 1)&#123;return num[len / 2];&#125; else &#123;</span><br><span class="line">            double m = num[len / 2 - 1] + num[len / 2];</span><br><span class="line">            return m / 2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; nums1 = &#123;3, 4&#125;;</span><br><span class="line">    vector&lt;int&gt; nums2 = &#123;1, 2&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    double l = solution.findMedianSortedArrays(nums1, nums2);</span><br><span class="line">    cout &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-盛最多水的容器"><a href="#10-盛最多水的容器" class="headerlink" title="10_盛最多水的容器"></a>10_盛最多水的容器</h2><ul>
<li>如图，两个指针，分别从左右两边向里遍历，哪个高度小，对应的指针移位一次</li>
</ul>
<p><img src="/pictrues/11.png" alt="题目描述" title="题目描述"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxArea(vector&lt;int&gt;&amp; height) &#123;</span><br><span class="line">        int area = 0, l = 0, r = (int)(height.size() - 1);  // 初始化双指针</span><br><span class="line">        while (l &lt; r)&#123;</span><br><span class="line">            int h = min(height[l], height[r]);</span><br><span class="line">            area = max(area, h * (r - l));	// 注意r和l的大小</span><br><span class="line">            if(height[l] &lt; height[r])&#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125; else r--;</span><br><span class="line">        &#125;</span><br><span class="line">        return area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; height = &#123;1, 8, 6, 2, 5, 4, 8, 3, 7&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    std::cout &lt;&lt; solution.maxArea(height) &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15_三数之和"></a>15_三数之和</h2><ul>
<li>先排序，再用三重循环或者双指针，需注意前两个元素不可重复</li>
<li>注意<code>continue</code>用法以及声明一个<font color="#FF0000">二维数组</font></li>
<li>输入<code>nums = [-1, 0, 1, 2, -1, -4]</code></li>
<li>输出<code>[[-1, 0, 1],[-1, -1, 2]]</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;    // sort()函数</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; vec;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        for(int i = 0; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            if(i &gt; 0 &amp;&amp; nums[i] == nums[i - 1])&#123;continue;&#125;  // 如果为真，则进入下一个循环</span><br><span class="line">            int k = (int)(nums.size()) - 1; // 每一次循环，都初始化k，只要前两个元素不出现重复，第三个元素就不会重复</span><br><span class="line">            for(int j = i + 1; j &lt; nums.size(); j++)&#123;</span><br><span class="line">                if(j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1])&#123;continue;&#125;</span><br><span class="line">                while (k &gt; j &amp;&amp; nums[i] + nums[j] + nums[k] &gt; 0)&#123;</span><br><span class="line">                    k--;</span><br><span class="line">                &#125;</span><br><span class="line">                if(k == j)&#123;break;&#125;</span><br><span class="line">                if(nums[i] + nums[j] + nums[k] == 0)&#123;</span><br><span class="line">                    vec.push_back(&#123;nums[i], nums[j], nums[k]&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; nums = &#123;-1, 0, 1, 2, -1, -4&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; vec = solution.threeSum(nums);</span><br><span class="line">    for(auto &amp; i : vec)&#123;</span><br><span class="line">        for(int j : i)&#123;</span><br><span class="line">            cout &lt;&lt; j;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16_最接近的三数之和"></a>16_最接近的三数之和</h2><ul>
<li>找出三个数使其和与target值最接近</li>
<li>一般推荐排序+双指针</li>
</ul>
<h3 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int sum = nums[1] + nums[2] + nums[3], sub = abs(nums[1] + nums[2] + nums[3] - target);</span><br><span class="line">        for(int i = 0; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            for(int j = i + 1; j &lt; nums.size(); j++)&#123;</span><br><span class="line">                for(int k = j + 1; k &lt; nums.size(); k++)&#123;</span><br><span class="line">                    if(abs(nums[i] + nums[j] + nums[k] - target) &lt; sub)&#123;</span><br><span class="line">                        sum = nums[i] + nums[j] + nums[k];</span><br><span class="line">                        sub = abs(nums[i] + nums[j] + nums[k] - target);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; s = &#123;-1, 2, 1, 4&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    std::cout &lt;&lt; solution.threeSumClosest(s, 0) &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        int sum = 1e7;</span><br><span class="line">        int len = nums.size();</span><br><span class="line">        for(int i = 0; i &lt; len; i++)&#123;</span><br><span class="line">            if(i &gt; 0 &amp;&amp; nums[i] == nums[i - 1])&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            int j = i + 1, k = len - 1;</span><br><span class="line">            while (j &lt; k)&#123;</span><br><span class="line">                if(nums[i] + nums[j] + nums[k] == target)&#123;</span><br><span class="line">                    return target;</span><br><span class="line">                &#125;</span><br><span class="line">                if(abs(sum - target) &gt; abs(nums[i] + nums[j] + nums[k] - target))&#123;</span><br><span class="line">                    sum = nums[i] + nums[j] + nums[k];</span><br><span class="line">                &#125;</span><br><span class="line">                if(nums[i] + nums[j] + nums[k] &gt; target)&#123;</span><br><span class="line">                    int k0 = k - 1;</span><br><span class="line">                    while (j &lt; k0 &amp;&amp; nums[k0] == nums[k0 + 1])&#123;</span><br><span class="line">                        k0--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    k = k0;</span><br><span class="line">                &#125; else&#123;</span><br><span class="line">                    int j0 = j + 1;</span><br><span class="line">                    while (j0 &lt; k &amp;&amp; nums[j0] == nums[j0 - 1])&#123;</span><br><span class="line">                        j0++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    j = j0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; s = &#123;-1, 2, 1, 4&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    std::cout &lt;&lt; solution.threeSumClosest(s, 0) &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17_电话号码的字母组合"></a>17_电话号码的字母组合</h2><ul>
<li>先把第一个数字对应的几个字母分开放入输出字符串数组<code>res</code>中</li>
<li>之后每遍历一个数字，<code>res</code>对应的元素与数字对应的字母分别相加，存放在<code>tmp</code>中，</li>
<li>最后更新<code>res</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution1 &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; letterCombinations(string digits) &#123;</span><br><span class="line">        if(digits.empty())&#123;return &#123;&#125;;&#125;</span><br><span class="line">        vector&lt;string&gt; s = &#123;&quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;&#125;;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        int k = 0, pos = (digits[0] - &apos;0&apos;) - 2;</span><br><span class="line">        while (k &lt; s[pos].size())&#123;</span><br><span class="line">            char ch = s[pos][k];</span><br><span class="line">            string l;     // string是指针类型</span><br><span class="line">            l.append(1, ch);</span><br><span class="line">            res.push_back(l);</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        int len = 1;</span><br><span class="line">        while (len &lt; digits.size())&#123;</span><br><span class="line">            vector&lt;string&gt; tmp;</span><br><span class="line">            for(int i = 0; i &lt; res.size(); i++)&#123;</span><br><span class="line">                int d = digits[len] - &apos;0&apos;;</span><br><span class="line">                d -= 2;</span><br><span class="line">                for(int j = 0; j &lt; s[d].size(); j++)&#123;</span><br><span class="line">                    string l1;</span><br><span class="line">                    l1.append(res[i] + s[d][j]);</span><br><span class="line">                    tmp.push_back(l1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res = tmp;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    string digit = &quot;26&quot;;</span><br><span class="line">    Solution1 solution;</span><br><span class="line">    vector&lt;string&gt; res = solution.letterCombinations(digit);</span><br><span class="line">    for(auto &amp; re : res)&#123;</span><br><span class="line">        for(char j : re)&#123;</span><br><span class="line">            cout &lt;&lt; j;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18_四数之和"></a>18_四数之和</h2><ul>
<li>三数之和前两个数字确定后，第三个数是唯一确定的</li>
<li>四数之和前两个数字确定后，后两个数字不唯一，满足条件后，要继续遍历(注意重复)</li>
<li>第一位数字确定后，第二位数字都是从<code>i+1</code>开始，<code>nums[j]</code>一确定，后面就已罗列出所有不重复的可能性，因此第二重循环再次确定<code>nums[j]</code>时，要与之前的不一样</li>
<li><code>nums[i]</code>同理</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        for(int i = 0; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            if(i &gt; 0 &amp;&amp; nums[i] == nums[i - 1])&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int j = i +1; j &lt; nums.size(); j++)&#123;</span><br><span class="line">                if(j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1])&#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                int k = j + 1, l = nums.size();</span><br><span class="line">                l--;</span><br><span class="line">                while (k &lt; l)&#123;</span><br><span class="line">                    int sum = nums[i] + nums[j] + nums[k] + nums[l];</span><br><span class="line">                    if(sum == target)&#123;</span><br><span class="line">                        res.push_back(&#123;nums[i], nums[j], nums[k], nums[l]&#125;);</span><br><span class="line">                        int k0 = k + 1;</span><br><span class="line">                        while (k0 &lt; l &amp;&amp; nums[k0] == nums[k])&#123;</span><br><span class="line">                            k0++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        k = k0;</span><br><span class="line">                    &#125; else if(sum &gt; target)&#123;</span><br><span class="line">                        int l0 = l - 1;</span><br><span class="line">                        while (l0 &gt; k &amp;&amp; nums[l0] == nums[l])&#123;</span><br><span class="line">                            l0--;</span><br><span class="line">                        &#125;</span><br><span class="line">                        l = l0;</span><br><span class="line">                    &#125; else&#123;</span><br><span class="line">                        int k0 = k + 1;</span><br><span class="line">                        while (k0 &lt; l &amp;&amp; nums[k0] == nums[k])&#123;</span><br><span class="line">                            k0++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        k = k0;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; nums = &#123;-3, -2, -1, 0, 0, 1, 2, 3&#125;;</span><br><span class="line">    int target = 0;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; res = solution.fourSum(nums, target);</span><br><span class="line">    for(const auto&amp; re : res)&#123;</span><br><span class="line">        for(auto num : re)&#123;</span><br><span class="line">            cout &lt;&lt; num;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; &quot;,&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22_括号生成"></a>22_括号生成</h2><ul>
<li>先用递归生成所有可能性的括号，再判断其是否有效</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool valid(string &amp;cur)&#123;</span><br><span class="line">        unordered_map&lt;char, char&gt; map&#123;</span><br><span class="line">                &#123;&apos;)&apos;, &apos;(&apos;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        stack&lt;char&gt; stc;</span><br><span class="line">        for(char ch : cur)&#123;</span><br><span class="line">            if(map.count(ch))&#123;</span><br><span class="line">                if(stc.empty())&#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">                stc.pop();</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                stc.push(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stc.empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void generateALL(int n, string &amp;cur, vector&lt;string&gt; &amp;res)&#123;</span><br><span class="line">        if(cur.size() == n)&#123;</span><br><span class="line">            if(valid(cur))&#123;</span><br><span class="line">                res.push_back(cur);</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        cur += &apos;(&apos;;</span><br><span class="line">        generateALL(n, cur, res);</span><br><span class="line">        cur.pop_back();</span><br><span class="line">        cur += &apos;)&apos;;</span><br><span class="line">        generateALL(n, cur, res);</span><br><span class="line">        cur.pop_back();     // 返回上一次递归，删除一个保持长度不变</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;string&gt; generateParenthesis(int n)&#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        string cur;</span><br><span class="line">        n *= 2;     //  肯定为偶数</span><br><span class="line">        generateALL(n, cur, res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;string&gt; s = solution.generateParenthesis(2);</span><br><span class="line">    for(string l : s)&#123;</span><br><span class="line">        for(char ch : l)&#123;</span><br><span class="line">            cout &lt;&lt; ch;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; &quot;   &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="26-删除排序数组中的重复项"><a href="#26-删除排序数组中的重复项" class="headerlink" title="26_删除排序数组中的重复项"></a>26_删除排序数组中的重复项</h2><ul>
<li>被我搞复杂了，用双指针已经有<code>len=1</code>却又在循环里定义了个<code>j=i+1</code>，直接在开头定义<code>i=0</code>即可，返回<code>i+1</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if(nums.empty())&#123;return 0;&#125;</span><br><span class="line">        int i = 0;</span><br><span class="line">        for(int j = 0; j &lt; nums.size(); j++)&#123;</span><br><span class="line">            if(nums[j] != nums[i])&#123;</span><br><span class="line">                nums[i + 1] = nums[j];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return i + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; nums = &#123;0, 0, 1, 1, 1, 2, 2, 3, 3, 4&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    int len = solution.removeDuplicates(nums);</span><br><span class="line">    for(int i = 0; i &lt; len; i++)&#123;</span><br><span class="line">        std::cout &lt;&lt; nums[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27_移除元素"></a>27_移除元素</h2><ul>
<li>又又又被我搞复杂了，没错在下算出了要移除元素的个数，然后剩下的元素整体搬到移除元素的起点@#￥%……&amp;*</li>
<li>双指针真的好简单啊，连排序都用不到</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;</span><br><span class="line">        int i = 0;</span><br><span class="line">        for (int j = 0; j &lt; nums.size(); j++) &#123;</span><br><span class="line">            if (nums[j] != val) &#123;</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;int&gt; nums = &#123;0, 1, 2, 2, 3, 0, 4, 2&#125;;</span><br><span class="line">    int val = 2;</span><br><span class="line">    int len = solution.removeElement(nums, val);</span><br><span class="line">    for(int i = 0; i &lt; len; i++)&#123;</span><br><span class="line">        std::cout &lt;&lt; nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31_下一个排列"></a>31_下一个排列</h2><ul>
<li>对字典序列不了解，我是直接看算法的，首先考虑特殊情况，<code>nums</code>为空或者只有一个数字，直接<code>return</code>，(等等，这步可以跳过)</li>
<li>从右往左找两次，一次小的一次大的，交换再排序，用<code>swap</code></li>
<li>翻转次序直接调用函数<code>reverse</code>，<code>#include &lt;algorithm&gt;</code>，淦！</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">        void nextPermutation(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">            int i = nums.size() - 2;</span><br><span class="line">            while (i &gt;= 0 &amp;&amp; nums[i] &gt;= nums[i + 1]) &#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            if (i &gt;= 0) &#123;</span><br><span class="line">                int j = nums.size() - 1;</span><br><span class="line">                while (j &gt;= 0 &amp;&amp; nums[i] &gt;= nums[j]) &#123;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">                swap(nums[i], nums[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            reverse(nums.begin() + i + 1, nums.end());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; nums = &#123;1, 5, 1&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    solution.nextPermutation(nums);</span><br><span class="line">    for(int n : nums)&#123;</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33_搜索旋转排序数组"></a>33_搜索旋转排序数组</h2><ul>
<li>看题解是有时间复杂度要求的，愣了一下，也是，不然一次遍历就可以解决为什么会标中等难度呢</li>
<li>每次从中间查找，左右两段必有一个完全升序，这里分两种情况</li>
<li>左边完全升序：判断<code>target</code>在不在，在更新<code>r</code>，不在更新<code>l</code></li>
<li>右边完全升序：判断<code>target</code>在不在，在更新<code>l</code>，不在更新<code>r</code></li>
</ul>
<h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int search(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        int l = 0, r = n - 1;</span><br><span class="line">        while (l &lt;= r)&#123;</span><br><span class="line">            int mid = (r + l) / 2;</span><br><span class="line">            if(nums[mid] == target)&#123;return mid;&#125;</span><br><span class="line">            if(nums[l] &lt;= nums[mid])&#123;</span><br><span class="line">                if(target &gt;= nums[l] &amp;&amp; target &lt; nums[mid])&#123;</span><br><span class="line">                    r = mid - 1;</span><br><span class="line">                &#125; else&#123;</span><br><span class="line">                    l = mid + 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                if(target &gt; nums[mid] &amp;&amp; target &lt;= nums[r])&#123;</span><br><span class="line">                    l = mid + 1;</span><br><span class="line">                &#125; else&#123;</span><br><span class="line">                    r = mid - 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; nums = &#123;6, 4, 5&#125;;</span><br><span class="line">    int target = 5;</span><br><span class="line">    Solution solution;</span><br><span class="line">    std::cout &lt;&lt; solution.search(nums, target) &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34_在排序数组中查找元素的第一个和最后一个位置"></a>34_在排序数组中查找元素的第一个和最后一个位置</h2><ul>
<li><font color="#FF0000">排序有关，首推二分</font></li>
<li>我是先用二分法找到<code>target</code>，如果没有，直接返回<code>{-1,-1}</code>，找到之后在遍历左右两边等于<code>target</code>的个数，后来想了想，万一整个数组都是<code>target</code>，不就是遍历吗</li>
<li>看了题解才知道，要用二分法找两次，一次是第一个<font color="#FF0000">大于等于</font><code>target</code>的下标，另一次是第一个<font color="#FF0000">大于</font><code>target</code>的下标</li>
<li>找的时候要仔细思考其内在逻辑，判断条件是大于还是大于等于，诸如此类</li>
</ul>
<h3 id="二分法-1"><a href="#二分法-1" class="headerlink" title="二分法"></a>二分法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int search(vector&lt;int&gt;&amp; nums, int target, bool f)&#123;</span><br><span class="line">        int len = nums.size(), ans = len;   // 如果目标在最后，ans初始化为len，不能减一，要始终大于target</span><br><span class="line">        int l = 0, r = len - 1;</span><br><span class="line">        while (l &lt;= r)&#123;</span><br><span class="line">            int mid = (l + r) / 2;</span><br><span class="line">            if(nums[mid] &lt; target || (nums[mid] &lt;= target &amp;&amp; f))&#123;</span><br><span class="line">                l = mid + 1;</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                r = mid - 1;</span><br><span class="line">                ans = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int a = search(nums, target, false);</span><br><span class="line">        int b = search(nums, target, true) - 1;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">        if(a &lt;= b &amp;&amp; b &lt; nums.size() &amp;&amp; nums[b] == target &amp;&amp; nums[a] == target)&#123;</span><br><span class="line">            return &#123;a, b&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        return &#123;-1, -1&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; nums = &#123;8&#125;;</span><br><span class="line">    int target = 8;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;int&gt; pos = solution.searchRange(nums, target);</span><br><span class="line">    for(int n : pos)&#123;</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35_搜索插入位置"></a>35_搜索插入位置</h2><ul>
<li>根据前一题的思路，我采用找出第一个比<code>target</code>大的值，当然如果有等于，则直接返回下标</li>
<li>插入时，这个第一个比<code>target</code>大的值的下标就是返回的值</li>
</ul>
<h3 id="二分法-2"><a href="#二分法-2" class="headerlink" title="二分法"></a>二分法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        if(nums.empty())&#123;return 0;&#125;</span><br><span class="line">        int len = nums.size(), ans = len;</span><br><span class="line">        int l = 0, r = len - 1;</span><br><span class="line">        while (l &lt;= r)&#123;</span><br><span class="line">            int mid = (l + r) / 2;</span><br><span class="line">            if(nums[mid] == target)&#123;return mid;&#125;</span><br><span class="line">            if(nums[mid] &lt; target)&#123;</span><br><span class="line">                l = mid + 1;</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                r = mid - 1;</span><br><span class="line">                ans = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; nums = &#123;10&#125;;</span><br><span class="line">    int target = 2;</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.searchInsert(nums, target) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="36-有效的数独"><a href="#36-有效的数独" class="headerlink" title="36_有效的数独"></a>36_有效的数独</h2><ul>
<li>一开始用的三次遍历，三个条件各一次，看了题解一次遍历即可</li>
<li>如果用哈希表，那么每一行每一列每一个子数独都要用到哈希表，一共27个</li>
<li>看来别人的答案，可以用三个二维数组，同样判断个数是否大于1</li>
<li>对应的位置不会变，例如相同的<font color="#FF0000">行数</font>，列不同，<font color="#FF0000">字符</font>一样，那么对于维护行的二维数组定位一样</li>
<li><code>(r / 3) * 3</code>注意一下与<code>r</code>不一样，前者是3的倍数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;</span><br><span class="line">        vector&lt;unordered_map&lt;char, int&gt;&gt; row(9);</span><br><span class="line">        vector&lt;unordered_map&lt;char, int&gt;&gt; column(9);</span><br><span class="line">        vector&lt;unordered_map&lt;char, int&gt;&gt; box(9);</span><br><span class="line">        for(int r = 0; r &lt; 9; r++)&#123;</span><br><span class="line">            for(int c = 0; c &lt; 9; c++)&#123;</span><br><span class="line">                if(isdigit(board[r][c]))&#123;</span><br><span class="line">                    row[r][board[r][c]]++;</span><br><span class="line">                    column[c][board[r][c]]++;</span><br><span class="line">                    int n = (r / 3) * 3 + c / 3;</span><br><span class="line">                    box[n][board[r][c]]++;</span><br><span class="line">                    if(row[r][board[r][c]] &gt; 1 || column[c][board[r][c]] &gt; 1 || box[n][board[r][c]] &gt; 1)&#123;</span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int r = 9, c = 9;   // 行数 列数</span><br><span class="line">    vector&lt;vector&lt;char&gt;&gt; board(r, vector&lt;char&gt;(c, &apos;.&apos;));    //初始化二维数组</span><br><span class="line">    board[0][2] = &apos;4&apos;; board[0][6] = &apos;6&apos;; board[0][7] = &apos;3&apos;;</span><br><span class="line">    board[2][0] = &apos;5&apos;; board[2][7] = &apos;9&apos;; //board[1][4] = &apos;9&apos;; board[1][5] = &apos;5&apos;;</span><br><span class="line">    board[3][3] = &apos;5&apos;; board[3][4] = &apos;6&apos;; //board[2][7] = &apos;6&apos;;</span><br><span class="line">    board[4][0] = &apos;9&apos;; board[4][2] = &apos;3&apos;; board[4][8] = &apos;1&apos;;</span><br><span class="line">    board[5][3] = &apos;6&apos;;</span><br><span class="line">    board[6][3] = &apos;8&apos;;</span><br><span class="line">    for(auto ch_r : board)&#123;</span><br><span class="line">        for(char ch_c : ch_r)&#123;</span><br><span class="line">            cout &lt;&lt; ch_c &lt;&lt; &quot;  &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.isValidSudoku(board) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="37-解数独"><a href="#37-解数独" class="headerlink" title="37_解数独"></a>37_解数独</h2><ul>
<li>首先我想到的是遍历，遍历的同时判断是否有效，有效就下一个，无效就填入下一个数字，所有数字都不对，那就emmmmmmmmm</li>
<li>想法是美好的，写起来很困难，其一：对数独进行一次遍历，要先判断是否为空，这样才能写入数字，写入数字也要从1-9开始循环</li>
<li>开头有了两个<code>for</code>循环，对于1-9用的<code>while</code>，再调用判断是否有效函数，后来发现这个过程是<font color="#FF0000">不可逆</font>的，如果这个格子里1-9数字都不对，那怎么修改上一个空格的数字呢</li>
<li>用<code>if</code>？记录空格子的位置？要想<font color="#FF0000">回溯</font>，还得用递归</li>
<li>记录空格子的位置，方便直接操作，递归函数用的<code>bool</code>，每次递归都从数字1-9遍历，首先第一个空格子，先判断是否有效，有效，写入数字1，&lt;font color=#</li>
<li>6600&gt;递归下一个格子，如果下一个格子一直有效，那么会递归到最后一个格子，也就是出口；如果下一个格子无效，那么<font color="#FF0000">擦除</font>数字1即可，之后会从数字2开始</li>
<li>理解进一步加深，别看我还在第一个格子数字1，其实后面所有情况我都已经遍历完了；复杂度确实比较高，可以再优化下：比如将判断有效函数与递归结合起来，用<font color="#00FF00">三个</font>二维数组，默认值都是0，在记录空格子的位置时，同时将<font color="#FF0000">各行各列各个九宫格</font>出现的数字记录，即二维数组取值1，表示出现过，之后就看这个数有没有出现就行，记得回溯上一个递归时，别忘了<font color="#0000FF">“擦除”</font></li>
<li>为什么要优化呢，因为我超出时间限制了</li>
</ul>
<h3 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h3><ul>
<li>二维数组赋值的时候要一次性赋值，如果是一个一个赋值会失败，这是坑吗？</li>
<li>我在下面注释了，我仔细观察了，在第二行第九列遍历数字的时候，应该在8停下，进入下一个递归，(当然前面都是对的)，但是判断的时候，却是显示第九列已经有了8，，，，希望哪位有缘人能解惑</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;pair&lt;int, int&gt;&gt; pos;</span><br><span class="line">    bool row[9][9];</span><br><span class="line">    bool column[9][9];</span><br><span class="line">    bool box[9][9];</span><br><span class="line">public:</span><br><span class="line">    bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int index) &#123;</span><br><span class="line">        if(index == pos.size())&#123;return true;&#125;   //递归出口</span><br><span class="line">        int r_in = pos[index].first, c_in = pos[index].second;  //当前位置</span><br><span class="line">        for(int number = 1; number &lt; 10; number++)&#123;</span><br><span class="line">            if(!row[r_in][number - 1] &amp;&amp; !column[c_in][number - 1] &amp;&amp; !box[r_in / 3 * 3 + c_in / 3][number - 1])&#123;</span><br><span class="line">                board[r_in][c_in] = number + &apos;0&apos;;</span><br><span class="line">                row[r_in][number - 1] = true;</span><br><span class="line">                column[c_in][number - 1] = true;</span><br><span class="line">                box[r_in / 3 * 3 + c_in / 3][number - 1] = true;</span><br><span class="line">                if(dfs(board, index + 1))&#123;return true;&#125;</span><br><span class="line">                row[r_in][number - 1] = false;</span><br><span class="line">                column[c_in][number - 1] = false;</span><br><span class="line">                box[r_in / 3 * 3 + c_in / 3][number - 1] = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;</span><br><span class="line">        for(int r = 0; r &lt; 9; r++) &#123;</span><br><span class="line">            for (int c = 0; c &lt; 9; c++) &#123;</span><br><span class="line">                if(!isdigit(board[r][c]))&#123;</span><br><span class="line">                    pos.emplace_back(r, c);</span><br><span class="line">                &#125; else&#123;</span><br><span class="line">                    unordered_map&lt;char, int&gt; m1;</span><br><span class="line">                    row[r][board[r][c] - &apos;0&apos; - 1] = true;</span><br><span class="line">                    column[c][board[r][c] - &apos;0&apos; - 1] = true;</span><br><span class="line">                    box[r / 3 * 3 + c / 3][board[r][c] - &apos;0&apos; - 1] = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(board, 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;vector&lt;char&gt;&gt; board(9, vector&lt;char&gt;(9, &apos;.&apos;));    //初始化二维数组</span><br><span class="line">    board = &#123;&#123;&apos;5&apos;,&apos;3&apos;,&apos;.&apos;,&apos;.&apos;,&apos;7&apos;,&apos;.&apos;,&apos;.&apos;,&apos;.&apos;,&apos;.&apos;&#125;,</span><br><span class="line">             &#123;&apos;6&apos;,&apos;.&apos;,&apos;.&apos;,&apos;1&apos;,&apos;9&apos;,&apos;5&apos;,&apos;.&apos;,&apos;.&apos;,&apos;.&apos;&#125;,</span><br><span class="line">             &#123;&apos;.&apos;,&apos;9&apos;,&apos;8&apos;,&apos;.&apos;,&apos;.&apos;,&apos;.&apos;,&apos;.&apos;,&apos;6&apos;,&apos;.&apos;&#125;,</span><br><span class="line">             &#123;&apos;8&apos;,&apos;.&apos;,&apos;.&apos;,&apos;.&apos;,&apos;6&apos;,&apos;.&apos;,&apos;.&apos;,&apos;.&apos;,&apos;3&apos;&#125;,</span><br><span class="line">             &#123;&apos;4&apos;,&apos;.&apos;,&apos;.&apos;,&apos;8&apos;,&apos;.&apos;,&apos;3&apos;,&apos;.&apos;,&apos;.&apos;,&apos;1&apos;&#125;,</span><br><span class="line">             &#123;&apos;7&apos;,&apos;.&apos;,&apos;.&apos;,&apos;.&apos;,&apos;2&apos;,&apos;.&apos;,&apos;.&apos;,&apos;.&apos;,&apos;6&apos;&#125;,</span><br><span class="line">             &#123;&apos;.&apos;,&apos;6&apos;,&apos;.&apos;,&apos;.&apos;,&apos;.&apos;,&apos;.&apos;,&apos;2&apos;,&apos;8&apos;,&apos;.&apos;&#125;,</span><br><span class="line">             &#123;&apos;.&apos;,&apos;.&apos;,&apos;.&apos;,&apos;4&apos;,&apos;1&apos;,&apos;9&apos;,&apos;.&apos;,&apos;.&apos;,&apos;5&apos;&#125;,</span><br><span class="line">             &#123;&apos;.&apos;,&apos;.&apos;,&apos;.&apos;,&apos;.&apos;,&apos;8&apos;,&apos;.&apos;,&apos;.&apos;,&apos;7&apos;,&apos;9&apos;&#125;&#125;;</span><br><span class="line"></span><br><span class="line">	// 有缘人可以试下</span><br><span class="line">//    board[1][0] = &apos;6&apos;; board[1][3] = &apos;1&apos;; board[1][4] = &apos;9&apos;; board[1][5] = &apos;5&apos;;</span><br><span class="line">//    board[2][1] = &apos;9&apos;; board[2][2] = &apos;8&apos;; board[2][7] = &apos;6&apos;;</span><br><span class="line">//    board[3][1] = &apos;8&apos;; board[3][4] = &apos;6&apos;; board[3][8] = &apos;3&apos;;</span><br><span class="line">//    board[4][0] = &apos;4&apos;; board[4][3] = &apos;8&apos;; board[4][5] = &apos;3&apos;; board[4][8] = &apos;1&apos;;</span><br><span class="line">//    board[5][0] = &apos;7&apos;; board[5][4] = &apos;2&apos;; board[5][8] = &apos;6&apos;;</span><br><span class="line">//    board[6][1] = &apos;6&apos;; board[6][6] = &apos;2&apos;; board[6][7] = &apos;8&apos;;</span><br><span class="line">//    board[7][3] = &apos;4&apos;; board[7][4] = &apos;1&apos;; board[7][5] = &apos;9&apos;; board[7][8] = &apos;5&apos;;</span><br><span class="line">//    board[8][4] = &apos;8&apos;; board[8][7] = &apos;7&apos;; board[8][8] = &apos;9&apos;;</span><br><span class="line"></span><br><span class="line">    for(int r = 0; r &lt; 9; r++) &#123;</span><br><span class="line">        for (int c = 0; c &lt; 9; c++) &#123;</span><br><span class="line">            cout &lt;&lt; board[r][c] &lt;&lt; &quot;  &quot;;</span><br><span class="line">            if(c == 2 || c == 5)&#123;</span><br><span class="line">                cout &lt;&lt; &quot;  &quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        if(r == 2 || r == 5)&#123;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    Solution solution;</span><br><span class="line">    solution.solveSudoku(board);</span><br><span class="line">    for(int r = 0; r &lt; 9; r++) &#123;</span><br><span class="line">        for (int c = 0; c &lt; 9; c++) &#123;</span><br><span class="line">            cout &lt;&lt; board[r][c] &lt;&lt; &quot;  &quot;;</span><br><span class="line">            if(c == 2 || c == 5)&#123;</span><br><span class="line">                cout &lt;&lt; &quot;  &quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        if(r == 2 || r == 5)&#123;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39_组合总和"></a>39_组合总和</h2><ul>
<li>回溯永远的神！当时就如何把潜在的值放入数组，并且之后还可以删除百思不得其解，看了题解，有种了然的感觉</li>
</ul>
<h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void dfs(vector&lt;int&gt;&amp; candidates, int target, vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; tmp, int i)&#123;</span><br><span class="line">        if(i == candidates.size())&#123;return;&#125;</span><br><span class="line">        if(target == 0)&#123;</span><br><span class="line">            res.emplace_back(tmp);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(candidates, target, res, tmp, i + 1);</span><br><span class="line">        if(target - candidates[i] &gt;= 0)&#123;</span><br><span class="line">            tmp.push_back(candidates[i]);</span><br><span class="line">            dfs(candidates, target - candidates[i], res, tmp, i);</span><br><span class="line">            tmp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target)&#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;    //存放结果</span><br><span class="line">        vector&lt;int&gt; tmp;    //每一节树枝暂时存放的结果</span><br><span class="line">        int i = 0;  //数组起始位置</span><br><span class="line">        dfs(candidates, target, res, tmp, i);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; candidates = &#123;2, 3, 6, 7&#125;;</span><br><span class="line">    int target = 7;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; res = solution.combinationSum(candidates, target);</span><br><span class="line">    for(const auto&amp; i : res)&#123;</span><br><span class="line">        for(auto j : i)&#123;</span><br><span class="line">            cout &lt;&lt; j;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="40-组合总和"><a href="#40-组合总和" class="headerlink" title="40_组合总和 ||"></a>40_组合总和 ||</h2><ul>
<li>这题深陷上一题的框架里，递归或者回溯，先捋一捋感觉就是本来会递归的，加上回溯之后，就不会了</li>
<li>有几点要注意下，在递归传递参数的时候，比如记录结果的数组，如果参数比较多，可以在类里单独声明属性，这样就可以不用&amp;带了</li>
<li>回溯的时候，一般都是先放入，回溯后，还要再拿出来</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">    vector&lt;int&gt; tmp;</span><br><span class="line">public:</span><br><span class="line">    void dfs(vector&lt;int&gt;&amp; candidates, int target, int i)&#123;</span><br><span class="line">        if(target == 0)&#123;</span><br><span class="line">            res.emplace_back(tmp);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int j = i; j &lt; candidates.size(); j++)&#123;</span><br><span class="line">            if(j &gt; i &amp;&amp; candidates[j] == candidates[j - 1])&#123;continue;&#125;</span><br><span class="line">            if(target - candidates[j] &gt;= 0)&#123;</span><br><span class="line">                tmp.push_back(candidates[j]);</span><br><span class="line">                dfs(candidates, target - candidates[j], j + 1);</span><br><span class="line">                tmp.pop_back();     //回溯后删除</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123;</span><br><span class="line">        sort(candidates.begin(), candidates.end());     //先排序</span><br><span class="line">        dfs(candidates, target, 0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; candidates = &#123;2, 2, 2, 2, 2&#125;;</span><br><span class="line">    int target = 8;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; res = solution.combinationSum2(candidates, target);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    for(auto re : res)&#123;</span><br><span class="line">        for(int r : re)&#123;</span><br><span class="line">            cout &lt;&lt; r;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="41-缺失的第一个正数"><a href="#41-缺失的第一个正数" class="headerlink" title="41_缺失的第一个正数"></a>41_缺失的第一个正数</h2><ul>
<li>第一个循环对数组<code>nums</code>的负数取正，第二个循环判断是否小于<code>n</code>，判断的时候怎么还有负数？我？？？？？？</li>
<li>咳咳，是我太菜了，第二个循环是加负号，并不是原地加，而是<code>nums[nums[j] - 1]</code>这个数，还没有遍历到他，他就变成负数了</li>
<li>第二个循环就不要更改数组了，用<font color="#FF0000">中间值</font>代替</li>
<li>这个方法，我想不到</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int firstMissingPositive(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if(nums.empty())&#123;return 1;&#125;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        for(int&amp; i : nums)&#123;</span><br><span class="line">            if(i &lt;= 0)&#123;</span><br><span class="line">                i = n + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j = 0; j &lt; n; j++)&#123;</span><br><span class="line">            int tmp = abs(nums[j]);</span><br><span class="line">            if(tmp &lt;= n)&#123;</span><br><span class="line">                nums[tmp - 1] = -1 * abs(nums[tmp - 1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int k = 0; k &lt; n; k++)&#123;</span><br><span class="line">            if(nums[k] &gt; 0)&#123;</span><br><span class="line">                return k + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return n + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; nums = &#123;2, 1&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    std::cout &lt;&lt; solution.firstMissingPositive(nums) &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42_接雨水"></a>42_接雨水</h2><ul>
<li>一开始的思路是想到俄罗斯方块消行（对数组两端裁剪，等于0的去掉，再遍历，如果为零，则<code>ans++</code>，否则减1，最后递归，直到数组的长度小于3），每次都一层或者层的消，最后超出时间限制</li>
<li>看了题解有关栈的方法，大体上是分成多个小段，对每个小段计算水的体积，计算体积是一层一层来计算，高度*长度，即始终确保是个矩形</li>
</ul>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int trap(vector&lt;int&gt;&amp; height) &#123;</span><br><span class="line">        int len = height.size(), ans = 0;</span><br><span class="line">        stack&lt;int&gt; stk;</span><br><span class="line">        for(int i = 0; i &lt; len; i++)&#123;</span><br><span class="line">            while (!stk.empty() &amp;&amp; height[i] &gt; height[stk.top()])&#123;</span><br><span class="line">                int t = stk.top();</span><br><span class="line">                stk.pop();</span><br><span class="line">                if(stk.empty())&#123;break;&#125;</span><br><span class="line">                int h = min(height[stk.top()] - height[t], height[i] - height[t]);</span><br><span class="line">                ans = h * (i - stk.top() - 1) + ans;</span><br><span class="line">            &#125;</span><br><span class="line">            stk.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; height = &#123;0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    std::cout &lt;&lt; solution.trap(height) &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="45-跳跃游戏"><a href="#45-跳跃游戏" class="headerlink" title="45_跳跃游戏 ||"></a>45_跳跃游戏 ||</h2><ul>
<li>之前罗马数字用了贪心算法，当时没怎么在意，这题也可用，虽然会超出时间限制：当跳到数组的最后时，从后往前推，哪个位置可以跳到，选距离最大的那个位置，并更新<code>pos</code></li>
<li>第二个方法是正向查找，每次找到可到达的最远位置，还是太菜了…</li>
</ul>
<h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><ul>
<li>反向</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int jump(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if(nums.size() &lt;= 1)&#123;return 0;&#125;</span><br><span class="line">        int pos = (int)(nums.size() - 1), ans = 0;</span><br><span class="line">        while (pos &gt; 0)&#123;</span><br><span class="line">            for(int i = 0; i &lt; pos; i++)&#123;</span><br><span class="line">                if(i + nums[i] &gt;= pos)&#123;</span><br><span class="line">                    pos = i;</span><br><span class="line">                    ans++;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; nums = &#123;2, 3, 1, 1, 4&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.jump(nums) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>正向</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int jump(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int maxPos = 0, n = nums.size(), end = 0, step = 0;</span><br><span class="line">        for (int i = 0; i &lt; n - 1; ++i) &#123;</span><br><span class="line">            if (maxPos &gt;= i) &#123;</span><br><span class="line">                maxPos = max(maxPos, i + nums[i]);</span><br><span class="line">                if (i == end) &#123;</span><br><span class="line">                    end = maxPos;</span><br><span class="line">                    ++step;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return step;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46_全排列"></a>46_全排列</h2><ul>
<li>这题咋一看跟之前的回溯(剪树枝)有点像，后来发现不对，最开始的树根会变，仔细思考了下，有点类似数独那题，要用递归</li>
<li>像平时思考一样，第一个位置可以放1，2，3三个数，那么第二个位置就只能放两个数了，以此往后，到最后一个数时进行回溯，同时<code>tmp</code>数组要删除一个数</li>
<li>一次通过</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void dfs(vector&lt;int&gt; nums, vector&lt;int&gt;&amp; tmp, vector&lt;vector&lt;int&gt;&gt;&amp; res, int n)&#123;</span><br><span class="line">        if(tmp.size() == n)&#123;</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            vector&lt;int&gt; nums_tmp = nums;</span><br><span class="line">            tmp.push_back(nums[i]);</span><br><span class="line">            nums_tmp.erase(nums_tmp.begin() + i);</span><br><span class="line">            dfs(nums_tmp, tmp, res, n);</span><br><span class="line">            tmp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        vector&lt;int&gt; tmp;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        dfs(nums, tmp, res, n);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; nums = &#123;1, 2, 3&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; res = solution.permute(nums);</span><br><span class="line">    for(const auto&amp; i : res)&#123;</span><br><span class="line">        for(auto j : i)&#123;</span><br><span class="line">            cout &lt;&lt; j;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="47-全排列"><a href="#47-全排列" class="headerlink" title="47_全排列 ||"></a>47_全排列 ||</h2><ul>
<li>跟上题一样，只需添加几行代码就行；在进行去重复时，要先梳理下原数组，同样的挨在一起</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void dfs(vector&lt;int&gt; nums, vector&lt;int&gt;&amp; tmp, vector&lt;vector&lt;int&gt;&gt;&amp; res, int n)&#123;</span><br><span class="line">        if(tmp.size() == n)&#123;</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            if(i &gt;= 1 &amp;&amp; nums[i] == nums[i - 1])&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            vector&lt;int&gt; nums_tmp = nums;</span><br><span class="line">            tmp.push_back(nums[i]);</span><br><span class="line">            nums_tmp.erase(nums_tmp.begin() + i);</span><br><span class="line">            dfs(nums_tmp, tmp, res, n);</span><br><span class="line">            tmp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        vector&lt;int&gt; tmp;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        dfs(nums, tmp, res, n);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; nums = &#123;1, 2, 1&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; res = solution.permuteUnique(nums);</span><br><span class="line">    for(const auto&amp; i : res)&#123;</span><br><span class="line">        for(auto j : i)&#123;</span><br><span class="line">            cout &lt;&lt; j;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48_旋转图像"></a>48_旋转图像</h2><ul>
<li>一步到位不了，那就分两步；第一步：转置，声明一个中间值<code>tmp</code>；第二步：以中间列为轴心，翻转180度</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        int tmp = 0, n = matrix.size();</span><br><span class="line">        for(int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">            for(int j = i + 1; j &lt; n; j++)&#123;</span><br><span class="line">                tmp = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[j][i];</span><br><span class="line">                matrix[j][i] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">            for(int j = 0; j &lt; n - j - 1; j++)&#123;</span><br><span class="line">                tmp = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[i][n - j - 1];</span><br><span class="line">                matrix[i][n - j - 1] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; matrix = &#123;&#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;, &#123;7, 8, 9&#125;&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    solution.rotate(matrix);</span><br><span class="line">    for(auto i : matrix)&#123;</span><br><span class="line">        for(auto j : i)&#123;</span><br><span class="line">            cout &lt;&lt; j;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="51-N皇后"><a href="#51-N皇后" class="headerlink" title="51_N皇后"></a>51_N皇后</h2><ul>
<li>这题类似于解数独，每次放置<code>Q</code>之前都要判断那三个规则；数独那题是先放数字，再判断规则；</li>
<li>重点就是标记，不能只用0或1来标记，去标记的时候会覆盖之前的（这个格子不能放，去完标记操作后，变成可以放），在递归时就会产生错误；标记的时候，用一个二维数组来维护行、列、斜线（正对角线、次对角线）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">    vector&lt;string&gt; tmp;</span><br><span class="line">public:</span><br><span class="line">    void mark(vector&lt;vector&lt;int&gt;&gt;&amp; oblique, int i, int j, int n, int m, bool flag)&#123;</span><br><span class="line">        int a = 0, b = m;</span><br><span class="line">        if(!flag)&#123;a = m; b = 0;&#125;</span><br><span class="line"></span><br><span class="line">        int i_tmp = i, j_tmp = j;  // 斜线有两条，分开来写，如果写在一起，有一个到边界另一个就停止了</span><br><span class="line">        while (i_tmp &lt; n &amp;&amp; j_tmp &lt; n)&#123;</span><br><span class="line">            if(oblique[i_tmp][j_tmp] == a)&#123;</span><br><span class="line">                oblique[i_tmp][j_tmp] = b;  // 每次标记都要不一样，否则消除标记时会覆盖原来的</span><br><span class="line">            &#125;</span><br><span class="line">            i_tmp++; j_tmp++;</span><br><span class="line">        &#125;</span><br><span class="line">        i_tmp = i, j_tmp = j;</span><br><span class="line">        while (i_tmp &lt; n &amp;&amp; j_tmp &gt;= 0)&#123;</span><br><span class="line">            if(oblique[i_tmp][j_tmp] == a)&#123;</span><br><span class="line">                oblique[i_tmp][j_tmp] = b;  // 每次标记都要不一样，否则消除标记时会覆盖原来的</span><br><span class="line">            &#125;</span><br><span class="line">            i_tmp++; j_tmp--;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i_0 = 0; i_0 &lt; n; i_0++)&#123;</span><br><span class="line">            if(oblique[i_0][j] == a)&#123;</span><br><span class="line">                oblique[i_0][j] = b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j_0 = 0; j_0 &lt; n; j_0++)&#123;</span><br><span class="line">            if(oblique[i][j_0] == a)&#123;</span><br><span class="line">                oblique[i][j_0] = b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void dfs(int n, vector&lt;int&gt;&amp; row, vector&lt;vector&lt;int&gt;&gt;&amp; oblique, int Q_number)&#123;</span><br><span class="line">        if(Q_number == n)&#123;</span><br><span class="line">            res.emplace_back(tmp);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i = Q_number ; i &lt; n; i++)&#123;</span><br><span class="line">            for(int j = 0; j &lt; n; j++)&#123;</span><br><span class="line">                if(oblique[i][j] == 0)&#123;</span><br><span class="line">                    tmp[i][j] = &apos;Q&apos;;   // 放置Q后，要将其余对应的位置做标记，方便之后判断</span><br><span class="line">                    Q_number++;</span><br><span class="line">                    row[i] = 1;</span><br><span class="line">                    mark(oblique, i, j, n, i + 1, true);</span><br><span class="line"></span><br><span class="line">                    dfs(n, row, oblique, Q_number);</span><br><span class="line"></span><br><span class="line">                    tmp[i][j] = &apos;.&apos;;    // 回溯后，抹去Q</span><br><span class="line">                    Q_number--;</span><br><span class="line">                    row[i] = 0;</span><br><span class="line">                    mark(oblique, i, j, n, i + 1, false);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(row[i] == 0)&#123;return;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123;</span><br><span class="line">        vector&lt;int&gt; row(n);</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; oblique(n, vector&lt;int&gt;(n));</span><br><span class="line">        int Q_number = 0;</span><br><span class="line">        for(int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">            tmp.emplace_back(&quot;&quot;);</span><br><span class="line">            for(int j = 0; j &lt; n; j++)&#123;</span><br><span class="line">                tmp[i].push_back(&apos;.&apos;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   // 初始化tmp</span><br><span class="line">        dfs(n, row, oblique, Q_number);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; res = solution.solveNQueens(6);</span><br><span class="line">    for(const auto&amp; re :res)&#123;</span><br><span class="line">        for(const auto&amp; r : re)&#123;</span><br><span class="line">            for(auto s : r)&#123;</span><br><span class="line">                cout &lt;&lt; s &lt;&lt; &quot; &quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; &quot;----------&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="52-N皇后"><a href="#52-N皇后" class="headerlink" title="52_N皇后 ||"></a>52_N皇后 ||</h2><ul>
<li>只要将上题输出改成个数就行（代码就不粘了）</li>
</ul>
<h2 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53_最大子序和"></a>53_最大子序和</h2><ul>
<li>用双指针法失败了，在判断两边指针谁先移动感觉没有规律，如果两边对应的数字一样大，那不得分情况；最后手撸了一遍三重循环(笑)</li>
<li>动态规划转移方程，算<code>f(i)</code>(每一个连续子段都有个末尾，根据末尾出现的位置，可以将数组从头到尾遍历一遍)，注意循环到最后的结果是最后一个<code>f(i)</code>，还要比较大小（怪不得这题算简单题）</li>
</ul>
<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int ans = INT32_MIN, tmp = 0;</span><br><span class="line">        for(int num : nums)&#123;</span><br><span class="line">            if(num &gt;= tmp + num)&#123;</span><br><span class="line">                tmp = num;</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                tmp += num;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = max(ans, tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; nums = &#123;-2,1,-3,4,-1,2,1,-5&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    int ans = solution.maxSubArray(nums);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54_螺旋矩阵"></a>54_螺旋矩阵</h2><ul>
<li>有点像贪吃蛇；我用了四个方向函数，向右函数末尾会调用向下函数，向下函数会调用向左函数······每次调用函数都会判断是否满足条件，我觉得我写的比较繁琐，提交记录却出人意料的好</li>
<li>看下题解优化下</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void right(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, vector&lt;vector&lt;int&gt;&gt;&amp; tmp, vector&lt;int&gt;&amp; res, int&amp; i, int&amp; j, bool&amp; flag, int m, int n)&#123;</span><br><span class="line">        if(!flag)&#123;return;&#125;</span><br><span class="line">        while (j &lt; n &amp;&amp; tmp[i][j] != 0)&#123;</span><br><span class="line">            res.push_back(matrix[i][j]);</span><br><span class="line">            tmp[i][j] = 0;</span><br><span class="line">            cout &lt;&lt; &quot;(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot;&lt;&lt; j &lt;&lt; &quot;)&quot;;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        j--;</span><br><span class="line">        i++;</span><br><span class="line">        if(i &gt;= m || (tmp[i][j] == 0 &amp;&amp; i &lt; m))&#123;</span><br><span class="line">            flag = false;</span><br><span class="line">        &#125;</span><br><span class="line">        down(matrix, tmp, res, i, j, flag, m, n);</span><br><span class="line">    &#125;</span><br><span class="line">    void down(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, vector&lt;vector&lt;int&gt;&gt;&amp; tmp, vector&lt;int&gt;&amp; res, int&amp; i, int&amp; j, bool&amp; flag, int m, int n)&#123;</span><br><span class="line">        if(!flag)&#123;return;&#125;</span><br><span class="line">        while (i &lt; m &amp;&amp; tmp[i][j] != 0)&#123;</span><br><span class="line">            res.push_back(matrix[i][j]);</span><br><span class="line">            tmp[i][j] = 0;</span><br><span class="line">            cout &lt;&lt; &quot;(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot;&lt;&lt; j &lt;&lt; &quot;)&quot;;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        i--;</span><br><span class="line">        j--;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        if(j &lt; 0 || (tmp[i][j] == 0 &amp;&amp; j &gt;= 0))&#123;</span><br><span class="line">            flag = false;</span><br><span class="line">        &#125;</span><br><span class="line">        left(matrix, tmp, res, i, j, flag, m, n);</span><br><span class="line">    &#125;</span><br><span class="line">    void left(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, vector&lt;vector&lt;int&gt;&gt;&amp; tmp, vector&lt;int&gt;&amp; res, int&amp; i, int&amp; j, bool&amp; flag, int m, int n)&#123;</span><br><span class="line">        if(!flag)&#123;return;&#125;</span><br><span class="line">        while (j &gt;= 0 &amp;&amp; tmp[i][j] != 0)&#123;</span><br><span class="line">            res.push_back(matrix[i][j]);</span><br><span class="line">            tmp[i][j] = 0;</span><br><span class="line">            cout &lt;&lt; &quot;(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot;&lt;&lt; j &lt;&lt; &quot;)&quot;;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        j++;</span><br><span class="line">        i--;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        if(i &lt; 0 || (tmp[i][j] == 0 &amp;&amp; i &gt;= 0))&#123;</span><br><span class="line">            flag = false;</span><br><span class="line">        &#125;</span><br><span class="line">        up(matrix, tmp, res, i, j, flag, m, n);</span><br><span class="line">    &#125;</span><br><span class="line">    void up(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, vector&lt;vector&lt;int&gt;&gt;&amp; tmp, vector&lt;int&gt;&amp; res, int&amp; i, int&amp; j, bool&amp; flag, int m, int n)&#123;</span><br><span class="line">        if(!flag)&#123;return;&#125;</span><br><span class="line">        while (i &gt;= 0 &amp;&amp; tmp[i][j] != 0)&#123;</span><br><span class="line">            res.push_back(matrix[i][j]);</span><br><span class="line">            tmp[i][j] = 0;</span><br><span class="line">            cout &lt;&lt; &quot;(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot;&lt;&lt; j &lt;&lt; &quot;)&quot;;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        j++;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        if(j &gt;= n || (tmp[i][j] == 0 &amp;&amp; j &lt; n))&#123;</span><br><span class="line">            flag = false;</span><br><span class="line">        &#125;</span><br><span class="line">        right(matrix, tmp, res, i, j, flag, m, n);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        int m = matrix.size(), n = matrix[0].size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; tmp(m, vector&lt;int&gt;(n, 1));</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        int i = 0, j = 0;</span><br><span class="line">        bool flag = true;</span><br><span class="line"></span><br><span class="line">        right(matrix,tmp, res, i, j, flag, m, n);</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; matrix = &#123;&#123;1,2,3&#125;, &#123;4,5,6&#125;, &#123;7,8,9&#125;&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;int&gt; res = solution.spiralOrder(matrix);</span><br><span class="line">    for(auto re : res)&#123;</span><br><span class="line">        cout &lt;&lt; re &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55_跳跃游戏"></a>55_跳跃游戏</h2><ul>
<li>这题用了跳跃游戏||的反向贪心算法，通过是通过了，就是运行时间有点久，一千多ms</li>
<li>还是参考下题解吧：维护可以到达的最远距离</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    // 反向贪心算法</span><br><span class="line">    bool canJump1(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int l = nums.size();</span><br><span class="line">        l--;</span><br><span class="line">        while (l &gt; 0)&#123;</span><br><span class="line">            cout &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">            for(int j = 0; j &lt; l; j++)&#123;</span><br><span class="line">                if(nums[j] + j &gt;= l)&#123;</span><br><span class="line">                    l = j;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                if(j == l - 1)&#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    //维护最大距离</span><br><span class="line">    bool canJump(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int distance = 0;</span><br><span class="line">        for(int i = 0; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            if(i &lt;= distance)&#123;</span><br><span class="line">                distance = max(i + nums[i], distance);</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; nums = &#123;2,3,1,1,4&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.canJump(nums) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56_合并区间"></a>56_合并区间</h2><ul>
<li>不小心看到了提示（链表），看到提示反而不会了0.0</li>
<li>还是看了别人的博客视频，对这个二维数组进行排序，用<code>sort()</code>时要注意参数，直接写<code>sort(intervals.begin(), intervals.end(), cmp);</code>会在<code>cmp</code>报错</li>
<li>对于像<code>bool cmp(const Interval &amp;a,const Interval &amp;b)</code>这样的成员函数，它是属于类的，所以调用它必须需要对象才可以，<code>bool cmp( Solution* this, const Interval &amp;a,const Interval &amp;b );</code>它有一个<code>implicit parameter</code>(隐含参数)，这才导致它无法被<code>sort()</code>这样的函数调用，主要是参数不匹配，改成静态即可</li>
<li>用下面这个方法，提交记录指标比较低；看了下答案，原来可以直接省去<code>cmp</code>参数0.0</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    static bool cmp(vector&lt;int&gt; a, vector&lt;int&gt; b) &#123;</span><br><span class="line">        return a[0] &lt; b[0]; // 小于号是从小到大排列</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        sort(intervals.begin(), intervals.end(), cmp);</span><br><span class="line">        for(auto i : intervals)&#123;</span><br><span class="line">            if(res.empty() || i[0] &gt; res[res.size() - 1][1])&#123;</span><br><span class="line">                res.push_back(i);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                res[res.size() - 1][1] = max(res[res.size() - 1][1], i[1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; intervals = &#123;&#123;1,3&#125;,&#123;2,6&#125;,&#123;8,10&#125;,&#123;15,18&#125;&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; res = solution.merge(intervals);</span><br><span class="line">    for(const auto&amp; re : res)&#123;</span><br><span class="line">        for(auto r : re)&#123;</span><br><span class="line">            cout &lt;&lt; r &lt;&lt; &quot; &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; &quot;, &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="57-插入区间"><a href="#57-插入区间" class="headerlink" title="57_插入区间"></a>57_插入区间</h2><ul>
<li>本质上和上一题还是一样的，先把新区间放在最后再排序，然后合并；康康题解的思路，再手撕一遍；</li>
<li>自己手动写的时候，步骤比较繁琐，而且还没实现出来0.0，都是找有重叠的区间，一上来就默认有重叠了，记录了重叠区间的位置，合并之前还要删除重叠的区间，最后插入…</li>
<li>还是一次遍历总区间，将合适的放入<code>res</code>里，最后再康没有重叠就直接插入新区间（不用再找第几个位置插入了）；遇到一个坑，clion里代码是可以得出正确答案的，leetcode就不行。。。<code>bool flag = false;</code>这里要写完整</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; insert1(vector&lt;vector&lt;int&gt;&gt;&amp; intervals, vector&lt;int&gt;&amp; newInterval) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; tmp = intervals;</span><br><span class="line">        tmp.push_back(newInterval);</span><br><span class="line">        sort(tmp.begin(), tmp.end());</span><br><span class="line">        for(auto i : tmp)&#123;</span><br><span class="line">            if(res.empty() || i[0] &gt; res[res.size() - 1][1])&#123;</span><br><span class="line">                res.push_back(i);</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                res[res.size() - 1][1] = max(i[1], res[res.size() - 1][1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; insert(vector&lt;vector&lt;int&gt;&gt;&amp; intervals, vector&lt;int&gt;&amp; newInterval) &#123;</span><br><span class="line">        if(intervals.empty())&#123;return &#123;newInterval&#125;;&#125;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        int l = newInterval[0], r = newInterval[1];</span><br><span class="line">        bool flag = false;</span><br><span class="line">        for(auto i : intervals)&#123;</span><br><span class="line">            if(i[0] &gt; r)&#123;</span><br><span class="line">                if(!flag)&#123;res.push_back(&#123;l, r&#125;); flag = true;&#125;</span><br><span class="line">                res.push_back(i);</span><br><span class="line">            &#125; else if(i[1] &lt; l)&#123;</span><br><span class="line">                res.push_back(i);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                l = min(l, i[0]);</span><br><span class="line">                r = max(r, i[1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!flag)&#123;res.push_back(&#123;l, r&#125;);&#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; intervals = &#123;&#123;1,3&#125;,&#123;6,9&#125;&#125;;</span><br><span class="line">    vector&lt;int&gt; newInterval = &#123;3,5&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; res = solution.insert(intervals, newInterval);</span><br><span class="line">    for(auto re : res)&#123;</span><br><span class="line">        cout &lt;&lt; re[0] &lt;&lt; &quot; &quot; &lt;&lt; re[1] &lt;&lt; &quot;, &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="59-螺旋矩阵"><a href="#59-螺旋矩阵" class="headerlink" title="59_螺旋矩阵 ||"></a>59_螺旋矩阵 ||</h2><ul>
<li>这题感觉比|简单点</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void right(vector&lt;vector&lt;int&gt;&gt;&amp; res, int i, int j, int&amp; number, int n)&#123;</span><br><span class="line">        if(number &gt; n * n)&#123;return;&#125;</span><br><span class="line">        while (j &lt; n &amp;&amp; res[i][j] == 0)&#123;</span><br><span class="line">            res[i][j] = number;</span><br><span class="line">            number++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        j--;</span><br><span class="line">        down(res, i + 1, j, number, n);</span><br><span class="line">    &#125;</span><br><span class="line">    void down(vector&lt;vector&lt;int&gt;&gt;&amp; res, int i, int j, int&amp; number, int n)&#123;</span><br><span class="line">        if(number &gt; n * n)&#123;return;&#125;</span><br><span class="line">        while (i &lt; n &amp;&amp; res[i][j] == 0)&#123;</span><br><span class="line">            res[i][j] = number;</span><br><span class="line">            number++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        i--;</span><br><span class="line">        left(res, i, j - 1, number, n);</span><br><span class="line">    &#125;</span><br><span class="line">    void left(vector&lt;vector&lt;int&gt;&gt;&amp; res, int i, int j, int&amp; number, int n)&#123;</span><br><span class="line">        if(number &gt; n * n)&#123;return;&#125;</span><br><span class="line">        while (j &gt;= 0 &amp;&amp; res[i][j] == 0)&#123;</span><br><span class="line">            res[i][j] = number;</span><br><span class="line">            number++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        j++;</span><br><span class="line">        up(res, i - 1, j, number, n);</span><br><span class="line">    &#125;</span><br><span class="line">    void up(vector&lt;vector&lt;int&gt;&gt;&amp; res, int i, int j, int&amp; number, int n)&#123;</span><br><span class="line">        if(number &gt; n * n)&#123;return;&#125;</span><br><span class="line">        while (i &gt;= 0 &amp;&amp; res[i][j] == 0)&#123;</span><br><span class="line">            res[i][j] = number;</span><br><span class="line">            number++;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        right(res, i, j + 1, number, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res(n, vector&lt;int&gt;(n, 0));</span><br><span class="line">        int number = 1;</span><br><span class="line">        right(res, 0, 0,number, n);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; matrix = &#123;&#123;1,2,3&#125;, &#123;4,5,6&#125;, &#123;7,8,9&#125;&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; res = solution.generateMatrix(2);</span><br><span class="line">    for(const auto&amp; re : res)&#123;</span><br><span class="line">        for(auto r : re)&#123;</span><br><span class="line">            cout &lt;&lt; r &lt;&lt; &quot; &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="63-不同路径"><a href="#63-不同路径" class="headerlink" title="63_不同路径 ||"></a>63_不同路径 ||</h2><ul>
<li>组合数学用不了了，试着用递归，不出所料超出时间限制</li>
<li>每次都要判断两个方向，每次选择一个方向，另一个方向就会暂停，一直到最后的格子，才会返回上一层，没错这就是递归；那怎样才能让两个方向同时进行呢，这样一到最后的格子，答案也随之出来，有点像遍历；</li>
<li>回想以前的题，接触过几次动态规划，说实话动态规划有点像马尔科夫链——当前状态取决于上一个状态，仔细思考后发现：最后一个格子的所有路径=左边的格子+上边的格子，以此往前推可以得出，任意一个格子的路径数=与之相邻左边的格子+上边的格子；如果格子在边界，那么默认左边或者上边为0。</li>
<li>主要是如何标记这个二维数组：万事开头难，开头不能有障碍物（初始为0），再标记为1；之后遍历，跳过开头，如果遇到障碍物，先标记为0，再<code>continue;</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123;</span><br><span class="line">        if(obstacleGrid[0][0] == 1)&#123;return 0;&#125;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; tmp = obstacleGrid;</span><br><span class="line">        tmp[0][0] = 1;</span><br><span class="line">        int m = obstacleGrid.size(), n = obstacleGrid[0].size();</span><br><span class="line">        for(int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">            for(int j = 0; j &lt; n; j++)&#123;</span><br><span class="line">                if(i == 0 &amp;&amp; j == 0)&#123; continue;&#125;    //开头直接跳过</span><br><span class="line">                if(tmp[i][j] == 1)&#123;tmp[i][j] = 0;continue;&#125;</span><br><span class="line">                int up = i == 0 ? 0 : tmp[i - 1][j], left = j == 0 ? 0 : tmp[i][j - 1];</span><br><span class="line">                tmp[i][j] = up + left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return tmp[m - 1][n - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; obstacleGrid = &#123;&#123;0,0,0,0&#125;&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.uniquePathsWithObstacles(obstacleGrid) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64_最小路径和"></a>64_最小路径和</h2><ul>
<li>这个和上题一个思路，麻烦就在于边界，之后就判断上边和左边哪个值更小</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        int m = grid.size(), n = grid[0].size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; tmp = grid;</span><br><span class="line">        for(int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">            for(int j = 0; j &lt; n; j++)&#123;</span><br><span class="line">                if(i == 0)&#123;</span><br><span class="line">                    tmp[i][j] += j == 0 ? 0 : tmp[i][j - 1];</span><br><span class="line">                &#125; else if(j == 0)&#123;</span><br><span class="line">                    tmp[i][j] += tmp[i - 1][j];</span><br><span class="line">                &#125; else&#123;</span><br><span class="line">                    tmp[i][j] += min(tmp[i - 1][j], tmp[i][j - 1]);</span><br><span class="line">                &#125;</span><br><span class="line">                cout &lt;&lt; tmp[i][j] &lt;&lt; &quot; &quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        return tmp[m - 1][n - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; grid = &#123;&#123;0,2,2&#125;,</span><br><span class="line">                                &#123;0,3,6&#125;,</span><br><span class="line">                                &#123;6,9,0&#125;&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.minPathSum(grid) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="66-加一"><a href="#66-加一" class="headerlink" title="66_加一"></a>66_加一</h2><ul>
<li>这题类似43_字符串相乘，主要考虑进位（初始值为1）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        int carry = 1, l = digits.size();</span><br><span class="line">        for(int i = l - 1; i &gt;= 0; i--)&#123;</span><br><span class="line">            int ans = digits[i] + carry;</span><br><span class="line">            res.insert(res.begin(), ans % 10);</span><br><span class="line">            carry = ans / 10;</span><br><span class="line">        &#125;</span><br><span class="line">        if(carry != 0)&#123;res.insert(res.begin(), carry);&#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; digits = &#123;9, 8, 9&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;int&gt; res = solution.plusOne(digits);</span><br><span class="line">    for(auto re : res)&#123;</span><br><span class="line">        cout &lt;&lt; re;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="68-文本左右对齐"><a href="#68-文本左右对齐" class="headerlink" title="68_文本左右对齐"></a>68_文本左右对齐</h2><ul>
<li>因为每一行要尽可能多的放入单词，单词之间至少一个空格，我的思路和题解其实是一样的：先把单词放好，再将空格平均分配（商和余数）</li>
<li>例如标记出了空格的所有位置，那么插入几个空格，后面的位置全部都要更新；吐槽下，最后一行我以为也要对齐的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void insert_space(string&amp; tmp, int maxWidth, bool flag)&#123;</span><br><span class="line">        if(tmp.size() &gt;= maxWidth)&#123;return;&#125;</span><br><span class="line">        int n = maxWidth - (int)tmp.size(); //末尾空格数</span><br><span class="line">        cout &lt;&lt; &quot;tmp.size() = &quot; &lt;&lt; tmp.size() &lt;&lt; &quot; n = &quot; &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">        vector&lt;int&gt; pos;</span><br><span class="line">        for(int i = 0; i &lt; tmp.size() - 1; i++)&#123;</span><br><span class="line">            if(tmp[i] == &apos; &apos; &amp;&amp; tmp[i + 1] != &apos; &apos;)&#123;</span><br><span class="line">                pos.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(pos.empty() || flag)&#123;</span><br><span class="line">            while (n &gt; 0)&#123;</span><br><span class="line">                tmp.push_back(&apos; &apos;);</span><br><span class="line">                n--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">            int n_pos = pos.size(); //间隔数</span><br><span class="line">            int remainder = n % n_pos; //余数</span><br><span class="line">            for(int j = 0; j &lt; n_pos; j++)&#123;</span><br><span class="line">                int quotient = n / n_pos;   //商</span><br><span class="line">                if(remainder &gt; 0)&#123;</span><br><span class="line">                    tmp.insert(pos[j], quotient + 1, &apos; &apos;);</span><br><span class="line">                    int k = j + 1;</span><br><span class="line">                    while (k &lt; n_pos)&#123;</span><br><span class="line">                        pos[k] += quotient + 1;</span><br><span class="line">                        k++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    remainder--;</span><br><span class="line">                &#125; else&#123;</span><br><span class="line">                    tmp.insert(pos[j], quotient, &apos; &apos;);</span><br><span class="line">                    int k = j + 1;</span><br><span class="line">                    while (k &lt; n_pos)&#123;</span><br><span class="line">                        pos[k] += quotient;</span><br><span class="line">                        k++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;string&gt; fullJustify(vector&lt;string&gt;&amp; words, int maxWidth) &#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        string tmp;</span><br><span class="line">        for(int i = 0; i &lt; words.size(); i++)&#123;</span><br><span class="line">            if(tmp.size() + words[i].size() + 1 &lt;= maxWidth &amp;&amp; !tmp.empty())&#123;</span><br><span class="line">                tmp.push_back(&apos; &apos;);</span><br><span class="line">            &#125; else if(tmp.size() + words[i].size() + 1 &gt; maxWidth &amp;&amp; !tmp.empty())&#123;</span><br><span class="line">                insert_space(tmp, maxWidth, false);</span><br><span class="line">                res.push_back(tmp);</span><br><span class="line">                tmp.clear();</span><br><span class="line">            &#125;</span><br><span class="line">            tmp.append(words[i]);</span><br><span class="line">            if(i + 1 == words.size())&#123;</span><br><span class="line">                insert_space(tmp, maxWidth, true);</span><br><span class="line">                res.push_back(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;string&gt; words = &#123;&quot;Science&quot;,&quot;is&quot;,&quot;what&quot;,&quot;we&quot;,&quot;understand&quot;,&quot;well&quot;,&quot;enough&quot;,&quot;to&quot;,&quot;explain&quot;,&quot;to&quot;,&quot;a&quot;,&quot;computer.&quot;,&quot;Art&quot;,&quot;is&quot;,&quot;everything&quot;,&quot;else&quot;,&quot;we&quot;,&quot;do&quot;&#125;;</span><br><span class="line">    vector&lt;string&gt; words1 = &#123;&quot;Don&apos;t&quot;,&quot;go&quot;,&quot;around&quot;,&quot;saying&quot;,&quot;the&quot;,&quot;world&quot;,&quot;owes&quot;,&quot;you&quot;,&quot;a&quot;,&quot;living;&quot;,&quot;the&quot;,&quot;world&quot;,&quot;owes&quot;,&quot;you&quot;,&quot;nothing;&quot;,&quot;it&quot;,&quot;was&quot;,&quot;here&quot;,&quot;first.&quot;&#125;;</span><br><span class="line">    int maxWidth = 30;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;string&gt; res = solution.fullJustify(words1, maxWidth);</span><br><span class="line">    for(const auto&amp; re :res)&#123;</span><br><span class="line">        for(auto r : re)&#123;</span><br><span class="line">            if(r == &apos; &apos;)&#123;r = &apos;-&apos;;&#125;</span><br><span class="line">            cout &lt;&lt; r;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="73-矩阵置零"><a href="#73-矩阵置零" class="headerlink" title="73_矩阵置零"></a>73_矩阵置零</h2><ul>
<li>这题虽说不太严谨(标记的那个方法)，不过有一种题解很有意思，手撕下；要先判断第一行或者第一列是否有0，需要两个标志，有就要在最后对应行或者列置0，其次在做其他标记</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        bool row = false, col = false;</span><br><span class="line">        for(int j = 0; j &lt; matrix[0].size(); j++)&#123;</span><br><span class="line">            if(matrix[0][j] == 0)&#123;</span><br><span class="line">                col = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i = 0; i &lt; matrix.size(); i++)&#123;</span><br><span class="line">            if(matrix[i][0] == 0)&#123;</span><br><span class="line">                row = true;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int j = 0; j &lt; matrix[0].size(); j++)&#123;</span><br><span class="line">                if(matrix[i][j] == 0)&#123;</span><br><span class="line">                    matrix[0][j] = 0;</span><br><span class="line">                    matrix[i][0] = 0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i = 1; i &lt; matrix.size(); i++)&#123;</span><br><span class="line">            for(int j = 1; j &lt; matrix[0].size(); j++)&#123;</span><br><span class="line">                if(matrix[i][0] == 0 || matrix[0][j] == 0)&#123;</span><br><span class="line">                    matrix[i][j] = 0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(row)&#123;</span><br><span class="line">            for(int i = 1; i &lt; matrix.size(); i++)&#123;</span><br><span class="line">                matrix[i][0] = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(col)&#123;</span><br><span class="line">            for(int j = 1; j &lt; matrix[0].size(); j++)&#123;</span><br><span class="line">                matrix[0][j] = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; matrix = &#123;&#123;1,2,3,4&#125;,</span><br><span class="line">                                   &#123;5,0,7,8&#125;,</span><br><span class="line">                                   &#123;0,10,11,12&#125;,</span><br><span class="line">                                   &#123;13,14,15,0&#125;&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    solution.setZeroes(matrix);</span><br><span class="line">    for(auto ma : matrix)&#123;</span><br><span class="line">        for(auto m : ma)&#123;</span><br><span class="line">            cout &lt;&lt; m &lt;&lt; &quot; &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="74-搜索二维矩阵"><a href="#74-搜索二维矩阵" class="headerlink" title="74_搜索二维矩阵"></a>74_搜索二维矩阵</h2><ul>
<li>思路简单，先确定在哪一行，在对这一行进行二分查找，确定哪一行也是二分查找，不过要考虑这一行最后一个数，写的时候感觉怪怪的；看了题解，，，，才知道原来可以精确定位到行列</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123;</span><br><span class="line">        int row = matrix.size(), col = matrix[0].size(), idx = row * col; //一共有idx个数，并且是升序，直接看成一维的</span><br><span class="line">        if(matrix[0][0] &lt;= target &amp;&amp; target &lt;= matrix[row - 1][col - 1])&#123;</span><br><span class="line">            int l = 0, r = idx - 1;</span><br><span class="line">            while (l &lt;= r)&#123;</span><br><span class="line">//                cout &lt;&lt; &quot;l = &quot; &lt;&lt; l &lt;&lt; &quot; r  = &quot; &lt;&lt; r &lt;&lt; endl;</span><br><span class="line">                int mid = (l + r) / 2;</span><br><span class="line">                if(matrix[mid / col][mid % col] == target)&#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">                if(matrix[mid / col][mid % col] &lt; target)&#123;</span><br><span class="line">                    l = mid + 1;</span><br><span class="line">                &#125; else&#123;</span><br><span class="line">                    r = mid - 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; matrix = &#123;&#123;1,5,7,8&#125;,</span><br><span class="line">                                  &#123;10,12,15,19&#125;&#125;;</span><br><span class="line">    int target = 19;</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.searchMatrix(matrix, target) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="75-数组"><a href="#75-数组" class="headerlink" title="75_数组"></a>75_数组</h2><ul>
<li>首先交换两个元素可以不用中间值，直接用<code>swap</code>函数；其次就是这题要把0都放在头部，2都放在尾部，要是与2交换的是0，还要再交换0这一步；要是还是2，要用<code>while</code>来操作；遍历到最后就不用交换2了，这里就要再加一个判断条件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void sortColors(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int l = 0, r = nums.size();</span><br><span class="line">        r--;</span><br><span class="line">        for(int i = 0; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            while (nums[i] == 2 &amp;&amp; i &lt; r)&#123;</span><br><span class="line">                swap(nums[i], nums[r]);</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">            if(nums[i] == 0)&#123;</span><br><span class="line">                swap(nums[i], nums[l]);</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; nums = &#123;1,0,2,1,1,0&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    solution.sortColors(nums);</span><br><span class="line">    for(const auto&amp; n : nums)&#123;</span><br><span class="line">        cout &lt;&lt; n;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="77-组合"><a href="#77-组合" class="headerlink" title="77_组合"></a>77_组合</h2><ul>
<li>从n个数选k个，不需要排列；总之要避免重复，每次进行循环时，都要从下一个<code>++l</code>开始</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#ifndef Solution_   //代码只编译一次</span><br><span class="line">#define Solution_</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;iterator&gt;     // std::ostream_iterator</span><br><span class="line">#include &lt;algorithm&gt;    // std::copy</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; tmp, int n, int k, int l)&#123;</span><br><span class="line">        if(tmp.size() == k)&#123;</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = l; i &lt;= n; i++)&#123;</span><br><span class="line">            tmp.push_back(i);</span><br><span class="line">            dfs(res, tmp, n, k, ++l);   //++l与l++不一样</span><br><span class="line">            tmp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        vector&lt;int&gt; tmp;</span><br><span class="line">        int l = 1;</span><br><span class="line">        dfs(res, tmp, n, k, l);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; res = solution.combine(4, 2);</span><br><span class="line">    for(const auto&amp; re : res)&#123;</span><br><span class="line">        //如果不加载包含库，copy()貌似只有字符类型</span><br><span class="line">        copy(re.begin(), re.end(), ostream_iterator&lt;int&gt;(cout));</span><br><span class="line">        cout &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<h2 id="78-子集"><a href="#78-子集" class="headerlink" title="78_子集"></a>78_子集</h2><ul>
<li>做个小结，39.组合总和 40.组合总和II 46.全排列 47.全排列II 78.子集 都是一种类型的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#ifndef Solution_</span><br><span class="line">#define Solution_</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;iterator&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void dfs(vector&lt;int&gt;&amp; nums, vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; tmp, int i, int n, int l)&#123;</span><br><span class="line">        if(i == 0)&#123;</span><br><span class="line">            res.emplace_back(); //放一个空的数组，不用push_back(&#123;&#125;)</span><br><span class="line">            return;</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">            if(tmp.size() == i)&#123;</span><br><span class="line">                res.push_back(tmp);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int j = l; j &lt; n; j++)&#123;</span><br><span class="line">                tmp.emplace_back(nums[j]);</span><br><span class="line">                dfs(nums, res, tmp, i, n, ++l);</span><br><span class="line">                tmp.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        vector&lt;int&gt; tmp;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        for(int i = 0; i &lt;= n; i++)&#123;</span><br><span class="line">            int l = 0;</span><br><span class="line">            dfs(nums, res, tmp, i, n, l);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; nums = &#123;1, 0&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; res = solution.subsets(nums);</span><br><span class="line">    for(const auto &amp; re : res)&#123;</span><br><span class="line">        copy(re.begin(), re.end(), ostream_iterator&lt;int&gt;(cout));</span><br><span class="line">        cout &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<h2 id="79-单词搜索"><a href="#79-单词搜索" class="headerlink" title="79_单词搜索"></a>79_单词搜索</h2><ul>
<li>深度优先搜索与回溯，题解与我自己写的思路一样，不过我的超出了时间限制，题解答案也有一千多毫秒</li>
<li>优化的地方小结下：主函数在双重循环下仅调用回溯函数即可，不需要再进行标记操作；标记操作放在回溯函数内；遍历四周上下左右时，可以定义个二维数组，加一或者减一，再对其遍历，之后再让索引限制在边界内；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#ifndef Solution_</span><br><span class="line">#define Solution_</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool check(vector&lt;vector&lt;char&gt;&gt;&amp; board, vector&lt;vector&lt;int&gt;&gt;&amp; visited, int i, int j, string&amp; s, int k) &#123;</span><br><span class="line">        if (board[i][j] != s[k]) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else if (k == s.length() - 1) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[i][j] = true;</span><br><span class="line">        vector&lt;pair&lt;int, int&gt;&gt; directions&#123;&#123;0, 1&#125;, &#123;0, -1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;&#125;;</span><br><span class="line">        bool result = false;</span><br><span class="line">        for (const auto&amp; dir: directions) &#123;</span><br><span class="line">            int newi = i + dir.first, newj = j + dir.second;</span><br><span class="line">            if (newi &gt;= 0 &amp;&amp; newi &lt; board.size() &amp;&amp; newj &gt;= 0 &amp;&amp; newj &lt; board[0].size()) &#123;</span><br><span class="line">                if (!visited[newi][newj]) &#123;</span><br><span class="line">                    bool flag = check(board, visited, newi, newj, s, k + 1);</span><br><span class="line">                    if (flag) &#123;</span><br><span class="line">                        result = true;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[i][j] = false;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123;</span><br><span class="line">        int h = board.size(), w = board[0].size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; visited(h, vector&lt;int&gt;(w));</span><br><span class="line">        for (int i = 0; i &lt; h; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; w; j++) &#123;</span><br><span class="line">                bool flag = check(board, visited, i, j, word, 0);</span><br><span class="line">                if (flag) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;vector&lt;char&gt;&gt; board = &#123;&#123;&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;&#125;,</span><br><span class="line">                                  &#123;&apos;S&apos;,&apos;F&apos;,&apos;E&apos;,&apos;S&apos;&#125;,</span><br><span class="line">                                  &#123;&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;&#125;&#125;;</span><br><span class="line">    string word = &quot;ABCESEEEFS&quot;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.exist(board, word) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<h2 id="80-删除排序数组中的重复项-II"><a href="#80-删除排序数组中的重复项-II" class="headerlink" title="80_删除排序数组中的重复项_II"></a>80_删除排序数组中的重复项_II</h2><ul>
<li>百思不得其解，观摩下神仙写法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#ifndef Solution_</span><br><span class="line">#define Solution_</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;iterator&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int i = 0;</span><br><span class="line">        for(const auto &amp; n : nums)&#123;</span><br><span class="line">            if(i &lt; 2 || n &gt; nums[i - 2]) nums[i++] = n;</span><br><span class="line">        &#125;</span><br><span class="line">        return i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; nums = &#123;0,0,1,1,2,3,3&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.removeDuplicates(nums) &lt;&lt; endl;</span><br><span class="line">    copy(nums.begin(), nums.end(), ostream_iterator&lt;int&gt;(cout));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<h2 id="81-搜索旋转排序数组-II"><a href="#81-搜索旋转排序数组-II" class="headerlink" title="81_搜索旋转排序数组_II"></a>81_搜索旋转排序数组_II</h2><ul>
<li>与I相比，当出现中间指针与左右两边中的一个相等时，会无法判断<code>target</code>在哪个区间；看了题解，真的是一语惊醒梦中人：出现相等的情况，将左指针加一即可！</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool search(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int l = 0, r = nums.size();</span><br><span class="line">        r--;</span><br><span class="line">        while (l &lt;= r)&#123;  //需要包含相等的情况，有可能这个才是目标值</span><br><span class="line">            int mid = (l + r) / 2;</span><br><span class="line">            if(nums[mid] == target)&#123;return true;&#125;</span><br><span class="line"></span><br><span class="line">            if(nums[l] &lt; nums[mid])&#123;</span><br><span class="line">                if(target &gt;= nums[l] &amp;&amp; target &lt; nums[mid])&#123;</span><br><span class="line">//                    cout &lt;&lt; &quot;---&quot; &lt;&lt; endl;</span><br><span class="line">                    r = mid - 1;</span><br><span class="line">                &#125; else&#123;</span><br><span class="line">                    l = mid + 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if(nums[l] &gt; nums[mid])&#123;</span><br><span class="line">                if(target &gt; nums[mid] &amp;&amp; target &lt;= nums[r])&#123;</span><br><span class="line">                    l = mid + 1;</span><br><span class="line">                &#125; else&#123;</span><br><span class="line">                    r = mid - 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                l++;    //去除一个重复干扰项</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; nums = &#123;1,0,1,1,1&#125;;</span><br><span class="line">    int target = 0;</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.search(nums, target) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84_柱状图中最大的矩形"></a>84_柱状图中最大的矩形</h2><ul>
<li>第一次超出时间限制了，做了优化：对于相同的数字，其面积是一样的；因此遍历的时候应该跳过之前计算过的值！不对，只有当这个数字是最小时，才一样；否则有的一样有的不一样；先把相邻的跳过康康能不能通过————居然通过了！</li>
<li>题解有个枚举矩形左右边界的解法，思路很简单，双重循环，但是超出时间限制了0.0；学习下其他方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//共有三个方法</span><br><span class="line"></span><br><span class="line">//正常思路，每遍历一个柱子，都向两边延申、计算面积；保留值更大的那个</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int area(vector&lt;int&gt;&amp; heights, int i, int n)&#123;</span><br><span class="line">        int area_i = heights[i], tmp_i = i;</span><br><span class="line">        while (++tmp_i &lt; n)&#123;</span><br><span class="line">            if(heights[i] &lt;= heights[tmp_i])&#123;</span><br><span class="line">                area_i += heights[i];</span><br><span class="line">            &#125; else&#123;break;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp_i = i;</span><br><span class="line">        while (--tmp_i &gt;= 0)&#123;</span><br><span class="line">            if(heights[i] &lt;= heights[tmp_i])&#123;</span><br><span class="line">                area_i += heights[i];</span><br><span class="line">            &#125; else&#123;break;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return area_i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123;</span><br><span class="line">        int res = 0, n = heights.size();</span><br><span class="line">        for(int i = 0; i &lt; n; ++i)&#123;</span><br><span class="line">            if(i &gt; 0 &amp;&amp; heights[i] == heights[i - 1])&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            int tmp = area(heights, i, n);</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; &quot; -- &quot; &lt;&lt; tmp &lt;&lt; endl;</span><br><span class="line">            if(res &lt; tmp)&#123;</span><br><span class="line">                res = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    //枚举矩形的边界</span><br><span class="line">    /*int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123;</span><br><span class="line">        int n = heights.size();</span><br><span class="line">        int ans = 0;</span><br><span class="line">        // 枚举左边界</span><br><span class="line">        for (int left = 0; left &lt; n; ++left) &#123;</span><br><span class="line">            int minHeight = INT_MAX;</span><br><span class="line">            // 枚举右边界</span><br><span class="line">            for (int right = left; right &lt; n; ++right) &#123;</span><br><span class="line">                // 确定高度</span><br><span class="line">                minHeight = min(minHeight, heights[right]);</span><br><span class="line">                // 计算面积</span><br><span class="line">                ans = max(ans, (right - left + 1) * minHeight);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;*/</span><br><span class="line">&#125;;</span><br><span class="line">//单调栈解法</span><br><span class="line">class Solution1 &#123;</span><br><span class="line">public:</span><br><span class="line">    int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123;</span><br><span class="line">        int n = heights.size();</span><br><span class="line">        vector&lt;int&gt; left(n), right(n);</span><br><span class="line"></span><br><span class="line">        stack&lt;int&gt; mono_stack;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            while (!mono_stack.empty() &amp;&amp; heights[mono_stack.top()] &gt;= heights[i]) &#123;</span><br><span class="line">                mono_stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            left[i] = (mono_stack.empty() ? -1 : mono_stack.top());</span><br><span class="line">            mono_stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mono_stack = stack&lt;int&gt;();</span><br><span class="line">        for (int i = n - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">            while (!mono_stack.empty() &amp;&amp; heights[mono_stack.top()] &gt;= heights[i]) &#123;</span><br><span class="line">                mono_stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            right[i] = (mono_stack.empty() ? n : mono_stack.top());</span><br><span class="line">            mono_stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int ans = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            ans = max(ans, (right[i] - left[i] - 1) * heights[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; heights&#123;4,2,0,3,2,5&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.largestRectangleArea(heights) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="85-最大矩形"><a href="#85-最大矩形" class="headerlink" title="85_最大矩形"></a>85_最大矩形</h2><ul>
<li>先写个思路：应该找矩形对角线的两端，尝试枚举两端法？</li>
<li>这个思路写完了，左上端是对原二维数组进行遍历，遇到1就调用函数计算出最大的面积；重点在调用函数：是对<font color="#FF0000">左上端所在的行列</font>为起点、向右下形成的部分二维数组进行遍历，遇到0(那么这个0所在列就是下次循环的边界条件)-面积计算方法就是长×宽；再<code>break;</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    //找出一端确定时，另一端所有位置的最大面积</span><br><span class="line">    int area(vector&lt;vector&lt;char&gt;&gt;&amp; matrix, int row, int col)&#123;</span><br><span class="line">        int ans = 0, j_tmp = matrix[0].size();</span><br><span class="line">        for(int i = row; i &lt; matrix.size(); ++i)&#123;</span><br><span class="line">            if(matrix[i][col] == 0)&#123;</span><br><span class="line">                ans = max(ans, i - row + 1);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            for(int j = col; j &lt; j_tmp; ++j)&#123;</span><br><span class="line">                int tmp = (i - row + 1) * (j - col + 1);</span><br><span class="line">                if(matrix[i][j] == &apos;0&apos;)&#123;</span><br><span class="line">                    tmp -= (i - row + 1);</span><br><span class="line">                    ans = max(ans, tmp);</span><br><span class="line">                    j_tmp = j;</span><br><span class="line">                    break;</span><br><span class="line">                &#125; else if(j + 1 == j_tmp &amp;&amp; matrix[i][j] == &apos;1&apos;)&#123;</span><br><span class="line">                    ans = max(ans, tmp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int maximalRectangle(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        for(int i = 0; i &lt; matrix.size(); ++i)&#123;</span><br><span class="line">            for(int j = 0; j &lt; matrix[0].size(); ++j)&#123;</span><br><span class="line">                if(matrix[i][j] == &apos;1&apos;)&#123;</span><br><span class="line">                    res = max(res, area(matrix, i, j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;vector&lt;char&gt;&gt; matrix&#123;&#123;&apos;0&apos;,&apos;0&apos;,&apos;0&apos;&#125;,</span><br><span class="line">                                &#123;&apos;0&apos;,&apos;0&apos;,&apos;0&apos;&#125;,</span><br><span class="line">                                &#123;&apos;1&apos;,&apos;1&apos;,&apos;1&apos;&#125;&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.maximalRectangle(matrix) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88_合并两个有序数组"></a>88_合并两个有序数组</h2><ul>
<li>这题是在<code>nums1</code>后默认加了几个0；先把这几个0变成<code>nums2</code>的元素；最后排序</li>
<li>以后排序还是用双指针好点</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">    void merge(vector&lt;int&gt; &amp;nums1, int n, vector&lt;int&gt; &amp;nums2, int m)&#123;</span><br><span class="line">        int ptr = n + m - 1, p1 = n - 1, p2 = m - 1;</span><br><span class="line">        while (p1 != ptr)&#123;</span><br><span class="line">            if(p1 &gt;= 0 &amp;&amp; nums1[p1] &gt; nums2[p2])</span><br><span class="line">                nums1[ptr--] = nums1[p1--];</span><br><span class="line">            else</span><br><span class="line">                nums1[ptr--] = nums2[p2--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; nums1&#123;1, 2, 5, 0, 0, 0&#125;, nums2&#123;2, 3, 4&#125;;</span><br><span class="line">    int n = 3, m = 3;</span><br><span class="line">    Solution solution;</span><br><span class="line">    solution.merge(nums1, n, nums2, m);</span><br><span class="line">    for(const auto &amp;num : nums1)</span><br><span class="line">        cout &lt;&lt; num;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="89-格雷编码"><a href="#89-格雷编码" class="headerlink" title="89_格雷编码"></a>89_格雷编码</h2><ul>
<li>可以看出有对称性，这种对称性是以翻倍的形式存在；^是异或运算符，求幂用<code>cmath</code>里的<code>pow(x,y)</code>；下面暂时用^，好理解点</li>
<li>n = 0时{0}；n = 1时{0,2^0+0}</li>
<li>n = 1时{0,1}；n = 2时{0,1,2^1+1,2^1+0}</li>
<li>n = k时是对n = k -1的数组进行处理，后一半的数字恰好是前一半倒序的数字与2的n-1次幂之和</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void doubled(vector&lt;int&gt; &amp;res, int n)&#123;</span><br><span class="line">        if(n == 0)&#123;</span><br><span class="line">            res.emplace_back(0);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        doubled(res, --n);  //先对n减一，再递归，返回后n是减一的状态</span><br><span class="line">        int i = res.size();</span><br><span class="line">        while (i &gt; 0)&#123;  //^是异或运算符</span><br><span class="line">            res.emplace_back(res[--i] + pow(2, n));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; grayCode(int n) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        doubled(res, n);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    Solution solution;</span><br><span class="line">    int n = 4;</span><br><span class="line">    vector&lt;int&gt; res = solution.grayCode(n);</span><br><span class="line">    for(const auto &amp;r : res)</span><br><span class="line">        cout &lt;&lt; r &lt;&lt; &quot; &quot;;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="90-子集-II"><a href="#90-子集-II" class="headerlink" title="90_子集_II"></a>90_子集_II</h2><ul>
<li>这题与之前的递归有点不太一样；首先一个重点：因为是排列，所以每次递归循环都要从<code>i+1</code>开始，而不是最初的值+1（<code>int start</code>-&gt;<code>start + 1</code>）；就拿第一次循环循环来说从<code>i=0</code>开始递归，之后<code>i=1</code>时<code>start</code>还是0，<code>start + 1</code>为参数传递的话，<code>nums[i]</code>就会重复两次</li>
<li>因为是重复数字，所有要将相同的数字跳过√</li>
<li>这题没有递归出口，一上来就将<code>tmp</code>放入<code>res</code>中</li>
<li>最后别忘了先排个序</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void dfs(vector&lt;vector&lt;int&gt;&gt; &amp;res, vector&lt;int&gt; &amp;tmp, vector&lt;int&gt;&amp; nums, int start)&#123;</span><br><span class="line">        //一开始递归就将tmp放入res</span><br><span class="line">        cout &lt;&lt; &quot;tmp = &quot; ;</span><br><span class="line">        for(const auto &amp;t : tmp)</span><br><span class="line">            cout &lt;&lt; t &lt;&lt; &quot; &quot;;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        res.emplace_back(tmp);</span><br><span class="line">        for(int i = start; i &lt; nums.size(); ++i)&#123;</span><br><span class="line">            cout &lt;&lt; &quot;start = &quot; &lt;&lt; start &lt;&lt; &quot;, i = &quot; &lt;&lt; i &lt;&lt; &quot;, nums[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot; &lt;&lt; nums[i] &lt;&lt; endl;</span><br><span class="line">            if(i &gt; start  &amp;&amp; nums[i] ==nums[i - 1])&#123;</span><br><span class="line">                cout &lt;&lt; &quot;nums[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot; &lt;&lt; nums[i] &lt;&lt; &quot; == &quot; &lt;&lt; &quot;nums[&quot; &lt;&lt; i - 1 &lt;&lt; &quot;] = &quot; &lt;&lt; nums[i - 1] &lt;&lt; endl;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp.emplace_back(nums[i]);</span><br><span class="line">            dfs(res, tmp, nums, i + 1);//不是start+1而是i+1！！</span><br><span class="line">            tmp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        vector&lt;int&gt; tmp;</span><br><span class="line">        //这次回溯无需循环，直接调用函数</span><br><span class="line">        dfs(res, tmp, nums, 0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; nums&#123;1, 2, 2&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; res = solution.subsetsWithDup(nums);</span><br><span class="line">    for(const auto &amp;re : res)&#123;</span><br><span class="line">        for(const auto &amp;r : re)</span><br><span class="line">            cout &lt;&lt; r &lt;&lt; &quot; &quot;;</span><br><span class="line">        cout &lt;&lt; &quot;, &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="93-复原IP地址"><a href="#93-复原IP地址" class="headerlink" title="93_复原IP地址"></a>93_复原IP地址</h2><ul>
<li>这题做起来有点心累，但是执行用时和内存消耗还是十分令人愉悦的；</li>
<li>第一步，限制传入的字符串<code>s</code>的长度，确保肯定能分成四段</li>
<li>第二步，用递归，第一段的地址可能是1位2位3位数字，后面递归用剩下来的字符串</li>
<li>第三步，要判断数字是否有效，单独写了个函数，确保数字字符串在<code>&quot;0&quot;-&quot;255&quot;</code>之间，且不能有前导0</li>
<li>第四步，就是递归的出口了，判断数字有效后要插入<code>.</code>，我用了<code>.</code>的个数来判断，如果<code>.</code>的个数有了3个，那么只需判断剩下的字符是否有效，有效就让<code>tmp</code>加上这一段字符串放入答案中，无论是否有效都会返回；</li>
<li>第五步，返回之后，<code>tmp</code>应该弹出上一个点之后的地址，而不是全部删除，之后在循环里会以2个数字判断是否有效，并继续放入<code>tmp</code></li>
<li>我傻了，字符串可以直接比较大小，去除前导零的情况即可；还有<code>s.substr(index, i)</code>index是可以指向尾部元素的后一个位置的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool effective(string s)&#123;</span><br><span class="line">        if(s.size() == 1)</span><br><span class="line">            return true;</span><br><span class="line">        if(s.size() == 2)&#123;</span><br><span class="line">            if(s[0] != &apos;0&apos;)</span><br><span class="line">                return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if(s.size() == 3)&#123;</span><br><span class="line">            if(s[0] == &apos;1&apos;)</span><br><span class="line">                return true;</span><br><span class="line">            if(s[0] == &apos;2&apos;)&#123;</span><br><span class="line">                if(s[1] &gt;= &apos;0&apos; &amp;&amp; s[1] &lt;= &apos;4&apos;)</span><br><span class="line">                    return true;</span><br><span class="line">                if(s[1] == &apos;5&apos; &amp;&amp; s[2] &lt;= &apos;5&apos;)</span><br><span class="line">                    return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void dfs(vector&lt;string&gt; &amp;res, string tmp, string s, int n)&#123;</span><br><span class="line">//        cout &lt;&lt; &quot;tmp = &quot; &lt;&lt; tmp &lt;&lt; &quot; s = &quot; &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">        if(!tmp.empty() &amp;&amp; !s.empty())&#123;</span><br><span class="line">            tmp.push_back(&apos;.&apos;);</span><br><span class="line">            ++n;</span><br><span class="line">//            cout &lt;&lt; &quot;n = &quot; &lt;&lt; n &lt;&lt; &quot;  &quot; &lt;&lt; tmp &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        if(n == 3)&#123;</span><br><span class="line">            if(effective(s))</span><br><span class="line">                res.emplace_back(tmp += s);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int l = s.size();</span><br><span class="line">        for(int i = 0; i &lt; min(3, l); ++i)&#123;</span><br><span class="line">//            cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">            if(effective(s.substr(0, i + 1)))&#123;</span><br><span class="line">//                tmp += s.substr(0, i + 1);</span><br><span class="line">                string s_tmp = tmp + s.substr(0, i + 1);</span><br><span class="line">                string s1 = (s.size() - i - 1 == 0 ? &quot;&quot; : s.substr(i + 1, s.size() - i - 1));</span><br><span class="line">                dfs(res, s_tmp, s1, n);</span><br><span class="line">//                tmp.clear();    //不能全部删除，只能删除一段！</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;string&gt; restoreIpAddresses(string s) &#123;</span><br><span class="line">        //首先字符串本身有着长度要求</span><br><span class="line">        if(s.size() &lt; 4 || s.size() &gt; 12) return &#123;&#125;;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        //其次将s分成4段，每段中的数字只能是0-255；数字不能以0开头除了0本身</span><br><span class="line">        string tmp; //用于存放每段对应的数字</span><br><span class="line">        dfs(res, tmp, s, 0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    string s(&quot;25525511135&quot;);</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;string&gt; res = solution.restoreIpAddresses(s);</span><br><span class="line">    for(const auto &amp;r : res)</span><br><span class="line">        cout &lt;&lt; r &lt;&lt; &quot;   &quot;;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="118-杨辉三角"><a href="#118-杨辉三角" class="headerlink" title="118_杨辉三角"></a>118_杨辉三角</h2><ul>
<li>这题我看看题解有没有更好的方法，啊对，可以直接用公式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; generate(int numRows) &#123;</span><br><span class="line">        if(numRows == 0) return &#123;&#125;;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        for(int i = 1; i &lt;= numRows; ++i)&#123;</span><br><span class="line">            if(i == 1)</span><br><span class="line">                res.push_back(&#123;1&#125;);</span><br><span class="line">            else if(i == 2)</span><br><span class="line">                res.push_back(&#123;1, 1&#125;);</span><br><span class="line">            else&#123;</span><br><span class="line">                vector&lt;int&gt; tmp = &#123;1&#125;;</span><br><span class="line">                for(int j = 1; j &lt; res.back().size(); ++j)&#123;</span><br><span class="line">                    tmp.push_back(res.back()[j] + res.back()[j - 1]);</span><br><span class="line">                &#125;</span><br><span class="line">                tmp.push_back(1);</span><br><span class="line">                res.push_back(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; res = solution.generate(5);</span><br><span class="line">    for(const auto &amp; re : res) &#123;</span><br><span class="line">        for (const auto &amp;r : re)</span><br><span class="line">            cout &lt;&lt; r &lt;&lt; &quot; &quot;;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="119-杨辉三角-II"><a href="#119-杨辉三角-II" class="headerlink" title="119_杨辉三角_II"></a>119_杨辉三角_II</h2><ul>
<li>emmmm，学习下滚动数组的思想，每一行只用了上一行的值；注意从第0行开始</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; getRow(int rowIndex) &#123;</span><br><span class="line">        if(rowIndex == 0) return &#123;1&#125;;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        for(int i = 0; i &lt;= rowIndex; ++i)&#123;</span><br><span class="line">            if(i == 0)</span><br><span class="line">                res.push_back(&#123;1&#125;);</span><br><span class="line">            else if(i == 1)</span><br><span class="line">                res.push_back(&#123;1, 1&#125;);</span><br><span class="line">            else&#123;</span><br><span class="line">                vector&lt;int&gt; tmp = &#123;1&#125;;</span><br><span class="line">                for(int j = 1; j &lt; res.back().size(); ++j)&#123;</span><br><span class="line">                    tmp.push_back(res.back()[j] + res.back()[j - 1]);</span><br><span class="line">                &#125;</span><br><span class="line">                tmp.push_back(1);</span><br><span class="line">                res.push_back(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;int&gt; tmp = solution.getRow(5);</span><br><span class="line">    for (const auto &amp;r : tmp)</span><br><span class="line">        cout &lt;&lt; r &lt;&lt; &quot; &quot;;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="120-三角形最小路径和"><a href="#120-三角形最小路径和" class="headerlink" title="120_三角形最小路径和"></a>120_三角形最小路径和</h2><ul>
<li>仔细思考后发现，需要考虑相同数字的情况；用动态规划康康</li>
<li>注意几个细节；首先可以直接调用<code>*min_element(f[n - 1].begin(), f[n - 1].end())</code>来获取最后一行的最小值，这样写的好处是即使只有一行，也能正确返回，所以大循环直接从<code>i = 1</code>开始；还有次循环可以直接写成<code>j = 1; j &lt; i</code>；</li>
<li>收藏下一位大佬写的代码！</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) &#123;</span><br><span class="line">        if(triangle.empty()) return 0;</span><br><span class="line">        if(triangle.size() == 1) return triangle[0][0];</span><br><span class="line">        int ans = INT32_MAX;</span><br><span class="line">        int r = triangle.size(), c = triangle.back().size();//行，列</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(r, vector&lt;int&gt;(c, 0));</span><br><span class="line">        for(int i = 0; i &lt; r; ++i)&#123;</span><br><span class="line">            if(i == 0)&#123;</span><br><span class="line">                dp[0][0] = triangle[0][0];</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int j = 0; j &lt; triangle[i].size(); ++j)&#123;</span><br><span class="line">                if(j == 0)</span><br><span class="line">                    dp[i][j] = dp[i - 1][j] + triangle[i][j];</span><br><span class="line">                else if(j + 1 &lt; triangle[i].size())</span><br><span class="line">                    dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - 1]) +  triangle[i][j];</span><br><span class="line">                else</span><br><span class="line">                    dp[i][j] = dp[i - 1][j - 1] + triangle[i][j];</span><br><span class="line"></span><br><span class="line">                if(i + 1 == r)</span><br><span class="line">                    ans = min(ans, dp[i][j]);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//大佬写的，由下至上，只用了一个数组来维护</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) &#123;</span><br><span class="line">        vector&lt;int&gt; dp(triangle.back());</span><br><span class="line">        for(int i = triangle.size() - 2; i &gt;= 0; i --)</span><br><span class="line">            for(int j = 0; j &lt;= i; j ++)</span><br><span class="line">                dp[j] = min(dp[j], dp[j + 1]) + triangle[i][j];</span><br><span class="line">        return dp[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121_买卖股票的最佳时机"></a>121_买卖股票的最佳时机</h2><ul>
<li>这题有点意思，二维动态规划数组和双重循环暴力求解没区别，都会超出时间限制；用动态规划是肯定的，关键在于如何降维数组</li>
<li>时间有限，就直接在网站上手撕了……</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        vector&lt;int&gt; dp(prices.size(), 0);</span><br><span class="line">        int tmp = prices[0];</span><br><span class="line">        for(int i = 1; i &lt; prices.size(); ++i)&#123;</span><br><span class="line">            if(prices[i] &lt;= tmp)&#123;</span><br><span class="line">                dp[i] = dp[i - 1];</span><br><span class="line">                tmp = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                dp[i] = max(dp[i - 1], prices[i] - tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        return dp.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="122-买卖股票的最佳时机-ll"><a href="#122-买卖股票的最佳时机-ll" class="headerlink" title="122_买卖股票的最佳时机_ll"></a>122_买卖股票的最佳时机_ll</h2><ul>
<li>同样是动态规划，自己写的不够简洁；官方题解确实跑得快</li>
<li>贪心算法是将所有上坡的利润都加起来…我写的动态规划好像就是贪心…..</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        int n = prices.size();</span><br><span class="line">        if(n &lt;= 1) return 0;</span><br><span class="line">        int tmp = prices[0];</span><br><span class="line">        vector&lt;int&gt; dp(n, 0);</span><br><span class="line">        for(int i = 1; i &lt; n; ++i)&#123;</span><br><span class="line">            if(prices[i] &lt;= tmp)&#123;</span><br><span class="line">                dp[i] = dp[i - 1];</span><br><span class="line">                tmp = prices[i]; //更新历史最低价</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                if(i + 1 &lt; n &amp;&amp; prices[i] &gt; prices[i + 1])&#123;</span><br><span class="line">                    dp[i] = prices[i] - tmp + dp[i - 1];    //卖出</span><br><span class="line">                    tmp = prices[i + 1]; //更新历史最低价为卖出第二天的价格</span><br><span class="line">                &#125;else if(i + 1 &lt; n)&#123;</span><br><span class="line">                    //不卖</span><br><span class="line">                    dp[i] = dp[i - 1];</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    dp[i] = prices[i] - tmp + dp[i - 1];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="123-买卖股票的最佳时机-III"><a href="#123-买卖股票的最佳时机-III" class="headerlink" title="123_买卖股票的最佳时机_III"></a>123_买卖股票的最佳时机_III</h2><ul>
<li>这题的动态规划没想出来，用了暴力求解，但超出时间限制了；对于动态规划，首先要了解所有的状态有哪些，再去了解之间的转移关系</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices)&#123;</span><br><span class="line">        int n = prices.size();</span><br><span class="line">        if(n &lt;= 1) return 0;</span><br><span class="line">        int buy1 = -prices[0], sell1 = 0, buy2 = -prices[0], sell2 = 0;</span><br><span class="line">        for(int i = 1; i &lt; n; ++i)&#123;</span><br><span class="line">            buy1 = max(buy1, -prices[i]);</span><br><span class="line">            sell1 = max(sell1, buy1 + prices[i]);</span><br><span class="line">            buy2 = max(buy2, sell1 - prices[i]);</span><br><span class="line">            sell2 = max(sell2, buy2 + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return sell2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; prices = &#123;1,2,4,2,5,7,2,4,9,0&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.maxProfit(prices) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128_最长连续序列"></a>128_最长连续序列</h2><ul>
<li>这题先排序，再去重，然后双指针，不过时间复杂度超过了<code>O(n)</code>了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if(nums.size() &lt;= 1) return nums.size();</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        vector&lt;int&gt; num;</span><br><span class="line">        for(const auto &amp;nu : nums)&#123;</span><br><span class="line">            if(num.empty() || nu != num.back())</span><br><span class="line">                num.emplace_back(nu);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int ans = 1, l = 0, r = l + 1;</span><br><span class="line">        while (r &lt; num.size())&#123;</span><br><span class="line">            if(num[r] == num[r - 1] + 1)&#123;</span><br><span class="line">                if(r + 1 == num.size())</span><br><span class="line">                    ans = max(ans, r - l + 1);</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                ans = max(ans, r - l);</span><br><span class="line">                l = r;</span><br><span class="line">            &#125;</span><br><span class="line">            ++r;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; nums = &#123;1,2,0,1&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.longestConsecutive(nums) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="130-被围绕的区域"><a href="#130-被围绕的区域" class="headerlink" title="130_被围绕的区域"></a>130_被围绕的区域</h2><ul>
<li>得先找出所有与边上的<code>O</code>相连的区域，然后再将其余区域都用<code>X</code>代替？</li>
<li>标记的时候不能一行一行来，因为上一行要依赖下一行的信息；只能暴力了，依次对边上的<code>O</code>作标记，还要对其上下左右也标记，一直到没有<code>O</code>为止</li>
<li>从边界开始DFS；官方题解就是简洁，上下左右只需要或运算判断符就好了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void mark(vector&lt;vector&lt;char&gt;&gt;&amp; board, vector&lt;vector&lt;int&gt;&gt; &amp;tmp, int i, int j)&#123;</span><br><span class="line">        if(board[i][j] == &apos;X&apos;) return;</span><br><span class="line">        //cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; &quot; j = &quot; &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">        tmp[i][j] = 1;</span><br><span class="line">        int up = i - 1 == -1 ? 0 : i - 1;</span><br><span class="line">        int down = i + 1 == tmp.size() ? i : i + 1;</span><br><span class="line">        int left = j - 1 == -1 ? 0 : j - 1;</span><br><span class="line">        int right = j + 1 == tmp[0].size() ? j : j + 1;</span><br><span class="line">        if(board[up][j] == &apos;O&apos; &amp;&amp; tmp[up][j] == 0)</span><br><span class="line">            mark(board, tmp, up, j);</span><br><span class="line">        if(board[down][j] == &apos;O&apos; &amp;&amp; tmp[down][j] == 0)</span><br><span class="line">            mark(board, tmp, down, j);</span><br><span class="line">        if(board[i][left] == &apos;O&apos; &amp;&amp; tmp[i][left] == 0)</span><br><span class="line">            mark(board, tmp, i, left);</span><br><span class="line">        if(board[i][right] == &apos;O&apos; &amp;&amp; tmp[i][right] == 0)</span><br><span class="line">            mark(board, tmp, i, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;</span><br><span class="line">        if(board.empty()) return;</span><br><span class="line">        int row = board.size(), col = board[0].size();</span><br><span class="line">        if(row &lt; 3 || col &lt; 3) return;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; tmp(row, vector&lt;int&gt;(col, 0));</span><br><span class="line">        //每个边界点做标记</span><br><span class="line">        int t_tmp = 0;</span><br><span class="line">        while (t_tmp &lt; col)&#123;</span><br><span class="line">            mark(board,tmp, 0, t_tmp);</span><br><span class="line">            mark(board,tmp, row - 1, t_tmp);</span><br><span class="line">            ++t_tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        t_tmp = 0;</span><br><span class="line">        while (t_tmp  &lt; row)&#123;</span><br><span class="line">            mark(board,tmp, t_tmp, 0);</span><br><span class="line">            mark(board,tmp, t_tmp, col - 1);</span><br><span class="line">            ++t_tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 1; i &lt; row - 1; ++i)&#123;</span><br><span class="line">            for(int j = 1; j &lt; col - 1; ++j)&#123;</span><br><span class="line">                if(board[i][j] == &apos;O&apos; &amp;&amp; tmp[i][j] == 0)</span><br><span class="line">                    board[i][j] = &apos;X&apos;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;vector&lt;char&gt;&gt; board(&#123;&#123;&apos;O&apos;,&apos;X&apos;,&apos;X&apos;,&apos;O&apos;,&apos;X&apos;&#125;,</span><br><span class="line">                                  &#123;&apos;X&apos;,&apos;O&apos;,&apos;O&apos;,&apos;X&apos;,&apos;O&apos;&#125;,</span><br><span class="line">                                  &#123;&apos;X&apos;,&apos;O&apos;,&apos;X&apos;,&apos;O&apos;,&apos;X&apos;&#125;,</span><br><span class="line">                                  &#123;&apos;O&apos;,&apos;X&apos;,&apos;O&apos;,&apos;O&apos;,&apos;O&apos;&#125;,</span><br><span class="line">                                  &#123;&apos;X&apos;,&apos;X&apos;,&apos;O&apos;,&apos;X&apos;,&apos;O&apos;&#125;&#125;);</span><br><span class="line">    cout &lt;&lt; &quot;board = &quot; &lt;&lt; endl;</span><br><span class="line">    for(const auto &amp;bo : board)&#123;</span><br><span class="line">        for(const auto &amp;b : bo)</span><br><span class="line">            cout &lt;&lt; b &lt;&lt; &quot; &quot;;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Solution solution;</span><br><span class="line">    solution.solve(board);</span><br><span class="line">    cout &lt;&lt; &quot;res = &quot; &lt;&lt; endl;</span><br><span class="line">    for(const auto &amp;bo : board)&#123;</span><br><span class="line">        for(const auto &amp;b : bo)</span><br><span class="line">            cout &lt;&lt; b &lt;&lt; &quot; &quot;;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131_分割回文串"></a>131_分割回文串</h2><ul>
<li>首先每个字符本身就是个回文字符串，然后…这题思路有点乱</li>
<li>思路不清晰的时候，感觉无从下手，又或者就差临门一脚，好在山重水复疑无路，休息一会后思路又清晰了</li>
<li>每次递归从第一个字符开始切，判断左边是否是回文串，如果是，就将右边字符串放入形参递归，不是就从第二个字符开始切，这样会一直切到最后一个字符；<code>tmp</code>每次递归回来后要弹出一个<code>string</code></li>
<li>我用的是递归加回溯</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isPalindrome(string &amp;hs)&#123;</span><br><span class="line">        if(hs.size() &lt;= 1) return true;</span><br><span class="line">        string s(hs);</span><br><span class="line">        reverse(s.begin(), s.end());</span><br><span class="line">        return s == hs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void dfs(string &amp;s)&#123;</span><br><span class="line">        if(s.empty())&#123;</span><br><span class="line">            ans.emplace_back(tmp);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 1; i &lt;= s.size(); ++i)&#123;</span><br><span class="line">            string lhs(s.begin(), s.begin() + i);</span><br><span class="line">            if(isPalindrome(lhs))&#123;</span><br><span class="line">                string rhs(s.begin() + i, s.end());</span><br><span class="line">                tmp.emplace_back(lhs);</span><br><span class="line">                dfs(rhs);</span><br><span class="line">                tmp.pop_back();</span><br><span class="line">            &#125; else</span><br><span class="line">                continue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123;</span><br><span class="line">        dfs(s);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line">    vector&lt;string&gt; tmp;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    string s = &quot;aabb&quot;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; ans = solution.partition(s);</span><br><span class="line">    for(const auto &amp;an : ans)&#123;</span><br><span class="line">        for(const auto &amp;a : an)</span><br><span class="line">            cout &lt;&lt; a &lt;&lt; &quot; &quot;;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="134-加油站"><a href="#134-加油站" class="headerlink" title="134_加油站"></a>134_加油站</h2><ul>
<li>首先总油量要大于消耗，但大于等于就一定可以走完一圈吗</li>
<li>遇事不决，暴力求解；雾草，，，居然过了，赶紧看看题解有没有好的方法</li>
<li>题解优化了代码，题解牛批，我还是粘贴自己写的烂代码吧</li>
<li><code>int j = (i + cnt) % n;</code>这个代码可以省去一次<code>for</code>循环</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;iterator&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool yep(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost, int p)&#123;</span><br><span class="line">        int n = gas.size();</span><br><span class="line">        int res = 0;</span><br><span class="line">        for(int i = p; i &lt; n; ++i)&#123;</span><br><span class="line">            res = res + gas[i] - cost[i];</span><br><span class="line">            if(res &lt; 0)</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; p; ++i)&#123;</span><br><span class="line">            res = res + gas[i] - cost[i];</span><br><span class="line">            if(res &lt; 0)</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123;</span><br><span class="line">       //所有加油站都遍历一遍，当作起点</span><br><span class="line">        int ans = -1;</span><br><span class="line">        for(int i = 0; i &lt; gas.size(); ++i)&#123;</span><br><span class="line">            if(gas[i] &gt;= cost[i])&#123;</span><br><span class="line">                if(yep(gas, cost, i))&#123;</span><br><span class="line">                    ans = i;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; gas(&#123;1,2,3,4,5&#125;), cost(&#123;3,4,5,1,2&#125;);</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.canCompleteCircuit(gas, cost) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="135-分发糖果"><a href="#135-分发糖果" class="headerlink" title="135_分发糖果"></a>135_分发糖果</h2><ul>
<li>高评分的孩子的糖果是由两边低评分的孩子共同决定的，举个例子，[2,3]，第二个孩子评分比第一个高，那么糖果肯定比第一个多，至于多几个则要看后面有多少比他评分低的孩子；如果后面一个孩子评分高，那就只能多一颗糖果；以此类推…</li>
<li>同理，[3,3]，评分一样，那么第二个孩子的糖果数与前者无关，只与后面有关，如果后面没有人，那一颗足以</li>
<li>关键是要找到一个低谷；感觉用单调栈好一点</li>
<li>栈我不会，，，又是一道心力憔悴的一题…终于做出来是有多么喜悦！！！找波峰或者波谷太麻烦，考虑的因素太多，直接顺着和反着各遍历一次</li>
<li>就是反向遍历的时候要考虑波峰这个位置，要看左右两边哪个大</li>
<li>按照惯例，官方题解也跑一下…</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;numeric&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int candy(vector&lt;int&gt;&amp; ratings) &#123;</span><br><span class="line">        if(ratings.empty()) return 0;</span><br><span class="line">        if(ratings.size() == 1) return 1;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        //关键找到谷峰、谷底</span><br><span class="line">        vector&lt;int&gt; tmp(ratings.size(), 1);</span><br><span class="line">        int i = 1;</span><br><span class="line"></span><br><span class="line">        while (i &lt; ratings.size())&#123;</span><br><span class="line">            if(ratings[i] &gt; ratings[i - 1])</span><br><span class="line">                tmp[i] += tmp[i - 1];</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        --i;</span><br><span class="line">        while (i &gt; 0)&#123;</span><br><span class="line">            if(ratings[i - 1] &gt; ratings[i])&#123;</span><br><span class="line">                if(i - 2 &gt;= 0 &amp;&amp; ratings[i - 1] &gt; ratings[i - 2])&#123;</span><br><span class="line">                    tmp[i - 1] = max(tmp[i - 2], tmp[i]) + 1;</span><br><span class="line">                &#125; else&#123;</span><br><span class="line">                    tmp[i - 1] += tmp[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            --i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(const auto &amp;t : tmp)</span><br><span class="line">            cout &lt;&lt; t &lt;&lt; &quot; &quot;;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        return accumulate(tmp.begin(), tmp.end(), ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; ratings(&#123;29,51,87,87,72,12,13&#125;);</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.candy(ratings) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136_只出现一次的数字"></a>136_只出现一次的数字</h2><ul>
<li>这题暴力了，但是还是写的很烂</li>
<li>异或运算牛批</li>
</ul>
<p><img src="/pictrues/bit.png" alt="位运算"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        for(int i = 0; i &lt; nums.size(); ++i)&#123;</span><br><span class="line">            if(i + 1 == nums.size())</span><br><span class="line">                return nums[i];</span><br><span class="line"></span><br><span class="line">            if(nums[i] == nums[i + 1])</span><br><span class="line">                ++i;</span><br><span class="line">            else</span><br><span class="line">                return nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="137-只出现一次的数字-ll"><a href="#137-只出现一次的数字-ll" class="headerlink" title="137_只出现一次的数字_ll"></a>137_只出现一次的数字_ll</h2><ul>
<li>位运算太高明了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        unordered_map&lt;int, int&gt; map;</span><br><span class="line">        for(const auto &amp;n : nums)</span><br><span class="line">            map[n]++;</span><br><span class="line">        for(auto &amp; iter : map)&#123;</span><br><span class="line">            if(iter.second == 1)</span><br><span class="line">                return iter.first;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="149-直线上最多的点数"><a href="#149-直线上最多的点数" class="headerlink" title="149_直线上最多的点数"></a>149_直线上最多的点数</h2><ul>
<li>这题暴力出来了…没有去重，直接将每个点所在的直线都计算出来，比较点的个数</li>
<li>击败双5%，哈哈哈——去除重复点应该可以大幅减小计算时间</li>
<li>学习下如何储存一条直线</li>
<li>题解用double作哈希表键值会有问题，测试样例<code>[{0,0}, {941150,94911151}, {94911151,94911152}]</code>通不过，用字符串吧</li>
<li>或者将斜率的分子和分母约至最简，<code>for (auto&amp; [_, i] : mp)</code>这个是C++17里的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution_ &#123;</span><br><span class="line">public:</span><br><span class="line">    int res = 2;</span><br><span class="line">    vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; lines;</span><br><span class="line">    int pos = -1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    int maxPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;</span><br><span class="line">        int l =static_cast&lt;int&gt;(points.size());</span><br><span class="line">        if(l &lt;= 2) return l;</span><br><span class="line">        //从第一个点开始建立直线</span><br><span class="line">//        lines.clear();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; tmp;</span><br><span class="line">        tmp.push_back(points[0]);</span><br><span class="line">        tmp.push_back(points[1]);</span><br><span class="line">        lines.push_back(tmp);</span><br><span class="line"></span><br><span class="line">        for(int i = 2; i &lt; l; ++i)&#123;</span><br><span class="line">            //判断当前点是否在已有的直线里，若有则放入，没有则新建</span><br><span class="line">            if(isLineAlready(points[i][0], points[i][1]))&#123;</span><br><span class="line">                lines[pos].push_back(points[i]);</span><br><span class="line">                res = max(res, static_cast&lt;int&gt;(lines[pos].size()));</span><br><span class="line">                pos = -1;</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                tmp.clear();</span><br><span class="line">                tmp.push_back(points[0]);</span><br><span class="line">                tmp.push_back(points[i]);</span><br><span class="line">                lines.push_back(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //递归</span><br><span class="line">        lines.clear();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; p;</span><br><span class="line">        copy(points.begin() + 1, points.end(), inserter(p, p.begin()));</span><br><span class="line">        res = max(res, maxPoints(p));</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool isLineAlready(int x, int y)&#123;</span><br><span class="line">        for(int i = 0; i &lt; lines.size(); ++i)&#123;</span><br><span class="line">            if(lines[i][0][0] == lines[i][1][0] &amp;&amp; lines[i][0][0] == x)&#123;</span><br><span class="line">                pos = i;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            double k = static_cast&lt;double&gt;(lines[i][0][1] - lines[i][1][1]) / (lines[i][0][0] - lines[i][1][0]);</span><br><span class="line">            double k_ = static_cast&lt;double&gt;(y - lines[i][0][1]) / (x - lines[i][0][0]);</span><br><span class="line">            if(abs(k - k_) &lt;= 10e-5)&#123;</span><br><span class="line">                pos = i;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//大佬写的，用哈希表果然比vector快</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    // 求最大公约数</span><br><span class="line">    int gcd(int a, int b) &#123;</span><br><span class="line">        int t;</span><br><span class="line">        if (a &lt; b) swap(a, b);</span><br><span class="line">        while(b &gt; 0) &#123;</span><br><span class="line">            t = a % b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = t;</span><br><span class="line">        &#125;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">    // 斜率 k = (x1 - x2) / (y1 - y2)</span><br><span class="line">    pair&lt;int, int&gt; k (int x1, int x2, int y1, int y2) &#123;</span><br><span class="line">        bool flag = true; // 符号</span><br><span class="line">        int up, down; // 分子, 分母</span><br><span class="line">//        这里的斜率是将横坐标的差值放在分子上</span><br><span class="line">        if (y1 - y2 == 0) return &#123;INT_MAX, INT_MAX&#125;;</span><br><span class="line">        else &#123;</span><br><span class="line">            int dx = x1 - x2;</span><br><span class="line">            int dy = y1 - y2;</span><br><span class="line">            // 符号相反</span><br><span class="line">            if ((dx ^ dy) &lt; 0) flag = false;</span><br><span class="line">            dx = abs(dx), dy = abs(dy);</span><br><span class="line">            up = dx / gcd(dx, dy);</span><br><span class="line">            down = dy / gcd(dx, dy);</span><br><span class="line">        &#125;</span><br><span class="line">        return flag ? make_pair(up, down) : make_pair(-up, down);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int maxPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;</span><br><span class="line">        map&lt;pair&lt;int, int&gt;, int&gt; mp; // (斜率, 数目)</span><br><span class="line">        int ans = 1;</span><br><span class="line">        for (int i = 0; i &lt; points.size(); ++i) &#123;</span><br><span class="line">            for (int j = i + 1; j &lt; points.size(); ++j) &#123;</span><br><span class="line">                ++mp[k(points[i][0], points[j][0], points[i][1], points[j][1])];</span><br><span class="line">            &#125;</span><br><span class="line">            /*for (auto&amp; [_, i] : mp) &#123;</span><br><span class="line">                ans = max(ans, i + 1);</span><br><span class="line">            &#125;*/</span><br><span class="line">            for(const auto &amp;m : mp)&#123;</span><br><span class="line">                ans = max(ans, m.second + 1);</span><br><span class="line">            &#125;</span><br><span class="line">            mp.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; points(&#123;&#123;1,1&#125;, &#123;3,2&#125;, &#123;5,3&#125;, &#123;4,1&#125;, &#123;2,3&#125;, &#123;1,4&#125;&#125;);</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.maxPoints(points) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二刷"><a href="#二刷" class="headerlink" title="二刷"></a>二刷</h3><ul>
<li>再一次做的时候——暴力还是出现各种问题，三重循环、求斜率时应该用<code>double</code>而不是<code>int</code>——三重循环通过了！！！<ul>
<li>而且还比第一次时间更快？</li>
<li>真佩服我自己…之前写的居然还用了递归…</li>
<li>还有个小问题，就是<code>double</code>相比较——虽然我直接写<code>==</code>能通过，但这是不对的，应该写<code>abs(slope - _slope) &lt;= 10e-5</code></li>
</ul>
</li>
</ul>
<p><img src="/pictrues/149_2.png" alt title="提交结果"></p>
<ul>
<li>看到记录斜率去重、如果遇到平行线了呢？这次好好记录下！——第一遍大佬（题解）的记录<ul>
<li>首先是两重循环，第一个点和其余点组成斜率，计算出斜率最多的点数+1</li>
<li>第二次遍历的时候，清空哈希表！</li>
<li>最大公约数Greatest common divisor——有两种写法，而且无需取绝对值（因为参数带入之前就已经取过绝对值-不停的取余</li>
<li>为了解决斜率为负的情况，统一让分母取正</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">//二刷手撕</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;</span><br><span class="line">        //有点眼熟、一看题号、原来做过——两点确定一条直线</span><br><span class="line">        int n = points.size();</span><br><span class="line">        if(n &lt; 3)</span><br><span class="line">            return n;</span><br><span class="line">        //至少是两个点</span><br><span class="line">        int ans = 2;</span><br><span class="line">        //先选择第一个点</span><br><span class="line">        for(int i = 0; i &lt; n - 1; ++i)&#123;</span><br><span class="line">            //选择第二个点——如果直线已经用过，则跳过这个点——这里没有实现</span><br><span class="line">            for(int j = i + 1; j &lt; n; ++j)&#123;</span><br><span class="line">                //依次判断后面的点，在不在这条直线上</span><br><span class="line">                int tmp = 2;</span><br><span class="line">                for(int k = j + 1; k &lt; n; ++k)&#123;</span><br><span class="line">                    //斜率无穷大</span><br><span class="line">                    if(points[i][0] == points[j][0] &amp;&amp; points[i][0] == points[k][0])&#123;</span><br><span class="line">                        ++tmp;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //如果三个横坐标，有一对相等，就跳过</span><br><span class="line">                    if(points[i][0] == points[j][0] || points[i][0] == points[k][0])</span><br><span class="line">                        continue;</span><br><span class="line"></span><br><span class="line">                    //斜率有限值</span><br><span class="line">                    double slope = static_cast&lt;double&gt;(points[i][1] - points[j][1]) / (points[i][0] - points[j][0]);</span><br><span class="line">                    double _slope = static_cast&lt;double&gt;(points[i][1] - points[k][1]) / (points[i][0] - points[k][0]);</span><br><span class="line">                    if(abs(slope - _slope) &lt;= 10e-5)</span><br><span class="line">                        ++tmp;</span><br><span class="line">                &#125;</span><br><span class="line">                ans = max(ans, tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br><span class="line">//题解</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    //这里的求最大公约数太妙了</span><br><span class="line">    int gcd(int a, int b) &#123;</span><br><span class="line">        return b ? gcd(b, a % b) : a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int maxPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;</span><br><span class="line">        int n = points.size();</span><br><span class="line">        if (n &lt;= 2) &#123;</span><br><span class="line">            return n;</span><br><span class="line">        &#125;</span><br><span class="line">        int ret = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            if (ret &gt;= n - i || ret &gt; n / 2) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            unordered_map&lt;int, int&gt; mp;</span><br><span class="line">            for (int j = i + 1; j &lt; n; j++) &#123;</span><br><span class="line">                int x = points[i][0] - points[j][0];</span><br><span class="line">                int y = points[i][1] - points[j][1];</span><br><span class="line">                if (x == 0) &#123;</span><br><span class="line">                    y = 1;</span><br><span class="line">                &#125; else if (y == 0) &#123;</span><br><span class="line">                    x = 1;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    if (y &lt; 0) &#123;</span><br><span class="line">                        x = -x;</span><br><span class="line">                        y = -y;</span><br><span class="line">                    &#125;</span><br><span class="line">                    int gcdXY = gcd(abs(x), abs(y));</span><br><span class="line">                    x /= gcdXY, y /= gcdXY;</span><br><span class="line">                &#125;</span><br><span class="line">                //这里是为了，取唯一性</span><br><span class="line">                mp[ y+ x * 20001]++;</span><br><span class="line">            &#125;</span><br><span class="line">            int maxn = 0;</span><br><span class="line">            for(const auto &amp;m : mp)&#123;</span><br><span class="line">                maxn = max(maxn, m.second + 1);</span><br><span class="line">            &#125;</span><br><span class="line">            //c17版本</span><br><span class="line">//            for (auto&amp; [_, num] : mp) &#123;</span><br><span class="line">//                maxn = max(maxn, num + 1);</span><br><span class="line">//            &#125;</span><br><span class="line">            ret = max(ret, maxn);</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150_逆波兰表达式求值"></a>150_逆波兰表达式求值</h2><ul>
<li>…</li>
<li>先了解下定义、a+b，这是中缀表达式，写成后缀表达式就是：ab+</li>
<li>给出的例子都没有包含括号</li>
<li>还可以就是<code>string</code>转其他类型有点忘了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int evalRPN(vector&lt;string&gt;&amp; tokens) &#123;</span><br><span class="line">        stack&lt;int&gt; number;</span><br><span class="line">//        stack&lt;string&gt; symbol;</span><br><span class="line">        for(auto s : tokens)&#123;</span><br><span class="line">            if(isdigit(s[0]) || s.size() &gt; 1)&#123;</span><br><span class="line">                int num = stoi(s);</span><br><span class="line">                number.push(num);</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                int a = number.top();</span><br><span class="line">                number.pop();</span><br><span class="line">                int b = number.top();</span><br><span class="line">                number.pop();</span><br><span class="line">                switch (s[0]) &#123;</span><br><span class="line">                    case &apos;+&apos;:</span><br><span class="line">                        number.push(b + a);</span><br><span class="line">                        break;</span><br><span class="line">                    case &apos;-&apos;:</span><br><span class="line">                        number.push(b - a);</span><br><span class="line">                        break;</span><br><span class="line">                    case &apos;*&apos;:</span><br><span class="line">                        number.push(b * a);</span><br><span class="line">                        break;</span><br><span class="line">                    case &apos;/&apos;:</span><br><span class="line">                        number.push(b / a);</span><br><span class="line">                        break;</span><br><span class="line">                    default:</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; number.top() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return number.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">//    ((10 * (6 / ((9 + 3) * -11))) + 17) + 5</span><br><span class="line">    vector&lt;string&gt; tokens(&#123;&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;/&quot;,&quot;*&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;&#125;);</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.evalRPN(tokens) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="152-乘积最大子数组"><a href="#152-乘积最大子数组" class="headerlink" title="152_乘积最大子数组"></a>152_乘积最大子数组</h2><ul>
<li>这题虽然想到了用<code>f(i)</code>作为第<code>i</code>个元素为结尾的数组的最大乘积，但是不知道怎么遍历，明明第53题类似的，看来不自己深入思考，迟早会忘得干净</li>
<li>动态规划，先重做下53题…</li>
<li>再学习下分治的思想</li>
<li>状态转移方程如下</li>
</ul>
<p><img src="/pictrues/max.png" alt="状态转移方程" title="这个是错的"><br><img src="/pictrues/maxmin.png" alt="状态转移方程" title="正确"></p>
<ul>
<li>求数组的最大值，可以直接用<code>*max_element(maxF.begin(), maxF.end());</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProduct(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;int&gt; ma(nums), mi(nums);</span><br><span class="line">        int ans = nums[0];</span><br><span class="line">        for(int i = 1; i &lt; nums.size(); ++i)&#123;</span><br><span class="line">            ma[i] = max(ma[i - 1] * nums[i], max(mi[i - 1] * nums[i], nums[i]));</span><br><span class="line">            mi[i] = min(ma[i - 1] * nums[i], min(mi[i - 1] * nums[i], nums[i]));</span><br><span class="line">            ans = max(ans, ma[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    //如果是几个负数连在一起呢</span><br><span class="line">    vector&lt;int&gt; nums(&#123;2,-5,-2,-4,3&#125;);</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.maxProduct(nums) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="153-寻找旋转排序数组中的最小值"><a href="#153-寻找旋转排序数组中的最小值" class="headerlink" title="153_寻找旋转排序数组中的最小值"></a>153_寻找旋转排序数组中的最小值</h2><ul>
<li>只要二分法找出右边的数字比左边小即可，注意二分时考虑指针相等的情况，不然会无限循环</li>
<li>53题还是有点不细心，，，</li>
<li>题解写的更清晰些</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution_ &#123;</span><br><span class="line">public:</span><br><span class="line">    int findMin(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int low = 0;</span><br><span class="line">        int high = nums.size() - 1;</span><br><span class="line">        while (low &lt; high) &#123;</span><br><span class="line">            int pivot = low + (high - low) / 2;</span><br><span class="line">            if (nums[pivot] &lt; nums[high]) &#123;</span><br><span class="line">                high = pivot;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                low = pivot + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nums[low];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findMin(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        int l = 0, r = n - 1;</span><br><span class="line">        while(l &lt;= r)&#123;</span><br><span class="line">            int m = (l + r) / 2;</span><br><span class="line">            if(m == n - 1)</span><br><span class="line">                return nums[0];</span><br><span class="line">            if(nums[m] &lt; nums[m + 1] &amp;&amp; nums[l] &lt;= nums[m])&#123;</span><br><span class="line">                l = m + 1;</span><br><span class="line">            &#125;else if(nums[m] &lt; nums[m + 1] &amp;&amp; nums[l] &gt; nums[m])&#123;</span><br><span class="line">                r = m - 1;</span><br><span class="line">            &#125;else if(nums[m] &gt; nums[m + 1])&#123;</span><br><span class="line">                return nums[m + 1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="154-寻找旋转排序数组中的最小值-II"><a href="#154-寻找旋转排序数组中的最小值-II" class="headerlink" title="154_寻找旋转排序数组中的最小值_II"></a>154_寻找旋转排序数组中的最小值_II</h2><ul>
<li>出现了重复的数字，之前有也一题类似的，找目标值，忘了怎么写了….</li>
<li>如果左指针与右指针对应的数字相等，那么一种情况是，两者之间所有数字都相等；如果是刚开始，那么最小数字可能在中间，或者本身就是最小数字</li>
<li>看了题解，如果出现重复的数字，那就必有右端点的替代品，忽略区间的右端点！！！</li>
<li>有个小细节，输出的是左指针，条件比较的是中指针和右指针</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findMin(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = static_cast&lt;int&gt;(nums.size());</span><br><span class="line">        int l = 0, r = n - 1;</span><br><span class="line">        while (l &lt; r)&#123;</span><br><span class="line">            int m = l + (r - l) / 2;</span><br><span class="line">            if(nums[m] &lt; nums[r])&#123;</span><br><span class="line">                r = m;</span><br><span class="line">            &#125; else if(nums[m] &gt; nums[r])&#123;</span><br><span class="line">                l = m + 1;</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                --r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="162-寻找峰值"><a href="#162-寻找峰值" class="headerlink" title="162_寻找峰值"></a>162_寻找峰值</h2><ul>
<li>我这个方法，太笨了，，，复杂度来看应该用二分，而我是从两边同时开始遍历….</li>
<li>判断条件可以直接判断<code>if (nums[i] &gt; nums[i + 1])</code>…题目条件给出相邻的两个元素一定不同，所以只要出现这个条件就一定是<code>i</code>，否则就是数组的最后一个元素，高，实在是高！</li>
<li>还有二分的时候可以递归也可以迭代，如果<code>nums[mid] &gt; nums[mid + 1]</code>那么不能直接返回<code>mid</code>，因为不知道<code>mid-1</code>的情况，最后输出的是<code>l</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /*int findPeakElement(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        for(int i = 0; i &lt; n - 1; ++i)&#123;</span><br><span class="line">            if(nums[i] &gt; nums[i + 1])</span><br><span class="line">                return i;</span><br><span class="line">        &#125;</span><br><span class="line">        return n - 1;</span><br><span class="line">    &#125;*/</span><br><span class="line">    int findPeakElement(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        int l = 0, r = n - 1;</span><br><span class="line">        while(l &lt; r)&#123;</span><br><span class="line">            int mid = (l + r) / 2;</span><br><span class="line">            if(nums[mid] &gt; nums[mid + 1])</span><br><span class="line">                r = mid;    //这里不能直接返回mid</span><br><span class="line">            else</span><br><span class="line">                l = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; nums(&#123;1,2,1&#125;);</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.findPeakElement(nums) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="164-最大间距"><a href="#164-最大间距" class="headerlink" title="164_最大间距"></a>164_最大间距</h2><ul>
<li>学习下基数排序，基数排序可以在<code>O(N)</code>的时间内完成整数之间的排序。</li>
<li>还有基于桶的算法</li>
<li><code>cnt[i] += cnt[i - 1]</code>有点理解了，<code>cnt</code>存放的是比如个位数从小到大排好的个数，比如个位数是2的有一个，对应个位数没有的为0；累加(和是总个数)就相当于目标数组对应的位置了，方便后续再拿出来放回数组</li>
<li>还有就是放回数组的时候为什么要从后往前遍历，从前往后的话，会在十位数的时候出现位置反掉的情况，仅针对十位数相同的数字;因为每次循环过后，数组最后一位数字都是某位（比如个位数）最大的，每次放回数组时，对应的位置会减一，再遇到相同十位数的数字就只能在前面放置</li>
<li>桶排序，感觉本质上差不多；与基数排序的区别就是不用一位一位数的比，直接就分好空间了，大的数只能在后面；而小的数只能在前面，桶的顺序是从小到大的；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">//小项目里写这句话很方便，大项目不推荐</span><br><span class="line">using namespace std;</span><br><span class="line">//基数排序</span><br><span class="line">class Solution_ &#123;</span><br><span class="line">public:</span><br><span class="line">    int maximumGap(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = static_cast&lt;int&gt;(nums.size());</span><br><span class="line">        if (n &lt; 2) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        //相当于10的exp次方</span><br><span class="line">        int exp = 1;</span><br><span class="line">        vector&lt;int&gt; buf(n);</span><br><span class="line">        //先找出最大值</span><br><span class="line">        int maxVal = *max_element(nums.begin(), nums.end());</span><br><span class="line">        //最大值可能不止两位数</span><br><span class="line">        while (maxVal &gt;= exp) &#123;</span><br><span class="line">//            cout &lt;&lt; &quot;exp = &quot; &lt;&lt; exp &lt;&lt; &quot;: &quot; &lt;&lt; endl;</span><br><span class="line">            vector&lt;int&gt; cnt(10);</span><br><span class="line">            for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">                int digit = (nums[i] / exp) % 10; //一开始是个位数，之后就是十位数，再之后就是百位数...</span><br><span class="line">                cnt[digit]++;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int i = 1; i &lt; 10; i++) &#123;</span><br><span class="line">                cnt[i] += cnt[i - 1];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            for (int i = n - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">                int digit = (nums[i] / exp) % 10; //个位数同上</span><br><span class="line">//                cout &lt;&lt; &quot;nums[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot; &lt;&lt; nums[i] &lt;&lt; &quot; digit = &quot; &lt;&lt; digit &lt;&lt; &quot; &quot;;</span><br><span class="line">                buf[cnt[digit] - 1] = nums[i];</span><br><span class="line">//                cout &lt;&lt; &quot;buf[cnt[&quot; &lt;&lt; digit &lt;&lt; &quot;] - 1 = &quot; &lt;&lt; cnt[digit] - 1 &lt;&lt; &quot;] = &quot; &lt;&lt; nums[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">                cnt[digit]--;</span><br><span class="line">//                cout &lt;&lt; &quot;cnt[&quot; &lt;&lt; digit &lt;&lt; &quot;]-- = &quot; &lt;&lt; cnt[digit] &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            copy(buf.begin(), buf.end(), nums.begin());</span><br><span class="line">            exp *= 10;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int ret = 0;</span><br><span class="line">        for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">            ret = max(ret, nums[i] - nums[i - 1]);</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//桶排序</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maximumGap(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        if (n &lt; 2) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        //找出最大值、最小值</span><br><span class="line">        int minVal = *min_element(nums.begin(), nums.end());</span><br><span class="line">        int maxVal = *max_element(nums.begin(), nums.end());</span><br><span class="line">        int d = max(1, (maxVal - minVal) / (n - 1));</span><br><span class="line">        //桶的个数</span><br><span class="line">        int bucketSize = (maxVal - minVal) / d + 1;</span><br><span class="line"></span><br><span class="line">        vector&lt;pair&lt;int, int&gt;&gt; bucket(bucketSize, &#123;-1, -1&#125;);  // 存储 (桶内最小值，桶内最大值) 对，(-1, -1) 表示该桶是空的</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            //idx表示第几个桶</span><br><span class="line">            int idx = (nums[i] - minVal) / d;</span><br><span class="line">            if (bucket[idx].first == -1) &#123;  //如果桶是空的，最小值最大值都是nums[i]</span><br><span class="line">                bucket[idx].first = bucket[idx].second = nums[i];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                bucket[idx].first = min(bucket[idx].first, nums[i]);</span><br><span class="line">                bucket[idx].second = max(bucket[idx].second, nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; &quot;bucketSize = &quot; &lt;&lt; bucketSize &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;bucket = &quot; &lt;&lt; endl;</span><br><span class="line">        for(const auto b : bucket)&#123;</span><br><span class="line">            cout &lt;&lt; b.first &lt;&lt; &quot; &quot; &lt;&lt; b.second &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int ret = 0;</span><br><span class="line">        int prev = -1;</span><br><span class="line">        for (int i = 0; i &lt; bucketSize; i++) &#123;</span><br><span class="line">            if (bucket[i].first == -1) continue;</span><br><span class="line">            if (prev != -1) &#123;</span><br><span class="line">                ret = max(ret, bucket[i].first - bucket[prev].second);</span><br><span class="line">            &#125;</span><br><span class="line">            prev = i;</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; nums(&#123;29,25,3,49,9,37,21,43&#125;);  //8</span><br><span class="line">    Solution solution;</span><br><span class="line">    int ans = solution.maximumGap(nums);</span><br><span class="line">    cout &lt;&lt; &quot;ans = &quot; &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167_两数之和_II_输入有序数组"></a>167_两数之和_II_输入有序数组</h2><ul>
<li>双指针不多说了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123;</span><br><span class="line">        int l = 0, r = numbers.size();</span><br><span class="line">        --r;</span><br><span class="line">        while(l &lt; r)&#123;</span><br><span class="line">            if(numbers[l] + numbers[r] == target)</span><br><span class="line">                break;</span><br><span class="line">            if(numbers[l] + numbers[r] &gt; target)&#123;</span><br><span class="line">                --r;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                ++l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return &#123;l + 1, r + 1&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169_多数元素"></a>169_多数元素</h2><ul>
<li>用<code>map</code>记录个数，消耗比较高</li>
<li>投票算法学习下</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">//#include &lt;unordered_map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /*int majorityElement(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        unordered_map&lt;int, int&gt; map;</span><br><span class="line">        for(auto n : nums)&#123;</span><br><span class="line">            map[n]++;</span><br><span class="line">            if(map[n] &gt; nums.size() / 2)</span><br><span class="line">                return n;</span><br><span class="line">        &#125;</span><br><span class="line">        return nums[0];</span><br><span class="line">    &#125;*/</span><br><span class="line">    //投票算法</span><br><span class="line">    int majorityElement(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int count = 0;</span><br><span class="line">        int tmp = 0;</span><br><span class="line">        for(auto n : nums)&#123;</span><br><span class="line">            if(count == 0)&#123;</span><br><span class="line">                tmp = n;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                if(tmp == n)</span><br><span class="line">                    ++count;</span><br><span class="line">                else</span><br><span class="line">                    --count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; nums(&#123;2,2,1,1,1,2,2&#125;);</span><br><span class="line">    Solution solution;</span><br><span class="line">    int ans = solution.majorityElement(nums);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="174-地下城游戏"><a href="#174-地下城游戏" class="headerlink" title="174_地下城游戏"></a>174_地下城游戏</h2><ul>
<li>自己想的思路和题解一样，但是答案好优美，好简洁</li>
<li>因为我的二维<code>dp</code>是<code>n*m</code>；答案是<code>(n+1)*(m+1)</code>；这样的好处在于，最后一个格子的上边和左边可以直接设为1，而无需考虑血量包或者小怪</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int calculateMinimumHP(vector&lt;vector&lt;int&gt;&gt;&amp; dungeon) &#123;</span><br><span class="line">        if(dungeon.empty()) return 0;</span><br><span class="line">        int row = dungeon.size(), col = dungeon[0].size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(row, vector&lt;int&gt;(col, 0));</span><br><span class="line">        //骑士在进入每一个房间时，血量都要大于0，不然会立即死亡，所以dp[][]表示到达这个房间的最小血量</span><br><span class="line">        //从后往前遍历，只记录到达这个格子的最小血量，遇到血量包，就将这个格子的最小血量初始化为1或者（dp[][] - 血量包），因为你得活着到达这里才能吃到血包</span><br><span class="line">        if(dungeon[row - 1][col - 1] &gt; 0)&#123;</span><br><span class="line">            dp[row - 1][col - 1] = 1;</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">            dp[row - 1][col - 1] = dungeon[row - 1][col - 1] * (-1) + 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i = row - 1; i &gt; -1; --i)&#123;</span><br><span class="line">            for(int j = col - 1; j &gt; -1; --j)&#123;</span><br><span class="line">                if(i == row - 1 &amp;&amp; j == col - 1) continue;</span><br><span class="line">                if(i == row - 1)&#123;</span><br><span class="line">                    if(dungeon[i][j] &gt; 0 &amp;&amp; dungeon[i][j] &gt;= dp[i][j + 1])</span><br><span class="line">                        dp[i][j] = 1;</span><br><span class="line">                    else</span><br><span class="line">                        dp[i][j] = dp[i][j + 1] - dungeon[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">                if(j == col - 1)&#123;</span><br><span class="line">                    if(dungeon[i][j] &gt; 0 &amp;&amp; dungeon[i][j] &gt;= dp[i + 1][j])</span><br><span class="line">                        dp[i][j] = 1;</span><br><span class="line">                    else</span><br><span class="line">                        dp[i][j] = dp[i + 1][j] - dungeon[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">                if(i != row - 1 &amp;&amp; j != col - 1)&#123;</span><br><span class="line">                    int down = (dungeon[i][j] &gt; 0 &amp;&amp; dungeon[i][j] &gt; dp[i + 1][j]) ? 1 : dp[i + 1][j] - dungeon[i][j];</span><br><span class="line">                    int right = (dungeon[i][j] &gt; 0 &amp;&amp; dungeon[i][j] &gt; dp[i][j + 1]) ? 1 : dp[i][j + 1] - dungeon[i][j];</span><br><span class="line">                    dp[i][j] = min(down, right);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[0][0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution_ &#123;</span><br><span class="line">public:</span><br><span class="line">    int calculateMinimumHP(vector&lt;vector&lt;int&gt;&gt;&amp; dungeon) &#123;</span><br><span class="line">        int n = dungeon.size(), m = dungeon[0].size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(m + 1, INT_MAX));</span><br><span class="line">        dp[n][m - 1] = dp[n - 1][m] = 1;</span><br><span class="line">        for (int i = n - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">            for (int j = m - 1; j &gt;= 0; --j) &#123;</span><br><span class="line">                int minn = min(dp[i + 1][j], dp[i][j + 1]);</span><br><span class="line">                dp[i][j] = max(minn - dungeon[i][j], 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[0][0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    //[[1,-3,3],[0,-2,0],[-3,-3,-3]]</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; dungeon(&#123;</span><br><span class="line">        &#123;0,0,0&#125;,</span><br><span class="line">        &#123;1,1,-1&#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    Solution solution;</span><br><span class="line">    int ans = solution.calculateMinimumHP(dungeon);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;ans = &quot; &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="187-重复的DNA序列"><a href="#187-重复的DNA序列" class="headerlink" title="187_重复的DNA序列"></a>187_重复的DNA序列</h2><ul>
<li>题解有三种方法，我只会第一种</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;unordered_set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; findRepeatedDnaSequences(string s) &#123;</span><br><span class="line">        if(s.size() &lt; 10) return vector&lt;string&gt;();</span><br><span class="line">        //用set更好一点</span><br><span class="line">        /*unordered_map&lt;string, int&gt; map;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        for(int i = 0; i &lt; s.size() - 9; ++i)&#123;</span><br><span class="line">            string tmp = s.substr(i, 10);</span><br><span class="line">            ++map[tmp];</span><br><span class="line">            if(map[tmp] &gt; 1)&#123;</span><br><span class="line">                ans.push_back(tmp);</span><br><span class="line">                map[tmp] = INT32_MIN;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;*/</span><br><span class="line">        unordered_set&lt;string&gt; set, res;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        for(int i = 0; i &lt; s.size() - 9; ++i)&#123;</span><br><span class="line">            string tmp = s.substr(i, 10);</span><br><span class="line">            if(set.find(tmp) != set.end())&#123;</span><br><span class="line">                res.insert(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            set.insert(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        copy(res.begin(), res.end(), inserter(ans, ans.end()));</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="188-买卖股票的最佳时机-IV"><a href="#188-买卖股票的最佳时机-IV" class="headerlink" title="188_买卖股票的最佳时机_IV"></a>188_买卖股票的最佳时机_IV</h2><ul>
<li>参考了之前卖两次的思路；不仅买还有卖，所以应该是<code>2*k</code>个变量，一维数组即可，可以写成一列的形式</li>
<li>第0行表示第一次买；第1行表示第一次卖——卖的时候比较卖和不卖两种情况——买的时候比较买和不买两种情况</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        if(k == 0 || prices.empty()) return 0;</span><br><span class="line">        //卖或者不卖、买或者不买</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt; dp(2 * k, 0);</span><br><span class="line">        for(int j = 0; j &lt; prices.size(); ++j)&#123;</span><br><span class="line">            for(int i = 0; i &lt; 2 * k; ++i)&#123;</span><br><span class="line">                if(j == 0 )&#123;</span><br><span class="line">                    if(i % 2 == 0)</span><br><span class="line">                        dp[i] = -prices[0];</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    if(i == 0) //第一次买</span><br><span class="line">                        dp[i] = max(dp[i], -prices[j]);</span><br><span class="line">                    else&#123;</span><br><span class="line">                        if(i % 2 == 1)  //第i次卖</span><br><span class="line">                            dp[i] = max(dp[i], dp[i - 1] + prices[j]);</span><br><span class="line">                        else    //第i次买</span><br><span class="line">                            dp[i] = max(dp[i], dp[i - 1] - prices[j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="189-旋转数组"><a href="#189-旋转数组" class="headerlink" title="189_旋转数组"></a>189_旋转数组</h2><ul>
<li>本来想露一手的，…… ，还是老老实实本本分分吧</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void rotate(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        k %= n;</span><br><span class="line">        if(n &lt; 2 || k == 0) return;</span><br><span class="line">        vector&lt;int&gt; tmp(nums.begin() + n - k, inserter(tmp, tmp.end()));</span><br><span class="line">        copy(nums.begin(), nums.begin() + n - k - 1, tmp.end());</span><br><span class="line">        nums = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//额外的数组</span><br><span class="line">class Solution1 &#123;</span><br><span class="line">public:</span><br><span class="line">    void rotate(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        vector&lt;int&gt; newArr(n);</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            newArr[(i + k) % n] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        nums.assign(newArr.begin(), newArr.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//翻转数组</span><br><span class="line">class Solution2 &#123;</span><br><span class="line">public:</span><br><span class="line">    void reverse(vector&lt;int&gt;&amp; nums, int start, int end) &#123;</span><br><span class="line">        while (start &lt; end) &#123;</span><br><span class="line">            swap(nums[start], nums[end]);</span><br><span class="line">            start += 1;</span><br><span class="line">            end -= 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void rotate(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        k %= nums.size();</span><br><span class="line">        reverse(nums, 0, nums.size() - 1);</span><br><span class="line">        reverse(nums, 0, k - 1);</span><br><span class="line">        reverse(nums, k, nums.size() - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//环状替换</span><br><span class="line">class Solution3 &#123;</span><br><span class="line">public:</span><br><span class="line">    void rotate(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        k = k % n;</span><br><span class="line">        int count = gcd(k, n); //最大公约数,C++14好像没有</span><br><span class="line">        for (int start = 0; start &lt; count; ++start) &#123;</span><br><span class="line">            int current = start;</span><br><span class="line">            int prev = nums[start];</span><br><span class="line">            do &#123;</span><br><span class="line">                int next = (current + k) % n;</span><br><span class="line">                swap(nums[next], prev);</span><br><span class="line">                current = next;</span><br><span class="line">            &#125; while (start != current);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198_打家劫舍"></a>198_打家劫舍</h2><ul>
<li>本想用递归的，但感觉一次遍历即可</li>
<li>这种小聪明不能再犯了，，，这题一看就是动态规划</li>
<li>ohhhhhhhhh；虽然做出来了，但是和题解有些出入</li>
</ul>
<p><img src="/pictrues/198.png" alt="转移方程"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int rob(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        //dp[i]表示选择偷第i家的最大金钱数</span><br><span class="line">        vector&lt;int&gt; dp(n + 1, 0);</span><br><span class="line">        dp[1] = nums[0];</span><br><span class="line">        int ans = dp[1];</span><br><span class="line">        for(int i = 1; i &lt; n; ++i)&#123;</span><br><span class="line">            //cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">           //更新dp[i + 1]</span><br><span class="line">            for(int j = 0; j &lt; i; ++j)&#123;</span><br><span class="line">                //cout &lt;&lt; &quot;j = &quot; &lt;&lt; j &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">                dp[i + 1] = max(dp[i + 1], dp[j] + nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            ans = max(ans, dp[i + 1]);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//滚动数组</span><br><span class="line">class Solution_ &#123;</span><br><span class="line">public:</span><br><span class="line">    int rob(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if (nums.empty()) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int size = nums.size();</span><br><span class="line">        if (size == 1) &#123;</span><br><span class="line">            return nums[0];</span><br><span class="line">        &#125;</span><br><span class="line">//      dp[i]表示到了第i家，最大金钱数，而且至于前两次有关</span><br><span class="line">        int first = nums[0], second = max(nums[0], nums[1]);</span><br><span class="line">        for (int i = 2; i &lt; size; i++) &#123;</span><br><span class="line">            int temp = second;</span><br><span class="line">            second = max(first + nums[i], second);</span><br><span class="line">            first = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        return second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; nums(&#123;2,1,1,2&#125;);</span><br><span class="line">    Solution solution;</span><br><span class="line">    int ans = solution.rob(nums);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200_岛屿数量"></a>200_岛屿数量</h2><ul>
<li>每遇到一个未标记的1就将所有与这个1相连的1标记，然后遍历下一个？？这个思路属于DFS，康康题解BFS咋写</li>
<li>emmmm 并查集直接看《算法导论》第3版，第21章 Data Structures for Disjoint Sets；还有这个方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution_ &#123;</span><br><span class="line">public:</span><br><span class="line">    void mark(vector&lt;vector&lt;char&gt;&gt;&amp; grid, int i, int j, vector&lt;char&gt;::size_type m, vector&lt;char&gt;::size_type n)&#123;</span><br><span class="line">        if(grid[i][j] == &apos;1&apos; &amp;&amp; !tmp[i][j])</span><br><span class="line">            tmp[i][j] = true;</span><br><span class="line">        else</span><br><span class="line">            return;</span><br><span class="line">        int up = (i == 0) ? 0 : i - 1;</span><br><span class="line">        int down = (i + 1 == m) ? i : i + 1;</span><br><span class="line">        int left = (j == 0) ? 0 : j - 1;</span><br><span class="line">        int right = (j + 1 == n) ? j : j + 1;</span><br><span class="line">        mark(grid, up, j, m, n);</span><br><span class="line">        mark(grid, down, j, m, n);</span><br><span class="line">        mark(grid, i, left, m, n);</span><br><span class="line">        mark(grid, i, right, m, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        //每遇到一个未标记的1就将所有与这个1相连的1标记，然后遍历下一个？？</span><br><span class="line">        auto m = grid.size(), n = grid[0].size();</span><br><span class="line">        tmp = vector&lt;vector&lt;bool&gt;&gt;(m, vector&lt;bool&gt;(n, false));</span><br><span class="line">        int ans = 0;</span><br><span class="line">        for(int i = 0; i &lt; m; ++i)&#123;</span><br><span class="line">            for(int j = 0; j &lt; n; ++j)&#123;</span><br><span class="line">                if(grid[i][j] == &apos;1&apos; &amp;&amp; !tmp[i][j])&#123;</span><br><span class="line">                    ++ans;</span><br><span class="line">                    mark(grid, i, j, m, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;bool&gt;&gt; tmp;</span><br><span class="line">&#125;;</span><br><span class="line">//并查集</span><br><span class="line">class UnionFind &#123;</span><br><span class="line">public:</span><br><span class="line">    UnionFind(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        count = 0;</span><br><span class="line">        auto m = grid.size();</span><br><span class="line">        auto n = grid[0].size();</span><br><span class="line">        for (int i = 0; i &lt; m; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                if (grid[i][j] == &apos;1&apos;) &#123;</span><br><span class="line">                    parent.push_back(static_cast&lt;int&gt;(i * n) + j);//相当于拉成一维数组、所在的位置</span><br><span class="line">                    ++count;    //1的个数</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    parent.push_back(-1);</span><br><span class="line">                &#125;</span><br><span class="line">                rank.push_back(0);//？？为啥不直接初始化？</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int find(int i) &#123;</span><br><span class="line">        //i是转换之后的位置</span><br><span class="line">        //现在的parent[i]要么是-1要么就是_i * n + _j == i</span><br><span class="line">        if (parent[i] != i) &#123;</span><br><span class="line">            //这里会更改，递归...</span><br><span class="line">            parent[i] = find(parent[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return parent[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void unite(int x, int y) &#123;</span><br><span class="line">        //x,y是上下左右所在的...长度！</span><br><span class="line">        int rootx = find(x);</span><br><span class="line">        int rooty = find(y);</span><br><span class="line">        //两个1不在一个集合</span><br><span class="line">        if (rootx != rooty) &#123;</span><br><span class="line">            if (rank[rootx] &lt; rank[rooty]) &#123;</span><br><span class="line">                swap(rootx, rooty);</span><br><span class="line">            &#125;</span><br><span class="line">            parent[rooty] = rootx;</span><br><span class="line">            if (rank[rootx] == rank[rooty]) rank[rootx] += 1;</span><br><span class="line">            --count; //这里注意减减了，最终结果就是岛屿的数量</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int getCount() const &#123;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    vector&lt;int&gt; parent;</span><br><span class="line">    vector&lt;int&gt; rank;   //用来降低并查集的高度,find的时候就更快</span><br><span class="line">    int count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        int nr = static_cast&lt;int&gt;(grid.size());</span><br><span class="line">        if (!nr) return 0;</span><br><span class="line">        int nc = static_cast&lt;int&gt;(grid[0].size());</span><br><span class="line"></span><br><span class="line">        UnionFind uf(grid);</span><br><span class="line">//        int num_islands = 0;</span><br><span class="line">        for (int r = 0; r &lt; nr; ++r) &#123;</span><br><span class="line">            for (int c = 0; c &lt; nc; ++c) &#123;</span><br><span class="line">                if (grid[r][c] == &apos;1&apos;) &#123;</span><br><span class="line">                    grid[r][c] = &apos;0&apos;;</span><br><span class="line">                    if (r - 1 &gt;= 0 &amp;&amp; grid[r-1][c] == &apos;1&apos;) uf.unite(r * nc + c, (r-1) * nc + c);</span><br><span class="line">                    if (r + 1 &lt; nr &amp;&amp; grid[r+1][c] == &apos;1&apos;) uf.unite(r * nc + c, (r+1) * nc + c);</span><br><span class="line">                    if (c - 1 &gt;= 0 &amp;&amp; grid[r][c-1] == &apos;1&apos;) uf.unite(r * nc + c, r * nc + c - 1);</span><br><span class="line">                    if (c + 1 &lt; nc &amp;&amp; grid[r][c+1] == &apos;1&apos;) uf.unite(r * nc + c, r * nc + c + 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return uf.getCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209_长度最小的子数组"></a>209_长度最小的子数组</h2><ul>
<li>滑动窗口我硬是写不出来，总是哪里出错，我还是太菜了…</li>
<li>再学习下前缀树和，二分法题解用的是<code>lower_bound</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        if (n == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int ans = INT_MAX;</span><br><span class="line">        int start = 0, end = 0;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        while (end &lt; n) &#123;</span><br><span class="line">            sum += nums[end];</span><br><span class="line">            while (sum &gt;= s) &#123;</span><br><span class="line">                //在循环里面更新ans的值</span><br><span class="line">                ans = min(ans, end - start + 1);</span><br><span class="line">                sum -= nums[start];</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans == INT_MAX ? 0 : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//前缀树</span><br><span class="line">class Solution_ &#123;</span><br><span class="line">public:</span><br><span class="line">    int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        if (n == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int ans = INT_MAX;</span><br><span class="line">        vector&lt;int&gt; sums(n + 1, 0);</span><br><span class="line">        // 为了方便计算，令 size = n + 1</span><br><span class="line">        // sums[0] = 0 意味着前 0 个元素的前缀和为 0</span><br><span class="line">        // sums[1] = A[0] 前 1 个元素的前缀和为 A[0]</span><br><span class="line">        // 以此类推</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            sums[i] = sums[i - 1] + nums[i - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            int target = s + sums[i - 1];</span><br><span class="line">            auto bound = lower_bound(sums.begin(), sums.end(), target);</span><br><span class="line">            if (bound != sums.end()) &#123;</span><br><span class="line">                ans = min(ans, static_cast&lt;int&gt;((bound - sums.begin()) - (i - 1)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans == INT_MAX ? 0 : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; nums(&#123;1,2,3,4,5&#125;);</span><br><span class="line">    int target = 11;</span><br><span class="line">    Solution solution;</span><br><span class="line">    int ans = solution.minSubArrayLen(target, nums);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="213-打家劫舍-II"><a href="#213-打家劫舍-II" class="headerlink" title="213_打家劫舍_II"></a>213_打家劫舍_II</h2><ul>
<li>看之前那题还以为是题解，没想到是我写的…原来我还是挺厉害的</li>
<li>我写的<code>dp[i]</code>表示偷这间屋子的最大金额，最终答案是将所有<code>dp</code>比较取最大值；题解更容易理解<code>dp[i]</code>表示从开始到现在这个屋子的最大金额，最终结果直接输出最后的数字</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int robRange(vector&lt;int&gt;&amp; nums, int start, int end) &#123;</span><br><span class="line">        int first = nums[start], second = max(nums[start], nums[start + 1]);</span><br><span class="line">        for (int i = start + 2; i &lt;= end; i++) &#123;</span><br><span class="line">            int temp = second;</span><br><span class="line">            second = max(first + nums[i], second);</span><br><span class="line">            first = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        return second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int rob(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int length = nums.size();</span><br><span class="line">        if (length == 1) &#123;</span><br><span class="line">            return nums[0];</span><br><span class="line">        &#125; else if (length == 2) &#123;</span><br><span class="line">            return max(nums[0], nums[1]);</span><br><span class="line">        &#125;</span><br><span class="line">        return max(robRange(nums, 0, length - 2), robRange(nums, 1, length - 1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215_数组中的第K个最大元素"></a>215_数组中的第K个最大元素</h2><ul>
<li>这题用了选择排序，能过，但是时间消耗很大；但是直接用<code>sort()</code>却很快，以后看STL是重点了解下为什么这么快；好像是快速排序</li>
<li>先重点学习下十大经典排序算法中的快速排序和堆排序；之前了解的桶排序、基数排序也忘得差不多了</li>
<li>心静不下来….</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;ctime&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution_ &#123;</span><br><span class="line">public:</span><br><span class="line">    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        return nums[nums.size() - k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//快速排序</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int quickSelect(vector&lt;int&gt;&amp; a, int l, int r, int index) &#123;</span><br><span class="line">        //调用函数，返回</span><br><span class="line">        int q = randomPartition(a, l, r);</span><br><span class="line">        if (q == index) &#123;</span><br><span class="line">            return a[q];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return q &lt; index ? quickSelect(a, q + 1, r, index) : quickSelect(a, l, q - 1, index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inline int randomPartition(vector&lt;int&gt;&amp; a, int l, int r) &#123;</span><br><span class="line">        //i是l和r之间的随机数</span><br><span class="line">        int i = rand() % (r - l + 1) + l;</span><br><span class="line">        swap(a[i], a[r]);</span><br><span class="line">        return partition(a, l, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inline int partition(vector&lt;int&gt;&amp; a, int l, int r) &#123;</span><br><span class="line">        int x = a[r], i = l - 1;</span><br><span class="line">        for (int j = l; j &lt; r; ++j) &#123;</span><br><span class="line">            if (a[j] &lt;= x) &#123;</span><br><span class="line">                swap(a[++i], a[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(a[i + 1], a[r]);</span><br><span class="line">        return i + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        srand(time(nullptr));</span><br><span class="line">        return quickSelect(nums, 0, nums.size() - 1, nums.size() - k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="216-组合总和-III"><a href="#216-组合总和-III" class="headerlink" title="216_组合总和_III"></a>216_组合总和_III</h2><ul>
<li>dfs搞定</li>
<li>题解用了9位二进制，每一位二进制代表对应的数字有没有被选中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;iterator&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;unordered_set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void dfs(int k, int n, int pos)&#123;</span><br><span class="line">        if(k == 0)&#123;</span><br><span class="line">            if(n == 0)</span><br><span class="line">                ans.push_back(tmp);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = pos; i &lt; 10; ++i)&#123;</span><br><span class="line">            //如果数字在里面，说明还没被加进和里</span><br><span class="line">            if(set.find(i) != set.end())&#123;</span><br><span class="line">                if(k == 1 &amp;&amp; (n &lt; 1 || n &gt; 9))</span><br><span class="line">                    return;</span><br><span class="line"></span><br><span class="line">                tmp.push_back(i);</span><br><span class="line">                set.erase(i);</span><br><span class="line">                dfs(k - 1, n - i, i + 1);</span><br><span class="line">                tmp.pop_back();</span><br><span class="line">                set.insert(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123;</span><br><span class="line">        //k是个数，n是和</span><br><span class="line">        for(int i = 1; i &lt; 10; ++i)&#123;</span><br><span class="line">            set.insert(i);</span><br><span class="line">        &#125;</span><br><span class="line">        int pos = 1;</span><br><span class="line">        dfs(k, n, pos);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">    vector&lt;int&gt; tmp;</span><br><span class="line">    unordered_set&lt;int&gt; set;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int k = 3, n = 9;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; ans(solution.combinationSum3(k, n));</span><br><span class="line">    for(const auto &amp; a : ans)&#123;</span><br><span class="line">        copy(a.begin(), a.end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot;));</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="217-存在重复元素"><a href="#217-存在重复元素" class="headerlink" title="217_存在重复元素"></a>217_存在重复元素</h2><ul>
<li>一次遍历？</li>
<li>也可以先排序，这排序十种面试前要滚瓜烂熟！！！</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        unordered_map&lt;int, int&gt; map;</span><br><span class="line">        for(const auto&amp; n : nums)&#123;</span><br><span class="line">            map[n]++;</span><br><span class="line">            if(map[n] == 2)</span><br><span class="line">                return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="218-天际线问题"><a href="#218-天际线问题" class="headerlink" title="218_天际线问题"></a>218_天际线问题</h2><ul>
<li>好家伙，这几道题目都在一起…分治、递归、归并</li>
<li>归并时，天际线的高度永远是左天际线和右天际线的较大值。</li>
</ul>
<p><img src="/pictrues/218.png" alt="天际线" title="天际线"></p>
<ul>
<li>还是两两合并，最后一起合并好理解一点；我还是选择了线性扫描…</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;iterator&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; getSkyline(vector&lt;vector&lt;int&gt;&gt;&amp; buildings) &#123;</span><br><span class="line">        vector&lt;pair&lt;int,int&gt;&gt; h;</span><br><span class="line">        multiset&lt;int&gt; m;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">        //1、将每一个建筑分成“两个部分”，例如:[2,9,10]可以转换成[2，-10][9,10]，我们用负值来表示左边界</span><br><span class="line">        for(const auto&amp; b:buildings)</span><br><span class="line">        &#123;</span><br><span class="line">            h.emplace_back(b[0], -b[2]);</span><br><span class="line">            h.emplace_back(b[1], b[2]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //2、根据x值对分段进行排序</span><br><span class="line">        sort(h.begin(),h.end());</span><br><span class="line">        int prev = 0, cur = 0;</span><br><span class="line">        m.insert(0);</span><br><span class="line"></span><br><span class="line">        //3、遍历</span><br><span class="line">        for (auto &amp;i:h)</span><br><span class="line">        &#123;</span><br><span class="line">            //m是multiset，会对高度进行排序</span><br><span class="line">            if (i.second &lt; 0) m.insert(-i.second);  //左端点，高度入堆</span><br><span class="line">            else m.erase(m.find(i.second));         //右端点，高度出堆</span><br><span class="line"></span><br><span class="line">            cur = *m.rbegin();                      //当前最大高度高度</span><br><span class="line"></span><br><span class="line">            if (cur != prev) &#123;                      //当前最大高度不等于最大高度perv表示这是一个转折点</span><br><span class="line">                res.push_back(&#123;i.first, cur&#125;);      //添加坐标</span><br><span class="line">                prev = cur;                         //更新最大高度</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; buildings = &#123;&#123;2,9,10&#125;, &#123;3,7,15&#125;, &#123;5,12,12&#125;, &#123;15,20,10&#125;, &#123;19,24,8&#125;&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; ans(solution.getSkyline(buildings));</span><br><span class="line">    for(const auto &amp;a : ans)&#123;</span><br><span class="line">        copy(a.begin(), a.end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot;));</span><br><span class="line">        cout &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二刷-1"><a href="#二刷-1" class="headerlink" title="二刷"></a>二刷</h3><ul>
<li>完蛋，一点印象都没有<ul>
<li>隐隐约约记得分治，把多个矩阵合并起来，然后再那啥？ </li>
<li>仔细审题，建筑按照左端点x坐标从小到大排序了</li>
<li>左右两端在整数范围内</li>
<li>下次一定！！明天吧，今天有点晚了</li>
</ul>
</li>
</ul>
<h2 id="219-存在重复元素-II"><a href="#219-存在重复元素-II" class="headerlink" title="219_存在重复元素_II"></a>219_存在重复元素_II</h2><ul>
<li>冲!</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool containsNearbyDuplicate(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        //简单题直接冲</span><br><span class="line">        unordered_map&lt;int, int&gt; map;</span><br><span class="line">        for(int i = 0; i &lt; nums.size(); ++i)&#123;</span><br><span class="line">            if(map.find(nums[i]) == map.end())&#123;</span><br><span class="line">                //若找不到，就加入</span><br><span class="line">                map[nums[i]] = i;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                if(i - map[nums[i]] &lt;= k)</span><br><span class="line">                    return true;</span><br><span class="line">                else</span><br><span class="line">                    map[nums[i]] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="220-存在重复元素-III"><a href="#220-存在重复元素-III" class="headerlink" title="220_存在重复元素_III"></a>220_存在重复元素_III</h2><ul>
<li>不仅要考虑数组边界；还要考虑整数边界；按题意来看，滑动窗口的长度只要不超过<code>k+1</code>即可，又把窗口里面的数字给排序了，我觉得这个方法比较笨，而且由于各种边界问题没通过</li>
<li>。。。可是，我一眼就看到题解的滑动窗口和有序集合</li>
<li>题解还用到了桶排序，因为滑动窗口内，排序更容易找出符合条件的解</li>
<li>而且桶排序比有序集合要快很多</li>
<li>下图是宫水三叶大佬的题解</li>
</ul>
<p><img src="/pictrues/220.png" alt="桶排序" title="桶排序"></p>
<p><img src="/pictrues/220_1.png" alt="桶排序" title="桶排序"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//滑动窗口、有序集合</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool containsNearbyAlmostDuplicate(vector&lt;int&gt;&amp; nums, int k, int t) &#123;</span><br><span class="line">        int n = static_cast&lt;int&gt;(nums.size());</span><br><span class="line">        set&lt;int&gt; rec;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            //第二次遇到lower_bound()函数</span><br><span class="line">            auto iter = rec.lower_bound(max(nums[i], INT_MIN + t) - t);</span><br><span class="line">            if (iter != rec.end() &amp;&amp; *iter &lt;= min(nums[i], INT_MAX - t) + t) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            rec.insert(nums[i]);</span><br><span class="line">            if (i &gt;= k) &#123;</span><br><span class="line">                rec.erase(nums[i - k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221_最大正方形"></a>221_最大正方形</h2><ul>
<li>为什么我的暴力给出的结果不对…还是用下题解；原来我只是在第一层</li>
<li>动态规划，我觉得状态转移方程写不出来，但又感觉能写出来，看题解还是要会证明</li>
<li>动态规划最重要的就是想清楚 <code>d[i,j]</code> 代表着什么，这个太重要了。 这道题中的 <code>d[i, j]</code> 代表的是，以坐标点<code>(i,j)</code> 为右下角的正方形最大边长；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        if (matrix.size() == 0 || matrix[0].size() == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int maxSide = 0;</span><br><span class="line">        int rows = matrix.size(), columns = matrix[0].size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(rows, vector&lt;int&gt;(columns));</span><br><span class="line">        for (int i = 0; i &lt; rows; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; columns; j++) &#123;</span><br><span class="line">                if (matrix[i][j] == &apos;1&apos;) &#123;</span><br><span class="line">                    if (i == 0 || j == 0) &#123;</span><br><span class="line">                        dp[i][j] = 1;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        dp[i][j] = min(min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                    maxSide = max(maxSide, dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int maxSquare = maxSide * maxSide;</span><br><span class="line">        return maxSquare;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="223-矩形面积"><a href="#223-矩形面积" class="headerlink" title="223_矩形面积"></a>223_矩形面积</h2><ul>
<li>这题我也不知道放在哪儿</li>
<li>首先改一下参数名字，方便理解很多，其次就是分几种情况，我以为要写很多，其实几行就可以了，我还是太菜了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) &#123;</span><br><span class="line">        // 调整矩阵的位置，保证第一个矩阵在左下角</span><br><span class="line">        if (A &gt; E)</span><br><span class="line">        &#123;</span><br><span class="line">            return computeArea(E, F, G, H, A, B, C, D);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 计算两个面积之和</span><br><span class="line">        int sum = abs(A-C)*abs(B-D) + abs(E-G)*abs(F-H);</span><br><span class="line"></span><br><span class="line">        // 没有重叠，直接返回两个面积</span><br><span class="line">        if (C &lt;= E || B &gt;= H || D &lt;= F)</span><br><span class="line">        &#123;</span><br><span class="line">            return sum;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 计算重叠的区域</span><br><span class="line">        int overlap = abs(max(A, E)-min(C, G)) * abs(max(B, F)-min(D, H));</span><br><span class="line"></span><br><span class="line">        return sum - overlap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="228-汇总区间"><a href="#228-汇总区间" class="headerlink" title="228_汇总区间"></a>228_汇总区间</h2><ul>
<li>这题目，，有点绕，也就是说找出连续的数字，将他们合并起来！</li>
<li><code>to_string()</code>函数又忘了，通过了，但是内存消耗倒数…</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;iterator&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; summaryRanges(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if(nums.empty())</span><br><span class="line">            return vector&lt;string&gt;();</span><br><span class="line">        auto n = nums.size();</span><br><span class="line"></span><br><span class="line">        if(n == 1)&#123;</span><br><span class="line">            return vector&lt;string&gt;&#123;to_string(nums[0])&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int pre = 0;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        for(int i = 1; i &lt; n; ++i)&#123;</span><br><span class="line">            //不相等才更新pre，这里漏掉最后一个数字，即最后一个数字与前一个不相等</span><br><span class="line">            if(nums[i] != (nums[i - 1] + 1))&#123;</span><br><span class="line">                if(i - pre == 1)&#123;</span><br><span class="line">                    ans.emplace_back(to_string(nums[pre]));</span><br><span class="line">                    pre = i;</span><br><span class="line">                &#125; else&#123;</span><br><span class="line">                    string str = to_string(nums[pre]);</span><br><span class="line">                    str += &quot;-&gt;&quot;;</span><br><span class="line">                    str += to_string(nums[i - 1]);</span><br><span class="line">                    ans.push_back(str);</span><br><span class="line">                    pre = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if(i == n - 1)&#123;</span><br><span class="line">                if(pre == n - 1)&#123;</span><br><span class="line">                    ans.emplace_back(to_string(nums[pre]));</span><br><span class="line">                &#125; else&#123;</span><br><span class="line">                    string str = to_string(nums[pre]);</span><br><span class="line">                    str += &quot;-&gt;&quot;;</span><br><span class="line">                    str += to_string(nums[i]);</span><br><span class="line">                    ans.push_back(str);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//感觉题解好点，while能够方便处理最后的情况</span><br><span class="line">class Solution1 &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; summaryRanges(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;string&gt; ret;</span><br><span class="line">        int i = 0;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        while (i &lt; n) &#123;</span><br><span class="line">            int low = i;</span><br><span class="line">            i++;</span><br><span class="line">            while (i &lt; n &amp;&amp; nums[i] == nums[i - 1] + 1) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            int high = i - 1;</span><br><span class="line">            string temp = to_string(nums[low]);</span><br><span class="line">            if (low &lt; high) &#123;</span><br><span class="line">                temp.append(&quot;-&gt;&quot;);</span><br><span class="line">                temp.append(to_string(nums[high]));</span><br><span class="line">            &#125;</span><br><span class="line">            ret.push_back(move(temp));</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; nums = &#123;0,2,3,4,6,8,9&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;string&gt; ans = solution.summaryRanges(nums);</span><br><span class="line">    copy(ans.begin(), ans.end(), ostream_iterator&lt;string&gt;(cout, &quot; &quot;));</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="229-求众数-II"><a href="#229-求众数-II" class="headerlink" title="229_求众数_II"></a>229_求众数_II</h2><ul>
<li>排序+双指针过了，但是时间消耗很多，难道排序这块出了点问题？</li>
<li>隐含条件：如果两个人的票数都超过了三分之一，剩余的票就不到三分之一了；最终答案元素不会超过两个</li>
<li>摩尔投票法…没听说过</li>
<li>大佬的理解：摩尔投票法本质上就是宾果消消乐游戏，每次消除3个不同的数。由于数组长度为n，因此消消乐最多进行[n/3]次。因此，我们想要的答案（超过[n/3]的数字）一定没有被消除完，一定存在最后活下来的两个数当中。 但是，存活的两个数不一定都是想要的真正的答案，最后再遍历确认一下这两个数是不是答案即可。</li>
<li>这种计数法…以前有道题做过，<code>count++</code>、<code>count--</code>；对，一定做过</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//排序+双指针</span><br><span class="line">class Solution1 &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; majorityElement(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        //出现的次数！！！空间复杂度为常数，那就不能用哈希了</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        vector&lt;int&gt; ans;</span><br><span class="line">        int i = 0;</span><br><span class="line">        while(i &lt; n)&#123;</span><br><span class="line">            if(!ans.empty() &amp;&amp; nums[i] == ans.back())&#123;</span><br><span class="line">                ++i;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //超过n / 3</span><br><span class="line">            int pos = i + n / 3;</span><br><span class="line">            if(pos &lt; n)&#123;</span><br><span class="line">                if(nums[i] == nums[pos])&#123;</span><br><span class="line">                    ans.push_back(nums[i]);</span><br><span class="line">                    i = pos + 1;</span><br><span class="line">                &#125; else&#123;</span><br><span class="line">                    ++i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//消消乐</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; majorityElement(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;int&gt; ans;</span><br><span class="line">        if (nums.empty()) return ans;</span><br><span class="line"></span><br><span class="line">        int cand1, cand2;</span><br><span class="line">        int count1, count2;</span><br><span class="line">        cand1 = cand2 = count1 = count2 = 0;</span><br><span class="line"></span><br><span class="line">        // 抵消阶段</span><br><span class="line">        for (int i = 0; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            if (nums[i] == cand1) count1++;</span><br><span class="line">            else if (nums[i] == cand2) count2++;</span><br><span class="line">            else if (count1 &amp;&amp; count2) &#123;</span><br><span class="line">                count1--;</span><br><span class="line">                count2--;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (!count1) &#123;</span><br><span class="line">                cand1 = nums[i];</span><br><span class="line">                count1++;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                cand2 = nums[i];</span><br><span class="line">                count2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 计数阶段</span><br><span class="line">        count1 = count2 = 0;</span><br><span class="line">        for (int i = 0; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            if (nums[i] == cand1) count1++;</span><br><span class="line">            else if(nums[i] == cand2) count2++; // 必须用else if，保证每个数只算到一个候选人头上</span><br><span class="line">            else &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (count1 &gt; nums.size() / 3) ans.push_back(cand1);</span><br><span class="line">        if (count2 &gt; nums.size() / 3) ans.push_back(cand2);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="238-除自身以外数组的乘积"><a href="#238-除自身以外数组的乘积" class="headerlink" title="238_除自身以外数组的乘积"></a>238_除自身以外数组的乘积</h2><ul>
<li>不能用除法</li>
<li>一个前缀，一个后缀，但想不出来，怎么用常数空间；输出数组不算进复杂度之内，那就在数组数组下文章即可</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;iterator&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution1 &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        auto n = nums.size();</span><br><span class="line">        if(n &lt; 2)</span><br><span class="line">            return nums;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; tmp(2, vector&lt;int&gt;(n, 0));</span><br><span class="line">        int l = 0, r = n - 1;</span><br><span class="line">        while(l &lt; n)&#123;</span><br><span class="line">            tmp[0][l] = (l == 0 ? nums[l] : (tmp[0][l - 1] * nums[l]));</span><br><span class="line">            tmp[1][r] = (r == n - 1 ? nums[r] : (tmp[1][r + 1] * nums[r]));</span><br><span class="line">            ++l;</span><br><span class="line">            --r;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; ans(n, 0);</span><br><span class="line">        ans[0] = tmp[1][1];</span><br><span class="line">        r = 1;</span><br><span class="line">        while(r &lt; n)&#123;</span><br><span class="line">            if(r != n - 1)</span><br><span class="line">                ans[r] = tmp[0][r - 1] * tmp[1][r + 1];</span><br><span class="line">            else</span><br><span class="line">                ans[r] = tmp[0][r - 1];</span><br><span class="line">            ++r;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//题解</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int length = nums.size();</span><br><span class="line">        vector&lt;int&gt; answer(length);</span><br><span class="line"></span><br><span class="line">        // answer[i] 表示索引 i 左侧所有元素的乘积</span><br><span class="line">        // 因为索引为 &apos;0&apos; 的元素左侧没有元素， 所以 answer[0] = 1</span><br><span class="line">        answer[0] = 1;</span><br><span class="line">        for (int i = 1; i &lt; length; i++) &#123;</span><br><span class="line">            answer[i] = nums[i - 1] * answer[i - 1];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // R 为右侧所有元素的乘积</span><br><span class="line">        // 刚开始右边没有元素，所以 R = 1</span><br><span class="line">        int R = 1;</span><br><span class="line">        for (int i = length - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">            // 对于索引 i，左边的乘积为 answer[i]，右边的乘积为 R</span><br><span class="line">            answer[i] = answer[i] * R;</span><br><span class="line">            // R 需要包含右边所有的乘积，所以计算下一个结果时需要将当前值乘到 R 上</span><br><span class="line">            R *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; nums = &#123;1,2,3,4&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;int&gt; ans(solution.productExceptSelf(nums));</span><br><span class="line">    copy(ans.begin(), ans.end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot;));</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239_滑动窗口最大值"></a>239_滑动窗口最大值</h2><ul>
<li>除了暴力，我想不到好的方法…</li>
<li>每日一题的背包问题，花费了不少精力，，，出现问题是好事！把问题解决了就说明理解了</li>
<li>优先队列——之前有一题，应该也是每日一题，有小根堆、大根堆</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        priority_queue&lt;pair&lt;int, int&gt;&gt; q;</span><br><span class="line">        for (int i = 0; i &lt; k; ++i) &#123;</span><br><span class="line">            q.emplace(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; ans = &#123;q.top().first&#125;;</span><br><span class="line">        for (int i = k; i &lt; n; ++i) &#123;</span><br><span class="line">            q.emplace(nums[i], i);</span><br><span class="line">            while (q.top().second &lt;= i - k) &#123;</span><br><span class="line">                q.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(q.top().first);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="240-搜索二维矩阵-II"><a href="#240-搜索二维矩阵-II" class="headerlink" title="240_搜索二维矩阵_II"></a>240_搜索二维矩阵_II</h2><ul>
<li>总是少了很多特例，比如只有一个数字、只有一行、只有一列、、或者更新中点时，一直停留在原地…</li>
<li>对哦，我怎么把暴力法给忘了呢！！</li>
<li>同样是二分，为什么我的这么烂</li>
<li>题解四最容易理解，从左下角出发，根据条件判断向上还是向右；至于为什么从左下角出发：选左上角，往右走和往下走都增大，不能选；选右下角，往上走和往左走都减小，不能选；选左下角，往右走增大，往上走减小，可选；选右上角，往下走增大，往左走减小，可选</li>
<li>大佬：这个二维数组就类似一棵排序二叉树，对于每一个数来说，上方的数都小于它，右边的数都大于它，所以把左下角作为根节点开始查找！</li>
<li>看来每日一题（困难）要CV了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123;</span><br><span class="line">        auto m = matrix.size(), n = matrix[0].size();</span><br><span class="line"></span><br><span class="line">        if(target &lt; matrix[0][0] || target &gt; matrix[m - 1][n - 1])</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        int x = m - 1, y = 0;</span><br><span class="line">        while(x &gt;= 0 &amp;&amp; y &lt; n)&#123;</span><br><span class="line">            if(matrix[x][y] == target) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;else if(matrix[x][y] &gt; target)&#123;</span><br><span class="line">                --x;</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                ++y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="260-只出现一次的数字-III"><a href="#260-只出现一次的数字-III" class="headerlink" title="260_只出现一次的数字_III"></a>260_只出现一次的数字_III</h2><ul>
<li>想用异或前缀和实现，但是会出现其他干扰，即异或答案是对的，但不是想要的答案，甚至有的数字都没有出现过</li>
<li>要不就反着再遍历一次？也没用，而且我不是常数空间…</li>
<li>题解真的是太牛皮了…可是为什么至选择一位不为0呢，想了想好像是理所当然的，非0即1！！</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; singleNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int ret = 0;</span><br><span class="line">        for (int n : nums)</span><br><span class="line">            ret ^= n;</span><br><span class="line">        int div = 1;</span><br><span class="line">        while ((div &amp; ret) == 0)</span><br><span class="line">            div &lt;&lt;= 1;</span><br><span class="line"></span><br><span class="line">        int a = 0, b = 0;</span><br><span class="line">        for (int n : nums)</span><br><span class="line">            if (div &amp; n)</span><br><span class="line">                a ^= n;</span><br><span class="line">            else</span><br><span class="line">                b ^= n;</span><br><span class="line">        return vector&lt;int&gt;&#123;a, b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="268-丢失的数字"><a href="#268-丢失的数字" class="headerlink" title="268_丢失的数字"></a>268_丢失的数字</h2><ul>
<li>这里求个和就解决了，我真机智</li>
<li>看了评论；数学求和有溢出风险，不过题解的位运算真的惊艳到我了<ul>
<li>先对<code>[0,n]</code>求异或，然后将结果分别对<code>nums</code>数组元素进行异或，最终可以得到缺失的值</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;numeric&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int missingNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        // 这里accumulate是有返回值的</span><br><span class="line">        int sum = accumulate(nums.begin(), nums.end(), 0);</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        int tmp = n * (n + 1) / 2;</span><br><span class="line">        return tmp - sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="274-H-指数"><a href="#274-H-指数" class="headerlink" title="274_H 指数"></a>274_H 指数</h2><ul>
<li>暴力居然成功了（注意点是引用次数至少大于等于h），，，应该用动态规划</li>
<li>原来是排序！好好学习下计数排序——我还是太菜了，评论都说排序是最傻的方法…</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//暴力</span><br><span class="line">class Solution1 &#123;</span><br><span class="line">public:</span><br><span class="line">    int hIndex(vector&lt;int&gt;&amp; citations) &#123;</span><br><span class="line">        if(citations.empty())</span><br><span class="line">            return 0;</span><br><span class="line">        //论文数与至少的引用数一样</span><br><span class="line">        auto n = citations.size();</span><br><span class="line"></span><br><span class="line">        //大于等于i次引用的一共有几篇；应该遍历一次就应该知道最终答案，每遍历一个数字，就要更新对应的数字</span><br><span class="line">        vector&lt;int&gt; tmp(n, 0);</span><br><span class="line">        for(const auto &amp;c : citations)&#123;</span><br><span class="line">            if(c &gt;= n)&#123;</span><br><span class="line">                //所有的元素都要加一</span><br><span class="line">                for(auto &amp;t : tmp)&#123;</span><br><span class="line">                    ++t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else if(c &gt; 0)&#123;</span><br><span class="line">                for(int i = 0; i &lt; c; ++i)&#123;</span><br><span class="line">                    ++tmp[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = n - 1; i &gt;= 0; --i)&#123;</span><br><span class="line">            if(tmp[i] == i + 1)</span><br><span class="line">                return i + 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//排序</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int hIndex(vector&lt;int&gt;&amp; citations) &#123;</span><br><span class="line">        sort(citations.begin(), citations.end());</span><br><span class="line">        //这里要从后往前遍历</span><br><span class="line">        int i = 0;</span><br><span class="line">        while(i &lt; citations.size() &amp;&amp; citations[citations.size() - 1 - i] &gt; i)&#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        return i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二刷-2"><a href="#二刷-2" class="headerlink" title="二刷"></a>二刷</h3><ul>
<li>本来想二刷的，但看到了之前的几行代码，然后二刷了个寂寞<ul>
<li>这样吧，把<code>i = 0</code>改成最后。不太好改！</li>
<li>因为<code>i</code>就是最后要输出的结果！！</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//上面那个好像就是自己写的，这才是题解！！！</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int hIndex(vector&lt;int&gt;&amp; citations) &#123;</span><br><span class="line">        sort(citations.begin(), citations.end());</span><br><span class="line">        int h = 0, i = citations.size() - 1;</span><br><span class="line">        while (i &gt;= 0 &amp;&amp; citations[i] &gt; h) &#123;</span><br><span class="line">            h++;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        return h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="275-H-指数-II"><a href="#275-H-指数-II" class="headerlink" title="275_H 指数_II"></a>275_H 指数_II</h2><ul>
<li>二分、左边界、返回<code>n - l</code>——搞定</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int hIndex(vector&lt;int&gt;&amp; citations) &#123;</span><br><span class="line">        //这个，，，是跟上题一样好像，对数时间，先用二分看看</span><br><span class="line">        if(citations.back() == 0) return 0;</span><br><span class="line"></span><br><span class="line">        //应该是左边界</span><br><span class="line">        int n = citations.size();</span><br><span class="line">        int l = 0, r = n;</span><br><span class="line">        while(l &lt; r)&#123;</span><br><span class="line">            int mid = l + (r - l) / 2;</span><br><span class="line">            if(citations[mid] &gt;= (n - mid))&#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                l = mid + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //最后l所在的元素是起点，一直到最后元素的个数才是答案</span><br><span class="line">        return n - l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二刷-3"><a href="#二刷-3" class="headerlink" title="二刷"></a>二刷</h3><ul>
<li>既然排好序了，那就用二分法<ul>
<li>手撕下</li>
<li>可以，一次过</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//二刷</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int hIndex(vector&lt;int&gt;&amp; citations) &#123;</span><br><span class="line">        //下标是i，那么个数就是i+1个</span><br><span class="line">        //直观来看，应该看下标i对应的数字 是否大于 以及之后所有的数字的个数+1（包含本身）</span><br><span class="line">        if(citations.empty()) return 0;</span><br><span class="line">        int n = citations.size();</span><br><span class="line">        int l = 0, r = n;</span><br><span class="line"></span><br><span class="line">        while(l &lt; r)&#123;</span><br><span class="line">            int mid = (r - l) / 2 + l;</span><br><span class="line">            int tmp = n - mid; //个数</span><br><span class="line">            if(citations[mid] &gt;= tmp)&#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                l = mid + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //l对应的位置就是符合条件的位置</span><br><span class="line">        return n - l;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="278-第一个错误的版本"><a href="#278-第一个错误的版本" class="headerlink" title="278_第一个错误的版本"></a>278_第一个错误的版本</h2><ul>
<li>这是之前的每日一题，还是简单题，（看过了labuladong的二分题解后）再做一遍；之后粘贴下两次的代码，比较下，如何防止边界溢出等等…</li>
<li>原来我之前已经改好了…</li>
<li>这里有个接口，就不放在<code>Clion</code>里了，也就是查找左边界</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// The API isBadVersion is defined for you.</span><br><span class="line">// bool isBadVersion(int version);</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int firstBadVersion(int n) &#123;</span><br><span class="line">        int l = 1, r = n;</span><br><span class="line">        while(l &lt; r)&#123;</span><br><span class="line">            //这里超出整数边界了</span><br><span class="line">            //long long mid = (l + r) / 2;</span><br><span class="line">            //get新知识点     int mid = left + (right - left) / 2; // 防止计算时溢出</span><br><span class="line">            int mid = l + (r - l) / 2;</span><br><span class="line">            //这样就不用long long</span><br><span class="line">            if(isBadVersion(mid))&#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                l = mid + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279_完全平方数"></a>279_完全平方数</h2><ul>
<li>这是每日一题的背包问题，正好做到了，再复习下！康康那个算法小抄</li>
<li>因为不知道放在哪个类别，因为背包用到了<code>vector</code>，所以就放在这里吧:)</li>
<li>思考了半天！终于自己写出了完全背包，对背包题的理解进一步加深！这里放个链接，<a href="https://cosmicxk.github.io/2019/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#more" target="_blank" rel="noopener">背包心得</a>——背包问题，这里就不在赘述，注释也写的很清楚</li>
<li>不过这题用完全背包遍历了很多没有必要的状态！题解用的直接是动态规划！——不过题解好像就是完全背包经过状态压缩得到的！</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;iterator&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution1 &#123;</span><br><span class="line">public:</span><br><span class="line">    int numSquares(int n) &#123;</span><br><span class="line">        //完全背包——每个物品的数量无限</span><br><span class="line">        //先算出平方数的种数</span><br><span class="line">        int l = static_cast&lt;int&gt;(sqrt(n));</span><br><span class="line">        //一般前者是物体，后者是重量——这里的dp只能是方法的个数，而不是最大或者最小，这个要另外再判断</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(l + 1, vector&lt;int&gt;(n + 1, 0));</span><br><span class="line">        //重量为0，置1——边界初始化</span><br><span class="line">        for(int j = 1; j &lt; n + 1; ++j)&#123;</span><br><span class="line">            //这里的j是1的个数，因为只有1这个平方数</span><br><span class="line">            dp[1][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        //dp[i][j]表示前i个平方数，和为j，所用到的最小个数</span><br><span class="line">        for(int i = 2; i &lt; l + 1; ++i)&#123;</span><br><span class="line">            for(int j = 1; j &lt; n + 1; ++j)&#123;</span><br><span class="line">                //不选第i个平方数，这里i要大于1——所以这里直接赋值，而不是取小</span><br><span class="line">                dp[i][j] = dp[i - 1][j];</span><br><span class="line">                //选第i个物品——这里是取小，而不是加，因为要最小个数，而不是一共有多少种</span><br><span class="line">                if(j &gt;= (i * i))&#123;</span><br><span class="line">                    //还有是dp[i][j - i * i]而不是dp[i - 1][j - i * i]，因为是完全背包</span><br><span class="line">                    //比如和为12，取平方数4，那么12-4=8也可以取平方数4！即和为8的前4个平方数的最小个数</span><br><span class="line">                    //还有个问题如果是9，直接取平方数3，所以是dp[3][9]=1</span><br><span class="line">                    dp[i][j] = min(dp[i][j], dp[i][j - i * i] + 1); //取了这个平方数，这里就要加1</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(const auto&amp; d : dp)&#123;</span><br><span class="line">            copy(d.begin(), d.end(), ostream_iterator&lt;int&gt;(cout, &quot;    &quot;));</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[l][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//题解</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int numSquares(int n) &#123;</span><br><span class="line">        vector&lt;int&gt; f(n + 1);</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            //这里i每次都会重新生成minn——用来记录最小个数</span><br><span class="line">            int minn = INT_MAX;</span><br><span class="line">            //这里的j就是平方数，从1开始！</span><br><span class="line">            for (int j = 1; j * j &lt;= i; j++) &#123;</span><br><span class="line">                minn = min(minn, f[i - j * j]);</span><br><span class="line">            &#125;</span><br><span class="line">            //这个加一是选择数字的个数——第二个for循环是选择</span><br><span class="line">            f[i] = minn + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n = 12;</span><br><span class="line">    Solution solution;</span><br><span class="line">    int ans = solution.numSquares(n);</span><br><span class="line">    cout &lt;&lt; &quot;ans = &quot; &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283_移动零"></a>283_移动零</h2><ul>
<li>还是比较简单的，双指针即可，再学习下题解是怎么做的</li>
<li>题解没有覆盖，而是<code>swap</code>交换，毕竟是移动0</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//自己手撕</span><br><span class="line">class Solution1 &#123;</span><br><span class="line">public:</span><br><span class="line">    void moveZeroes(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if(nums.empty())</span><br><span class="line">            return;</span><br><span class="line"></span><br><span class="line">        //双指针？</span><br><span class="line">        int pre = 0, cur = 0;</span><br><span class="line">        while(cur &lt; nums.size())&#123;</span><br><span class="line">            if(nums[cur] == 0)&#123;</span><br><span class="line">                ++cur;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                //如果不是0，得分情况</span><br><span class="line">                if(pre == cur)&#123;</span><br><span class="line">                    //说明还没有出现0！</span><br><span class="line">                    ++pre;</span><br><span class="line">                    ++cur;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    //pre还停留在上个0的起始位置，之后就是连续的覆盖</span><br><span class="line">                    nums[pre++] = nums[cur];</span><br><span class="line">                    ++cur;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(cur != pre)&#123;</span><br><span class="line">            while(pre &lt; nums.size())&#123;</span><br><span class="line">                nums[pre++] = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//题解交换</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void moveZeroes(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size(), left = 0, right = 0;</span><br><span class="line">        while (right &lt; n) &#123;</span><br><span class="line">            //如果不为0，那么两个指针一样，即自己交换自己</span><br><span class="line">            if (nums[right]) &#123;</span><br><span class="line">                swap(nums[left], nums[right]);</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="284-顶端迭代器"><a href="#284-顶端迭代器" class="headerlink" title="284_顶端迭代器"></a>284_顶端迭代器</h2><ul>
<li>恕我直言，这题没看懂，力扣没看懂的题不是一次两次了！不知道我从小语文就很差嘛！</li>
<li>这里引用大佬的思路</li>
</ul>
<p><img src="/pictrues/284.png" alt title="题解"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Iterator &#123;</span><br><span class="line">    struct Data;</span><br><span class="line">    Data* data;</span><br><span class="line">public:</span><br><span class="line">    Iterator(const vector&lt;int&gt;&amp; nums);</span><br><span class="line">    Iterator(const Iterator&amp; iter);</span><br><span class="line"></span><br><span class="line">    // Returns the next element in the iteration.</span><br><span class="line">    int next();</span><br><span class="line"></span><br><span class="line">    // Returns true if the iteration has more elements.</span><br><span class="line">    bool hasNext() const;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class PeekingIterator : public Iterator &#123;</span><br><span class="line">private:</span><br><span class="line">    int _val;</span><br><span class="line">    bool _next;</span><br><span class="line">public:</span><br><span class="line">    PeekingIterator(const vector&lt;int&gt;&amp; nums) : Iterator(nums) &#123;</span><br><span class="line">        _next = Iterator::hasNext();</span><br><span class="line">        if(_next) _val = Iterator::next();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int peek() &#123;</span><br><span class="line">        return _val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int next() &#123;</span><br><span class="line">        int cur = _val;</span><br><span class="line">        _next = Iterator::hasNext();</span><br><span class="line">        if(_next) _val = Iterator::next();</span><br><span class="line">        return cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool hasNext() const &#123;</span><br><span class="line">        return _next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="287-寻找重复数"><a href="#287-寻找重复数" class="headerlink" title="287_寻找重复数"></a>287_寻找重复数</h2><ul>
<li>之前做过这样的思路——投票<ul>
<li>重复的数，票数是最多的！但是忘了是哪一题了</li>
</ul>
</li>
<li>最好的情况是只有两个不同的数字，其中一个只有一个，剩下的全是重复的另一个；最坏的情况是1~n的数字都有，重复的那个只出现两次</li>
<li>想了半天想不出来（不用哈希）——问题是题解的三种方法我居然看不懂！！</li>
<li>居然还可以用快慢指针！！！这里截一下大佬的题解——以后面试，也不能一招吃遍鲜，那样显得底蕴太少<ul>
<li>最近见到好多<code>do-while</code>循环体</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/287.png" alt title="快慢指针"></p>
<p><img src="/pictrues/287_1.png" alt title="下标0位置不可能在环内"></p>
<ul>
<li>看到这个图的时候，我知道懂了！</li>
</ul>
<p><img src="/pictrues/287_2.png" alt title="下标与元素的值进行映射"></p>
<ul>
<li><p>这题与142题的区别</p>
<ul>
<li>慢指针走一步 <code>slow = slow.next</code> ==&gt; 本题 <code>slow = nums[slow]</code></li>
<li>快指针走两步 <code>fast = fast.next.next</code> ==&gt; 本题 <code>fast = nums[nums[fast]]</code></li>
</ul>
</li>
<li><p>光顾着博客和力扣了，第二天才发现本地<code>Clion</code>还空着….</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//快慢指针</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findDuplicate(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int slow = 0, fast = 0;</span><br><span class="line">        //这里是判断环</span><br><span class="line">        do &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">        &#125; while (slow != fast);</span><br><span class="line"></span><br><span class="line">        //这里慢指针置0，之后两指针都依次走一步，相遇点即是重复点</span><br><span class="line">        slow = 0;</span><br><span class="line">        while (slow != fast) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        return slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="289-生命游戏"><a href="#289-生命游戏" class="headerlink" title="289_生命游戏"></a>289_生命游戏</h2><ul>
<li>细胞自动机学一下——复制原矩阵、复合状态</li>
<li>还有种思路很厉害——也需要遍历周围8个格子——可以一次过！</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//根据大佬的思路重新手撕一遍</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    //</span><br><span class="line">    void gameOfLife(vector&lt;vector&lt;int&gt;&gt;&amp; board) &#123;</span><br><span class="line">        int r = static_cast&lt;int&gt;(board.size());</span><br><span class="line">        int c = static_cast&lt;int&gt;(board[0].size());</span><br><span class="line"></span><br><span class="line">        int neighbors[3] = &#123;-1, 0, 1&#125;;</span><br><span class="line">        //遍历原矩阵，只针对活着的细胞，格子为1或者个位数为1</span><br><span class="line">        for(int i = 0; i &lt; r; ++i)&#123;</span><br><span class="line">            for(int j = 0; j &lt; c; ++j)&#123;</span><br><span class="line">                //活着的细胞个位数一定为1</span><br><span class="line">                if(board[i][j] % 10 == 0)</span><br><span class="line">                    continue;</span><br><span class="line"></span><br><span class="line">                //这里学习下，遍历周围8个格子的小技巧，首先自己是排除在外的</span><br><span class="line">                for(int _i = 0; _i &lt; 3; ++_i)&#123;</span><br><span class="line">                    for(int _j = 0; _j &lt; 3; ++_j)&#123;</span><br><span class="line">                        if(!(_i == 1 &amp;&amp; _j == 1))&#123;</span><br><span class="line">                            int _r = i + neighbors[_i];</span><br><span class="line">                            int _c = j + neighbors[_j];</span><br><span class="line">                            //不能超出边界，周围8个格子都加10</span><br><span class="line">                            if(_r &gt;= 0 &amp;&amp; _r &lt; r &amp;&amp; _c &gt;= 0 &amp;&amp; _c &lt; c)&#123;</span><br><span class="line">                                board[_r][_c] += 10;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //二次遍历</span><br><span class="line">        for(int i = 0; i &lt; r; ++i)&#123;</span><br><span class="line">            for(int j = 0; j &lt; c; ++j)&#123;</span><br><span class="line">                //四个规则，活细胞三个，死细胞一个</span><br><span class="line">                if(board[i][j] % 10 == 1)&#123;</span><br><span class="line">                    if(board[i][j] &lt; 21) board[i][j] = 0;</span><br><span class="line">                    if(board[i][j] == 21 || board[i][j] == 31) board[i][j] = 1;</span><br><span class="line">                    if(board[i][j] &gt; 31) board[i][j] = 0;</span><br><span class="line"></span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    if(board[i][j] == 30)&#123;</span><br><span class="line">                        board[i][j] = 1;</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line">                        //死细胞周围不是正好3个活细胞，也要重置</span><br><span class="line">                        board[i][j] = 0;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="295-数据流的中位数"><a href="#295-数据流的中位数" class="headerlink" title="295_数据流的中位数"></a>295_数据流的中位数</h2><ul>
<li><p>感觉数据结构可能会有数组，就放在数组这儿了</p>
</li>
<li><p>粘贴下昨晚写的思路</p>
<ul>
<li>首先每次放入数字，都要排好序，还要有一个总数，再加上两个指针</li>
<li>有了总数，可以迅速定位中位数，或者直接根据下标访问数字，来求中位数，但是又要排好序</li>
<li>直接用<code>vector&lt;int&gt;(101)</code>，对应的元素放数字（也就是下标的个数），并且初始化两个指针，之后根据放入的数字在指针左还是右，以及指针左右两边的数字总数（这个应该不需要，还是需要一个数来记录下左边的总数吧，不然后面不好判断指针是否需要移动），判断是否需要移动指针</li>
<li>指针移动时，找到数组第一个不为0的元素即可，就是判断是否移动，比较麻烦点，因为会有很多重复的数字，要不是提示所有整数都在0-100之间，还真不容易想到</li>
</ul>
</li>
<li><p>做到最后我傻眼了，怎么还有负数？</p>
<ul>
<li>如果这样，那得用双向链表了？<ul>
<li>双向链表在移动指针时比较方便</li>
</ul>
</li>
<li>成功了，但是消耗比较高</li>
</ul>
</li>
<li><p>看看题解咋做的</p>
<ul>
<li>方法一，数组 + <code>sort()</code>排序超时</li>
<li>方法二，还是数组 + 插入排序，又忘了这个函数<code>lower_bound(store.begin(), store.end(), num)</code>返回的是位置</li>
<li>方法三，原来堆这么好用嘛<ul>
<li>两个堆，一个放大数、一个放小数，之后要平衡这两个堆！（优先级队列？）</li>
<li>最大堆可以比最小堆多一个元素</li>
<li>完全平衡时，返回两个堆顶元素，否则，返回大堆的顶元素</li>
<li>好处就是不用比较，直接按步骤来，先放入<code>lo</code>，如果两个堆数目不等——再将<code>lo</code>的最大元素放入<code>hi</code><ul>
<li>这里会出现一个问题，<code>hi</code>会有数字比<code>lo</code>小，所以应该是先放<code>lo</code>，再放<code>hi</code>，——这一步是为了确保<code>hi</code>的数字比<code>lo</code>大；然后反过来，确保<code>lo</code>长度不会比<code>hi</code>小!</li>
</ul>
</li>
<li>默认生成的优先级队列，第一个元素是最大的——如果加入<code>greater&lt;int&gt;</code>，那么第一个数字就是最小的</li>
</ul>
</li>
<li>方法四，自平衡二叉树<ul>
<li>也是用的双指针，看看是怎么实现的，<code>multiset&lt;int&gt;</code>是不是从小到大默认排好序的？艹，一种植物</li>
<li>之后根据奇偶数来更新</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//双向链表，手撕</span><br><span class="line">struct myList&#123;</span><br><span class="line">    myList* pre;</span><br><span class="line">    myList* next;</span><br><span class="line">    int val;</span><br><span class="line">    //构造函数</span><br><span class="line">    myList() : pre(nullptr), next(nullptr), val(0)&#123;&#125;</span><br><span class="line">    explicit myList(int val) : pre(nullptr), next(nullptr), val(val)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class MedianFinder1 &#123;</span><br><span class="line">public:</span><br><span class="line">    /* initialize your data structure here. */</span><br><span class="line">    MedianFinder1() : l(nullptr), r(nullptr), n(0)&#123;</span><br><span class="line">        head = new myList(INT32_MIN);</span><br><span class="line">        tail = new myList(INT32_MAX);</span><br><span class="line">        head-&gt;next = tail;</span><br><span class="line">        tail-&gt;pre = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void addNum(int num) &#123;</span><br><span class="line">        if(!l)&#123;</span><br><span class="line">            ++n;</span><br><span class="line">            //第一次放数据</span><br><span class="line">            head-&gt;next = new myList(num);</span><br><span class="line">            head-&gt;next-&gt;pre = head;</span><br><span class="line">            head-&gt;next-&gt;next = tail;</span><br><span class="line">            tail-&gt;pre = head-&gt;next;</span><br><span class="line">            //初始化两个指针</span><br><span class="line">            l = head-&gt;next;</span><br><span class="line">            r = head-&gt;next;</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">            ++n;</span><br><span class="line">            //因该先加节点，再判断奇偶数！——不对，这样也不好判断</span><br><span class="line">            if(n % 2 == 0)&#123;</span><br><span class="line">                //俩指针需要分开</span><br><span class="line">                if(l-&gt;val &gt;= num)&#123;</span><br><span class="line">                    myList* carry = l-&gt;pre;</span><br><span class="line">                    //找到第一个比num不大的节点</span><br><span class="line">                    while (carry-&gt;pre != nullptr &amp;&amp; carry-&gt;val &gt;= num)&#123;</span><br><span class="line">                        carry = carry-&gt;pre;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //在carry的右边新建节点</span><br><span class="line">                    auto tmp = carry-&gt;next;</span><br><span class="line">                    carry-&gt;next = new myList(num);</span><br><span class="line">                    carry-&gt;next-&gt;pre = carry;</span><br><span class="line">                    tmp-&gt;pre = carry-&gt;next;</span><br><span class="line">                    carry-&gt;next-&gt;next = tmp;</span><br><span class="line">                    //左指针左移</span><br><span class="line">                    l = l-&gt;pre;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    myList* carry = r-&gt;next;</span><br><span class="line">                    //找到第一个比num不小的节点</span><br><span class="line">                    while (carry-&gt;next != nullptr &amp;&amp; carry-&gt;val &lt; num)&#123;</span><br><span class="line">                        carry = carry-&gt;next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //在carry的左边新建节点</span><br><span class="line">                    auto tmp = carry-&gt;pre;</span><br><span class="line">                    tmp-&gt;next = new myList(num);</span><br><span class="line">                    tmp-&gt;next-&gt;pre = tmp;</span><br><span class="line"></span><br><span class="line">                    carry-&gt;pre = tmp-&gt;next;</span><br><span class="line">                    tmp-&gt;next-&gt;next = carry;</span><br><span class="line">                    //右指针右移</span><br><span class="line">                    r = r-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                //俩指针需要归一</span><br><span class="line">                if(l-&gt;val &gt;= num)&#123;</span><br><span class="line">                    auto carry = l-&gt;pre;</span><br><span class="line">                    while(carry-&gt;pre != nullptr &amp;&amp; carry-&gt;val &gt;= num)&#123;</span><br><span class="line">                        carry = carry-&gt;pre;</span><br><span class="line">                    &#125;</span><br><span class="line">                    auto tmp = carry-&gt;next;</span><br><span class="line">                    carry-&gt;next = new myList(num);</span><br><span class="line">                    carry-&gt;next-&gt;pre = carry;</span><br><span class="line">                    carry-&gt;next-&gt;next = tmp;</span><br><span class="line">                    tmp-&gt;pre = carry-&gt;next;</span><br><span class="line">                    //右指针左移</span><br><span class="line">                    r = r-&gt;pre;</span><br><span class="line">                &#125;else if(r-&gt;val &lt;= num)&#123;</span><br><span class="line">                    auto carry = r-&gt;next;</span><br><span class="line">                    while (carry-&gt;next != nullptr &amp;&amp; carry-&gt;val &lt;= num)&#123;</span><br><span class="line">                        carry = carry-&gt;next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    auto tmp = carry-&gt;pre;</span><br><span class="line">                    tmp-&gt;next = new myList(num);</span><br><span class="line">                    tmp-&gt;next-&gt;pre = tmp;</span><br><span class="line">                    tmp-&gt;next-&gt;next = carry;</span><br><span class="line">                    carry-&gt;pre = tmp-&gt;next;</span><br><span class="line">                    //左指针右移</span><br><span class="line">                    l = l-&gt;next;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    l-&gt;next = new myList(num);</span><br><span class="line">                    l-&gt;next-&gt;pre = l;</span><br><span class="line">                    l-&gt;next-&gt;next = r;</span><br><span class="line">                    r-&gt;pre = l-&gt;next;</span><br><span class="line">                    //归一</span><br><span class="line">                    l = l-&gt;next;</span><br><span class="line">                    r = r-&gt;pre;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    double findMedian() &#123;</span><br><span class="line">        </span><br><span class="line">        return static_cast&lt;double&gt;(l-&gt;val + r-&gt;val) / 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    //这两个指针用来</span><br><span class="line">    myList* l;</span><br><span class="line">    myList* r;</span><br><span class="line">    //head和tail之间存放数据</span><br><span class="line">    myList* head;</span><br><span class="line">    myList* tail;</span><br><span class="line">    //用来判断奇偶数</span><br><span class="line">    int n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//插入排序</span><br><span class="line">class MedianFinder2 &#123;</span><br><span class="line">    vector&lt;int&gt; store; // resize-able container</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    // Adds a number into the data structure.</span><br><span class="line">    void addNum(int num)</span><br><span class="line">    &#123;</span><br><span class="line">        if (store.empty())</span><br><span class="line">            store.push_back(num);</span><br><span class="line">        else</span><br><span class="line">            store.insert(lower_bound(store.begin(), store.end(), num), num);     // binary search and insertion combined</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Returns the median of current data stream</span><br><span class="line">    double findMedian()</span><br><span class="line">    &#123;</span><br><span class="line">        int n = store.size();</span><br><span class="line">        return n &amp; 1 ? store[n / 2] : (store[n / 2 - 1] + store[n / 2]) * 0.5;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//优先级队列</span><br><span class="line">class MedianFinder3 &#123;</span><br><span class="line">    priority_queue&lt;int&gt; lo;                              // max heap</span><br><span class="line">    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; hi;   // min heap</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    // Adds a number into the data structure.</span><br><span class="line">    void addNum(int num)</span><br><span class="line">    &#123;</span><br><span class="line">        lo.push(num);                                    // Add to max heap</span><br><span class="line">        //确保hi的数字比lo大</span><br><span class="line">        hi.push(lo.top());</span><br><span class="line">        lo.pop();</span><br><span class="line"></span><br><span class="line">        if (lo.size() &lt; hi.size()) &#123;</span><br><span class="line">            //平衡，确保`lo`长度不会比`hi`小</span><br><span class="line">            lo.push(hi.top());</span><br><span class="line">            hi.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Returns the median of current data stream</span><br><span class="line">    double findMedian()</span><br><span class="line">    &#123;</span><br><span class="line">        return lo.size() &gt; hi.size() ? (double) lo.top() : (lo.top() + hi.top()) * 0.5;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//自平衡二叉树</span><br><span class="line">class MedianFinder &#123;</span><br><span class="line">    multiset&lt;int&gt; data;</span><br><span class="line">    multiset&lt;int&gt;::iterator lo_median, hi_median;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    MedianFinder() : lo_median(data.end()), hi_median(data.end())&#123;&#125;</span><br><span class="line"></span><br><span class="line">    void addNum(int num)&#123;</span><br><span class="line">        const size_t n = data.size();   // store previous size</span><br><span class="line">        data.insert(num);               // insert into multiset</span><br><span class="line"></span><br><span class="line">        if (!n) &#123;</span><br><span class="line">            // no elements before, one element now</span><br><span class="line">            lo_median = hi_median = data.begin();</span><br><span class="line">        &#125;</span><br><span class="line">        else if (n &amp; 1) &#123;</span><br><span class="line">            // odd size before (i.e. lo == hi), even size now (i.e. hi = lo + 1)</span><br><span class="line">            if (num &lt; *lo_median)       // num &lt; lo</span><br><span class="line">                lo_median--;</span><br><span class="line">            else                        // num &gt;= hi</span><br><span class="line">                hi_median++;            // insertion at end of equal range</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            // even size before (i.e. hi = lo + 1), odd size now (i.e. lo == hi)</span><br><span class="line">            if (num &gt; *lo_median &amp;&amp; num &lt; *hi_median) &#123;</span><br><span class="line">                lo_median++;                    // num in between lo and hi</span><br><span class="line">                hi_median--;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (num &gt;= *hi_median)         // num inserted after hi</span><br><span class="line">                lo_median++;</span><br><span class="line">            else                                // num &lt;= lo &lt; hi</span><br><span class="line">                lo_median = --hi_median;        // insertion at end of equal range spoils lo</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    double findMedian()&#123;</span><br><span class="line">        return (*lo_median + *hi_median) * 0.5;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这题告一段落了</li>
</ul>
<h2 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300_最长递增子序列"></a>300_最长递增子序列</h2><ul>
<li>这题想了两天没啥好的思路，总感觉似曾相识<ul>
<li>印象中，之前用了递归，因为不是遇到大的数字就选择，也可以不选这个数字，因为这个数字可能过大，导致整体长度小</li>
<li>之前递归不出所料应该超时了，，，看看能不能用动态规划</li>
<li>这题我属实不会</li>
<li>看了题解的一句话——定义 <code>dp[i]</code> 为考虑前 <code>i</code> 个元素，以第 <code>i</code> 个数字结尾的最长上升子序列的长度，注意 <code>nums[i]</code> 必须被选取。<ul>
<li>我就知道似曾相识！！最后结果就是遍历一遍数组，取最大值，这个在之前某个题目里用到过！当时还特地问了师兄，末尾为什么一定得选择</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = (int)nums.size();</span><br><span class="line">        if (n == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; dp(n, 0);</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i] = 1;</span><br><span class="line">            for (int j = 0; j &lt; i; ++j) &#123;</span><br><span class="line">                //这个if是啥意思——哦哦，递增序列，一直递推下去就是一直递增的</span><br><span class="line">                if (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                    dp[i] = max(dp[i], dp[j] + 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //*max_element()好久不见</span><br><span class="line">        return *max_element(dp.begin(), dp.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>还可以用贪心？麻了麻了</li>
</ul>
<h2 id="303-区域和检索-数组不可变"><a href="#303-区域和检索-数组不可变" class="headerlink" title="303_区域和检索-数组不可变"></a>303_区域和检索-数组不可变</h2><ul>
<li>看题意应该是只构造一次？<ul>
<li>知识点应该是前缀和</li>
<li>可以一次过，就是需要注意<code>i</code>、<code>j</code>本身都包含在内</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class NumArray &#123;</span><br><span class="line">public:</span><br><span class="line">    NumArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        //i~j，包含这两个坐标，若这两个相等，总和就是数字本身，为了方便还是加个0</span><br><span class="line">        sum.emplace_back(0);</span><br><span class="line">        int tmp = 0;</span><br><span class="line">        for(auto num : nums)&#123;</span><br><span class="line">            tmp += num;</span><br><span class="line">            sum.emplace_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int sumRange(int left, int right) &#123;</span><br><span class="line">        return sum[right + 1] - sum[left];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    vector&lt;int&gt; sum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="304-二维区域和检索-矩阵不可变"><a href="#304-二维区域和检索-矩阵不可变" class="headerlink" title="304_二维区域和检索-矩阵不可变"></a>304_二维区域和检索-矩阵不可变</h2><ul>
<li>仔细想了想，前缀和还是能实现的，对应区域相减时，要把剩余的区域也减掉<ul>
<li>生成前缀和的时候要一行一行的来</li>
<li>要把重复的区域加上或者减去</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class NumMatrix &#123;</span><br><span class="line">public:</span><br><span class="line">    NumMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) : row(matrix.size()), col(matrix[0].size()), sum(matrix) &#123;</span><br><span class="line">        // 这里初始化 sum，先初始化边界 —— 第一行、第一列</span><br><span class="line">        for(int i = 1; i &lt; row; ++i)&#123;</span><br><span class="line">            sum[i][0] += sum[i - 1][0];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int j = 1; j &lt; col; ++j)&#123;</span><br><span class="line">            sum[0][j] += sum[0][j - 1];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i = 1; i &lt; row; ++i)&#123;</span><br><span class="line">            for(int j = 1; j &lt; col; ++j)&#123;</span><br><span class="line">                // 这里有三个部分</span><br><span class="line">                sum[i][j] += (sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int sumRegion(int row1, int col1, int row2, int col2) &#123;</span><br><span class="line">        if(row1 == 0 &amp;&amp; col1 == 0)&#123;</span><br><span class="line">            return sum[row2][col2];</span><br><span class="line">        &#125;else if(row1 == 0)&#123;</span><br><span class="line">            return sum[row2][col2] - sum[row2][col1 - 1];</span><br><span class="line">        &#125;else if(col1 == 0)&#123;</span><br><span class="line">            return sum[row2][col2] - sum[row1 - 1][col2];</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            // 两个都不为 0</span><br><span class="line">            return sum[row2][col2] - sumRegion(0, 0, row1 - 1, col2) - sumRegion(0, 0, row2, col1 - 1) + sumRegion(0, 0, row1 - 1, col1 - 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; sum;</span><br><span class="line">    int row;</span><br><span class="line">    int col;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>题解比我优化的好<ul>
<li>两个维度初始化都多出一个，腾出空间，省去判断边界的麻烦！</li>
</ul>
</li>
</ul>
<h2 id="307-区域和检索-数组可修改"><a href="#307-区域和检索-数组可修改" class="headerlink" title="307_区域和检索 - 数组可修改"></a>307_区域和检索 - 数组可修改</h2><ul>
<li>一维数组前缀和，修改了对应的元素后，那么后面所有的总和都要改变，但是这样每改一次，牵一发而动全身不妥<ul>
<li>可以记录下位置以及元素，之后返回结果的时候再更新</li>
<li>如何判断区间内是否存在元素被修改</li>
</ul>
</li>
</ul>
<h2 id="363-矩形区域不超过K的最大数值和"><a href="#363-矩形区域不超过K的最大数值和" class="headerlink" title="363_矩形区域不超过K的最大数值和"></a>363_矩形区域不超过K的最大数值和</h2><ul>
<li>看题解之前毫无思路，看了之后…降维打击！</li>
<li>矩阵的每列和（相当于把矩阵压扁、压成一维的），然后题目就变成了数组中找区间和</li>
<li>至于怎么找，仔细思考下如何用二分</li>
<li>学习下<code>set.lower_bound</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;iterator&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    //求最大区间和</span><br><span class="line">    void numAns(vector&lt;int&gt; &amp;tmp, int k)&#123;</span><br><span class="line">        //0是必要的，要不然遇到s - k = 0 时会找不到正确位置</span><br><span class="line">        set&lt;int&gt; res(&#123;0&#125;);</span><br><span class="line">        int s = 0;</span><br><span class="line">        for(auto t : tmp)&#123;</span><br><span class="line">            //累加和</span><br><span class="line">            s += t;</span><br><span class="line">            //s - k是从0开始到i的累加和</span><br><span class="line">            auto iter = res.lower_bound(s - k);</span><br><span class="line">            cout &lt;&lt; &quot;s = &quot; &lt;&lt; s &lt;&lt; &quot; s - k = &quot; &lt;&lt; s - k &lt;&lt; &quot; iter-&gt;&quot; &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">            //如果存在不低于s - k的值，那么从i开始到s这一段就是最大累加和（不超过k）</span><br><span class="line">            if(iter != res.end())&#123;</span><br><span class="line">                ans = max(ans, s - *iter);</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; &quot;ans = &quot; &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">            res.insert(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int maxSumSubmatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) &#123;</span><br><span class="line">        int r = matrix.size(), c = matrix[0].size();</span><br><span class="line">        for(int i = 0; i &lt; r; ++i)&#123;</span><br><span class="line">            vector&lt;int&gt; tmp(c, 0);</span><br><span class="line">            for(int j = i; j &lt; r; ++j)&#123;</span><br><span class="line">                //第i行和第j行之间压缩成一维数组</span><br><span class="line">                for(int m = 0; m &lt; c; ++m)&#123;</span><br><span class="line">                    tmp[m] += matrix[j][m];</span><br><span class="line">                &#125;</span><br><span class="line">                cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; &quot; j = &quot; &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">                copy(tmp.begin(), tmp.end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot;));</span><br><span class="line">                cout &lt;&lt; endl;</span><br><span class="line">                //对tmp求区间和</span><br><span class="line">                numAns(tmp, k);</span><br><span class="line">                if(ans == k)</span><br><span class="line">                    return k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int ans = INT32_MIN;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; matrix(&#123;&#123;2, 2, -1&#125;&#125;);</span><br><span class="line">    int k = 3;</span><br><span class="line">    Solution solution;</span><br><span class="line">    int ans = solution.maxSumSubmatrix(matrix, k);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="368-最大整除子集"><a href="#368-最大整除子集" class="headerlink" title="368_最大整除子集"></a>368_最大整除子集</h2><ul>
<li>思路一开始就错了，本来以为找到类似等比数列，再递归剩下的数，最后比较大小；但是一开始找的数列并不一定就是最长的</li>
<li>不应该是剩下来的，而是全部；也不对，有的数哪怕符合也不能要！</li>
<li>试试动态规划，也不太对，手画了一下，感觉是二叉树，求最长路径；用栈试试</li>
<li>…..</li>
<li>看题解；想到了升序，还是有点对头的；这题好难</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; largestDivisibleSubset(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int len = nums.size();</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line"></span><br><span class="line">        // 第 1 步：动态规划找出最大子集的个数、最大子集中的最大整数</span><br><span class="line">        vector&lt;int&gt; dp(len, 1);</span><br><span class="line">        int maxSize = 1;</span><br><span class="line">        int maxVal = dp[0];</span><br><span class="line">        for (int i = 1; i &lt; len; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; i; j++) &#123;</span><br><span class="line">                // 题目中说「没有重复元素」很重要</span><br><span class="line">                if (nums[i] % nums[j] == 0) &#123;</span><br><span class="line">                    //这个比较......</span><br><span class="line">                    dp[i] = max(dp[i], dp[j] + 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (dp[i] &gt; maxSize) &#123;</span><br><span class="line">                maxSize = dp[i];</span><br><span class="line">                maxVal = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 第 2 步：倒推获得最大子集</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        if (maxSize == 1) &#123;</span><br><span class="line">            res.push_back(nums[0]);</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = len - 1; i &gt;= 0 &amp;&amp; maxSize &gt; 0; i--) &#123;</span><br><span class="line">            if (dp[i] == maxSize &amp;&amp; maxVal % nums[i] == 0) &#123;</span><br><span class="line">                res.push_back(nums[i]);</span><br><span class="line">                maxVal = nums[i];</span><br><span class="line">                maxSize--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="377-组合总和-Ⅳ"><a href="#377-组合总和-Ⅳ" class="headerlink" title="377_组合总和_Ⅳ"></a>377_组合总和_Ⅳ</h2><ul>
<li>用递归超时…优化下</li>
<li>优化不了，题解说要动态规划…做这题花了一个多小时，笔试直接凉凉</li>
<li>这动态规划太牛了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int combinationSum4(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        //dp[target]表示和为target的总个数</span><br><span class="line">        vector&lt;int&gt; dp(target + 1);</span><br><span class="line">        dp[0] = 1;</span><br><span class="line">        for (int i = 1; i &lt;= target; i++) &#123;</span><br><span class="line">            for (int&amp; num : nums) &#123;</span><br><span class="line">                //防止溢出</span><br><span class="line">                if (num &lt;= i &amp;&amp; dp[i - num] &lt; INT_MAX - dp[i]) &#123;</span><br><span class="line">                    //在计算dp[i]dp[i] 时，应该计算所有的dp[i−num] 之和。</span><br><span class="line">                    dp[i] += dp[i - num];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; nums(&#123;1,2,3&#125;);</span><br><span class="line">    int target = 32;    //181997601</span><br><span class="line">    Solution solution;</span><br><span class="line">    int ans = solution.combinationSum4(nums, target);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="403-青蛙过河"><a href="#403-青蛙过河" class="headerlink" title="403_青蛙过河"></a>403_青蛙过河</h2><ul>
<li>这题得好好康康，深度优先搜索居然没想出来，因为习惯贪心了，却又发现贪心不了；不优化的话，深度优先搜索估计会超时</li>
<li>动态规划<code>dp[i][k] = dp[j][k - 1] || dp[j][k] || dp[j][k + 1];</code>这个转移方程不怎么理解</li>
<li><code>dp[i][k]</code>表示青蛙能否达到现在所处的石子编号为<code>i</code>且上一次跳跃距离为<code>k</code>的状态。</li>
<li>为什么是<code>n*n</code>，因为一开始的步数是0，每次都增加一个步数，也不过<code>n-1</code>；所以<del>行</del>列一共<code>n</code>维</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="690-员工的重要性"><a href="#690-员工的重要性" class="headerlink" title="690_员工的重要性"></a>690_员工的重要性</h2><ul>
<li>还可以，深度优先搜索和广度优先搜索</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">// Definition for Employee.</span><br><span class="line">class Employee &#123;</span><br><span class="line">public:</span><br><span class="line">    int id;</span><br><span class="line">    int importance;</span><br><span class="line">    vector&lt;int&gt; subordinates;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void sum(vector&lt;Employee*&gt; &amp;employees, int pos)&#123;</span><br><span class="line">        //有id，肯定有重要性，先求和再判断有没有下属</span><br><span class="line">        ans += employees[pos]-&gt;importance;</span><br><span class="line">        if(employees[pos]-&gt;subordinates.empty()) return;</span><br><span class="line">        for(auto id : employees[pos]-&gt;subordinates)&#123;</span><br><span class="line">            int p = map[id];</span><br><span class="line">            sum(employees, p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int getImportance(vector&lt;Employee*&gt; employees, int id) &#123;</span><br><span class="line">        if(employees.empty()) return 0;</span><br><span class="line">        int i = 0;</span><br><span class="line">        // 记录位置信息，方便查找</span><br><span class="line">        for(auto &amp;e : employees)&#123;</span><br><span class="line">            map[e-&gt;id] = i;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        int pos = map[id];</span><br><span class="line">        sum(employees, pos);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    unordered_map&lt;int, int&gt; map;</span><br><span class="line">    int ans;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1011-在D天内送达包裹的能力"><a href="#1011-在D天内送达包裹的能力" class="headerlink" title="1011_在D天内送达包裹的能力"></a>1011_在D天内送达包裹的能力</h2><ul>
<li>直觉是动态规划，不知状态、不知转移过程</li>
<li>看论文多了，这题居然已经是两天前的了，昨天的每日一题也是直接看了个大概，看样子还是坚持下去</li>
<li>方法妙在先确定D，之后就可以用贪心比较——送达的天数，之后不满足条件，可以用二分法找D，最后输出应该是左端点吧</li>
<li>注意条件右端点满足答案，但是，判断还会继续进行，不对，计算天数错误</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;numeric&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">// 自己手写了一遍，加强记忆</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int shipWithinDays(vector&lt;int&gt;&amp; weights, int D)&#123;</span><br><span class="line">        // 这应该是最小的载重</span><br><span class="line">        int l = *max_element(weights.begin(), weights.end());</span><br><span class="line">        int r = accumulate(weights.begin(), weights.end(), 0);</span><br><span class="line">        // 如果是输出左端点，那么while里应该是小于</span><br><span class="line">        while (l &lt; r)&#123;</span><br><span class="line">            cout &lt;&lt; &quot;l = &quot; &lt;&lt; l &lt;&lt; &quot; r = &quot; &lt;&lt; r &lt;&lt;endl;</span><br><span class="line">            int mid = (l + r) / 2;</span><br><span class="line">            cout &lt;&lt; &quot;mid = &quot; &lt;&lt; mid &lt;&lt; endl;</span><br><span class="line">            int D_ = 1, tmp = 0;</span><br><span class="line">            for(auto w : weights)&#123;</span><br><span class="line">                if((tmp + w) &lt;= mid)&#123;</span><br><span class="line">                    tmp += w;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                ++D_;</span><br><span class="line">                tmp = w;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; &quot;D_ = &quot; &lt;&lt; D_ &lt;&lt; endl;</span><br><span class="line">            if(D_ &gt; D)&#123;</span><br><span class="line">                //说明载重小了</span><br><span class="line">                l = mid + 1;</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution_ &#123;</span><br><span class="line">public:</span><br><span class="line">    int shipWithinDays(vector&lt;int&gt;&amp; weights, int D) &#123;</span><br><span class="line">        // 确定二分查找左右边界</span><br><span class="line">        int left = *max_element(weights.begin(), weights.end()), right = accumulate(weights.begin(), weights.end(), 0);</span><br><span class="line">        while (left &lt; right) &#123;</span><br><span class="line">            int mid = (left + right) / 2;</span><br><span class="line">            // need 为需要运送的天数</span><br><span class="line">            // cur 为当前这一天已经运送的包裹重量之和</span><br><span class="line">            int need = 1, cur = 0;</span><br><span class="line">            for (int weight: weights) &#123;</span><br><span class="line">                if (cur + weight &gt; mid) &#123;</span><br><span class="line">                    ++need;</span><br><span class="line">                    cur = 0;</span><br><span class="line">                &#125;</span><br><span class="line">                cur += weight;</span><br><span class="line">            &#125;</span><br><span class="line">            if (need &lt;= D) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                left = mid + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; weights(&#123;1,2,3,4,5,6,7,8,9,10&#125;);</span><br><span class="line">    int D = 5;</span><br><span class="line">    Solution solution;</span><br><span class="line">    int ans = solution.shipWithinDays(weights, D);</span><br><span class="line">    cout &lt;&lt; &quot;ans = &quot; &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1018-可被5整除的二进制前缀"><a href="#1018-可被5整除的二进制前缀" class="headerlink" title="1018_可被5整除的二进制前缀"></a>1018_可被5整除的二进制前缀</h2><ul>
<li>数组很长，全部转化为整数类型会超出边界，因为只需被5整除，所以被除数的个位为0或者5即可</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;bool&gt; prefixesDivBy5(vector&lt;int&gt;&amp; A) &#123;</span><br><span class="line">        vector&lt;bool&gt; res;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        for(int i : A)&#123;</span><br><span class="line">            ans = 2 * ans + i;</span><br><span class="line">            if(ans &gt;= 10)&#123;ans -= 10;&#125;</span><br><span class="line">            if(ans % 5 == 0)&#123;</span><br><span class="line">                if(ans == 0 || ans &gt;= 5)&#123;</span><br><span class="line">                    res.push_back(true);</span><br><span class="line">                &#125; else&#123;</span><br><span class="line">                    res.push_back(false);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                res.push_back(false);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; A = &#123;1,0,0,1&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;bool&gt; res = solution.prefixesDivBy5(A);</span><br><span class="line">    for(auto i : res)&#123;</span><br><span class="line">        cout &lt;&lt; i;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1723-完成所有工作的最短时间"><a href="#1723-完成所有工作的最短时间" class="headerlink" title="1723_完成所有工作的最短时间"></a>1723_完成所有工作的最短时间</h2><ul>
<li>本来每日一题是不打算写进博客的，准备以后做到，再重新做一遍的时候写，但看了看题号，还是写一下吧，可能不会做到这题了，也可能要好久…</li>
<li>我用递归加剪枝做出来了，题解又用了二分，并且与之前一题十分相似，先找出最小的工作量，然后确定上下限，最后二分判断？</li>
<li>好像是轮船载重那题，还有一道是降维打击那题？</li>
<li>官方题解确实速度更快</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;numeric&gt;</span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void dfs(vector&lt;int&gt; &amp;workers, vector&lt;int&gt;&amp; jobs, int pos, int mean, int k)&#123;</span><br><span class="line">        // 递归出口</span><br><span class="line">        if(flag) return;</span><br><span class="line">        if(pos == 0)&#123;</span><br><span class="line">            //找最小的工人</span><br><span class="line">            auto iter_min = min_element(workers.begin(), workers.end());</span><br><span class="line">            //找完最小值，加上之后，还要再找最大值</span><br><span class="line">            auto iter_max = max_element(workers.begin(), workers.end());</span><br><span class="line">            int tmp = max(*iter_min + jobs[pos], *iter_max);</span><br><span class="line">            ans = min(ans, tmp);</span><br><span class="line">            if(ans == mean)&#123;</span><br><span class="line">                flag = true;</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 对工人进行遍历</span><br><span class="line">        for(int i = 0; i &lt; k; ++i)&#123;</span><br><span class="line">            if((i &gt; 0 &amp;&amp; workers[i] == workers[i - 1]) || workers[i] &gt; mean)</span><br><span class="line">                continue;</span><br><span class="line">            // 到这里是小于均值的工人</span><br><span class="line">            workers[i] += jobs[pos];</span><br><span class="line">            dfs(workers, jobs, pos - 1, mean, k);</span><br><span class="line">            workers[i] -= jobs[pos];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int minimumTimeRequired(vector&lt;int&gt;&amp; jobs, int k) &#123;</span><br><span class="line">        // 从小到大排序</span><br><span class="line">        sort(jobs.begin(), jobs.end());</span><br><span class="line">        int sum = accumulate(jobs.begin(), jobs.end(), 0);</span><br><span class="line">        int mean = sum / k, pos = static_cast&lt;int&gt;(jobs.size()) - 1;</span><br><span class="line">        vector&lt;int&gt; workers(k, 0);</span><br><span class="line">        // 如果答案就是平均数，那就可以直接输出，在回溯里还要再加一个记号</span><br><span class="line">        dfs(workers, jobs, pos, mean, k);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int ans = INT32_MAX;</span><br><span class="line">    bool flag = false;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//题解</span><br><span class="line">class Solution_ &#123;</span><br><span class="line">public:</span><br><span class="line">    bool backtrack(vector&lt;int&gt;&amp; jobs, vector&lt;int&gt;&amp; workloads, int idx, int limit) &#123;</span><br><span class="line">        if (idx &gt;= jobs.size()) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        int cur = jobs[idx];</span><br><span class="line">        for (auto&amp; workload : workloads) &#123;</span><br><span class="line">            if (workload + cur &lt;= limit) &#123;</span><br><span class="line">                workload += cur;</span><br><span class="line">                if (backtrack(jobs, workloads, idx + 1, limit)) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">                workload -= cur;</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果当前工人未被分配工作，那么下一个工人也必然未被分配工作</span><br><span class="line">            // 或者当前工作恰能使该工人的工作量达到了上限</span><br><span class="line">            // 这两种情况下我们无需尝试继续分配工作</span><br><span class="line">            if (workload == 0 || workload + cur == limit) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool check(vector&lt;int&gt;&amp; jobs, int k, int limit) &#123;</span><br><span class="line">        vector&lt;int&gt; workloads(k, 0);</span><br><span class="line">        return backtrack(jobs, workloads, 0, limit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int minimumTimeRequired(vector&lt;int&gt;&amp; jobs, int k) &#123;</span><br><span class="line">        sort(jobs.begin(), jobs.end(), greater&lt;&gt;());</span><br><span class="line">        int l = jobs[0], r = accumulate(jobs.begin(), jobs.end(), 0);</span><br><span class="line">        while (l &lt; r) &#123;</span><br><span class="line">            int mid = (l + r) &gt;&gt; 1;</span><br><span class="line">            if (check(jobs, k, mid)) &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                l = mid + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//动态规划</span><br><span class="line">class Solution1 &#123;</span><br><span class="line">public:</span><br><span class="line">    int minimumTimeRequired(vector&lt;int&gt;&amp; jobs, int k) &#123;</span><br><span class="line">        int n = jobs.size();</span><br><span class="line">        vector&lt;int&gt; sum(1 &lt;&lt; n);</span><br><span class="line">        for (int i = 1; i &lt; (1 &lt;&lt; n); i++) &#123;</span><br><span class="line">            int x = __builtin_ctz(i), y = i - (1 &lt;&lt; x);</span><br><span class="line">            sum[i] = sum[y] + jobs[x];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(k, vector&lt;int&gt;(1 &lt;&lt; n));</span><br><span class="line">        for (int i = 0; i &lt; (1 &lt;&lt; n); i++) &#123;</span><br><span class="line">            dp[0][i] = sum[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; k; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; (1 &lt;&lt; n); j++) &#123;</span><br><span class="line">                int minn = INT_MAX;</span><br><span class="line">                for (int x = j; x; x = (x - 1) &amp; j) &#123;</span><br><span class="line">                    minn = min(minn, max(dp[i - 1][j - x], sum[x]));</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][j] = minn;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[k - 1][(1 &lt;&lt; n) - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; jobs(&#123;4,5,4,5,4&#125;);</span><br><span class="line">    int k = 2;</span><br><span class="line">    Solution_ solution;</span><br><span class="line">    int ans = solution.minimumTimeRequired(jobs, k);</span><br><span class="line">    cout &lt;&lt; &quot;ans = &quot; &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><ul>
<li>啊，之前一直忘记写<font color="#FF0000">delete</font>了……希望内存不要泄露太多；在哪里分配的就要在哪里删除，（否则，new出来的指针既不是类成员变量，又只是函数内部可见，不delete使用完谁也释放不了）</li>
<li>第二题就是链表，自以为做出来了就可以不认真看题解了，，直到百题，，还是看书意识到不对劲；</li>
<li>第二题用的是内置指针，然后用delete手动删除；第十九题试一下智能指针<code>shared_ptr</code>；如果使用智能指针，需要在类里面添加，并让析构函数负责删除；但似乎有点麻烦，因为题里给的函数是普通的指针</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void delete_list(ListNode * head)&#123;</span><br><span class="line">    ListNode *h1 = head;</span><br><span class="line">    ListNode *h2;</span><br><span class="line">    while (h1 != nullptr)&#123;</span><br><span class="line">        h2 = h1-&gt;next;</span><br><span class="line">        delete h1;</span><br><span class="line">        h1 = h2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>声明一个节点</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode&#123;	</span><br><span class="line">    int val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>给一个节点赋值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ListNode* head = new ListNode;	</span><br><span class="line">head-&gt;val = 0;</span><br><span class="line">head-&gt;next = NULL;</span><br></pre></td></tr></table></figure>

<ul>
<li>获取链表的长度、输出链表的所有值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int len = 1;			</span><br><span class="line">while(head-&gt;next!=NULL)			</span><br><span class="line">       &#123;</span><br><span class="line">           len++;</span><br><span class="line">           p=p-&gt;next;</span><br><span class="line">       &#125;</span><br><span class="line">for(int i = 0; i &lt; len; i++)&#123;</span><br><span class="line">       cout &lt;&lt; head-&gt;val &lt;&lt; &quot; &quot;;</span><br><span class="line">       head = head-&gt;next;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2_两数相加"></a>2_两数相加</h2><ul>
<li>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</li>
<li>输出：7 -&gt; 0 -&gt; 8</li>
<li>342+4</li>
<li>=807</li>
</ul>
<blockquote>
<p>C/C++</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct ListNode &#123;       //Definition for singly-linked list.</span><br><span class="line">    int val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode() : val(0), next(nullptr) &#123;&#125;;</span><br><span class="line">    explicit ListNode(int val) : val(val), next(nullptr) &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void delete_list(ListNode * head)&#123;</span><br><span class="line">    ListNode *h1 = head;</span><br><span class="line">    ListNode *h2;</span><br><span class="line">    while (h1 != nullptr)&#123;</span><br><span class="line">        h2 = h1-&gt;next;</span><br><span class="line">        delete h1;</span><br><span class="line">        h1 = h2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;</span><br><span class="line">        auto* l3 = new ListNode();</span><br><span class="line">        ListNode* p = l3;           //这只是一个节点,要想p=p-&gt;next,要根据构造函数创建新的节点</span><br><span class="line">        int carry = 0;              //进位</span><br><span class="line"></span><br><span class="line">        while(l1 != nullptr || l2 != nullptr)  &#123;</span><br><span class="line">            int sum = 0;        //对应节点之和</span><br><span class="line">            if(l1 != nullptr)&#123;</span><br><span class="line">                sum += l1-&gt;val;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            if(l2 != nullptr)&#123;</span><br><span class="line">                sum += l2-&gt;val;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            sum += carry;</span><br><span class="line">            p-&gt;next = new ListNode(sum % 10);</span><br><span class="line">            carry = floor(sum / 10);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        if(carry &gt; 0)&#123;</span><br><span class="line">            p-&gt;next = new ListNode(carry);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //return l3-&gt;next; 并没有释放头节点</span><br><span class="line">        p = l3;</span><br><span class="line">        l3 = l3-&gt;next;</span><br><span class="line">        delete p;</span><br><span class="line">        return l3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    auto *l1 = new ListNode(6);</span><br><span class="line">    auto carry = l1;</span><br><span class="line">    carry-&gt;next = new ListNode(9);</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    carry-&gt;next = new ListNode(2);</span><br><span class="line"></span><br><span class="line">    auto *l2 = new ListNode(3);</span><br><span class="line">    carry = l2;</span><br><span class="line">    carry-&gt;next = new ListNode(3);</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    carry-&gt;next = new ListNode(2);</span><br><span class="line"></span><br><span class="line">    Solution s;</span><br><span class="line">    ListNode *l3 = s.addTwoNumbers(l1, l2);</span><br><span class="line">    carry = l3;</span><br><span class="line">    while (carry != nullptr) &#123;</span><br><span class="line">        cout &lt;&lt; carry-&gt;val &lt;&lt; &quot; &quot;;</span><br><span class="line">        carry = carry-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    delete_list(l1);</span><br><span class="line">    delete_list(l2);</span><br><span class="line">    delete_list(l3);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19_删除链表的倒数第N个节点"></a>19_删除链表的倒数第N个节点</h2><ul>
<li>两次遍历，先遍历链表的长度，再根据<code>len-n</code>遍历得到删除的节点，将前一个节点的指针指向后一个节点，即可删除</li>
<li>两个指针，一个<code>slow</code>一个<code>fast</code>，刚开始都指向头部，再将<code>fast</code>往后移n个距离，最后同时遍历这两个指针，直到<code>fast-&gt;next == nullptr</code>，将<code>slow-&gt;next = slow-&gt;next-&gt;next</code></li>
</ul>
<h3 id="两次遍历"><a href="#两次遍历" class="headerlink" title="两次遍历"></a>两次遍历</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    shared_ptr&lt;ListNode&gt; next;</span><br><span class="line">    ListNode() : val(0), next(nullptr) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;创建了&quot; &lt;&lt; 0 &lt;&lt; &quot;节点&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    explicit ListNode(int x) : val(x), next(nullptr) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;创建了&quot; &lt;&lt; val &lt;&lt; &quot;节点&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~ListNode()&#123;</span><br><span class="line">        cout &lt;&lt; &quot;节点 &quot; &lt;&lt; val &lt;&lt; &quot; 已自动删除&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    shared_ptr&lt;ListNode&gt; removeNthFromEnd(shared_ptr&lt;ListNode&gt; head, int n) &#123;</span><br><span class="line">        if(!head)&#123;return head;&#125;</span><br><span class="line">        int len = 0;</span><br><span class="line">        auto carry1 = make_shared&lt;ListNode&gt;();</span><br><span class="line">        carry1-&gt;next = head;</span><br><span class="line">        while (carry1-&gt;next)&#123;   //当carry1变成nullptr时，就自动删除了</span><br><span class="line">            len++;</span><br><span class="line">            carry1 = carry1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        auto carry = make_shared&lt;ListNode&gt;();</span><br><span class="line">        carry-&gt;next = head;   //  再次初始化</span><br><span class="line">        while (len - n &gt; 0)&#123;</span><br><span class="line">            carry = carry-&gt;next;</span><br><span class="line">            len--;</span><br><span class="line">        &#125;</span><br><span class="line">        if(carry-&gt;next == head)&#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">            carry-&gt;next = carry-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    shared_ptr&lt;ListNode&gt; head = make_shared&lt;ListNode&gt;(1);</span><br><span class="line">    cout &lt;&lt; &quot;head: &quot; &lt;&lt; head.use_count() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;----&quot; &lt;&lt; endl;</span><br><span class="line">    auto carry = head;</span><br><span class="line">    cout &lt;&lt; &quot;head: &quot; &lt;&lt; head.use_count() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;carry: &quot; &lt;&lt; carry.use_count() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;----&quot; &lt;&lt; endl;</span><br><span class="line">    carry-&gt;next = make_shared&lt;ListNode&gt;(2);</span><br><span class="line">    cout &lt;&lt; &quot;head: &quot; &lt;&lt; head.use_count() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;carry: &quot; &lt;&lt; carry.use_count() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;----&quot; &lt;&lt; endl;</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    cout &lt;&lt; &quot;head: &quot; &lt;&lt; head.use_count() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;carry: &quot; &lt;&lt; carry.use_count() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;----&quot; &lt;&lt; endl;</span><br><span class="line">    carry-&gt;next = make_shared&lt;ListNode&gt;(3);</span><br><span class="line">    cout &lt;&lt; &quot;head: &quot; &lt;&lt; head.use_count() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;carry: &quot; &lt;&lt; carry.use_count() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;----&quot; &lt;&lt; endl;</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    cout &lt;&lt; &quot;head: &quot; &lt;&lt; head.use_count() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;carry: &quot; &lt;&lt; carry.use_count() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;----&quot; &lt;&lt; endl;</span><br><span class="line">    carry-&gt;next = make_shared&lt;ListNode&gt;(4);</span><br><span class="line">    cout &lt;&lt; &quot;head: &quot; &lt;&lt; head.use_count() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;carry: &quot; &lt;&lt; carry.use_count() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;----&quot; &lt;&lt; endl;</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    cout &lt;&lt; &quot;head: &quot; &lt;&lt; head.use_count() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;carry: &quot; &lt;&lt; carry.use_count() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;----&quot; &lt;&lt; endl;</span><br><span class="line">    carry-&gt;next = make_shared&lt;ListNode&gt;(5);</span><br><span class="line">    cout &lt;&lt; &quot;head: &quot; &lt;&lt; head.use_count() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;carry: &quot; &lt;&lt; carry.use_count() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;----&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Solution solution;</span><br><span class="line">    shared_ptr&lt;ListNode&gt; res = solution.removeNthFromEnd(head, 5);</span><br><span class="line">    cout &lt;&lt; &quot;res:&quot; &lt;&lt; res.use_count() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;head: &quot; &lt;&lt; head.use_count() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;carry: &quot; &lt;&lt; carry.use_count() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;----&quot; &lt;&lt; endl;</span><br><span class="line">    carry = res;</span><br><span class="line">    cout &lt;&lt; &quot;res:&quot; &lt;&lt; res.use_count() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;head: &quot; &lt;&lt; head.use_count() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;carry: &quot; &lt;&lt; carry.use_count() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;----&quot; &lt;&lt; endl;</span><br><span class="line">    while (carry)&#123;</span><br><span class="line">        cout &lt;&lt; carry-&gt;val &lt;&lt; endl;</span><br><span class="line">        carry = carry-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; &quot;++++&quot; &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="两个指针"><a href="#两个指针" class="headerlink" title="两个指针"></a>两个指针</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;</span><br><span class="line">        if(head == nullptr)&#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *slow = new ListNode;</span><br><span class="line">        ListNode *fast = new ListNode;</span><br><span class="line">        slow-&gt;next = head;</span><br><span class="line">        fast-&gt;next = head;</span><br><span class="line">        while (n &gt; 0)&#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        while (fast-&gt;next != nullptr)&#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        if(slow-&gt;next == head)&#123;</span><br><span class="line">            return head-&gt;next;</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">            slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    auto *head = new ListNode(1);</span><br><span class="line">    ListNode *carry = head;</span><br><span class="line">    carry-&gt;next = new ListNode(2);</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    carry-&gt;next = new ListNode(3);</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    carry-&gt;next = new ListNode(4);</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    carry-&gt;next = new ListNode(5);</span><br><span class="line"></span><br><span class="line">    Solution solution;</span><br><span class="line">    ListNode *res = solution.removeNthFromEnd(head, 1);</span><br><span class="line"></span><br><span class="line">    while (res != nullptr)&#123;</span><br><span class="line">        cout &lt;&lt; res-&gt;val;</span><br><span class="line">        res = res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21_合并两个有序链表"></a>21_合并两个有序链表</h2><h3 id="迭代-1"><a href="#迭代-1" class="headerlink" title="迭代"></a>迭代</h3><ul>
<li>本来是将结果放入一个新的链表里，看了答案只需改变指针方向即可</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 自己写的</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;</span><br><span class="line">        auto *carry = new ListNode;</span><br><span class="line">        auto *head = carry;</span><br><span class="line">        while (l2 != nullptr &amp;&amp; l1 != nullptr)&#123;</span><br><span class="line">            if(l1-&gt;val &gt; l2-&gt;val)&#123;</span><br><span class="line">                carry-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">                carry = carry-&gt;next;</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                carry-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">                carry = carry-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(l2 != nullptr)&#123;</span><br><span class="line">            carry-&gt;next = l2;</span><br><span class="line">        &#125;</span><br><span class="line">        if(l1 != nullptr)&#123;</span><br><span class="line">            carry-&gt;next = l1;</span><br><span class="line">        &#125;</span><br><span class="line">        return head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 迭代</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;</span><br><span class="line">        ListNode* preHead = new ListNode(-1);</span><br><span class="line">        ListNode* prev = preHead;</span><br><span class="line">        while (l1 != nullptr &amp;&amp; l2 != nullptr) &#123;</span><br><span class="line">            if (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">                prev-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                prev-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = prev-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        prev-&gt;next = l1 == nullptr ? l2 : l1;</span><br><span class="line">        return preHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    auto *l1 = new ListNode(1);</span><br><span class="line">    ListNode *carry = l1;</span><br><span class="line">    carry-&gt;next = new ListNode(2);</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    carry-&gt;next = new ListNode(4);</span><br><span class="line"></span><br><span class="line">    auto *l2 = new ListNode(1);</span><br><span class="line">    carry = l2;</span><br><span class="line">    carry-&gt;next = new ListNode(3);</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    carry-&gt;next = new ListNode(4);</span><br><span class="line"></span><br><span class="line">    Solution solution;</span><br><span class="line">    auto l = solution.mergeTwoLists(l1, l2);</span><br><span class="line">    while (l != nullptr)&#123;</span><br><span class="line">        cout &lt;&lt; l-&gt;val &lt;&lt; &quot; &quot;;</span><br><span class="line">        l = l-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h3><ul>
<li>牛皮</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;</span><br><span class="line">        if(l1 == nullptr)&#123;</span><br><span class="line">            return l2;</span><br><span class="line">        &#125; else if(l2 == nullptr)&#123;</span><br><span class="line">            return l1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(l1-&gt;val &lt; l2-&gt;val)&#123;</span><br><span class="line">            l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);</span><br><span class="line">            return l1;</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">            l2-&gt;next = mergeTwoLists(l1, l2-&gt;next);</span><br><span class="line">            return l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    auto *l1 = new ListNode(1);</span><br><span class="line">    ListNode *carry = l1;</span><br><span class="line">    carry-&gt;next = new ListNode(2);</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    carry-&gt;next = new ListNode(4);</span><br><span class="line"></span><br><span class="line">    auto *l2 = new ListNode(1);</span><br><span class="line">    carry = l2;</span><br><span class="line">    carry-&gt;next = new ListNode(3);</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    carry-&gt;next = new ListNode(4);</span><br><span class="line"></span><br><span class="line">    Solution solution;</span><br><span class="line">    auto l = solution.mergeTwoLists(l1, l2);</span><br><span class="line">    while (l != nullptr)&#123;</span><br><span class="line">        cout &lt;&lt; l-&gt;val &lt;&lt; &quot; &quot;;</span><br><span class="line">        l = l-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="23-合并K个升序链表"><a href="#23-合并K个升序链表" class="headerlink" title="23_合并K个升序链表"></a>23_合并K个升序链表</h2><ul>
<li>参照之前的合并2个升序链表，可以遍历链表型的数组</li>
</ul>
<h3 id="顺序合并"><a href="#顺序合并" class="headerlink" title="顺序合并"></a>顺序合并</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2)&#123;</span><br><span class="line">        if(l1 == nullptr)&#123;return l2;&#125;</span><br><span class="line">        auto *head = new ListNode(-1);</span><br><span class="line">        ListNode *carry = head;</span><br><span class="line">        while (l1 != nullptr &amp;&amp; l2 != nullptr)&#123;</span><br><span class="line">            if(l1-&gt;val &gt; l2-&gt;val)&#123;</span><br><span class="line">                carry-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                carry-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            carry = carry-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        carry-&gt;next = l1 == nullptr ? l2 : l1;</span><br><span class="line">        return head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123;</span><br><span class="line">        int len = lists.size(), i = 0;</span><br><span class="line">        if(len == 1)&#123;</span><br><span class="line">            return lists[0];</span><br><span class="line">        &#125;</span><br><span class="line">        auto *prehead = new ListNode(-1);</span><br><span class="line">        while (i &lt; len)&#123;</span><br><span class="line">            ListNode *tmp = prehead-&gt;next;</span><br><span class="line">            prehead-&gt;next = mergeTwoLists(tmp, lists[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        return prehead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;ListNode*&gt; lists;</span><br><span class="line">    auto *l1 = new ListNode(1);</span><br><span class="line">    ListNode *carry = l1;</span><br><span class="line">    carry-&gt;next = new ListNode(4);</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    carry-&gt;next = new ListNode(5);</span><br><span class="line">    lists.push_back(l1);</span><br><span class="line">    auto *l2 = new ListNode(1);</span><br><span class="line">    carry = l2;</span><br><span class="line">    carry-&gt;next = new ListNode(3);</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    carry-&gt;next = new ListNode(4);</span><br><span class="line">    lists.push_back(l2);</span><br><span class="line">    auto *l3 = new ListNode(2);</span><br><span class="line">    carry = l3;</span><br><span class="line">    carry-&gt;next = new ListNode(6);</span><br><span class="line">    lists.push_back(l3);</span><br><span class="line">    Solution solution;</span><br><span class="line">    auto *res = solution.mergeKLists(lists);</span><br><span class="line">    while (res != nullptr)&#123;</span><br><span class="line">        std::cout &lt;&lt; res-&gt;val &lt;&lt; &quot; &quot;;</span><br><span class="line">        res = res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24_两两交换链表中的节点"></a>24_两两交换链表中的节点</h2><ul>
<li>刚开始是想遍历来着，后来悟了，发现每次都是两两交换，递归搞定</li>
<li>写了几次递归，注意要先写递归的出口:)</li>
</ul>
<h3 id="递归-3"><a href="#递归-3" class="headerlink" title="递归"></a>递归</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* swapPairs(ListNode* head) &#123;</span><br><span class="line">        if(head == nullptr || head-&gt;next == nullptr)&#123;return head;&#125;</span><br><span class="line">        auto *l = head;</span><br><span class="line">        auto *r = l-&gt;next;</span><br><span class="line">        l-&gt;next = swapPairs(r-&gt;next);</span><br><span class="line">        r-&gt;next = l;</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    auto *head = new ListNode(1);</span><br><span class="line">    ListNode *carry = head;</span><br><span class="line">    carry-&gt;next = new ListNode(2);</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    carry-&gt;next = new ListNode(3);</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    carry-&gt;next = new ListNode(4);</span><br><span class="line">    Solution solution;</span><br><span class="line">    auto *res = solution.swapPairs(head);</span><br><span class="line">    while (res != nullptr)&#123;</span><br><span class="line">        std::cout &lt;&lt; res-&gt;val &lt;&lt; &quot; &quot;;</span><br><span class="line">        res = res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25_K 个一组翻转链表"></a>25_K 个一组翻转链表</h2><ul>
<li>同样可以用递归来交换，难点在于如何反转一个链表</li>
<li>若只有两个节点，只需改变指针位置即可</li>
<li>若有三个节点及以上，我是用一个数组储存节点的值，再从后往前遍历数组生成新的链表</li>
<li><font color="#FF0000"></font></li>
<li>_反转链表</li>
</ul>
<h3 id="递归-4"><a href="#递归-4" class="headerlink" title="递归"></a>递归</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* reverseKGroup(ListNode* head, int k) &#123;</span><br><span class="line">        int len = 0;</span><br><span class="line">        auto *tmp = head;</span><br><span class="line">        while (tmp != nullptr)&#123;</span><br><span class="line">            len++;</span><br><span class="line">            tmp = tmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        if(len &lt; k || len == 0 || len == 1)&#123;return head;&#125;</span><br><span class="line"></span><br><span class="line">        tmp = head;     // 初始化tmp;</span><br><span class="line">        int i = 0;</span><br><span class="line">        vector&lt;int&gt; vec;</span><br><span class="line">        auto *res = new ListNode(-1);</span><br><span class="line">        ListNode *carry = res;</span><br><span class="line">        while (i &lt; k)&#123;</span><br><span class="line">            vec.push_back(tmp-&gt;val);</span><br><span class="line">            tmp = tmp-&gt;next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        while (i != 0)&#123;</span><br><span class="line">            carry-&gt;next = new ListNode(vec[i - 1]);</span><br><span class="line">            carry = carry-&gt;next;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        carry-&gt;next = reverseKGroup(tmp, k);</span><br><span class="line">        return res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    auto *head = new ListNode(1);</span><br><span class="line">    ListNode *carry = head;</span><br><span class="line">    carry-&gt;next = new ListNode(2);</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    carry-&gt;next = new ListNode(3);</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    carry-&gt;next = new ListNode(4);</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    carry-&gt;next = new ListNode(5);</span><br><span class="line">    int k = 3;</span><br><span class="line">    Solution solution;</span><br><span class="line">    auto *res = solution.reverseKGroup(head, 2);</span><br><span class="line">    while (res != nullptr)&#123;</span><br><span class="line">        std::cout &lt;&lt; res-&gt;val &lt;&lt; &quot; &quot;;</span><br><span class="line">        res = res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="61-旋转链表"><a href="#61-旋转链表" class="headerlink" title="61_旋转链表"></a>61_旋转链表</h2><ul>
<li>一次通过，自然的想到让其收尾相连，然后转圈圈（注意长度互补：如果<code>k</code>为2，那么顺时针走<code>l-2</code>步），再收尾断开</li>
</ul>
<p><img src="/pictrues/list.png" alt="list" title="list"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* rotateRight(ListNode* head, int k) &#123;</span><br><span class="line">        if(head == nullptr)&#123;return nullptr;&#125;</span><br><span class="line">        ListNode* head_last = head;</span><br><span class="line">        int l = 1;  //长度</span><br><span class="line">        while (head_last-&gt;next != nullptr)&#123;</span><br><span class="line">            head_last = head_last-&gt;next;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(k == 0 || k % l == 0)&#123;return head;&#125;;</span><br><span class="line">        head_last-&gt;next = head;</span><br><span class="line">        k = k &lt; l ? (l - k) : (l - k % l);</span><br><span class="line">        while (k &gt; 0)&#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            head_last = head_last-&gt;next;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        head_last-&gt;next = nullptr;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    auto* head = new ListNode(1);</span><br><span class="line">    ListNode* tmp = head;</span><br><span class="line">    tmp-&gt;next = new ListNode(2);</span><br><span class="line">    tmp = tmp-&gt;next;</span><br><span class="line">    tmp-&gt;next = new ListNode(3);</span><br><span class="line">    tmp = tmp-&gt;next;</span><br><span class="line">    tmp-&gt;next = new ListNode(4);</span><br><span class="line">    tmp = tmp-&gt;next;</span><br><span class="line">    tmp-&gt;next = new ListNode(5);</span><br><span class="line">    Solution solution;</span><br><span class="line">    ListNode* res = solution.rotateRight(head, 2);</span><br><span class="line">    while (res != nullptr)&#123;</span><br><span class="line">        cout &lt;&lt; res-&gt;val &lt;&lt; &quot; &quot;;</span><br><span class="line">        res = res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="82-删除排序链表中的重复元素-II"><a href="#82-删除排序链表中的重复元素-II" class="headerlink" title="82_删除排序链表中的重复元素_II"></a>82_删除排序链表中的重复元素_II</h2><ul>
<li>刚开始想直接在原链表进行修改，但感觉有点绕；定义了一个新的链表，考虑特殊情况：原链表是空指针或者只有一个数，直接返回原链表；之后在遍历，判断其相同数字的个数，根据条件来增加节点，最后要考虑最后一个数字是否也是重复的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* deleteDuplicates(ListNode* head) &#123;</span><br><span class="line">        if(head == nullptr || head-&gt;next == nullptr)&#123;return head;&#125;</span><br><span class="line">        int n = 0, tmp = head-&gt;val;</span><br><span class="line">        auto *res = new ListNode();</span><br><span class="line">        auto *carry = res;</span><br><span class="line">        while (head != nullptr)&#123;</span><br><span class="line">            cout &lt;&lt; head-&gt;val &lt;&lt; &quot; - &quot; &lt;&lt; endl;</span><br><span class="line">            if(tmp == head-&gt;val)&#123;</span><br><span class="line">                n++;</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                if(n &lt; 2)&#123;</span><br><span class="line">                    carry-&gt;next = new ListNode(tmp);</span><br><span class="line">                    carry = carry-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                tmp = head-&gt;val;</span><br><span class="line">                if(head-&gt;next == nullptr)&#123;</span><br><span class="line">                    carry-&gt;next = new ListNode(tmp);</span><br><span class="line">                &#125;</span><br><span class="line">                n = 1;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    auto *head = new ListNode(1);</span><br><span class="line">    auto *carry = head;</span><br><span class="line">    carry-&gt;next = new ListNode(2);</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    carry-&gt;next = new ListNode(3);</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    carry-&gt;next = new ListNode(3);</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    carry-&gt;next = new ListNode(4);</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    carry-&gt;next = new ListNode(4);</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    carry-&gt;next = new ListNode(5);</span><br><span class="line">    Solution solution;</span><br><span class="line">    ListNode *res = solution.deleteDuplicates(head);</span><br><span class="line">    carry = res;</span><br><span class="line">    while (carry != nullptr)&#123;</span><br><span class="line">        cout &lt;&lt; carry-&gt;val &lt;&lt; &quot; &quot;;</span><br><span class="line">        carry = carry-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83_删除排序链表中的重复元素"></a>83_删除排序链表中的重复元素</h2><ul>
<li>这题是在原链表修改的，需要考虑最后可能会存在的几个重复数字；用两个指针，前一个和后一个，再比较他们值的大小</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* deleteDuplicates(ListNode* head) &#123;</span><br><span class="line">        if(head == nullptr || head-&gt;next == nullptr)&#123;return head;&#125;</span><br><span class="line">        ListNode *pre = head, *cur = head-&gt;next;</span><br><span class="line">        while (cur != nullptr)&#123;</span><br><span class="line">            if(pre-&gt;val != cur-&gt;val)&#123;</span><br><span class="line">                pre-&gt;next = cur;</span><br><span class="line">                pre = pre-&gt;next;</span><br><span class="line">//                cout &lt;&lt; pre-&gt;val &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            if(cur-&gt;next == nullptr &amp;&amp; pre-&gt;val == cur-&gt;val)&#123;</span><br><span class="line">                pre-&gt;next = nullptr;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    auto *head = new ListNode(1);</span><br><span class="line">    auto *carry = head;</span><br><span class="line">    carry-&gt;next = new ListNode(1);</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    carry-&gt;next = new ListNode(2);</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    carry-&gt;next = new ListNode(3);</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    carry-&gt;next = new ListNode(3);</span><br><span class="line">    Solution solution;</span><br><span class="line">    ListNode *res = solution.deleteDuplicates(head);</span><br><span class="line">    carry = res;</span><br><span class="line">    while (carry != nullptr)&#123;</span><br><span class="line">        cout &lt;&lt; carry-&gt;val &lt;&lt; &quot; &quot;;</span><br><span class="line">        carry = carry-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="86-分隔链表"><a href="#86-分隔链表" class="headerlink" title="86_分隔链表"></a>86_分隔链表</h2><ul>
<li>这题虽然用时和消耗比较高，但好歹和题解思路一样：维护两个链表，再把他们连接起来</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* partition(ListNode* head, int x) &#123;</span><br><span class="line">        auto *res = new ListNode(), *right = new ListNode();</span><br><span class="line">        auto *l = res, * r = right;</span><br><span class="line">        while (head != nullptr)&#123;</span><br><span class="line">            if(head-&gt;val &lt; x)&#123;</span><br><span class="line">                l-&gt;next = new ListNode(head-&gt;val);</span><br><span class="line">                l = l-&gt;next;</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                r-&gt;next = new ListNode(head-&gt;val);</span><br><span class="line">                r = r-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        l-&gt;next = right-&gt;next;</span><br><span class="line">        return res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    auto *head = new ListNode(1);</span><br><span class="line">    auto *carry = head;</span><br><span class="line">    carry-&gt;next = new ListNode(4);</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    carry-&gt;next = new ListNode(3);</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    carry-&gt;next = new ListNode(2);</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    carry-&gt;next = new ListNode(5);</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    carry-&gt;next = new ListNode(2);</span><br><span class="line">    int x = 3;</span><br><span class="line">    Solution solution;</span><br><span class="line">    auto *res = solution.partition(head, x);</span><br><span class="line">    carry = res;</span><br><span class="line">    while (carry != nullptr)&#123;</span><br><span class="line">        cout &lt;&lt; carry-&gt;val &lt;&lt; &quot; &quot;;</span><br><span class="line">        carry = carry-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92_反转链表_II"></a>92_反转链表_II</h2><ul>
<li>这里的<code>left</code>和<code>right</code>是类似于数组里的位置，并不是节点的值</li>
<li>要保存<code>left</code>和<code>right</code>之间的值，从后往前生成新的链表；还要保存两个断点的指针；最后将三段链表链接起来</li>
<li>不过这是一般的思路；还是跟206_反转链表这题有关</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* reverseBetween(ListNode* head, int left, int right) &#123;</span><br><span class="line">        if(left == right) return head;</span><br><span class="line">        //先找到left、right位置对应的节点</span><br><span class="line">        auto *pre = new ListNode(); //重新定义新的头部</span><br><span class="line">        auto *carry = pre;</span><br><span class="line">        auto *prel = head, *prer = head;</span><br><span class="line">        while (left &gt; 1)&#123;</span><br><span class="line">            carry-&gt;next = new ListNode(prel-&gt;val);</span><br><span class="line">            carry = carry-&gt;next;    //carry在prel之前</span><br><span class="line">            prel = prel-&gt;next;</span><br><span class="line">            --left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bool flag = false;</span><br><span class="line">        vector&lt;int&gt; tmp;</span><br><span class="line">        while (right &gt; 1)&#123;</span><br><span class="line">            if(prer == prel) flag = true;</span><br><span class="line">            if(flag) tmp.emplace_back(prer-&gt;val);</span><br><span class="line">            prer = prer-&gt;next;</span><br><span class="line">            --right;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp.emplace_back(prer-&gt;val);    //最后prel节点的数字</span><br><span class="line"></span><br><span class="line">//        cout &lt;&lt; carry-&gt;val &lt;&lt; &quot; &quot; &lt;&lt; prel-&gt;val &lt;&lt; &quot; &quot; &lt;&lt; prer-&gt;val &lt;&lt; endl;</span><br><span class="line">        auto *mid = new ListNode();</span><br><span class="line">        auto *mid_tmp = mid;</span><br><span class="line">        for(int i = tmp.size(); i &gt; 0; --i)&#123;</span><br><span class="line">            mid_tmp-&gt;next = new ListNode(tmp[i - 1]);</span><br><span class="line">            mid_tmp = mid_tmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">//        cout &lt;&lt; tmp.size() &lt;&lt; &quot; - &quot; &lt;&lt; mid-&gt;next-&gt;val &lt;&lt; &quot; &quot; &lt;&lt; mid_tmp-&gt;val &lt;&lt; endl;</span><br><span class="line">        carry-&gt;next = mid-&gt;next;    //第一次链接</span><br><span class="line">        mid_tmp-&gt;next = prer-&gt;next; //第二次链接</span><br><span class="line"></span><br><span class="line">        return pre-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    auto *head = new ListNode(1);</span><br><span class="line">    auto *carry = head;</span><br><span class="line">    carry-&gt;next = new ListNode(2);</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    carry-&gt;next = new ListNode(3);</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    carry-&gt;next = new ListNode(4);</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    carry-&gt;next = new ListNode(5);</span><br><span class="line">    Solution solution;</span><br><span class="line">    auto *res = solution.reverseBetween(head, 4, 5);</span><br><span class="line">    carry = res;</span><br><span class="line">    while (carry != nullptr)&#123;</span><br><span class="line">        cout &lt;&lt; carry-&gt;val &lt;&lt; &quot; &quot;;</span><br><span class="line">        carry = carry-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="138-复制带随机指针的链表"><a href="#138-复制带随机指针的链表" class="headerlink" title="138_复制带随机指针的链表"></a>138_复制带随机指针的链表</h2><ul>
<li>有了之前那个深拷贝图题的摧残，这题自然也就不在话下，dfs搞定</li>
<li>再练习下bfs；这题的bfs好像行不通，看看题解——迭代、新旧节点交替</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Node &#123;</span><br><span class="line">public:</span><br><span class="line">    int val;</span><br><span class="line">    Node* next;</span><br><span class="line">    Node* random;</span><br><span class="line">    </span><br><span class="line">    Node(int _val) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        next = NULL;</span><br><span class="line">        random = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    unordered_map&lt;Node*, Node*&gt; map;</span><br><span class="line">    Node* copyRandomList(Node* head) &#123;</span><br><span class="line">        if(!head) return nullptr;</span><br><span class="line"></span><br><span class="line">        if(map.find(head) != map.end())</span><br><span class="line">            return map[head];</span><br><span class="line"></span><br><span class="line">        Node* res = new Node(head-&gt;val);</span><br><span class="line">        map[head] = res;</span><br><span class="line"></span><br><span class="line">        res-&gt;next = copyRandomList(head-&gt;next);</span><br><span class="line">        res-&gt;random = copyRandomList(head-&gt;random);</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="二刷-4"><a href="#二刷-4" class="headerlink" title="二刷"></a>二刷</h3><ul>
<li>前几天 剑指Offer 刚做过，不过那时候，两个方法都不会，这次再来复习下<ul>
<li>看了第一次写的，居然用了递归……应该是题解，那就有三种方法了</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 哈希 + 循环</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    Node* copyRandomList(Node* head) &#123;</span><br><span class="line">        if(!head) return nullptr;</span><br><span class="line">        // 先建立 原节点 与 新节点 的对应关系</span><br><span class="line">        unordered_map&lt;Node*, Node*&gt; map;</span><br><span class="line">        auto carry = head;</span><br><span class="line">        while(carry != nullptr)&#123;</span><br><span class="line">            map[carry] = new Node(carry-&gt;val);</span><br><span class="line">            carry = carry-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">		// 这一句也可以不要</span><br><span class="line">        map[nullptr] = nullptr;</span><br><span class="line">        // 这里再将节点连线</span><br><span class="line">        carry = head;</span><br><span class="line">        while(carry != nullptr)&#123;</span><br><span class="line">            // next</span><br><span class="line">            map[carry]-&gt;next = map[carry-&gt;next];</span><br><span class="line">            map[carry]-&gt;random = map[carry-&gt;random];</span><br><span class="line">            carry = carry-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return map[head];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>再写一下拆分</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// 拆分</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    Node* copyRandomList(Node* head) &#123;</span><br><span class="line">        if(!head) return nullptr;</span><br><span class="line">        auto carry = head;</span><br><span class="line">        //添加新的节点的时候，就连好两条线</span><br><span class="line">        while(carry != nullptr)&#123;</span><br><span class="line">            // 先保存下一个节点</span><br><span class="line">            auto tmp = carry-&gt;next;</span><br><span class="line">            // next</span><br><span class="line">            carry-&gt;next = new Node(carry-&gt;val);</span><br><span class="line">            carry-&gt;next-&gt;next = tmp;</span><br><span class="line">            // random 这里不太好弄，得把 next 连好才行</span><br><span class="line">            carry = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        carry = head;</span><br><span class="line">        while(carry != nullptr)&#123;</span><br><span class="line">            auto tmp = carry-&gt;next;</span><br><span class="line">            // random，这里还要判断是否不为空</span><br><span class="line">            if(carry-&gt;random != nullptr) tmp-&gt;random = carry-&gt;random-&gt;next;</span><br><span class="line">            carry = tmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        // 拆分</span><br><span class="line">        carry = head;</span><br><span class="line">        auto nHead = carry-&gt;next;</span><br><span class="line">        auto cur = nHead;</span><br><span class="line">        while(carry != nullptr)&#123;</span><br><span class="line">            carry-&gt;next = cur-&gt;next;</span><br><span class="line">            // 这里也要判断是否不为空</span><br><span class="line">            if(cur-&gt;next != nullptr) cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">            carry = carry-&gt;next;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return nHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141_环形链表"></a>141_环形链表</h2><ul>
<li>哈希表、快慢指针</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool hasCycle(ListNode *head) &#123;</span><br><span class="line">        if(!head || !head-&gt;next) return false;</span><br><span class="line">        auto l = head, r = head-&gt;next;</span><br><span class="line">        while(r != nullptr)&#123;</span><br><span class="line">            l = l-&gt;next;</span><br><span class="line">            r = r-&gt;next;</span><br><span class="line">            if(!r)</span><br><span class="line">                return false;</span><br><span class="line">            r = r-&gt;next;</span><br><span class="line">            if(l == r)</span><br><span class="line">                return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142_环形链表_II"></a>142_环形链表_II</h2><ul>
<li>先判断有没有环？</li>
<li>这题用了哈希表，第一个重复的就是入环的点，没有就<code>return nullptr;</code>；进阶要求是使用常熟空间，再想想其他方法</li>
<li>大佬写的，快慢指针在同一起跑线，有环会在某一点相遇，之后再来一个慢指针，与相遇的点齐头并进，一次一步，之后再相遇的点就是入环点</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">/*</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *detectCycle(ListNode *head) &#123;</span><br><span class="line">        if(!head) return nullptr;</span><br><span class="line">        unordered_set&lt;ListNode*&gt; set;</span><br><span class="line">        auto carry = head;</span><br><span class="line">        while(carry)&#123;</span><br><span class="line">            if(set.find(carry) == set.end())</span><br><span class="line">                set.insert(carry);</span><br><span class="line">            else</span><br><span class="line">                return carry;</span><br><span class="line">            carry = carry-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *detectCycle(ListNode *head) &#123;</span><br><span class="line">        if(!head) return nullptr;</span><br><span class="line">        auto l = head, r = l;</span><br><span class="line">        bool flag = false;</span><br><span class="line">        while(r != nullptr)&#123;</span><br><span class="line">            l = l-&gt;next;</span><br><span class="line">            r = r-&gt;next;</span><br><span class="line">            if(!r)</span><br><span class="line">                break;</span><br><span class="line">            r = r-&gt;next;</span><br><span class="line">            if(l == r)&#123;</span><br><span class="line">                flag = true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!flag)</span><br><span class="line">            return nullptr;</span><br><span class="line"></span><br><span class="line">        auto pos = head;</span><br><span class="line">        while(pos != l)&#123;</span><br><span class="line">            pos = pos-&gt;next;</span><br><span class="line">            l = l-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="143-重排链表"><a href="#143-重排链表" class="headerlink" title="143_重排链表"></a>143_重排链表</h2><ul>
<li>内存消耗可以，用时比较拉跨</li>
<li>题解用了线性表，用下标访问节点</li>
<li>还有种方法，找中点、反转后半段链表、再合并，反转链表在后边，先留着</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">/*class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void updateR(ListNode* &amp;r)&#123;</span><br><span class="line">        auto tmp = r;</span><br><span class="line">        while(r-&gt;next != nullptr &amp;&amp; r-&gt;next != tmp)&#123;</span><br><span class="line">            r = r-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void reorderList(ListNode* head) &#123;</span><br><span class="line">        if(!head || !head-&gt;next) return;</span><br><span class="line">        auto l = head, r = l;</span><br><span class="line">        updateR(r);</span><br><span class="line">        while(l != r)&#123;</span><br><span class="line">            auto tmp = l-&gt;next;</span><br><span class="line">            l-&gt;next = r;</span><br><span class="line">            r-&gt;next = tmp;</span><br><span class="line">            l = tmp;</span><br><span class="line">            updateR(r);</span><br><span class="line">        &#125;</span><br><span class="line">        l-&gt;next = nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void reorderList(ListNode *head) &#123;</span><br><span class="line">        if (head == nullptr) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;ListNode *&gt; vec;</span><br><span class="line">        ListNode *node = head;</span><br><span class="line">        while (node != nullptr) &#123;</span><br><span class="line">            vec.emplace_back(node);</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        int i = 0, j = vec.size() - 1;</span><br><span class="line">        while (i &lt; j) &#123;</span><br><span class="line">            vec[i]-&gt;next = vec[j];</span><br><span class="line">            i++;</span><br><span class="line">            if (i == j) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            vec[j]-&gt;next = vec[i];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        vec[i]-&gt;next = nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="146-LRU-缓存机制"><a href="#146-LRU-缓存机制" class="headerlink" title="146_LRU 缓存机制"></a>146_LRU 缓存机制</h2><ul>
<li>这题没想到用链表而且还是手写的…</li>
<li>倒是想到了队列，每次用到都放（移动）在前面或者后面，这样另一面就是没用到的了</li>
<li>双向链表在<code>new</code>的时候，也要<code>delete</code>；巧妙结合了<code>map</code>与<code>list</code>的特性，类似于<code>key---node(key, value)</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct DLinkedNode &#123;</span><br><span class="line">    int key, value;</span><br><span class="line">    DLinkedNode* prev;</span><br><span class="line">    DLinkedNode* next;</span><br><span class="line">    DLinkedNode(): key(0), value(0), prev(nullptr), next(nullptr) &#123;&#125;</span><br><span class="line">    DLinkedNode(int _key, int _value): key(_key), value(_value), prev(nullptr), next(nullptr) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class LRUCache &#123;</span><br><span class="line">private:</span><br><span class="line">    unordered_map&lt;int, DLinkedNode*&gt; cache;</span><br><span class="line">    DLinkedNode* head;</span><br><span class="line">    DLinkedNode* tail;</span><br><span class="line">    int size;</span><br><span class="line">    int capacity;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    LRUCache(int _capacity): capacity(_capacity), size(0) &#123;</span><br><span class="line">        // 使用伪头部和伪尾部节点</span><br><span class="line">        head = new DLinkedNode();</span><br><span class="line">        tail = new DLinkedNode();</span><br><span class="line">        head-&gt;next = tail;</span><br><span class="line">        tail-&gt;prev = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int get(int key) &#123;</span><br><span class="line">        if (!cache.count(key)) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果 key 存在，先通过哈希表定位，再移到头部</span><br><span class="line">        DLinkedNode* node = cache[key];</span><br><span class="line">        moveToHead(node);</span><br><span class="line">        return node-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void put(int key, int value) &#123;</span><br><span class="line">        if (!cache.count(key)) &#123;</span><br><span class="line">            // 如果 key 不存在，创建一个新的节点</span><br><span class="line">            DLinkedNode* node = new DLinkedNode(key, value);</span><br><span class="line">            // 添加进哈希表</span><br><span class="line">            cache[key] = node;</span><br><span class="line">            // 添加至双向链表的头部</span><br><span class="line">            addToHead(node);</span><br><span class="line">            ++size;</span><br><span class="line">            if (size &gt; capacity) &#123;</span><br><span class="line">                // 如果超出容量，删除双向链表的尾部节点</span><br><span class="line">                DLinkedNode* removed = removeTail();</span><br><span class="line">                // 删除哈希表中对应的项</span><br><span class="line">                cache.erase(removed-&gt;key);</span><br><span class="line">                // 防止内存泄漏</span><br><span class="line">                delete removed;</span><br><span class="line">                --size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部</span><br><span class="line">            DLinkedNode* node = cache[key];</span><br><span class="line">            node-&gt;value = value;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void addToHead(DLinkedNode* node) &#123;</span><br><span class="line">        node-&gt;prev = head;</span><br><span class="line">        node-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;next-&gt;prev = node;</span><br><span class="line">        head-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void removeNode(DLinkedNode* node) &#123;</span><br><span class="line">        node-&gt;prev-&gt;next = node-&gt;next;  //双向链表的删除节点真是秒啊</span><br><span class="line">        node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void moveToHead(DLinkedNode* node) &#123;</span><br><span class="line">        removeNode(node);   //调用删除和增加节点函数</span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DLinkedNode* removeTail() &#123;</span><br><span class="line">        DLinkedNode* node = tail-&gt;prev;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>2021.10.31 开始二刷的第二天<ul>
<li>想了半天，一直在 <code>unordered_map</code> 与 <code>queue</code> 死磕</li>
<li>看到双向链表，愣了一下，不知道怎么处理，看了题解才知道<ul>
<li>靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的。</li>
<li>插入节点、删除节点！！！</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="147-对链表进行插入排序"><a href="#147-对链表进行插入排序" class="headerlink" title="147_对链表进行插入排序"></a>147_对链表进行插入排序</h2><ul>
<li>感觉不是很难</li>
<li>有了上一题的思路，这题用了伪头节点，需要注意的是，最后的<code>head</code>已不是输出的答案，而是伪头节点的<code>next</code>！！</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* insertionSortList(ListNode* head) &#123;</span><br><span class="line">        auto h = new ListNode();</span><br><span class="line">        h-&gt;next = head;</span><br><span class="line">        auto pre = h, carry = head;</span><br><span class="line">        while(carry != nullptr)&#123;</span><br><span class="line">            carry = carry-&gt;next;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">            //cout &lt;&lt; pre-&gt;val &lt;&lt; &quot; -&gt; &quot; &lt;&lt; carry-&gt;val &lt;&lt; endl;</span><br><span class="line">            while(carry != nullptr &amp;&amp; carry-&gt;val &lt; pre-&gt;val)&#123;</span><br><span class="line">                pre-&gt;next = carry-&gt;next;</span><br><span class="line">                auto tmp = h;</span><br><span class="line">                while(tmp-&gt;next-&gt;val &lt; carry-&gt;val)</span><br><span class="line">                    tmp = tmp-&gt;next;</span><br><span class="line">                //cout &lt;&lt; &quot;tmp = &quot; &lt;&lt; tmp-&gt;val &lt;&lt; endl;</span><br><span class="line">                carry-&gt;next = tmp-&gt;next;</span><br><span class="line">                tmp-&gt;next = carry;</span><br><span class="line">                carry = pre-&gt;next;</span><br><span class="line">                /*if(carry)</span><br><span class="line">                    cout &lt;&lt; &quot;pre = &quot; &lt;&lt; pre-&gt;val &lt;&lt; &quot; carry = &quot; &lt;&lt; carry-&gt;val &lt;&lt; endl;*/</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head = h-&gt;next;</span><br><span class="line">        delete h;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148_排序链表"></a>148_排序链表</h2><ul>
<li>这题可以直接用上一题的解法…</li>
<li>排序算法要多看看，这题用上一题的方法，执行用时很高，想想其他的办法</li>
<li>用一个数组来维护所有节点的值，居然会快很多…</li>
<li>时间复杂度是 O(n \log n)O(nlogn) 的排序算法包括归并排序、堆排序和快速排序（快速排序的最差时间复杂度是 O(n^2)O(n2)），其中最适合链表的排序算法是归并排序。</li>
<li>合并两条链表那题又刷了一遍，还是错了两次…</li>
<li>后来发现是中点那个函数出了问题，对于三个节点的链表，会无限循环；嗯，两个节点的链表也会…</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//自顶向下归并排序</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* midpoint(ListNode* head)&#123;</span><br><span class="line">        auto mid = head, cur = mid;</span><br><span class="line">        while (cur != nullptr)&#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            if(!cur)</span><br><span class="line">                break;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            if(!cur)</span><br><span class="line">                break;</span><br><span class="line">            mid = mid-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return mid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;</span><br><span class="line">        if(!l1) return l2;</span><br><span class="line">        if(!l2) return l1;</span><br><span class="line"></span><br><span class="line">        auto carry1 = l1, carry2 = l2;</span><br><span class="line">        while(carry1 != nullptr &amp;&amp; carry2 != nullptr)&#123;</span><br><span class="line">            ListNode* prev = nullptr;</span><br><span class="line">            while (carry1 != nullptr &amp;&amp; carry1-&gt;val &lt;= carry2-&gt;val)&#123;</span><br><span class="line">                prev = carry1;</span><br><span class="line">                carry1 = carry1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            if(prev != nullptr)</span><br><span class="line">                prev-&gt;next = carry2;</span><br><span class="line">            prev = nullptr;</span><br><span class="line">            while (carry1 != nullptr &amp;&amp; carry2 != nullptr &amp;&amp; carry2-&gt;val &lt;= carry1-&gt;val)&#123;</span><br><span class="line">                prev = carry2;</span><br><span class="line">                carry2 = carry2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            if(prev != nullptr)</span><br><span class="line">                prev-&gt;next = carry1;</span><br><span class="line">        &#125;</span><br><span class="line">        return l1-&gt;val &lt;= l2-&gt;val ? l1 : l2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode* sortList(ListNode* head) &#123;</span><br><span class="line">        if(!head || !head-&gt;next) return head;</span><br><span class="line">        //找中点</span><br><span class="line">        auto mid = midpoint(head);</span><br><span class="line">        //拆分链表</span><br><span class="line">        auto tmp = mid-&gt;next;</span><br><span class="line">        mid-&gt;next = nullptr;</span><br><span class="line"></span><br><span class="line">        auto l = head;</span><br><span class="line">        while (l != nullptr)&#123;</span><br><span class="line">            cout &lt;&lt; l-&gt;val &lt;&lt; &quot;-&gt;&quot;;</span><br><span class="line">            l = l-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        l = tmp;</span><br><span class="line">        while (l != nullptr)&#123;</span><br><span class="line">            cout &lt;&lt; l-&gt;val &lt;&lt; &quot;-&gt;&quot;;</span><br><span class="line">            l = l-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        //对两条链表分别排序</span><br><span class="line">        auto h1 = sortList(head);</span><br><span class="line">        auto h2 = sortList(tmp);</span><br><span class="line">        //合并两个有序链表</span><br><span class="line">        auto res = mergeTwoLists(h1, h2);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160_相交链表"></a>160_相交链表</h2><ul>
<li>题解很妙，创建两个指针 pA 和 pB，分别初始化为链表 A 和 B 的头结点。然后让它们向后逐结点遍历。当 pA 到达链表的尾部时，将它重定位到链表 B 的头结点; 类似的，当 pB 到达链表的尾部时，将它重定位到链表 A 的头结点。</li>
<li>这样就相当于，总长度是一样的，而终点就是相交的的点，而且只一次遍历即可</li>
<li>我之前是用了环形链表找第一个入环点的思路</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /*ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;</span><br><span class="line">        if(!headA || !headB) return nullptr;</span><br><span class="line">        auto tail = headA;</span><br><span class="line">        while(tail-&gt;next != nullptr)&#123;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tail-&gt;next = headA;</span><br><span class="line">        auto l = headB, r = l;</span><br><span class="line">        while(r != nullptr)&#123;</span><br><span class="line">            r = r-&gt;next;</span><br><span class="line">            if(!r)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            r = r-&gt;next;</span><br><span class="line">            l = l-&gt;next;</span><br><span class="line">            if(l == r)</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!r)&#123;</span><br><span class="line">            tail-&gt;next = nullptr;</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        auto carry = headB;</span><br><span class="line">        while(carry != r)&#123;</span><br><span class="line">            carry = carry-&gt;next;</span><br><span class="line">            r = r-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tail-&gt;next = nullptr;</span><br><span class="line">        return carry;</span><br><span class="line"></span><br><span class="line">    &#125;*/</span><br><span class="line">    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;</span><br><span class="line">        auto carry1 = headA, carry2 = headB;</span><br><span class="line">        while (carry1 != carry2)&#123;</span><br><span class="line">            if(!carry1)</span><br><span class="line">                carry1 = headB;</span><br><span class="line">            else</span><br><span class="line">                carry1 = carry1-&gt;next;</span><br><span class="line">            if(!carry2)</span><br><span class="line">                carry2 = headA;</span><br><span class="line">            else</span><br><span class="line">                carry2 = carry2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return carry1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二刷-5"><a href="#二刷-5" class="headerlink" title="二刷"></a>二刷</h3><ul>
<li>这题要多留个心眼——二刷；看下双指针是怎么证明的</li>
<li>关键点在于不相交的情况下，第二次遍历时会同时变空，因为总长度是一样的；所以循环里只需判断是否会同时变空，若是；直接返回空！</li>
<li>还是题解写的更优雅点</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;</span><br><span class="line">        if (headA == nullptr || headB == nullptr) &#123;</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *pA = headA, *pB = headB;</span><br><span class="line">        while (pA != pB) &#123;</span><br><span class="line">            pA = pA == nullptr ? headB : pA-&gt;next;</span><br><span class="line">            pB = pB == nullptr ? headA : pB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return pA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//自己手撕</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;</span><br><span class="line">        //复习下</span><br><span class="line">        auto a = headA;</span><br><span class="line">        auto b = headB;</span><br><span class="line">        while(a != b)&#123;</span><br><span class="line">            if(!a-&gt;next &amp;&amp; !b-&gt;next)&#123;</span><br><span class="line">                return nullptr;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if(!a-&gt;next)&#123;</span><br><span class="line">                a = headB;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                a = a-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if(!b-&gt;next)&#123;</span><br><span class="line">                b = headA;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                b = b-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202_快乐数"></a>202_快乐数</h2><ul>
<li>这题放在链表是有原因的，但是我没想到，，只用了数学的方法…</li>
<li>反了，数学的方法需要找规律，我用的就是哈希表记录重复的数字</li>
<li>快慢指针自然也就没想到</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;unordered_set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    //n为正整数</span><br><span class="line">    bool isHappy(int n) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;n = &quot; &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">//        if(n % 10 == 0)</span><br><span class="line">//            return true;</span><br><span class="line"></span><br><span class="line">        if(record.find(n) != record.end())</span><br><span class="line">            return false;</span><br><span class="line">        else</span><br><span class="line">            record.insert(n);</span><br><span class="line"></span><br><span class="line">        int ans = 0;</span><br><span class="line">        while (n &gt; 0)&#123;</span><br><span class="line">            int tmp = n % 10;</span><br><span class="line">            ans += (tmp * tmp);</span><br><span class="line">            n -= tmp;</span><br><span class="line">            n /= 10;</span><br><span class="line">        &#125;</span><br><span class="line">        if(ans == 1)</span><br><span class="line">            return true;</span><br><span class="line">        return isHappy(ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    unordered_set&lt;int&gt; record;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    Solution solution;</span><br><span class="line">    int n = 5;</span><br><span class="line">    auto res = solution.isHappy(n);</span><br><span class="line">    cout &lt;&lt; &quot;res = &quot; &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203_移除链表元素"></a>203_移除链表元素</h2><ul>
<li>这题比较简单，看看题解有无好的算法</li>
<li>哨兵的思想还是可以的，之前几题都接触过，在头部插一个为头节点</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* removeElements(ListNode* head, int val) &#123;</span><br><span class="line">        if(!head) return nullptr;</span><br><span class="line">        auto* h = new ListNode();</span><br><span class="line">        h-&gt;next = head;</span><br><span class="line">        auto prev = h, curr = head;</span><br><span class="line">        while (curr != nullptr)&#123;</span><br><span class="line">            if(curr-&gt;val == val)&#123;</span><br><span class="line">                prev-&gt;next = curr-&gt;next;</span><br><span class="line">            &#125; else</span><br><span class="line">                prev = prev-&gt;next;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return h-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二刷-6"><a href="#二刷-6" class="headerlink" title="二刷"></a>二刷</h3><ul>
<li>二刷留念</li>
<li>和第一次写的基本差不多，哈哈哈哈</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* removeElements(ListNode* head, int val) &#123;</span><br><span class="line">        //二刷</span><br><span class="line">        //设置个虚拟头节点</span><br><span class="line">        ListNode* h = new ListNode();</span><br><span class="line">        h-&gt;next = head;</span><br><span class="line"></span><br><span class="line">        auto pre = h;</span><br><span class="line">        auto cur = head;</span><br><span class="line">        while(cur != nullptr)&#123;</span><br><span class="line">            if(cur-&gt;val == val)&#123;</span><br><span class="line">                pre-&gt;next = cur-&gt;next;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                pre = cur;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return h-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206_反转链表"></a>206_反转链表</h2><ul>
<li>迭代本能的想到了栈或者队列，但是这题全然不需要，只是每次迭代的时候要保存下一个节点</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">// 栈</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">        if(!head)&#123;</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* nhead = new ListNode();</span><br><span class="line">        auto carry = nhead;</span><br><span class="line"></span><br><span class="line">        stack&lt;ListNode*&gt; stk;</span><br><span class="line">        stk.push(head);</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        while(!stk.empty())&#123;</span><br><span class="line">            while(head != nullptr)&#123;</span><br><span class="line">                stk.push(head);</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            auto tmp = stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">            carry-&gt;next = new ListNode(tmp-&gt;val);</span><br><span class="line">            carry = carry-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return nhead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution_ &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">        ListNode* prev = nullptr;</span><br><span class="line">        auto curr = head;</span><br><span class="line">        while(curr != nullptr)&#123;</span><br><span class="line">            auto tmp = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        return prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234_回文链表"></a>234_回文链表</h2><ul>
<li>这还真不好判断</li>
<li>这个没有重载<code>==</code>，不好比较两个链表是否相等</li>
<li>先计算出总长度<code>len</code>，然后从中间一直到最后将链表反转，然后两个头依次比较是否相等；看看题解是怎么写的</li>
<li>三种方法；第一种：将数值依次保存在数组中，然后用双指针进行比较，这是最简单的方法；第二种：递归没怎么看懂，先用全局变量保存下前节点（相对与回文链表来说），递归会递归到最后一个节点，然后进行比较，问题在于怎么在回溯的同时，全局变量会….嗷！直接<code>next</code>即可，手撕下！第三种：反转的时候，可以用快慢指针，然后可以直接反转前半段链表！之后再依次进行比较</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//自己手撕反转</span><br><span class="line">class Solution1 &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isPalindrome(ListNode* head) &#123;</span><br><span class="line">        if(!head)</span><br><span class="line">            return true;</span><br><span class="line">        //反转下链表？那就先保存下(深拷贝)原链表；不，这样，从中间开始反转，先算出长度</span><br><span class="line">        int len = 0;</span><br><span class="line">        auto carry = head;</span><br><span class="line">        while (carry != nullptr)&#123;</span><br><span class="line">            ++len;</span><br><span class="line">            carry = carry-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(len == 1)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //找到中间点；长度有奇偶性，应该是没关系的</span><br><span class="line">        int n = len / 2;</span><br><span class="line">        carry = head;</span><br><span class="line">        while (n &gt; 1)&#123;</span><br><span class="line">            carry = carry-&gt;next;</span><br><span class="line">            --n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //现在carry是第一段链表的末尾、中间点的前一个</span><br><span class="line">        auto h = carry-&gt;next;</span><br><span class="line">        if(len % 2 == 0)</span><br><span class="line">            carry-&gt;next = nullptr;</span><br><span class="line">        auto node = h-&gt;next;</span><br><span class="line">        h-&gt;next = nullptr;</span><br><span class="line">        while(node != nullptr)&#123;</span><br><span class="line">            auto tmp = node-&gt;next;</span><br><span class="line">            node-&gt;next = h;</span><br><span class="line">            h = node;</span><br><span class="line">            node = tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int i = 0;</span><br><span class="line">        while (i &lt; (len / 2))&#123;</span><br><span class="line">            if(h-&gt;val != head-&gt;val)</span><br><span class="line">                return false;</span><br><span class="line">            h = h-&gt;next;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//递归</span><br><span class="line">class Solution2 &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* pre = nullptr;</span><br><span class="line">    bool ans = true;</span><br><span class="line">    bool isPalindrome(ListNode* head) &#123;</span><br><span class="line">        if(!head)</span><br><span class="line">            return true;</span><br><span class="line"></span><br><span class="line">        pre = head;</span><br><span class="line">        dfs(head);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void dfs(ListNode* head)&#123;</span><br><span class="line">        if(!head || !ans)</span><br><span class="line">            return;</span><br><span class="line">        dfs(head-&gt;next);</span><br><span class="line">        if(pre-&gt;val != head-&gt;val)</span><br><span class="line">            ans = false;</span><br><span class="line">        pre = pre-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//题解递归</span><br><span class="line">class Solution3 &#123;</span><br><span class="line">    ListNode* frontPointer;</span><br><span class="line">public:</span><br><span class="line">    bool recursivelyCheck(ListNode* currentNode) &#123;</span><br><span class="line">        if (currentNode != nullptr) &#123;</span><br><span class="line">            if (!recursivelyCheck(currentNode-&gt;next)) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            //这里比较之前，要先递归到最后一个节点；</span><br><span class="line">            if (currentNode-&gt;val != frontPointer-&gt;val) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            frontPointer = frontPointer-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool isPalindrome(ListNode* head) &#123;</span><br><span class="line">        frontPointer = head;</span><br><span class="line">        return recursivelyCheck(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//快慢指针，前半段链表反转</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isPalindrome(ListNode* head) &#123;</span><br><span class="line">        if(!head || !head-&gt;next)</span><br><span class="line">            return true;</span><br><span class="line"></span><br><span class="line">        auto slow = head;</span><br><span class="line">        auto fast = head;</span><br><span class="line">        auto pre = head;</span><br><span class="line">        while (fast-&gt;next != nullptr)&#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">            //反转</span><br><span class="line">            auto tmp = slow-&gt;next;</span><br><span class="line">            if(slow == head)</span><br><span class="line">                head-&gt;next = nullptr;</span><br><span class="line">            else</span><br><span class="line">                slow-&gt;next = pre;</span><br><span class="line">            pre = slow;</span><br><span class="line">            slow = tmp;</span><br><span class="line"></span><br><span class="line">            if(!fast)</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(fast != nullptr)&#123;</span><br><span class="line">            //奇数</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        while (pre != nullptr)&#123;</span><br><span class="line">            if(pre-&gt;val != slow-&gt;val)</span><br><span class="line">                return false;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="237-删除链表中的节点"><a href="#237-删除链表中的节点" class="headerlink" title="237_删除链表中的节点"></a>237_删除链表中的节点</h2><ul>
<li>一开始没读懂题目，直接蒙了</li>
<li>还有指针作为参数是，会生成一个临时的指针，具有相同的地址，所指的对象相同</li>
<li>优化之后，发现跟题解一样</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//手撕原版</span><br><span class="line">class Solution1 &#123;</span><br><span class="line">public:</span><br><span class="line">    void deleteNode(ListNode* node) &#123;</span><br><span class="line">        //读懂了题目，思路就是：将node的值变为下一个节点的值，并断开连接，若还有下一个节点，那就依次添加新的相同值的节点</span><br><span class="line">        auto carry = node-&gt;next;</span><br><span class="line">        node-&gt;val = carry-&gt;val;</span><br><span class="line">        node-&gt;next = nullptr;</span><br><span class="line">        carry = carry-&gt;next;</span><br><span class="line">        while (carry != nullptr)&#123;</span><br><span class="line">            node-&gt;next = new ListNode(carry-&gt;val);</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">            carry = carry-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//手撕版本2.0；看了时间消耗排名，就知道我写的有点烦了，再优化下！</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void deleteNode(ListNode* node) &#123;</span><br><span class="line">        //先改值，再改变指针的指向</span><br><span class="line">        node-&gt;val = node-&gt;next-&gt;val;</span><br><span class="line">        node-&gt;next = node-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><ul>
<li><strong><em><code>string</code>是一种内置类型，定义的对象可以直接用<code>cout &lt;&lt; s</code>来输出！</em></strong></li>
<li><code>append(): Appends characters to the end</code></li>
<li><code>push_back(): Appends a character to the end</code></li>
<li><code>s.size()</code>类型比<code>int</code>大</li>
</ul>
<h2 id="3-最长字串"><a href="#3-最长字串" class="headerlink" title="3_最长字串"></a>3_最长字串</h2><ul>
<li>输入    <code>&quot;pwwkew&quot;</code></li>
<li>输出    <code>3</code></li>
<li>注意 <code>pwke</code> 不是子串<br><img src="/pictrues/3.jpg" alt="思路" title="思路"></li>
</ul>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using  namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLongestSubstring(string s) &#123;</span><br><span class="line">        string set;</span><br><span class="line">        int i = 0, j = 0, len = 0;</span><br><span class="line">        if(s.size() == 0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        for(j; j &lt; s.size(); j++)&#123;</span><br><span class="line">            if(set.find(s[j]) == -1)&#123;</span><br><span class="line">                set.push_back(s[j]);</span><br><span class="line">                int len1 = set.size();  //unsigned 型（unsignedint 或 unsigned long)</span><br><span class="line">                len = max(len, len1);	// len = max&lt;int&gt;(len, set.size());</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                while(set.find(s[j]) != -1)&#123; // find返回值是元素对应的位置</span><br><span class="line">                    set.erase(0, 1);</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                set.push_back(s[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string s = &quot;abcabcdbb&quot;;</span><br><span class="line">    Solution sl;</span><br><span class="line">    int len = sl.lengthOfLongestSubstring(s);</span><br><span class="line">    cout &lt;&lt; len &lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>2021.11.1 二刷<ul>
<li>这次没有用字符串，而是用哈希表，不过速度变慢了好像！</li>
</ul>
</li>
</ul>
<h2 id="5-最长回文字串"><a href="#5-最长回文字串" class="headerlink" title="5_最长回文字串"></a>5_最长回文字串</h2><ul>
<li>输入<code>&quot;babad&quot;</code>； 输出<code>&quot;bab&quot;</code></li>
<li>输入<code>&quot;cbbd&quot;</code>； 输出<code>&quot;bb&quot;</code></li>
<li>思路<br><img src="/pictrues/5.jpg" alt="思路" title="思路"></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using  namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int start = 0, l = 1;</span><br><span class="line">    string sl;</span><br><span class="line">    void search(int left, int right, string s)&#123;</span><br><span class="line">        while(left &gt;= 0 &amp;&amp; right &lt; s.size() &amp;&amp; s[left] == s[right])&#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(right - left - 1 &gt; l)&#123;</span><br><span class="line">            l = right - left - 1;</span><br><span class="line">            start = left + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    string longestPalindrome(string s) &#123;</span><br><span class="line">        for(int i = 0; i &lt; s.size(); i++)&#123;</span><br><span class="line">            search(i-1, i+1, s);</span><br><span class="line">            search(i+0, i+1, s);</span><br><span class="line">        &#125;</span><br><span class="line">        return sl.append(s, start, l);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string s = &quot;babad&quot;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    string l = solution.longestPalindrome(s);</span><br><span class="line">    for(int i = 0; i &lt; l.size(); i++)&#123;</span><br><span class="line">        cout &lt;&lt; l[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-Z形变换"><a href="#6-Z形变换" class="headerlink" title="6_Z形变换"></a>6_Z形变换</h2><ul>
<li>输入<code>&quot;LEETCODEISHIRING&quot;</code><br><img src="/pictrues/Z%E5%BD%A2.png" alt="Z形" title="Z形"></li>
<li>输出<code>&quot;LCIRETOESIIGEDHN&quot;</code>，行数3<br><img src="/pictrues/Z%E5%BD%A21.png" alt="Z形" title="Z形"></li>
<li>输出<code>&quot;LDREOEIIECIHNTSG&quot;</code>，行数4</li>
<li>思路<br><img src="/pictrues/Z.jpg" alt="思路" title="思路"></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string convert(string s, int numRows) &#123;</span><br><span class="line">        if(numRows == 1)&#123;return s;&#125;</span><br><span class="line">        string l;   // 存放输出</span><br><span class="line">        int numColumns = 1;</span><br><span class="line">        bool flag = true;   // 方向</span><br><span class="line">        vector&lt;vector&lt;char&gt;&gt; a(numRows, vector&lt;char&gt;(numColumns));</span><br><span class="line">        int n = 0, len = 0;</span><br><span class="line">        while (len &lt; s.size())&#123;</span><br><span class="line">            if(flag)&#123;</span><br><span class="line">                a[n].push_back(s[len]);</span><br><span class="line">                len ++;</span><br><span class="line">                n ++;</span><br><span class="line">                if(n &gt;= numRows)&#123;n -= 2; flag = false;&#125;</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                a[n].push_back(s[len]);</span><br><span class="line">                len ++;</span><br><span class="line">                n --;</span><br><span class="line">                if(n &lt; 0)&#123;n += 2; flag = true;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; numRows; i++)&#123;</span><br><span class="line">            for(int j = 1; j &lt; a[i].size(); j++)&#123;</span><br><span class="line">                l.push_back(a[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return l ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string s = &quot;LEETCODEISHIRING&quot;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    string l = solution.convert(s, 3);</span><br><span class="line">    for(int i = 0; i &lt; l.size(); i++)&#123;</span><br><span class="line">        cout &lt;&lt; l[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-字符串转整数"><a href="#8-字符串转整数" class="headerlink" title="8_字符串转整数"></a>8_字符串转整数</h2><ul>
<li>根据要求，维护一个指针，遍历，只有三种情况<code>“+···”、“-···”、“···”</code>才可继续下一步</li>
<li><code>···</code>表示数字，之后再化成整形，注意<font color="#FF0000">int</font>是否溢出溢出</li>
<li><code>s[i] - &#39;0&#39; &gt; 7</code>一个是字符类型，ASCALL码，一个是int型</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;cctype&gt;   // ctype.h</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int myAtoi(string s)&#123;</span><br><span class="line">        int i = 0, res = 0;</span><br><span class="line">        int flag = 1;</span><br><span class="line">        while (s[i] == &apos; &apos;)&#123;i++;&#125;</span><br><span class="line">        if(s[i] == &apos;-&apos;)&#123;flag = -1;&#125;</span><br><span class="line">        if(s[i] == &apos;-&apos; || s[i] == &apos;+&apos;)&#123;i++;&#125;</span><br><span class="line">        while (i &lt; s.size() &amp;&amp; isdigit(s[i]))&#123;</span><br><span class="line">            if(res &gt; INT32_MAX / 10 || (res == INT32_MAX / 10 &amp;&amp; (s[i] - &apos;0&apos;) &gt; 7))&#123;</span><br><span class="line">                return flag &gt; 0 ? INT32_MAX : INT32_MIN;</span><br><span class="line">            &#125;</span><br><span class="line">            res = 10 * res + (int)(s[i] - &apos;0&apos;);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        return flag &gt; 0 ? res : -res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string s = &quot;2147483646&quot;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.myAtoi(s) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-正则表达式匹配"><a href="#10-正则表达式匹配" class="headerlink" title="10_正则表达式匹配"></a>10_正则表达式匹配</h2><h3 id="递归-5"><a href="#递归-5" class="headerlink" title="递归"></a>递归</h3><ul>
<li>从前有座山，山里有个庙，庙里有个老和尚在给小和尚讲故事，讲的什么呀，讲的是从前有座山，山里有个庙······</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isMatch(string s, string p) &#123;</span><br><span class="line">        if(p.empty()) return s.empty();</span><br><span class="line"></span><br><span class="line">        bool firstmatch = !s.empty() &amp;&amp; (s[0] == p[0] || p[0] == &apos;.&apos;);</span><br><span class="line"></span><br><span class="line">        if(p.size() &gt;= 2 &amp;&amp; p[1] == &apos;*&apos;)&#123;</span><br><span class="line">            return isMatch(s, p.substr(2, p.size() - 2)) || (firstmatch &amp;&amp; isMatch(s.substr(1, s.size() - 1), p));</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">            return firstmatch &amp;&amp; isMatch(s.substr(1, s.size() - 1), p.substr(1, p.size() - 1));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string s = &quot;aa&quot;, p = &quot;*&quot;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    std::cout &lt;&lt; solution.isMatch(s, p) &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="12-整数转罗马数字"><a href="#12-整数转罗马数字" class="headerlink" title="12_整数转罗马数字"></a>12_整数转罗马数字</h2><ul>
<li>输入<code>3</code>，输出<code>III</code>、输入<code>9</code>，输出<code>IX</code></li>
<li>以下整数与罗马数字两两对应</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1&#125;;</span><br><span class="line">&#123;&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="贪心算法-1"><a href="#贪心算法-1" class="headerlink" title="贪心算法"></a>贪心算法</h3><ul>
<li>尽可能地找最大值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string intToRoman(int num) &#123;</span><br><span class="line">        int val[] = &#123;1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1&#125;;</span><br><span class="line">        string sym[] = &#123;&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;&#125;;</span><br><span class="line">        string s;</span><br><span class="line">        for(int i = 0; i &lt; 13; i++)&#123;</span><br><span class="line">            while (num &gt;= val[i])&#123;   // 不用if，是因为38里有3个10，而不是减一次就去减9</span><br><span class="line">                num -= val[i];</span><br><span class="line">                s.append(sym[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    Solution solution;</span><br><span class="line">    int x = 671;</span><br><span class="line">    std::cout &lt;&lt; solution.intToRoman(x) &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13_罗马数字转整数"></a>13_罗马数字转整数</h2><ul>
<li>只要这个<code>s[i]</code>字符对应的数字比<code>s[i+1]</code>小，就减去<code>s[i]</code>字符对应的数字</li>
<li>照这个思路最后一位字符对应的数字一定是加</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int romanToInt(string s) &#123;</span><br><span class="line">        int val[] = &#123;1000, 500, 100, 50, 10, 5, 1&#125;;</span><br><span class="line">        string sym = &quot;MDCLXVI&quot;;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for(int i = 0; i &lt; s.size(); i++)&#123;</span><br><span class="line">            int j = sym.find(s[i]);</span><br><span class="line">            if(i &lt; s.size() - 1 &amp;&amp; j &gt; sym.find(s[i + 1]))&#123;</span><br><span class="line">                sum -= val[j];</span><br><span class="line">            &#125; else sum += val[j];</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    string s = &quot;LVIII&quot;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    std::cout &lt;&lt; solution.romanToInt(s) &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14_最长公共前缀"></a>14_最长公共前缀</h2><ul>
<li>输入：<code>[&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</code></li>
<li>输出：<code>&quot;fl&quot;</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        string s;</span><br><span class="line">        int len = 0;	// 计算出最短的字符长度</span><br><span class="line">        for(auto &amp; str : strs)&#123;</span><br><span class="line">            len = max&lt;int&gt;(len, str.size());</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; len; i++)&#123;</span><br><span class="line">            int j = 0;</span><br><span class="line">            while (j &lt; strs.size() - 1 &amp;&amp; strs[j][i] == strs[j+1][i])&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            if(j == strs.size() - 1)&#123;</span><br><span class="line">                s.push_back(strs[0][i]);</span><br><span class="line">            &#125; else break;</span><br><span class="line">        &#125;</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;string&gt; strs = &#123;&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    int i = 0;</span><br><span class="line">    string s = solution.longestCommonPrefix(strs);</span><br><span class="line">    while (i &lt; s.size())&#123;</span><br><span class="line">        std::cout &lt;&lt; s[i];</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20_有效的括号"></a>20_有效的括号</h2><h3 id="递归-6"><a href="#递归-6" class="headerlink" title="递归"></a>递归</h3><ul>
<li>复杂度比较高</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isValid(string s) &#123;</span><br><span class="line">        int len = s.size();</span><br><span class="line">        cout &lt;&lt; &quot;len = &quot; &lt;&lt; len &lt;&lt; endl;</span><br><span class="line">        if(len % 2 == 1)&#123;return false;&#125;</span><br><span class="line">        if(len == 2 &amp;&amp; ((s[0] == &apos;(&apos; &amp;&amp; s[1] == &apos;)&apos;) || (s[0] == &apos;[&apos; &amp;&amp; s[1] == &apos;]&apos;) || (s[0] == &apos;&#123;&apos; &amp;&amp; s[1] == &apos;&#125;&apos;)))&#123;return true;&#125;</span><br><span class="line">        bool flag = false;</span><br><span class="line">        string l;</span><br><span class="line">        for(int i = 0; i &lt; len - 1; i++)&#123;</span><br><span class="line">            if((s[i] == &apos;(&apos; &amp;&amp; s[i + 1] == &apos;)&apos;) || (s[i] == &apos;[&apos; &amp;&amp; s[i + 1] == &apos;]&apos;) || (s[i] == &apos;&#123;&apos; &amp;&amp; s[i + 1] == &apos;&#125;&apos;))&#123;</span><br><span class="line">                flag = true;</span><br><span class="line">                if(i == 0)&#123;</span><br><span class="line">                    l = s.substr(2, len - 2);</span><br><span class="line">                &#125; else&#123;</span><br><span class="line">                    l = s.substr(0, i) + s.substr(i + 2, len - i - 1);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(flag)&#123;</span><br><span class="line">            return isValid(l);</span><br><span class="line">        &#125; else return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    Solution solution;</span><br><span class="line">    string s = &quot;(([])&#123;&#125;)&quot;;</span><br><span class="line">    std::cout &lt;&lt; solution.isValid(s) &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="栈-1"><a href="#栈-1" class="headerlink" title="栈"></a>栈</h3><ul>
<li><code>HashMap</code>头文件<code>&lt;unordered_map&gt;</code>，栈头文件<code>&lt;stack&gt;</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isValid(string s) &#123;</span><br><span class="line">        int n = s.size();</span><br><span class="line">        if (n % 2 == 1) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        unordered_map&lt;char, char&gt; pairs = &#123;</span><br><span class="line">                &#123;&apos;)&apos;, &apos;(&apos;&#125;,</span><br><span class="line">                &#123;&apos;]&apos;, &apos;[&apos;&#125;,</span><br><span class="line">                &#123;&apos;&#125;&apos;, &apos;&#123;&apos;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        stack&lt;char&gt; stk;</span><br><span class="line">        for (char ch: s) &#123;</span><br><span class="line">            if (pairs.count(ch)) &#123;  // 先找右括号</span><br><span class="line">                if (stk.empty() || stk.top() != pairs[ch]) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">                stk.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;  // 左括号依次弹入堆栈</span><br><span class="line">                stk.push(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stk.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    Solution solution;</span><br><span class="line">    string s = &quot;(([])&#123;&#125;)&quot;;</span><br><span class="line">    std::cout &lt;&lt; solution.isValid(s) &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="28-实现strStr"><a href="#28-实现strStr" class="headerlink" title="28_实现strStr()"></a>28_实现strStr()</h2><ul>
<li>字符串比较，可以直接用<code>string</code>里的<code>compare()</code>函数，也可以用<code>substr()</code>函数</li>
<li>不用再写一个一个元素进行比较的算法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int strStr(string haystack, string needle) &#123;</span><br><span class="line">        int l = needle.size(), n = haystack.size();</span><br><span class="line">        for(int start = 0; start &lt; n - l + 1; start++)&#123;</span><br><span class="line">            if(haystack.compare(start, l, needle) == 0)&#123;</span><br><span class="line">                return start;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	int strStr_(string haystack, string needle) &#123;</span><br><span class="line">        if(needle.empty()) return 0;</span><br><span class="line">        int l = needle.size(), r = haystack.size();</span><br><span class="line">        if(r &lt; l) return -1;    //加上这句运行更快？？</span><br><span class="line">        for(int i = 0; i &lt; (r - l + 1); ++i)&#123;</span><br><span class="line">            //i &lt; (haystack.size() - l + 1)应该是string::size_type没有负数，类型不一样</span><br><span class="line">            //for循环是先进入再判断条件吗，不对一开始就为false，一次也不执行，那就是要加括号？？</span><br><span class="line">            //substr的长度是总长度</span><br><span class="line">            if(haystack.substr(i, l) == needle)</span><br><span class="line">                return i;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    string haystack = &quot;mississippi&quot;;</span><br><span class="line">    string needle = &quot;issipi&quot;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.strStr(haystack, needle);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="30-串联所有单词的字串"><a href="#30-串联所有单词的字串" class="headerlink" title="30_串联所有单词的字串"></a>30_串联所有单词的字串</h2><ul>
<li>这题应该另起山头-哈希表，或者二叉树什么的，比较字符串的时候没有用<code>substr</code>，而是用了<code>unordered_map</code>里的<code>count</code>，是否有字符串类型的<code>key</code></li>
<li><code>map</code>的<code>value</code>是单词对应的个数</li>
<li>另一个核心思路是滑动窗口：之前有个题目是一个字符进行比较，而现在是一个单词(的<font color="#FF0000">长度</font>)，为了方便比较，将<code>words</code>转换成哈希表<code>m1</code></li>
<li>对<code>s</code>起始<font color="#FF0000">一个单词长度</font>进行遍历，<code>left</code>、<code>right</code>分别是窗口的左右边，每次更新增加一个单词的长度<code>one_word</code>，<code>right</code>一直更新到<code>s</code>末尾</li>
<li><code>s</code>中从<code>i</code>开始的第一个单词<code>s_tmp</code>，如果<code>m1</code>有，则将其放入新建的哈希表<code>m2</code>，其键值每次都加一，可以直接写成<code>m2[s_tmp]++</code>，如果数量超过了原本的数量，从<code>left</code>开始删除单词并更新<code>left</code>，直到数量相等，之后判断<code>m2</code>单词总数量<font color="#FF0000"><code>count</code></font>是否等于题目单词的总个数，等于保存<code>left</code></li>
<li>如果<code>m1</code>没有，更新<code>m2</code>、<code>left</code>、<code>count</code></li>
<li>注意的是，如果单词长度是3，那么<code>i</code>只需遍历到<code>s[2]</code>即可，之后就重复了</li>
</ul>
<h3 id="滑动窗口-1"><a href="#滑动窗口-1" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    // 滑动窗口</span><br><span class="line">    vector&lt;int&gt; findSubstring(string s, vector&lt;string&gt;&amp; words) &#123;</span><br><span class="line">        if(words.empty() || words[0].empty())&#123;return &#123;0&#125;;&#125;</span><br><span class="line">        int one_word = words[0].size();</span><br><span class="line">        int nums_word = words.size();</span><br><span class="line">        int len = nums_word * one_word;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        unordered_map&lt;string, int&gt; m1;</span><br><span class="line">        for(const auto&amp; str : words)&#123;m1[str]++;&#125;</span><br><span class="line"></span><br><span class="line">        for(int i = 0; i &lt; one_word; i++)&#123;</span><br><span class="line">            int left = i, right = i, count = 0;</span><br><span class="line">            unordered_map&lt;string, int&gt; m2;</span><br><span class="line">            while (right &lt; s.size() &amp;&amp; left + len &lt;= s.size())&#123;</span><br><span class="line">                string s_tmp = s.substr(right, one_word);</span><br><span class="line">                right += one_word;</span><br><span class="line">                if(m1.count(s_tmp) &gt; 0)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    m2[s_tmp]++;</span><br><span class="line">                    while (m2[s_tmp] &gt; m1[s_tmp])&#123;</span><br><span class="line">                        string s_tmp_l = s.substr(left, one_word);</span><br><span class="line">                        m2[s_tmp_l]--;</span><br><span class="line">                        count--;</span><br><span class="line">                        left += one_word;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if(count == nums_word)&#123;</span><br><span class="line">                        res.push_back(left);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else&#123;</span><br><span class="line">                    left = right;</span><br><span class="line">                    m2.clear();</span><br><span class="line">                    count = 0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">//    string s = &quot;wordgoodgoodgoodbestword&quot;;</span><br><span class="line">//    vector&lt;string&gt; words = &#123;&quot;word&quot;,&quot;good&quot;,&quot;best&quot;,&quot;good&quot;&#125;;</span><br><span class="line">    string s = &quot;aaa&quot;;</span><br><span class="line">    vector&lt;string&gt; words = &#123;&quot;a&quot;,&quot;a&quot;&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;int&gt; res = solution.findSubstring(s, words);</span><br><span class="line">    for(int i : res)&#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32_最长有效括号"></a>32_最长有效括号</h2><ul>
<li>动态规划不是一般人能想出来的</li>
<li>之前使用栈来判断是否有效，而这次是把字符对应的下标放入栈中，用来更新<font color="#FF0000">最大</font>长度：当前下标标减去栈顶的下标，这两者对应的字符都是右括号</li>
<li>如果是以<code>()</code>为开头，栈也为空，先把-1放入栈，再1-(-1)=2</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int longestValidParentheses(string s) &#123;</span><br><span class="line">        int max_len = 0;</span><br><span class="line">        stack&lt;int&gt; stk;</span><br><span class="line">        stk.push(-1);</span><br><span class="line">        for(int i = 0; i &lt; s.size(); i++)&#123;</span><br><span class="line">            if(s[i] == &apos;(&apos;)&#123;</span><br><span class="line">                stk.push(i);</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                stk.pop();</span><br><span class="line">                if(stk.empty())&#123;</span><br><span class="line">                    stk.push(i);</span><br><span class="line">                &#125; else&#123;</span><br><span class="line">                    max_len = max(max_len, i - stk.top());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return max_len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    string s = &quot;)()()(&quot;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    std::cout &lt;&lt; solution.longestValidParentheses(s) &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="38-外观数列"><a href="#38-外观数列" class="headerlink" title="38_外观数列"></a>38_外观数列</h2><ul>
<li>计算个数的时候，注意字符串的开头和结尾，还有递归函数是有返回值的</li>
</ul>
<h3 id="递归-7"><a href="#递归-7" class="headerlink" title="递归"></a>递归</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    string s = &quot;1&quot;;</span><br><span class="line">public:</span><br><span class="line">    string countAndSay(int n) &#123;</span><br><span class="line">        if(n == 1)&#123;return s;&#125;</span><br><span class="line">        int nums = 0;</span><br><span class="line">        char ch = s[0];</span><br><span class="line">        string tmp;</span><br><span class="line">        for(int i = 0; i &lt; s.size(); i++)&#123;</span><br><span class="line">            if(s[i] == ch)&#123;</span><br><span class="line">                nums++;</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                tmp.push_back(nums + &apos;0&apos;);</span><br><span class="line">                tmp.push_back(ch);</span><br><span class="line">                ch = s[i];</span><br><span class="line">                nums = 1;</span><br><span class="line">            &#125;</span><br><span class="line">            if(i + 1 == s.size())&#123;</span><br><span class="line">                tmp.push_back(nums + &apos;0&apos;);</span><br><span class="line">                tmp.push_back(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s = tmp;</span><br><span class="line">        s = countAndSay(n - 1);</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int n = 1;</span><br><span class="line">    Solution solution;</span><br><span class="line">    string res = solution.countAndSay(n);</span><br><span class="line">    for(char ch : res)&#123;</span><br><span class="line">        cout &lt;&lt; ch;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="43-字符串相乘"><a href="#43-字符串相乘" class="headerlink" title="43_字符串相乘"></a>43_字符串相乘</h2><ul>
<li>整形<code>int</code>与字符型<code>char</code>转换，直接加减‘0’即可，前面无需加括号说明类型</li>
<li>这题思路与下图一样，但我写了半天，一直在进位这里绕不出去，应该换个数据结构….</li>
</ul>
<p><img src="/pictrues/mul.png" alt="mul" title="mul"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string multiply(string num1, string num2) &#123;</span><br><span class="line">        //每一位相乘结果在res[i+1] res[i+j+1]这两位里 累加即可</span><br><span class="line">        if(num1 == &quot;0&quot; || num2 == &quot;0&quot;)&#123;return &quot;0&quot;;&#125;</span><br><span class="line"></span><br><span class="line">        int size1 = num1.length(), size2 = num2.length();</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt; memo(size1+size2, 0);   //只用一个数组来维护结果</span><br><span class="line">        string res = &quot;&quot;;</span><br><span class="line">        for(int i = size1-1; i&gt;=0; i--)&#123;</span><br><span class="line">            int n1 = num1[i]-&apos;0&apos;;</span><br><span class="line">            for(int j = size2-1; j&gt;=0; j--)&#123;</span><br><span class="line">                int n2 = num2[j]-&apos;0&apos;;</span><br><span class="line">                int tempSum = memo[i+j+1]+n1*n2;</span><br><span class="line">                memo[i+j+1] = tempSum % 10;</span><br><span class="line">                memo[i+j] += tempSum / 10;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bool flag = true;   //去除第一个为0的数字</span><br><span class="line">        for(int i = 0; i&lt;memo.size(); i++)&#123;</span><br><span class="line">            if(memo[i] != 0 || !flag)&#123;</span><br><span class="line">                flag = false;</span><br><span class="line">                res.push_back(memo[i]+&apos;0&apos;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    string nums1 = &quot;456&quot;, nums2 = &quot;123&quot;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    string res = solution.multiply(nums1, nums2);</span><br><span class="line">    cout &lt;&lt; &quot;res = &quot;;</span><br><span class="line">    for(auto re : res)&#123;</span><br><span class="line">        cout &lt;&lt; re;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="44-通配符匹配"><a href="#44-通配符匹配" class="headerlink" title="44_通配符匹配"></a>44_通配符匹配</h2><ul>
<li>跟之前的正则表达式匹配好像，温故而知新，‘*’可以匹配任意字符串，包括空字符串，即0个或者多个，在递归的过程中，只需用<code>||</code>即可</li>
<li>就相当于每次都会有一个分支，类似于前面的回溯，会遍历所有种情况，这题用这种方法超出时间限制了</li>
<li>学习下动态规划（字符串匹配）—状态转移方程+边界条件</li>
<li><code>dp[i][j]</code>表示<code>s</code>前<code>i</code>个字符和<code>p</code>前<code>j</code>个字符是否匹配，即<code>bool</code>类型（题解用了int类型的二维数组）；这里就有一个初始情况：<code>dp[0][j]</code>，初始化对字符串<code>p</code>遍历，只有<code>p[j-1] == &#39;*&#39;</code>时，才能为true，一旦不等就跳出循环，当然<code>dp[0][0] = true</code></li>
<li>状态转移方程<code>dp[i][j] = dp[i - 1][j - 1]</code>、<code>dp[i][j] = dp[i][j - 1]</code>、<code>dp[i][j] = dp[i - 1][j]</code>要分几种情况讨论</li>
</ul>
<p><img src="/pictrues/dp.png" alt="dp" title="dp"></p>
<ul>
<li>所有的<code>dp[j][0]</code>和<code>dp[0][j]</code>都是边界条件，最终的答案即为<code>d[m][n]</code></li>
</ul>
<h3 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isMatch(string s, string p) &#123;</span><br><span class="line">        int m = s.size(), n = p.size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1));</span><br><span class="line">        dp[0][0] = true;</span><br><span class="line">        for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">            if (p[i - 1] == &apos;*&apos;) &#123;</span><br><span class="line">                dp[0][i] = true;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt;= m; ++i) &#123;</span><br><span class="line">            for (int j = 1; j &lt;= n; ++j) &#123;</span><br><span class="line">                if (p[j - 1] == &apos;*&apos;) &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - 1] || dp[i - 1][j];</span><br><span class="line">                &#125;</span><br><span class="line">                else if (p[j - 1] == &apos;?&apos; || s[i - 1] == p[j - 1]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - 1][j - 1];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string s, p;</span><br><span class="line">    s = &quot;babbbbaabababaabbababaababbabbababbbaaaababbbabbbbbbbbbbaabbb&quot;;</span><br><span class="line">    p = &quot;b**bb**a**bba*b**a*bbb**aba***babbb*aa****aabb*bbb***b&quot;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.isMatch(s, p) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49_字母异位词分组"></a>49_字母异位词分组</h2><ul>
<li>哈希表的键值可以是各种类型的！字符串也可以进行排序！</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">        unordered_map&lt;string, vector&lt;string&gt;&gt; map;</span><br><span class="line">        for(const auto&amp; str : strs)&#123;</span><br><span class="line">            string key = str;</span><br><span class="line">            sort(key.begin(), key.end());</span><br><span class="line">            map[key].emplace_back(str);</span><br><span class="line">        &#125;</span><br><span class="line">        for(auto &amp; i : map)&#123;</span><br><span class="line">            res.emplace_back(i.second);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;string&gt; strs = &#123;&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; res = solution.groupAnagrams(strs);</span><br><span class="line">    for(auto i : res)&#123;</span><br><span class="line">        for(auto j : i)&#123;</span><br><span class="line">            for(auto k : j)&#123;</span><br><span class="line">                cout &lt;&lt; k;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; &quot;,&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="58-最后一个单词的长度"><a href="#58-最后一个单词的长度" class="headerlink" title="58_最后一个单词的长度"></a>58_最后一个单词的长度</h2><ul>
<li>这个思路就是一次遍历，更新单词的长度，遇到空格，就初始化</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLastWord(string s) &#123;</span><br><span class="line">        if(s.empty())&#123;return 0;&#125;</span><br><span class="line">//        s.push_back(&apos; &apos;);</span><br><span class="line">        int res = 0, tmp = 0;</span><br><span class="line">        for(auto i : s)&#123;</span><br><span class="line">            if(i == &apos; &apos; &amp;&amp; tmp != 0)&#123;</span><br><span class="line">//                res = tmp;</span><br><span class="line">                tmp = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            if(i != &apos; &apos;)&#123;</span><br><span class="line">                tmp++;</span><br><span class="line">                res = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    string s = &quot;     &quot;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.lengthOfLastWord(s) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="60-排列序列"><a href="#60-排列序列" class="headerlink" title="60_排列序列"></a>60_排列序列</h2><ul>
<li>发现自己的思维会停留在类似的题里，例如那道全排列，所以自然就想到先得出所有全排列的二维数组，再输出第几个，数字大点就超时了</li>
<li>换个思路，按照每个位置可以放几个数，给出<code>k</code>时，其实就可以得出答案了，如<code>n=3, k=2</code>，三个位置，第一个位置放1有（3-1）！也就是后面有2种顺序，再根据<code>k</code>，第一个位置只能放1，放2就超出<code>k</code>的范围了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int factorial(int i)&#123;</span><br><span class="line">        if(i == 0)&#123; //这里写0，是因为参数可能一开始就会输入0</span><br><span class="line">            return 1;</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">            return i * factorial(i - 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    string getPermutation(int n, int k) &#123;</span><br><span class="line">        string res;</span><br><span class="line">        vector&lt;int&gt; number;</span><br><span class="line">        for(int i = 1; i &lt;= n; i++)&#123;</span><br><span class="line">            number.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 1; i &lt;= n; i++)&#123;    //i代表第i个位置</span><br><span class="line">            int num = 0, tmp = factorial(n - i);    //num代表数字1到n的第几个</span><br><span class="line">            while (tmp &lt; k &amp;&amp; num &lt; number.size())&#123;</span><br><span class="line">                num++;</span><br><span class="line">                k -= tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(number[num] + &apos;0&apos;);</span><br><span class="line">            number.erase(number.begin() + num);</span><br><span class="line">        &#125;</span><br><span class="line">        return res; //差点忘了返回值，我说怎么一直报错呢，哈哈哈</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    Solution solution;</span><br><span class="line">    string res = solution.getPermutation(9, 78494);</span><br><span class="line">    for(auto s : res)&#123;</span><br><span class="line">        cout &lt;&lt; s &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="65-有效数字"><a href="#65-有效数字" class="headerlink" title="65_有效数字"></a>65_有效数字</h2><ul>
<li>这题虽说标记为困难，但逻辑比较简单，写起来比较繁琐，要考虑多种可能性</li>
<li>首先根据条件，判断是否有<code>e</code>或者<code>E</code>，如果没有直接判断是否有效（小数或者整数）；如果有，那就拆分字符串为两段：前半段必须有效（小数或者整数），后半段必须是整数</li>
<li>还是康康题解学习下自动机，没怎么看得懂0.0，还是康了一位<a href="https://www.youtube.com/watch?v=5gmtCtAooZE&feature=youtu.be" target="_blank" rel="noopener">yutuber大佬</a>，太强了！</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isNumber(string s) &#123;</span><br><span class="line">        while (s[0] == &apos; &apos;)&#123;s.erase(0, 1);&#125;</span><br><span class="line">        while (s[s.size() - 1] == &apos; &apos;)&#123;s.pop_back();&#125;</span><br><span class="line">        bool numberSeen = false;</span><br><span class="line">        bool dotSeen = false;</span><br><span class="line">        bool eSeen = false;</span><br><span class="line">        for(int i = 0; i &lt; s.size(); i++)&#123;</span><br><span class="line">            if(isdigit(s[i]))&#123;</span><br><span class="line">                numberSeen = true;</span><br><span class="line">            &#125; else if(s[i] == &apos;e&apos; || s[i] == &apos;E&apos;)&#123;</span><br><span class="line">                if(eSeen || !numberSeen)&#123;return false;&#125;</span><br><span class="line">                eSeen = true;</span><br><span class="line">                numberSeen = false;</span><br><span class="line">            &#125; else if(s[i] == &apos;.&apos;)&#123;</span><br><span class="line">                if(dotSeen || eSeen)&#123;return false;&#125;</span><br><span class="line">                dotSeen = true;</span><br><span class="line">            &#125; else if(s[i] == &apos;+&apos; || s[i] == &apos;-&apos;)&#123;</span><br><span class="line">                if(i != 0 &amp;&amp; (s[i - 1] != &apos;e&apos; &amp;&amp; s[i - 1] != &apos;E&apos;))&#123;return false;&#125;</span><br><span class="line">            &#125; else return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return numberSeen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    string s = &quot;-8e2.3  &quot;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.isNumber(s) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二刷-7"><a href="#二刷-7" class="headerlink" title="二刷"></a>二刷</h3><ul>
<li>二刷留念</li>
<li>有什么可留念的！这题我真的是……一言难尽，诸位如果不做这题，会遗憾终生的</li>
</ul>
<p><img src="/pictrues/65.png" alt title="有效数字"></p>
<ul>
<li>状态机、正则匹配还要学一学！</li>
</ul>
<p><img src="/pictrues/65_1.png" alt title="有限状态机"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isNumber(string s) &#123;</span><br><span class="line">        bool signSeen = false;</span><br><span class="line">        bool intSeen = false;</span><br><span class="line">        bool dotSeen = false;</span><br><span class="line">        bool eSeen = false;</span><br><span class="line"></span><br><span class="line">        for(auto ch : s)&#123;</span><br><span class="line">            //每遍历一个字符，都要先进行判断，然后再相应的赋值</span><br><span class="line">            if(ch == &apos;+&apos; || ch == &apos;-&apos;)&#123;</span><br><span class="line">                //e前后都是可以出现正负号，遍历到e会复位，所以只需判断之前有无正负号</span><br><span class="line">                //而且前面不能有数字，只能是第一位或者紧挨着e后面，不能只看前面有没有小数点，也要看e</span><br><span class="line">                if(signSeen || intSeen || (dotSeen &amp;&amp; !eSeen)) return false;</span><br><span class="line">                signSeen = true;</span><br><span class="line"></span><br><span class="line">            &#125;else if(isdigit(ch))&#123;</span><br><span class="line">                //如果是数字</span><br><span class="line">                intSeen = true;</span><br><span class="line"></span><br><span class="line">            &#125;else if(ch == &apos;.&apos;)&#123;</span><br><span class="line">                //如果是小数点，前面没有数字、后面也没有数字</span><br><span class="line">                if(dotSeen || eSeen) return false;</span><br><span class="line">                dotSeen = true;</span><br><span class="line"></span><br><span class="line">            &#125;else if(ch == &apos;e&apos; || ch == &apos;E&apos;)&#123;</span><br><span class="line">                //e后面必须要有数字，相应的复位；前面也必须是小数或者整数</span><br><span class="line">                //还要判断是否已经出现e！！！</span><br><span class="line">                if(!intSeen || eSeen) return false;</span><br><span class="line">                signSeen = false;</span><br><span class="line">                intSeen = false;</span><br><span class="line">                //这里要不要把小数点也置0呢，在符号位那边判断吧</span><br><span class="line">                eSeen = true;</span><br><span class="line"></span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                //其余符号</span><br><span class="line">                return false;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //最终结果都是看有没有数字</span><br><span class="line">        return intSeen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="67-二进制求和"><a href="#67-二进制求和" class="headerlink" title="67_二进制求和"></a>67_二进制求和</h2><ul>
<li>这两题的思路在43_字符串相乘那题试过，但是没有成功</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string addBinary(string a, string b) &#123;</span><br><span class="line">        int carry = 0, ans, l_a = a.size(), l_b = b.size();</span><br><span class="line">        l_a--; l_b--;</span><br><span class="line">        string res;</span><br><span class="line">        while (l_a &gt;= 0 &amp;&amp; l_b &gt;= 0)&#123;</span><br><span class="line">            ans = (a[l_a] - &apos;0&apos;) + (b[l_b] - &apos;0&apos;) + carry;</span><br><span class="line">            res.insert(res.begin(), (ans % 2) + &apos;0&apos;);</span><br><span class="line">            carry = ans / 2;</span><br><span class="line">            l_a--; l_b--;</span><br><span class="line">        &#125;</span><br><span class="line">        while (l_a &gt;= 0)&#123;</span><br><span class="line">            ans = (a[l_a] - &apos;0&apos;) + carry;</span><br><span class="line">            res.insert(res.begin(), (ans % 2) + &apos;0&apos;);</span><br><span class="line">            carry = ans / 2;</span><br><span class="line">            l_a--;</span><br><span class="line">        &#125;</span><br><span class="line">        while (l_b &gt;= 0)&#123;</span><br><span class="line">            ans = (b[l_b] - &apos;0&apos;) + carry;</span><br><span class="line">            res.insert(res.begin(), (ans % 2) + &apos;0&apos;);</span><br><span class="line">            carry = ans / 2;</span><br><span class="line">            l_b--;</span><br><span class="line">        &#125;</span><br><span class="line">        if(carry != 0)&#123;res.insert(0, 1, carry + &apos;0&apos;);&#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    string a = &quot;11&quot;, b = &quot;1&quot;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    string res = solution.addBinary(a, b);</span><br><span class="line">    for(auto re : res)&#123;</span><br><span class="line">        cout &lt;&lt; re &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="71-简化路径"><a href="#71-简化路径" class="headerlink" title="71_简化路径"></a>71_简化路径</h2><ul>
<li>这题做的过程比较苦恼，题解还没有官方，，，遇到<code>/../</code>，就要弹出上一个文件名，而不是弹出两个字符，这样用<code>vector&lt;string&gt;</code>类型好点，最后再将他们串联起来，还有像<code>/...</code>、<code>/..../</code>等等都相当于文件名</li>
<li>这题也算熟悉了Linux的路径名：<code>/</code>+字符串，我一直考虑<code>/</code>+字符串+<code>/</code></li>
<li>学习了新的循环格式<code>for_each( v.begin(), v.end(), [&amp;](string str){ result += str ;} );</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string simplifyPath(string path) &#123;</span><br><span class="line">        path += &apos;/&apos;;</span><br><span class="line">        string tmp = &quot;/&quot;;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        for(auto p : path)&#123;</span><br><span class="line">            if(p != &apos;/&apos;)&#123;</span><br><span class="line">                tmp += p;</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                if(tmp == &quot;/.&quot;)&#123;</span><br><span class="line">                    tmp.clear();</span><br><span class="line">                    tmp += &apos;/&apos;;</span><br><span class="line">                &#125; else if(tmp == &quot;/..&quot;)&#123;</span><br><span class="line">                    if(!res.empty())&#123;res.pop_back();&#125;</span><br><span class="line">                    tmp.clear();</span><br><span class="line">                    tmp += &apos;/&apos;;</span><br><span class="line">                &#125; else if(tmp == &quot;/&quot;)&#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125; else&#123;</span><br><span class="line">                    res.push_back(tmp);</span><br><span class="line">                    tmp.clear();</span><br><span class="line">                    tmp += &apos;/&apos;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        string ans;</span><br><span class="line"></span><br><span class="line">        for_each(res.begin(), res.end(), [&amp;](const string&amp; s)&#123;ans += s;&#125;);</span><br><span class="line">        if(ans.empty())&#123;ans += &apos;/&apos;;&#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    string path = &quot;/a/c//.//.....//..//.//.//.//b/../.&quot;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    string res = solution.simplifyPath(path);</span><br><span class="line">    for(auto re : res)&#123;</span><br><span class="line">        cout &lt;&lt; re;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72_编辑距离"></a>72_编辑距离</h2><ul>
<li>这题毫无头绪，想了好几天，还是最后看了那位yutuber的视频，不得不说动态规划还是很牛批</li>
<li>上一题那个不同路径||，我以为已经会动态规划了，其实是只知其形不知其义</li>
<li>上一个状态是什么，hors-ros、horse-ro、hors-ro这三个状态放在平面格子上可以看成左边、上边、对角线，前面两个状态只需添加一个字符就可以变成horse-ros，第三个状态似乎需要两步(其实只需一步)因为添加的字母不一样，如果字母一样呢？答案是不变的；举个例子：hors-ro之间转变的步数与horse-roe之间转变的步数是一样的、那么hors-ro可以先看成horse-roe，再替换字符变成horse-ros</li>
<li>妙极了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minDistance(string word1, string word2) &#123;</span><br><span class="line">        int m = word1.size(), n = word2.size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0));</span><br><span class="line">        //因为要取最小值，如果中间格子都是0的话，那结果也会是0，得先初始化下，值稍微取大点</span><br><span class="line">        for(int i = 0; i &lt;= m; i++)&#123;</span><br><span class="line">            for(int j = 0; j &lt;= n; j++)&#123;</span><br><span class="line">                dp[i][j] = INT32_MAX;</span><br><span class="line">                dp[0][j] = j;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][0] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">            for(int j = 0; j &lt; n; j++)&#123;</span><br><span class="line">                if(word1[i] == word2[j])&#123;</span><br><span class="line">                    dp[i + 1][j + 1] = dp[i][j];</span><br><span class="line">                &#125; else&#123;</span><br><span class="line">                    dp[i + 1][j + 1] = min(dp[i][j], min(dp[i + 1][j], dp[i][j + 1])) + 1;</span><br><span class="line">                  &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    string word1 = &quot;horse&quot;, word2 = &quot;ros&quot;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.minDistance(word1, word2);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="76-最小覆盖字串"><a href="#76-最小覆盖字串" class="headerlink" title="76_最小覆盖字串"></a>76_最小覆盖字串</h2><ul>
<li>发现了一个难点，就是如何判断子字符串包含所有的目标字符，我用了哈希表，先初始化对应的个数；遇到一个目标字符就将个数减一，个数变为0，就删除这一键值；哈希表为空，就说明都包含了；一开始比较顺利，但是添加新的键值再删除，发现不为空(后来发现用<code>emplace</code>函数也不行)</li>
<li>双指针，要先找出可行子串；再收缩；再扩张；题解是用两个<code>map</code>进行比较：对，遍历一遍，比较个数；每次遇到目标字符，都要进行此操作</li>
<li>看来做题目不能看进阶，得先做出来，要不然容易束缚思维(时间复杂度、空间复杂度之类的；比如时间O(n)，并不是只用一次遍历，甚至可以再套一次遍历，只要范围比前一个循环小，也可)</li>
<li><code>map</code>比较的时候，都得遍历一遍；以后输出改用更高位格的<code>copy()</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    unordered_map &lt;char, int&gt; ori, cnt;</span><br><span class="line"></span><br><span class="line">    bool check() &#123;</span><br><span class="line">        for (const auto &amp;p: ori) &#123;</span><br><span class="line">            if (cnt[p.first] &lt; p.second) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string minWindow(string s, string t) &#123;</span><br><span class="line">        for (const auto &amp;c: t) &#123;</span><br><span class="line">            ++ori[c];   //记录字符串t中字母的个数</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int l = 0, r = -1;</span><br><span class="line">        int len = INT_MAX, ansL = -1;</span><br><span class="line"></span><br><span class="line">        while (r &lt; int(s.size())) &#123;</span><br><span class="line">            if (ori.find(s[++r]) != ori.end()) &#123;    //在判断条件时，r已经加一了，如果有这个目标字母</span><br><span class="line">                ++cnt[s[r]];    //则记录下这个字母的个数，到时跟ori作比较</span><br><span class="line">            &#125;</span><br><span class="line">            //当且仅当cnt记录的 所有 字母的个数都 超出或者等于 对应的ori，才执行</span><br><span class="line">            while (check() &amp;&amp; l &lt;= r) &#123;</span><br><span class="line">                if (r - l + 1 &lt; len) &#123;  //如果这次符合的子字符串 比 之前的 短；则更新len,ansL</span><br><span class="line">                    len = r - l + 1;</span><br><span class="line">                    ansL = l;</span><br><span class="line">                &#125;</span><br><span class="line">                if (ori.find(s[l]) != ori.end()) &#123;</span><br><span class="line">                    --cnt[s[l]];</span><br><span class="line">                &#125;</span><br><span class="line">                ++l;    //l也可以直接到下一个目标字符，这样上一个条件就不用判断了</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ansL == -1 ? &quot;&quot; : s.substr(ansL, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    string res = solution.minWindow(s, t);</span><br><span class="line">	//如果不加载包含库，copy()貌似只有字符类型；#include &lt;iterator&gt;  -- std::ostream_iterator   #include &lt;algorithm&gt; -- std::copy</span><br><span class="line">    copy(res.begin(), res.end(), ostreambuf_iterator&lt;char&gt;(cout));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="87-扰乱字符串"><a href="#87-扰乱字符串" class="headerlink" title="87_扰乱字符串"></a>87_扰乱字符串</h2><ul>
<li>完全没思路，因为我不知道什么情况下会是<code>false</code>；后来发现题目给的二叉树不一定非得从中间分开，可以是任意位置，而且每次递归都可以是任意位置好像？因为题解循环的时候，就是从<code>i = 1</code>至最后把字符串分成两个字串，然后递归比较这两个字串按两种情况进行比较；这么一看还是很清晰的</li>
<li>当然出口条件得先设置</li>
<li>这种思路叫做递归+剪枝！</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    //C++递归+剪枝</span><br><span class="line">    bool isScramble(string s1, string s2) &#123;</span><br><span class="line">        int n = s1.length();</span><br><span class="line">        int m = s2.length();</span><br><span class="line">        if(m != n)</span><br><span class="line">            return false;   //一条语句可不用加&#123;&#125;</span><br><span class="line">        if(s1 == s2)</span><br><span class="line">            return true;</span><br><span class="line">        //这里确保s1,s2字母都相同</span><br><span class="line">        string s3 = s1;</span><br><span class="line">        sort(s3.begin(), s3.end());</span><br><span class="line">        string s4 = s2;</span><br><span class="line">        sort(s4.begin(), s4.end());</span><br><span class="line">        if(s3 != s4)</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        for(int i = 1; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            string x1 = s1.substr(0, i);</span><br><span class="line">            string y1 = s1.substr(i, n-i);</span><br><span class="line">            string x2 = s2.substr(0, i);</span><br><span class="line">            string y2 = s2.substr(i, n-i);</span><br><span class="line">            //前两部分一一对应是一种情况，另一种情况是交叉对应；因为是递归，只需考虑根循环即可</span><br><span class="line">            string x3 = s2.substr(0, n-i);</span><br><span class="line">            string y3 = s2.substr(n-i,i);</span><br><span class="line">            if(isScramble(x1,x2) &amp;&amp; isScramble(y1,y2))</span><br><span class="line">                return true;</span><br><span class="line">            if(isScramble(y1,x3) &amp;&amp; isScramble(x1,y3))</span><br><span class="line">                return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    string s1(&quot;great&quot;), s2(&quot;rgtea&quot;);</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.isScramble(s1, s2) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="91-解码方法"><a href="#91-解码方法" class="headerlink" title="91_解码方法"></a>91_解码方法</h2><ul>
<li>判断条件顺序很重要，先判断能不能解码，再分类，可以提高速度</li>
<li>如果出现0，那么0后面的数字可以直接pass，而且是第一次出现0的位置（×）</li>
<li>不对不对，如果出现0只能看前一个数字（这里有点坑，在代码里应该与字符进行比较）是否是1或者2，是那么这个0可以解码并且继续，不是，那么返回0</li>
<li>之后将数字一个一组或者两个一组（在1-26范围内）；计算出可能的解码情况；有点类似于排列组合</li>
<li>试试动态规划；<code>dp[i]</code>与前两项<code>dp[i-1]</code>、<code>dp[i-2]</code>都有关是我想不到的，我一直在凑与<code>dp[i-1]</code>的关系。。。</li>
<li>当本身一个数字解码时的情况：<code>dp[i]=dp[i-1]</code>；当与前一个数字组合解码时：<code>dp[i]=dp[i-2]</code></li>
<li>条件判断逻辑很重要，稍有不慎就会漏判或者误判</li>
<li>首先为了不让<code>s[i-1]</code>超出边界，分为<code>i==0</code>和<code>i&gt;0</code>两个部分；对于<code>s[i-2]</code>用三目运算符，<code>i==1?1:s[i-2]</code></li>
<li>其次，先判断整体能否解码，再判断只能一个数字解码、只能两个数字解码、两个都可以解码</li>
<li>做题做到现在，<font color="#FF0000">审题真的很重要</font>！！</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int numDecodings(string s) &#123;</span><br><span class="line">        int l = s.size();</span><br><span class="line">        vector&lt;int&gt; tmp(l, 0);</span><br><span class="line">        for(int i = 0; i &lt; l; ++i)&#123;</span><br><span class="line">            if(i == 0)&#123;</span><br><span class="line">                if(s[i] == &apos;0&apos;)</span><br><span class="line">                    break;</span><br><span class="line">                else</span><br><span class="line">                    tmp[0] = 1;</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                if(s[i] == &apos;0&apos; &amp;&amp; (s[i - 1] &gt; &apos;2&apos; || s[i - 1] == &apos;0&apos;))</span><br><span class="line">                    break;  //如果不属于这种情况，那么说明是可解码的</span><br><span class="line">                else if(s[i] == &apos;0&apos; &amp;&amp; (s[i - 1] == &apos;2&apos; || s[i - 1] == &apos;1&apos;))&#123;</span><br><span class="line">                    tmp[i] = (i == 1 ? 1 : tmp[i - 2]);</span><br><span class="line">                &#125;</span><br><span class="line">                //s[i] &lt;= &apos;6&apos; &amp;&amp; (s[i - 1] == &apos;2&apos;) || s[i - 1] == &apos;1&apos;)忽略了17</span><br><span class="line">                else if(((s[i] &gt; &apos;6&apos; &amp;&amp; s[i - 1] &gt;= &apos;2&apos;) || s[i - 1] &gt; &apos;2&apos;) || s[i - 1] == &apos;0&apos;)&#123;</span><br><span class="line">                    tmp[i] = tmp[i - 1];    //只能一个数字解码</span><br><span class="line">                &#125;</span><br><span class="line">                else    //一个数字、两个数字解码</span><br><span class="line">                    tmp[i] = tmp[i - 1] + (i == 1 ? 1 : tmp[i - 2]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return s.empty() ? 0 : tmp[l - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    string s = &quot;2611055971756562&quot;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.numDecodings(s) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="97-交错字符串"><a href="#97-交错字符串" class="headerlink" title="97_ 交错字符串"></a>97_ 交错字符串</h2><ul>
<li>唉，又超时了</li>
<li>这题还是用动态规划好，而且其中一个要点就是规划前要将边界初始化，还有就是让下标不能超出边界</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isInterleave(string s1, string s2, string s3) &#123;</span><br><span class="line">        if(s3.size() != s2.size() + s1.size()) return false;    //这一步写错了，找了半天发现比较的是s1和s2+s3</span><br><span class="line">        auto dp =vector&lt;vector&lt;int&gt;&gt;(s1.size() + 1, vector&lt;int&gt;(s2.size() + 1, 0));</span><br><span class="line">        dp[0][0] = 1;</span><br><span class="line">        for(int i = 0; i &lt;= s1.size(); ++i)&#123;</span><br><span class="line">            for(int j = 0; j &lt;= s2.size(); ++j)&#123;</span><br><span class="line">                if(j &gt; 0)&#123;</span><br><span class="line">                    if(dp[i][j - 1] == 1 &amp;&amp; s2[j - 1] == s3[i + j - 1]) dp[i][j] = 1; //还有个条件那就是对应字符应该相等</span><br><span class="line">                &#125;</span><br><span class="line">                if(i &gt; 0)&#123;</span><br><span class="line">                    if(dp[i - 1][j] == 1 &amp;&amp; s1[i - 1] == s3[i + j - 1]) dp[i][j] = 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[s1.size()][s2.size()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string s1(&quot;aabcc&quot;),s2(&quot;dbbca&quot;),s3(&quot;aadbbcbcac&quot;);</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.isInterleave(s1, s2, s3) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="115-不同的子序列"><a href="#115-不同的子序列" class="headerlink" title="115_不同的子序列"></a>115_不同的子序列</h2><ul>
<li>这题咋写递归，都超时！！！</li>
<li>试试动态规划，还不行就看题解，这题好像跟米哈游春招笔试第一道1807差不多，得写动态规划</li>
<li>不容易啊，终于做出来了，还会涉及字符串长度会超出整数边界；这里直接用<code>using st = std::string ::size_type</code>一劳永逸</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int numDistinct(string s, string t) &#123;</span><br><span class="line">        using st = std::string ::size_type;</span><br><span class="line">        st ls = s.size(), lt = t.size();</span><br><span class="line">        if(ls &lt; lt) return 0;</span><br><span class="line">        vector&lt;vector&lt;st&gt;&gt; dp(ls, vector&lt;st&gt;(lt, 0));</span><br><span class="line">        //边界初始化</span><br><span class="line">        for(st i = 0; i &lt; ls; ++i)&#123;</span><br><span class="line">            if(s[i] == t[0])</span><br><span class="line">                dp[i][0] += 1;</span><br><span class="line">            if(i &gt; 0)</span><br><span class="line">                dp[i][0] += dp[i - 1][0];</span><br><span class="line">        &#125;</span><br><span class="line">        for(st j = 1; j &lt; lt; ++j)&#123;</span><br><span class="line">            for(st i = j; i &lt; ls; ++i)&#123;</span><br><span class="line">                if(s[i] == t[j])</span><br><span class="line">                    dp[i][j] = dp[i - 1][j - 1];</span><br><span class="line"></span><br><span class="line">                dp[i][j] += dp[i - 1][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[ls - 1][lt - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    string s(&quot;rabbbit&quot;), t(&quot;b&quot;);</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.numDistinct(s, t) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="125-验证回文串"><a href="#125-验证回文串" class="headerlink" title="125_验证回文串"></a>125_验证回文串</h2><ul>
<li>这题还是可以的，用了<code>isalnum()</code>函数，判断字符是否是字母还是数字</li>
<li>在学习下其他方法：翻转API，直接判断两个字符串是否相等，不过要将原字符串处理下只留下字母和数字；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isPalindrome(string s) &#123;</span><br><span class="line">        if(s.empty()) return true;</span><br><span class="line">        int n = s.size();</span><br><span class="line">        int l = 0, r = n - 1;</span><br><span class="line">        bool flag = true;</span><br><span class="line">        while (l &lt;= r)&#123;</span><br><span class="line">            if(isalnum(s[l]) &amp;&amp; isalnum(s[r]))&#123;</span><br><span class="line">                if(tolower(s[l]) != tolower(s[r]))&#123;</span><br><span class="line">                    flag = false;</span><br><span class="line">                    break;</span><br><span class="line">                &#125; else&#123;</span><br><span class="line">                    ++l;</span><br><span class="line">                    --r;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if(isalnum(s[l]))</span><br><span class="line">                --r;</span><br><span class="line">            else if(isalnum(s[r]))</span><br><span class="line">                ++l;</span><br><span class="line">            else&#123;</span><br><span class="line">                ++l;</span><br><span class="line">                --r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    string s(&quot;A man, a plan, a canal: Panama&quot;);</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.isPalindrome(s) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="126-单词接龙-II"><a href="#126-单词接龙-II" class="headerlink" title="126_单词接龙_II"></a>126_单词接龙_II</h2><ul>
<li>思路应该是先找出所有的路径，然后再保留最短的路径；写完之后，用了好几个函数，代码也有五六十行；不出所料，超出时间限制了；思路一步一步来，先在字典里找出所有与<code>beginWord</code>只有一位字母不同的单词，之后循环再递归</li>
<li>好家伙，这是最短路径，需要抽象成图的模型，做这题花了一个多小时，那再笔试时是不是就可以放弃了…</li>
<li>判断是否只有一个字母不一样的方法还是一样的，我觉得我有可以了；这里面的映射有点像图论里的邻接矩阵</li>
<li>官方答案也会超时…这题一定是在跟我过不去！！！复制了好多题解都超时</li>
<li>构图的时候要无环图，有环图会增加不必要的时间</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int INF = 1 &lt;&lt; 20;</span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    unordered_map&lt;string, int&gt; wordId;</span><br><span class="line">    vector&lt;string&gt; idWord;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; edges;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; findLadders(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123;</span><br><span class="line">        int id = 0;</span><br><span class="line">        for (const string&amp; word : wordList) &#123;</span><br><span class="line">            if (!wordId.count(word)) &#123;</span><br><span class="line">                wordId[word] = id++;</span><br><span class="line">                idWord.push_back(word);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   //map里的int是对应的位置</span><br><span class="line">        if (!wordId.count(endWord))</span><br><span class="line">            return &#123;&#125;;</span><br><span class="line">        if (!wordId.count(beginWord)) &#123; //如果找不到起始单词，就放入map里</span><br><span class="line">            wordId[beginWord] = id++;</span><br><span class="line">            idWord.push_back(beginWord);</span><br><span class="line">        &#125;</span><br><span class="line">        edges.resize(idWord.size());//构建行数是idWord.size()的二维数组</span><br><span class="line">        for (int i = 0; i &lt; idWord.size(); i++) &#123;</span><br><span class="line">            for (int j = i + 1; j &lt; idWord.size(); j++) &#123;</span><br><span class="line">                if (transformCheck(idWord[i], idWord[j])) &#123;</span><br><span class="line">                    edges[i].push_back(j);</span><br><span class="line">                    edges[j].push_back(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        const int dest = wordId[endWord];//终点所在的位置</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">        queue&lt;vector&lt;int&gt;&gt; q;</span><br><span class="line">        vector&lt;int&gt; cost(id, INF);//其中cost[i]表示beginWord对应的点到第 i 个点的代价（即转换次数）。初始情况下其所有元素初始化为无穷大。</span><br><span class="line">        q.push(vector&lt;int&gt;&#123;wordId[beginWord]&#125;);</span><br><span class="line"></span><br><span class="line">        cost[wordId[beginWord]] = 0;//自己与自己的转换次数是0</span><br><span class="line">        while (!q.empty()) &#123;</span><br><span class="line">            vector&lt;int&gt; now = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line"></span><br><span class="line">            int last = now.back();</span><br><span class="line">            if (last == dest) &#123;</span><br><span class="line">                vector&lt;string&gt; tmp;</span><br><span class="line">                for (int index : now) &#123;</span><br><span class="line">                    tmp.push_back(idWord[index]);</span><br><span class="line">                &#125;</span><br><span class="line">                res.push_back(tmp);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                for (int i = 0; i &lt; edges[last].size(); i++) &#123;</span><br><span class="line">                    int to = edges[last][i];</span><br><span class="line">                    if (cost[last] + 1 &lt;= cost[to]) &#123;</span><br><span class="line">                        cost[to] = cost[last] + 1;</span><br><span class="line">                        vector&lt;int&gt; tmp(now);</span><br><span class="line">                        tmp.push_back(to);</span><br><span class="line">                        q.push(tmp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool transformCheck(const string&amp; str1, const string&amp; str2) &#123;</span><br><span class="line">        int differences = 0;</span><br><span class="line">        for (int i = 0; i &lt; str1.size() &amp;&amp; differences &lt; 2; i++) &#123;  //限制条件可以缩短时间</span><br><span class="line">            if (str1[i] != str2[i]) &#123;</span><br><span class="line">                ++differences;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return differences == 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    string beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;;</span><br><span class="line">    vector&lt;string&gt; wordList = &#123;&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; res = solution.findLadders(beginWord, endWord, wordList);</span><br><span class="line">    cout &lt;&lt; &quot;-------&quot; &lt;&lt; endl;</span><br><span class="line">    for(const auto &amp; re : res)&#123;</span><br><span class="line">        for(const auto &amp; s : re)</span><br><span class="line">            cout &lt;&lt; s &lt;&lt; &quot; &quot;;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二刷-8"><a href="#二刷-8" class="headerlink" title="二刷"></a>二刷</h3><ul>
<li>第一次做的时候，觉得这题是最难的，都不想看第二遍！——也是因为第一次没有过，哪怕抄了题解<ul>
<li>今天2021.6.26，把这题二刷下，看看双向BFS的本质！——只要找到一个相同的单词，就说明最短，因为是一层一层遍历的</li>
</ul>
</li>
<li>首先如何快速找到仅有单个字母不同的单词？26个英文字母遍历一遍？那就要先存入哈希了</li>
<li>两个队列的话，是怎么记录，如果找到同一个单词的话，的前后单词演变或者路径呢<ul>
<li>而且两个队列应该是先后更新，一起更新很容易错过！</li>
<li>关键在于找到之后，如何回溯，要是每个单词记录下上一个单词就好了！那应该用什么数据结构；而且每一层也要记录单词</li>
<li>学习下双层BFS的套路</li>
<li>做到最后才发现……原来是要返回所有的最短路径啊！！！艹(一种植物)！我还以为是找其中一个呢，已经花了好多时间，明天再做</li>
<li>那也差不多，只要找到一个单词，那就说明这一层上所有的相同单词都是最短路径</li>
<li>最后，<code>unordered_map&lt;string, string&gt;</code>这里出现了点问题，层次遍历的时候，会不会有多个父节点？<ul>
<li>出现了，多个父节点，指向同一个单词！！！雾草，要不用<code>unordered_map&lt;string, vector&lt;string&gt;&gt;</code>？</li>
<li>这样的话，为什么还要用双向BFS？直接从尾部开始不就好了？因为反转也挺麻烦</li>
<li>这就是图！</li>
</ul>
</li>
<li>尾队列出现了死循环！对，因为没有删除一开始就存在的<code>endWord</code>，那么<code>beginWord</code>也有可能在<code>set</code>中，如果不删，那么在寻找仅单个字符不同单词时，会再次放入映射父节点，从而乱套</li>
</ul>
</li>
<li>发现之前没有认真看题解评论，这次找了个大佬评论CV，终于过了，得好好学习下</li>
<li>双向搜索适合127！！！因为不需要记录来时的路径！<ul>
<li>惭愧，这题二刷了三四天！还没有完全掌握（主要是一鼓作气、再而衰、三而竭），我觉得这题得隔几天就温习下！！</li>
</ul>
</li>
</ul>
<h2 id="127-单词接龙"><a href="#127-单词接龙" class="headerlink" title="127_单词接龙"></a>127_单词接龙</h2><ul>
<li>这题是算出最短路径的长度，就是上一题求解数组的长度仅此而已吗？不，要明白为什么会是最短，是因为有<code>cost</code>数组，在广度优先搜索的时候只能搜索转换次数更大的单词，而不是回退原来已经转换过的单词；</li>
<li>还有就算上一题原封不动的提交，耗时也很高；学习下双向搜索</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;unordered_set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    unordered_map&lt;string, int&gt; wordId;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; edge;</span><br><span class="line">    int nodeNum = 0;</span><br><span class="line"></span><br><span class="line">    void addWord(string&amp; word) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;wordId.count(&quot; &lt;&lt; word &lt;&lt; &quot;) = &quot; &lt;&lt; wordId.count(word) &lt;&lt; endl;</span><br><span class="line">        if (!wordId.count(word)) &#123;</span><br><span class="line">            wordId[word] = nodeNum++;   //nodeNum++相当于给单词标记了位置</span><br><span class="line">            cout &lt;&lt; &quot; --- &quot; &lt;&lt; wordId.count(word) &lt;&lt; endl;</span><br><span class="line">            edge.emplace_back();    //增加行数</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void addEdge(string&amp; word) &#123;</span><br><span class="line">        addWord(word);  //只当没有word的时候才会加入map里</span><br><span class="line">        int id1 = wordId[word];</span><br><span class="line">        for (char&amp; it : word) &#123;</span><br><span class="line">            char tmp = it;</span><br><span class="line">            it = &apos;*&apos;;   //这个是引用，会改变原word，相当于把所有与word一个字母不同的单词都放入map里了</span><br><span class="line">            addWord(word);</span><br><span class="line">            int id2 = wordId[word];</span><br><span class="line">            cout &lt;&lt; &quot;id1 = &quot; &lt;&lt; id1 &lt;&lt; &quot; tmp = &quot; &lt;&lt; tmp &lt;&lt; &quot; id2 = &quot; &lt;&lt; id2 &lt;&lt; endl;</span><br><span class="line">            edge[id1].push_back(id2);</span><br><span class="line">            edge[id2].push_back(id1);</span><br><span class="line">            it = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int ladderLength(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123;</span><br><span class="line">        for (string&amp; word : wordList)</span><br><span class="line">            addEdge(word);</span><br><span class="line">        addEdge(beginWord); //beginWord最后在加</span><br><span class="line"></span><br><span class="line">        if (!wordId.count(endWord))</span><br><span class="line">            return 0;</span><br><span class="line"></span><br><span class="line">        /*for(const auto &amp;m : wordId)</span><br><span class="line">            cout &lt;&lt; m.first &lt;&lt; &quot;&lt;-&gt;&quot; &lt;&lt; m.second &lt;&lt; &quot; &quot;;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        for(const auto &amp;ed : edge)&#123;</span><br><span class="line">            for(const auto &amp;e : ed)</span><br><span class="line">                cout &lt;&lt; e &lt;&lt; &quot; &quot;;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;*/</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt; disBegin(nodeNum, INT_MAX); //这一步相当于单向搜索的cost，用来记录转换次数</span><br><span class="line">        int beginId = wordId[beginWord];</span><br><span class="line">        disBegin[beginId] = 0;</span><br><span class="line">        queue&lt;int&gt; queBegin;</span><br><span class="line">        queBegin.push(beginId);</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt; disEnd(nodeNum, INT_MAX);</span><br><span class="line">        int endId = wordId[endWord];</span><br><span class="line">        disEnd[endId] = 0;</span><br><span class="line">        queue&lt;int&gt; queEnd;</span><br><span class="line">        queEnd.push(endId);</span><br><span class="line"></span><br><span class="line">        while (!queBegin.empty() &amp;&amp; !queEnd.empty()) &#123;</span><br><span class="line">            int queBeginSize = queBegin.size();</span><br><span class="line">            for (int i = 0; i &lt; queBeginSize; ++i) &#123;</span><br><span class="line">                int nodeBegin = queBegin.front();</span><br><span class="line">                queBegin.pop();</span><br><span class="line">                if (disEnd[nodeBegin] != INT_MAX) &#123;</span><br><span class="line">                    return (disBegin[nodeBegin] + disEnd[nodeBegin]) / 2 + 1;</span><br><span class="line">                &#125;</span><br><span class="line">                for (int&amp; it : edge[nodeBegin]) &#123;</span><br><span class="line">                    if (disBegin[it] == INT_MAX) &#123;</span><br><span class="line">                        disBegin[it] = disBegin[nodeBegin] + 1;</span><br><span class="line">                        queBegin.push(it);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            int queEndSize = queEnd.size();</span><br><span class="line">            for (int i = 0; i &lt; queEndSize; ++i) &#123;</span><br><span class="line">                int nodeEnd = queEnd.front();</span><br><span class="line">                queEnd.pop();</span><br><span class="line">                if (disBegin[nodeEnd] != INT_MAX) &#123;</span><br><span class="line">                    return (disBegin[nodeEnd] + disEnd[nodeEnd]) / 2 + 1;</span><br><span class="line">                &#125;</span><br><span class="line">                for (int&amp; it : edge[nodeEnd]) &#123;</span><br><span class="line">                    if (disEnd[it] == INT_MAX) &#123;</span><br><span class="line">                        disEnd[it] = disEnd[nodeEnd] + 1;</span><br><span class="line">                        queEnd.push(it);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//大佬写的</span><br><span class="line">class Solution_ &#123;</span><br><span class="line">public:</span><br><span class="line">    int ladderLength(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123;</span><br><span class="line">        unordered_set&lt;string&gt; words(wordList.begin(), wordList.end());</span><br><span class="line">        if ( words.empty() || words.find(endWord) == words.end() ) return 0;</span><br><span class="line">        words.erase(beginWord);</span><br><span class="line">        queue&lt;string&gt; que;</span><br><span class="line">        que.push(beginWord);</span><br><span class="line">        unordered_set&lt;string&gt; visited;</span><br><span class="line">        visited.insert(beginWord);</span><br><span class="line">        int step = 1;</span><br><span class="line">        while ( !que.empty() ) &#123;</span><br><span class="line">            // 找到没有被访问过, 而且能够由当前单词转换而成的单词</span><br><span class="line">            int n = que.size();</span><br><span class="line">            // 每一轮(每一层step加个1)</span><br><span class="line">            while ( n-- ) &#123;</span><br><span class="line">                string curWord = que.front();</span><br><span class="line">                que.pop();</span><br><span class="line">                // 当前单词的每个字符都替换成其他的25个字符, 然后在单词表中查询</span><br><span class="line">                // 是不是包含转换后的单词</span><br><span class="line">                // 这里千万不能遍历单词表, 因为单词表很长, 而哈希表使用的红黑树</span><br><span class="line">                // 的查询效率比遍历单词表高很多</span><br><span class="line">                for ( int i = 0; i &lt; curWord.size(); ++i ) &#123;</span><br><span class="line">                    char originalChar = curWord[i];</span><br><span class="line">                    for ( int j = 0; j &lt; 26; ++j ) &#123;</span><br><span class="line">                        if ( char(&apos;a&apos; + j) == originalChar ) continue;</span><br><span class="line">                        curWord[i] = (char)(&apos;a&apos; + j);</span><br><span class="line">                        if ( words.find(curWord) != words.end() &amp;&amp; visited.find(curWord) == visited.end() ) &#123;</span><br><span class="line">                            if ( curWord == endWord ) return step + 1;</span><br><span class="line">                            else &#123;</span><br><span class="line">                                que.push(curWord);</span><br><span class="line">                                visited.insert(curWord);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    curWord[i] = originalChar;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++step;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;;</span><br><span class="line">    vector&lt;string&gt; wordList = &#123;&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    int res = solution.ladderLength(beginWord, endWord, wordList);</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="132-分割回文串-II"><a href="#132-分割回文串-II" class="headerlink" title="132_分割回文串_II"></a>132_分割回文串_II</h2><ul>
<li>切割的次数最少，直接递归加回溯的话，第一个可行解一般是都切成一个一个字符；难道要按次数循环嘛？或者按次数递归？</li>
<li>按次数循环，超出时间限制了…这种算法应该是暴力求解，还是用递归可能有效</li>
<li>递归也超时了….</li>
<li>难道要先找出最长的回文字串？再依次处理剩下的？</li>
<li>不，你需要动态规划，<code>g[i][j]</code>一般而言<code>i&lt;j</code>，难怪<code>i&gt;=j</code>时，一定是回文串，因为是空字符串或者就一个字符</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//动态规划</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minCut(string s) &#123;</span><br><span class="line">        int n = s.size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; g(n, vector&lt;int&gt;(n, true));</span><br><span class="line"></span><br><span class="line">        for (int i = n - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">            for (int j = i + 1; j &lt; n; ++j) &#123;</span><br><span class="line">                g[i][j] = (s[i] == s[j]) &amp;&amp; g[i + 1][j - 1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt; f(n, INT_MAX);</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            if (g[0][i]) &#123;</span><br><span class="line">                f[i] = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                for (int j = 0; j &lt; i; ++j) &#123;</span><br><span class="line">                    if (g[j + 1][i]) &#123;</span><br><span class="line">                        f[i] = min(f[i], f[j] + 1);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return f[n - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    string s(&quot;ababababababababababa&quot;);</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.minCut(s) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139_单词拆分"></a>139_单词拆分</h2><ul>
<li>这题与之前的字典题好像，不知道需不需要构图；</li>
<li>第一步在字典中找到所有与原字符串吻合的字串？然后拼接？字典中某个单词可重复使用…</li>
<li>不能拼接，每找一个，都要拆成两个部分，再分别判断；但是超出时间限制了</li>
<li>每次找到一个单词时，都需要将两边拆开，那如果有多个重复的呢？那就把所有重复的去掉，剩下来的单词放在数组里？？</li>
<li>上面思路是暴力求解，时间消耗倒数；以后遇到字符串，多想想动态规划</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;unordered_set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123;</span><br><span class="line">        auto wordDictSet = unordered_set &lt;string&gt; ();</span><br><span class="line">        for (auto &amp;word: wordDict) &#123;</span><br><span class="line">            wordDictSet.insert(word);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        auto dp = vector &lt;bool&gt; (s.size() + 1);</span><br><span class="line">        dp[0] = true;</span><br><span class="line">        for (int i = 1; i &lt;= s.size(); ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; i; ++j) &#123;</span><br><span class="line">                if (dp[j] &amp;&amp; wordDictSet.find(s.substr(j, i - j)) != wordDictSet.end()) &#123;</span><br><span class="line">                    dp[i] = true;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[s.size()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string s(&quot;catsandog&quot;);</span><br><span class="line">    vector&lt;string&gt; wordDict(&#123;&quot;cats&quot;,&quot;dog&quot;,&quot;sand&quot;,&quot;and&quot;,&quot;cat&quot;&#125;);</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.wordBreak(s, wordDict) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="140-单词拆分-ll"><a href="#140-单词拆分-ll" class="headerlink" title="140_单词拆分_ll"></a>140_单词拆分_ll</h2><ul>
<li>想起了被分割回文串支配的恐惧</li>
<li>这个不用构图，顺着字符一个一个来就行；还好，接着就直接往下递归</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;unordered_set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    unordered_set&lt;string&gt; set;</span><br><span class="line">    string w;</span><br><span class="line">    void dfs(string &amp;s)&#123;</span><br><span class="line">        if(s.empty())&#123;</span><br><span class="line">            res.emplace_back(w);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i = 1; i &lt;= s.size(); ++i)&#123;</span><br><span class="line">            if(set.find(s.substr(0, i)) != set.end())&#123;</span><br><span class="line">                string ww(w);</span><br><span class="line">                w += string(&quot; &quot;);</span><br><span class="line">                w += s.substr(0, i);</span><br><span class="line">                string tmp(s.substr(i, s.size()));</span><br><span class="line">                dfs(tmp);</span><br><span class="line">                w = ww; //回溯后这里要还原</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;string&gt; wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123;</span><br><span class="line">        for(const auto &amp; word : wordDict)</span><br><span class="line">            set.insert(word);</span><br><span class="line"></span><br><span class="line">        //两个都是非空</span><br><span class="line">        for(int i = 1; i &lt;= s.size(); ++i)&#123;</span><br><span class="line">            if(set.find(s.substr(0, i)) != set.end())&#123;</span><br><span class="line">                w = s.substr(0, i);</span><br><span class="line">                string tmp(s.substr(i, s.size()));</span><br><span class="line">                dfs(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    string s(&quot;catsanddog&quot;);</span><br><span class="line">    vector&lt;string&gt; wordDict(&#123;&quot;cat&quot;, &quot;cats&quot;, &quot;and&quot;, &quot;sand&quot;, &quot;dog&quot;&#125;);</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;string&gt; res = solution.wordBreak(s, wordDict);</span><br><span class="line">    for(const auto &amp; re : res)</span><br><span class="line">        cout &lt;&lt; re &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="151-翻转字符串里的单词"><a href="#151-翻转字符串里的单词" class="headerlink" title="151_翻转字符串里的单词"></a>151_翻转字符串里的单词</h2><ul>
<li>要考虑边界的问题，很容易想到从后往前遍历；然后记录一个单词头尾的位置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string reverseWords(string s) &#123;</span><br><span class="line">        if(s.empty()) return string();</span><br><span class="line">        int l = s.size();</span><br><span class="line">        string ans;</span><br><span class="line">        bool isSeen = false;</span><br><span class="line">        int pos = -1;</span><br><span class="line">        for(int i = l - 1; i &gt;= 0; --i)&#123;</span><br><span class="line">            if(s[i] == &apos; &apos;)&#123;</span><br><span class="line">                if(isSeen)&#123;</span><br><span class="line">                    if(!ans.empty())</span><br><span class="line">                        ans.push_back(&apos; &apos;);</span><br><span class="line"></span><br><span class="line">                    ans += s.substr(i + 1, pos - i);</span><br><span class="line">                    isSeen = false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                if(!isSeen)</span><br><span class="line">                    pos = i;</span><br><span class="line">                isSeen = true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        if(s[0] != &apos; &apos;)&#123;</span><br><span class="line">            if(!ans.empty())</span><br><span class="line">                ans.push_back(&apos; &apos;);</span><br><span class="line">            ans += s.substr(0, pos + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string s(&quot;  hello world!  &quot;);</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.reverseWords(s) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="165-比较版本号"><a href="#165-比较版本号" class="headerlink" title="165_比较版本号"></a>165_比较版本号</h2><ul>
<li>两个链表相加那题，<code>while</code>条件里是或；只要有一个不为空即可；这样简洁了代码，只需一个<code>while</code>即可</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int compareVersion(string version1, string version2) &#123;</span><br><span class="line">        int v1_l = 0, v1_r = 0;</span><br><span class="line">        int v2_l = 0, v2_r = 0;</span><br><span class="line">        int ans1 = 0, ans2 = 0;</span><br><span class="line">        while(v1_r &lt; version1.size() || v2_r &lt; version2.size())&#123;</span><br><span class="line">            ans1 = 0;</span><br><span class="line">            ans2 = 0;</span><br><span class="line">            //v1_r</span><br><span class="line">            while(v1_r &lt; version1.size() &amp;&amp; version1[v1_r] != &apos;.&apos;)&#123;</span><br><span class="line">                ++v1_r;</span><br><span class="line">            &#125;</span><br><span class="line">            if(v1_r == version1.size())&#123;</span><br><span class="line">                if(v1_l == v1_r)</span><br><span class="line">                    ans1 = 0;</span><br><span class="line">                else&#123;</span><br><span class="line">                    ans1 = stoi(version1.substr(v1_l, v1_r - v1_l));</span><br><span class="line">                    v1_l = v1_r;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;  //version1[v1_r] == &apos;.&apos;</span><br><span class="line">                ans1 = stoi(version1.substr(v1_l, v1_r - v1_l));</span><br><span class="line">                ++v1_r;</span><br><span class="line">                v1_l = v1_r;</span><br><span class="line">            &#125;</span><br><span class="line">            //cout &lt;&lt; &quot;v1: &quot; &lt;&lt; endl;</span><br><span class="line">            //cout &lt;&lt; &quot;ans1 = &quot; &lt;&lt; ans1 &lt;&lt; &quot;   l = &quot; &lt;&lt; v1_l &lt;&lt; &quot; r = &quot; &lt;&lt; v1_r &lt;&lt; endl;</span><br><span class="line">            //v2_r</span><br><span class="line">            while(v2_r &lt; version2.size() &amp;&amp; version2[v2_r] != &apos;.&apos;)&#123;</span><br><span class="line">                ++v2_r;</span><br><span class="line">            &#125;</span><br><span class="line">            if(v2_r == version2.size())&#123;</span><br><span class="line">                if(v2_l == v2_r)</span><br><span class="line">                    ans2 = 0;</span><br><span class="line">                else&#123;</span><br><span class="line">                    ans2 = stoi(version2.substr(v2_l, v2_r - v2_l));</span><br><span class="line">                    v2_l = v2_r;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;  //version1[v2_r] == &apos;.&apos;</span><br><span class="line">                ans2 = stoi(version2.substr(v2_l, v2_r - v2_l));</span><br><span class="line">                ++v2_r;</span><br><span class="line">                v2_l = v2_r;</span><br><span class="line">            &#125;</span><br><span class="line">            /*cout &lt;&lt; &quot;v2: &quot; &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; &quot;ans2 = &quot; &lt;&lt; ans2 &lt;&lt; &quot;   l = &quot; &lt;&lt; v2_l &lt;&lt; &quot; r = &quot; &lt;&lt; v2_r &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; &quot;--------&quot; &lt;&lt; endl;*/</span><br><span class="line">            //比较结果</span><br><span class="line">            if(ans1 &lt; ans2)</span><br><span class="line">                return -1;</span><br><span class="line">            if(ans1 &gt; ans2)</span><br><span class="line">                return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="166-分数到小数"><a href="#166-分数到小数" class="headerlink" title="166_分数到小数"></a>166_分数到小数</h2><ul>
<li>我在犹豫这题要不要放在整数边界里….</li>
<li>因为<code>int</code>最小值比最大值少一个，所以可先记录结果符号，再将其余的数都转为负数；这里里的<code>intPart</code>要用<code>long long</code>类型，不然，又会出现整数边界问题</li>
<li>哦对，思路是小学数学里的长除法…</li>
<li>记录出现的重复数字可以不一定是<code>unordered_map</code>，字符串也可以直接寻找…</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string fractionToDecimal(int numerator, int denominator) &#123;</span><br><span class="line">        if(numerator == 0) return &quot;0&quot;;</span><br><span class="line">        bool pot = false, repeat = false, symbol = false;</span><br><span class="line">        if((numerator &lt; 0 &amp;&amp; denominator &gt; 0) || (numerator &gt; 0 &amp;&amp; denominator &lt; 0))&#123;</span><br><span class="line">            symbol = true;</span><br><span class="line">        &#125;</span><br><span class="line">        numerator = numerator &lt; 0 ? numerator : numerator * (-1);</span><br><span class="line">        denominator = denominator &lt; 0 ? denominator : denominator * (-1);</span><br><span class="line">        int pos = -1;</span><br><span class="line"></span><br><span class="line">        long long numerator_ = numerator;</span><br><span class="line"></span><br><span class="line">        while (numerator_ != 0)&#123;</span><br><span class="line">//            cout &lt;&lt; &quot;ans = &quot; &lt;&lt; ans &lt;&lt; &quot;  numerator = &quot; &lt;&lt; numerator &lt;&lt; endl;</span><br><span class="line">            //计算整数部分</span><br><span class="line">            long long intPart = numerator_ / denominator;</span><br><span class="line">            //ans为空</span><br><span class="line">            if(ans.empty())&#123;</span><br><span class="line">//                cout &lt;&lt; &quot;intPart = &quot; &lt;&lt; intPart &lt;&lt; endl;</span><br><span class="line">                if(symbol)</span><br><span class="line">                    ans.append(&quot;-&quot;);</span><br><span class="line">                ans.append(to_string(intPart));</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                //ans不为空，说明肯定有小数点了，之后判断重复</span><br><span class="line">                //如果重复了</span><br><span class="line">                if(numRecord.find(numerator_) != numRecord.end())&#123;</span><br><span class="line">//                    cout &lt;&lt; numerator &lt;&lt; &quot; repeat!&quot; &lt;&lt; endl;</span><br><span class="line">                    repeat = true;</span><br><span class="line">                    pos = numRecord[numerator_];</span><br><span class="line">                    break;</span><br><span class="line">                &#125;else</span><br><span class="line">                    //如果不重复</span><br><span class="line">                    ans.append(to_string(intPart));</span><br><span class="line">            &#125;</span><br><span class="line">            //放置小数点之后开始记录分子值，先记录再更新numerator！</span><br><span class="line">            if(pot)</span><br><span class="line">                numRecord[numerator_] = static_cast&lt;int&gt;(ans.size()) - 1;</span><br><span class="line">            //小数部分 这里会超出整数边界</span><br><span class="line">            numerator_ = 10 * (numerator_ % denominator);</span><br><span class="line">            if(numerator_ != 0 &amp;&amp; !pot)&#123;</span><br><span class="line">                ans.append(&quot;.&quot;);</span><br><span class="line">                pot = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(repeat)&#123;</span><br><span class="line">            ans.insert(pos, 1, &apos;(&apos;);</span><br><span class="line">            ans.append(&quot;)&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    string ans;</span><br><span class="line">    unordered_map&lt;int, int&gt; numRecord;  //key保存分子的值，value保存当前整数部分字符串的位置</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int numerator = -2147483648, denominator = 1;</span><br><span class="line">    Solution solution;</span><br><span class="line">    string ans = solution.fractionToDecimal(numerator, denominator);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="168-Excel表列名称"><a href="#168-Excel表列名称" class="headerlink" title="168_Excel表列名称"></a>168_Excel表列名称</h2><ul>
<li>26进制转换，总感觉哪里怪怪的，其余二进制、八进制、十六进制都是从0开始计数的，26进制是从1开始计数，差点整不会了</li>
<li>不停的计算出余数，因为不管你有多少个26，最后一位肯定在0-26之间，而这个余数就是最后一位</li>
<li>也就是不停的在头部放入字符，之后再更新剩下来的值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string convertToTitle(int columnNumber) &#123;</span><br><span class="line">        //26进制，应该比较简单</span><br><span class="line">        vector&lt;string&gt; tmp(&#123;&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;,&quot;H&quot;,&quot;I&quot;,&quot;J&quot;,&quot;K&quot;,&quot;L&quot;,&quot;M&quot;,&quot;N&quot;,&quot;O&quot;,&quot;P&quot;,&quot;Q&quot;</span><br><span class="line">                                   ,&quot;R&quot;,&quot;S&quot;,&quot;T&quot;,&quot;U&quot;,&quot;V&quot;,&quot;W&quot;,&quot;X&quot;,&quot;Y&quot;,&quot;Z&quot;&#125;);</span><br><span class="line">        string ans;</span><br><span class="line">        while (columnNumber &gt; 0)&#123;</span><br><span class="line">            //余数</span><br><span class="line">            int remainder = columnNumber % 26;</span><br><span class="line">            string s(ans);</span><br><span class="line">            ans.clear();</span><br><span class="line">            if(remainder == 0)&#123;</span><br><span class="line">                ans.append(tmp.back());</span><br><span class="line">                ans += s;</span><br><span class="line">                if(columnNumber == 26)</span><br><span class="line">                    break;</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                ans.append(tmp[remainder - 1]);</span><br><span class="line">                ans += s;</span><br><span class="line">            &#125;</span><br><span class="line">            columnNumber = (columnNumber - remainder) / 26;</span><br><span class="line">//            cout &lt;&lt; &quot;columnNumber = &quot; &lt;&lt; columnNumber &lt;&lt; endl;</span><br><span class="line">            if(remainder == 0)</span><br><span class="line">                columnNumber -= 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int columnNumber = 51;</span><br><span class="line">    Solution solution;</span><br><span class="line">    string ans = solution.convertToTitle(columnNumber);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二刷-9"><a href="#二刷-9" class="headerlink" title="二刷"></a>二刷</h3><ul>
<li>记得当时数字1<del>26和0</del>25有点傻傻分不清<ul>
<li>52对应AZ，即26*1+26，和一般的进制相比，最后一位数其实应该小于26才对</li>
<li>要看是否是26的倍数，如果是应该添加26对应的字母而不是0对应的字母</li>
<li>但是<code>string</code>的<code>insert()</code>函数报错，说是没有这个函数？噢，必须要有三个参数<ul>
<li><code>string&amp; insert (size_t pos, const char* s, size_t n);</code>以及<code>string&amp; insert (size_t pos, const char* s);</code>里面的字符参数是指针，而数组下标的是引用</li>
<li>应该是这个<code>string&amp; insert (size_t pos,   size_t n, char c);</code></li>
</ul>
</li>
</ul>
</li>
<li>看了题解才发现，直接用<code>n + &#39;A&#39;</code>来代替数组！！</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">//二刷手撕</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string convertToTitle(int columnNumber) &#123;</span><br><span class="line">        //1对应A、26对应Z、52对应AZ</span><br><span class="line">        string ans;</span><br><span class="line">        vector&lt;char&gt; tmp = &#123;&apos; &apos;,&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;,&apos;F&apos;,&apos;G&apos;,&apos;H&apos;,</span><br><span class="line">                            &apos;I&apos;,&apos;J&apos;,&apos;K&apos;,&apos;L&apos;,&apos;M&apos;,&apos;N&apos;,&apos;O&apos;,&apos;P&apos;,&apos;Q&apos;,</span><br><span class="line">                            &apos;R&apos;,&apos;S&apos;,&apos;T&apos;,&apos;U&apos;,&apos;V&apos;,&apos;W&apos;,&apos;X&apos;,&apos;Y&apos;,&apos;Z&apos;&#125;;</span><br><span class="line">        while(columnNumber &gt; 0)&#123;</span><br><span class="line">            //是否是26的倍数</span><br><span class="line">            if(columnNumber % 26 == 0)&#123;</span><br><span class="line">                ans.insert(0, 1, tmp[26]);</span><br><span class="line">                //这里相当于右移</span><br><span class="line">                columnNumber = (columnNumber - 26) / 26;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                //看“个位数”</span><br><span class="line">                int n = columnNumber % 26;</span><br><span class="line">                ans.insert(0, 1, tmp[n]);</span><br><span class="line">                //注意这里要减去n</span><br><span class="line">                columnNumber = (columnNumber - n) / 26;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//题解</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string convertToTitle(int columnNumber) &#123;</span><br><span class="line">        string ans;</span><br><span class="line">        while (columnNumber &gt; 0) &#123;</span><br><span class="line">            //这里就无需判断余数是否为0了</span><br><span class="line">            int a0 = (columnNumber - 1) % 26 + 1;</span><br><span class="line">            //这里优先级不会冲突吗——不冲突</span><br><span class="line">            ans += a0 - 1 + &apos;A&apos;;</span><br><span class="line">            columnNumber = (columnNumber - a0) / 26;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(ans.begin(), ans.end());</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="171-Excel表列序号"><a href="#171-Excel表列序号" class="headerlink" title="171_Excel表列序号"></a>171_Excel表列序号</h2><ul>
<li>小试身手下：）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    //可以不用哈希数来记录字母</span><br><span class="line">    int titleToNumber(string columnTitle) &#123;</span><br><span class="line">        /*unordered_map&lt;char, int&gt; map;</span><br><span class="line">        int i = 1;</span><br><span class="line">        for(char c = &apos;A&apos;; c &lt;= &apos;Z&apos;; ++c)&#123;</span><br><span class="line">            map[c] = i++;</span><br><span class="line">        &#125;*/</span><br><span class="line">        int ans = 0;</span><br><span class="line">        for(auto c : columnTitle)&#123;</span><br><span class="line">            ans *= 26;</span><br><span class="line">            ans += (c - &apos;A&apos; + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二刷-10"><a href="#二刷-10" class="headerlink" title="二刷"></a>二刷</h3><ul>
<li>有句话怎么说来着，得心应手<ul>
<li>有个小问题，<code>ans</code> 应该是 <code>long long</code> 类型，不然有可能会超出整数边界</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int titleToNumber(string columnTitle) &#123;</span><br><span class="line">        // 先手撕，再做笔记；记得先减一再加一好像</span><br><span class="line">        // 还有不需要事先用数组记录大写的字母</span><br><span class="line">        if(columnTitle.empty()) return -1;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        // 正序遍历</span><br><span class="line">        for(auto ch : columnTitle)&#123;</span><br><span class="line">            int num = ch - &apos;A&apos; + 1;</span><br><span class="line">            ans = ans * 26 + num;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="179-最大数"><a href="#179-最大数" class="headerlink" title="179_最大数"></a>179_最大数</h2><ul>
<li>好家伙，自定义排序用<code>sort()</code>+<code>lamda</code>匿名函数！！！</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;iterator&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution_ &#123;</span><br><span class="line">public:</span><br><span class="line">    //与计数排序还是基数排序来着有点像，之前是先比较个位数，在比较十位数，以此类推</span><br><span class="line">    //这次应该是先比较每个元素的第一位数字，再往后推，这个方法似乎行不通</span><br><span class="line">    //比如3，31；应该是331最大而不是313  3，35；应该是353最大而不是335</span><br><span class="line">    //还是应该首字母相同的进行比较</span><br><span class="line"></span><br><span class="line">    bool smaller(string lhs, string rhs)&#123;</span><br><span class="line">//        cout &lt;&lt; &quot;lhs = &quot; &lt;&lt; lhs &lt;&lt; &quot; rhs = &quot; &lt;&lt; rhs &lt;&lt; endl;</span><br><span class="line">        if(rhs.empty()) return false;</span><br><span class="line">        if(lhs.empty()) return true;</span><br><span class="line">        string l = lhs + rhs;</span><br><span class="line">        string r = rhs + lhs;</span><br><span class="line">        return l &lt; r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string largestNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        //选择排序</span><br><span class="line">        if(nums.empty()) return string();</span><br><span class="line">        vector&lt;string&gt; nums_str;</span><br><span class="line">        nums_str.reserve(nums.size());</span><br><span class="line">        for(auto t : nums)</span><br><span class="line">            nums_str.emplace_back(to_string(t));</span><br><span class="line"></span><br><span class="line">        for(int i = 0; i &lt; nums_str.size() - 1; ++i)&#123;</span><br><span class="line">//            cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">            int tmp = i;</span><br><span class="line">            for(int j = i + 1; j &lt; nums_str.size(); ++j)&#123;</span><br><span class="line">//                cout &lt;&lt; &quot;j = &quot; &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">                if(smaller(nums_str[j], nums_str[tmp]))</span><br><span class="line">                    tmp = j;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">//            cout &lt;&lt; &quot;min = &quot; &lt;&lt; nums_str[tmp] &lt;&lt; endl;</span><br><span class="line">            swap(nums_str[i], nums_str[tmp]);</span><br><span class="line"></span><br><span class="line">            /*copy(nums_str.begin(), nums_str.end(), ostream_iterator&lt;string&gt;(cout, &quot; &quot;));</span><br><span class="line">            cout &lt;&lt; endl;*/</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        string ans;</span><br><span class="line">        for(int i = nums_str.size(); i &gt; 0; --i)&#123;</span><br><span class="line">            ans += nums_str[i - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        while (ans[0] == &apos;0&apos; &amp;&amp; ans.size() &gt; 1)&#123;</span><br><span class="line">            ans.erase(0, 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string largestNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;string&gt; v;</span><br><span class="line">        for(int t:nums) v.push_back(to_string(t));</span><br><span class="line">        sort(v.begin(), v.end(), [](const string &amp;a,const string &amp;b)&#123;</span><br><span class="line">            return a+b &gt; b+a; //两个字符串先后组合大小降序排列</span><br><span class="line">        &#125;);</span><br><span class="line">        if(v[0]==&quot;0&quot;) return &quot;0&quot;;</span><br><span class="line">        string ans=&quot;&quot;;</span><br><span class="line">        for(string t:v) ans+=t;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; nums = &#123;432, 43243&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    string ans = solution.largestNumber(nums);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="205-同构字符串"><a href="#205-同构字符串" class="headerlink" title="205_同构字符串"></a>205_同构字符串</h2><ul>
<li>每个字母不一定距离一样，但同一个字母距离必须一样；距离就是映射到另一个字母与原字母的差值</li>
<li>既然如此，那就<code>map</code>大法好；试了下，得要两个<code>map</code>，因为两个字符串是等价的，你能来，我也能去</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isIsomorphic(string s, string t) &#123;</span><br><span class="line">        unordered_map&lt;char, int&gt; map;</span><br><span class="line">        unordered_map&lt;char, int&gt; map1;</span><br><span class="line"></span><br><span class="line">        for(int i = 0; i &lt; s.size(); ++i)&#123;</span><br><span class="line">            // s -&gt; t</span><br><span class="line">            if(map.find(s[i]) == map.end())</span><br><span class="line">                map[s[i]] = s[i] - t[i];</span><br><span class="line">            else&#123;</span><br><span class="line">                if(map[s[i]] != s[i] - t[i])</span><br><span class="line">                    return false;</span><br><span class="line">            &#125;</span><br><span class="line">            // t -&gt; s</span><br><span class="line">            if(map1.find(t[i]) == map1.end())</span><br><span class="line">                map1[t[i]] = t[i] - s[i];</span><br><span class="line">            else&#123;</span><br><span class="line">                if(map1[t[i]] != t[i] - s[i])</span><br><span class="line">                    return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//大佬</span><br><span class="line">class Solution_ &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isIsomorphic(string s, string t) &#123;</span><br><span class="line">        for(int i=0; i&lt;s.length(); i++)&#123;</span><br><span class="line">            if(s.find(s[i])!=t.find(t[i])) return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    string s(&quot;badc&quot;), t(&quot;baba&quot;);</span><br><span class="line">    Solution solution;</span><br><span class="line">    bool ans = solution.isIsomorphic(s, t);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="214-最短回文串"><a href="#214-最短回文串" class="headerlink" title="214_最短回文串"></a>214_最短回文串</h2><ul>
<li>用动态规划的第一层循环要从后往前，不然会出现初始化边界问题</li>
<li>这题思路对的，就是找到从起始位置开始的最长回文串，枚举法以及之前分割回文串的动态规划的时间复杂度都是<code>O(n²)</code>，会超出时间限制</li>
<li>一次学到这么多新的算法，还真有点吃不消</li>
<li>先将KMP算法搞懂再说，这题码一下，以后有机会再看</li>
<li>KMP算法比字符串哈希还要快</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;iterator&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">// KMP algorithm</span><br><span class="line">class Solution_ &#123;</span><br><span class="line">public:</span><br><span class="line">    string shortestPalindrome(string s) &#123;</span><br><span class="line">        int n = static_cast&lt;int&gt;(s.size());</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt; fail(n, -1);</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">            int j = fail[i - 1];</span><br><span class="line"></span><br><span class="line">            while (j != -1 &amp;&amp; s[j + 1] != s[i]) &#123;</span><br><span class="line">                j = fail[j];</span><br><span class="line">            &#125;</span><br><span class="line">            if (s[j + 1] == s[i]) &#123;</span><br><span class="line">                fail[i] = j + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int best = -1;</span><br><span class="line">        for (int i = n - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">            while (best != -1 &amp;&amp; s[best + 1] != s[i]) &#123;</span><br><span class="line">                best = fail[best];</span><br><span class="line">            &#125;</span><br><span class="line">            if (s[best + 1] == s[i]) &#123;</span><br><span class="line">                ++best;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        string add = (best == n - 1 ? &quot;&quot; : s.substr(best + 1, n));</span><br><span class="line">        reverse(add.begin(), add.end());</span><br><span class="line">        return add + s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//字符串哈希</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string shortestPalindrome(string s) &#123;</span><br><span class="line">        int n = s.size();</span><br><span class="line">        int base = 131, mod = 1000000007;</span><br><span class="line">        int left = 0, right = 0, mul = 1;</span><br><span class="line">        int best = -1;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            left = ((long long)left * base + s[i]) % mod;</span><br><span class="line">            right = (right + (long long)mul * s[i]) % mod;</span><br><span class="line">            if (left == right) &#123;</span><br><span class="line">                best = i;</span><br><span class="line">            &#125;</span><br><span class="line">            mul = (long long)mul * base % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        string add = (best == n - 1 ? &quot;&quot; : s.substr(best + 1, n));</span><br><span class="line">        reverse(add.begin(), add.end());</span><br><span class="line">        return add + s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string s = &quot;aacecaaa&quot;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    string ans = solution.shortestPalindrome(s);</span><br><span class="line">    cout &lt;&lt; &quot;ans = &quot; &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="224-基本计算器"><a href="#224-基本计算器" class="headerlink" title="224_基本计算器"></a>224_基本计算器</h2><ul>
<li>想到用栈，但感觉要考虑的东西很多</li>
<li>题解的方法相当于一层一层的将括号去掉，在顺序遍历的同时；妙哇</li>
</ul>
<p><img src="/pictrues/224.png" alt="符号更新" title="符号更新"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int calculate(string s) &#123;</span><br><span class="line">        stack&lt;int&gt; ops;</span><br><span class="line">        ops.push(1);</span><br><span class="line">        int sign = 1;</span><br><span class="line"></span><br><span class="line">        int ret = 0;</span><br><span class="line">        int n = static_cast&lt;int&gt;(s.length());</span><br><span class="line">        int i = 0;</span><br><span class="line">        //这样写，很方便计算连着的数字之间有空格，也不对，如果有空格long num = 0重新初始化了</span><br><span class="line">        while (i &lt; n) &#123;</span><br><span class="line">            if (s[i] == &apos; &apos;) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; else if (s[i] == &apos;+&apos;) &#123;</span><br><span class="line">                sign = ops.top();</span><br><span class="line">                i++;</span><br><span class="line">            &#125; else if (s[i] == &apos;-&apos;) &#123;</span><br><span class="line">                sign = -ops.top();</span><br><span class="line">                i++;</span><br><span class="line">            &#125; else if (s[i] == &apos;(&apos;) &#123;</span><br><span class="line">                //这里放进去，把括号当成一个数字，主要考虑了括号前的符号</span><br><span class="line">                ops.push(sign);</span><br><span class="line">                i++;</span><br><span class="line">            &#125; else if (s[i] == &apos;)&apos;) &#123;</span><br><span class="line">                ops.pop();</span><br><span class="line">                i++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                long num = 0;</span><br><span class="line">                while (i &lt; n &amp;&amp; s[i] &gt;= &apos;0&apos; &amp;&amp; s[i] &lt;= &apos;9&apos;) &#123;</span><br><span class="line">                    num = num * 10 + (s[i] - &apos;0&apos;);</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                //遇到数字就会’加‘进答案里</span><br><span class="line">                ret += sign * num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string s = &quot;(1+(4+5+2)-3)+(6+8)&quot;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    int ans = solution.calculate(s);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="227-基本计算器-II"><a href="#227-基本计算器-II" class="headerlink" title="227_基本计算器_II"></a>227_基本计算器_II</h2><ul>
<li>没想到居然通过了，思路是遇到一个数字先存着，要将正负号一起相乘再存，然后遇到乘除就找出下一个数与前一个数相乘，再存着，最后确保栈里所有的数字能够直接相加即可</li>
<li>当然前提是整个字符串是有效的、看到逆波兰式我就知道我忘光光了</li>
<li>逆波兰式——看了好一会，就是将数字压入栈，遇到符号就弹出两个数字（要注意顺序）进行对应的运算，运算结果再压入栈，最后栈中只剩一个数字就是最终答案</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int calculate(string s) &#123;</span><br><span class="line">        //这里乘除代替了括号...还要考虑连着的数字</span><br><span class="line">        int n = static_cast&lt;int&gt;(s.size());</span><br><span class="line">        int i = 0, sign = 1;</span><br><span class="line">        stack&lt;long long&gt; stk;</span><br><span class="line"></span><br><span class="line">        //遇到一个数字，不应该直接加，而是看后面有没有乘除符号</span><br><span class="line">        while(i &lt; n)&#123;</span><br><span class="line">            //cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">            if(s[i] == &apos; &apos;) &#123;</span><br><span class="line">                ++i;</span><br><span class="line"></span><br><span class="line">            &#125;else if(s[i] == &apos;+&apos; || s[i] == &apos;-&apos;)&#123;</span><br><span class="line">                //遇到加减，就先把之前的和累加</span><br><span class="line">                sign = (s[i] == &apos;-&apos; ? -1 : 1);</span><br><span class="line">                ++i;</span><br><span class="line"></span><br><span class="line">            &#125;else if(isdigit(s[i]))&#123;</span><br><span class="line">                //这里把所有连着的数字解出来</span><br><span class="line">                long long num = s[i] - &apos;0&apos;;</span><br><span class="line">                while(isdigit(s[++i]))&#123;</span><br><span class="line">                    num = num * 10 + s[i] - &apos;0&apos;;</span><br><span class="line">                &#125;</span><br><span class="line">                //cout &lt;&lt; &quot;num = &quot; &lt;&lt; num * sign &lt;&lt; endl;</span><br><span class="line">                stk.push(num * sign);</span><br><span class="line"></span><br><span class="line">            &#125; else if(s[i] == &apos;*&apos; || s[i] == &apos;/&apos;)&#123;</span><br><span class="line">                auto tmp = s[i];</span><br><span class="line">                auto pre = stk.top();</span><br><span class="line">                stk.pop();</span><br><span class="line">                //cout &lt;&lt; &quot;pre = &quot; &lt;&lt; pre &lt;&lt; endl;</span><br><span class="line">                //这里需要找到下一个数字</span><br><span class="line">                ++i;</span><br><span class="line">                while(s[i] == &apos; &apos;)&#123;</span><br><span class="line">                    ++i;</span><br><span class="line">                &#125;</span><br><span class="line">                //s[i]现在是数字</span><br><span class="line">                long long num = s[i] - &apos;0&apos;;</span><br><span class="line">                while(isdigit(s[++i]))&#123;</span><br><span class="line">                    num = num * 10 + s[i] - &apos;0&apos;;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if(tmp == &apos;*&apos;)&#123;</span><br><span class="line">                    stk.push(pre * num);</span><br><span class="line">                &#125;</span><br><span class="line">                if(tmp == &apos;/&apos;)&#123;</span><br><span class="line">                    stk.push(pre / num);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //栈里面应该都是有正负的数字</span><br><span class="line">        int ans = 0;</span><br><span class="line">        cout &lt;&lt; &quot;stk = &quot;;</span><br><span class="line">        while(!stk.empty())&#123;</span><br><span class="line">            cout &lt;&lt; stk.top() &lt;&lt; &quot; &quot;;</span><br><span class="line">            ans += static_cast&lt;int&gt;(stk.top());</span><br><span class="line">            stk.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    string s = &quot;3+2*2&quot;; //(&apos;+&apos;, &apos;-&apos;, &apos;*&apos;, &apos;/&apos;)</span><br><span class="line">    Solution solution;</span><br><span class="line">    int ans = solution.calculate(s);</span><br><span class="line">    cout &lt;&lt; &quot;ans = &quot; &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="241-为运算表达式设计优先级"><a href="#241-为运算表达式设计优先级" class="headerlink" title="241_为运算表达式设计优先级"></a>241_为运算表达式设计优先级</h2><ul>
<li>这题…用递归？？</li>
<li>居然没有官方题解——分治！</li>
<li>好像分治就是递归啊；每找到一个运算符，就分治成左边与右边（直接调用自己）；因为每个运算符两边一定是存在数字的；之后就是双重循环生成一个新的数组；考虑特殊情况，即最后数组为空，那就说明没有运算符，直接将字符串的数字放入数组</li>
<li>大佬写的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; diffWaysToCompute(string expression) &#123;</span><br><span class="line">        // 存储中间值</span><br><span class="line">        vector&lt;int&gt; count;</span><br><span class="line">        for(int i = 0; i &lt; expression.size(); i++) &#123;</span><br><span class="line">            char c = expression[i];</span><br><span class="line">            // 找到运算符</span><br><span class="line">            if(c == &apos;+&apos; || c == &apos;-&apos; || c == &apos;*&apos;) &#123;</span><br><span class="line">                // 运算符左边的运算结果</span><br><span class="line">                vector&lt;int&gt; left = diffWaysToCompute(expression.substr(0, i));</span><br><span class="line">                // 运算符右边的运算结果</span><br><span class="line">                vector&lt;int&gt; right = diffWaysToCompute(expression.substr(i + 1));</span><br><span class="line">                // 左右两边继续运算</span><br><span class="line">                for(int&amp; l : left) &#123;</span><br><span class="line">                    for(int&amp; r : right) &#123;</span><br><span class="line">                        switch(c) &#123;</span><br><span class="line">                            case &apos;+&apos;:</span><br><span class="line">                                count.push_back(l + r);</span><br><span class="line">                                break;</span><br><span class="line">                            case &apos;-&apos;:</span><br><span class="line">                                count.push_back(l - r);</span><br><span class="line">                                break;</span><br><span class="line">                            case &apos;*&apos;:</span><br><span class="line">                                count.push_back(l * r);</span><br><span class="line">                                break;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // count为空说明当前无运算符，只是单独的数字，直接放入count中</span><br><span class="line">        if(count.size() == 0) &#123;</span><br><span class="line">            count.push_back(stoi(expression));</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242_有效的字母异位词"></a>242_有效的字母异位词</h2><ul>
<li>排序思路写的和题解一模一样</li>
<li>对于哈希表，有个折中的思路，就是对于纯字母来说，一共26个，可以直接用长度为26的数组，而且只用一个，先记录<code>s</code>中，各个字母的个数，然后用另一个字符串做测试，在遍历的同时，将对应的数组元素减一，如果出现小于0，直接返回<code>false</code>；因为不存在的字母初始值就是0！！！</li>
<li>对于进阶问题，不一定是字母，也有可能是其他乱七八糟的符号，就直接用哈希表了，也是只用一个即可</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isAnagram(string s, string t) &#123;</span><br><span class="line">        if(s.size() != t.size())</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        sort(s.begin(), s.end());</span><br><span class="line">        sort(t.begin(), t.end());</span><br><span class="line"></span><br><span class="line">        return s == t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="273-整数转换英文表示"><a href="#273-整数转换英文表示" class="headerlink" title="273_整数转换英文表示"></a>273_整数转换英文表示</h2><ul>
<li>这题看着不难，就是有多个0时，不好判断（我是从后往前遍历），有这样的特例容易打乱思路——而且这题也花了不少时间！</li>
<li>直接看题解吧</li>
<li>看到分治，瞬间觉得我的思路就是暴力！——题解居然没有C++的！直接复制大佬的，题解的分治也是三个一组分开！</li>
<li>数组是真的方便</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//大佬写的</span><br><span class="line">class Solution &#123;</span><br><span class="line">    // 提前加好空格</span><br><span class="line">    vector&lt;string&gt; dict1 = &#123;&quot;Zero&quot;,     &quot; One&quot;,       &quot; Two&quot;,      &quot; Three&quot;,</span><br><span class="line">                            &quot; Four&quot;,    &quot; Five&quot;,      &quot; Six&quot;,      &quot; Seven&quot;,</span><br><span class="line">                            &quot; Eight&quot;,   &quot; Nine&quot;,      &quot; Ten&quot;,      &quot; Eleven&quot;,</span><br><span class="line">                            &quot; Twelve&quot;,  &quot; Thirteen&quot;,  &quot; Fourteen&quot;, &quot; Fifteen&quot;,</span><br><span class="line">                            &quot; Sixteen&quot;, &quot; Seventeen&quot;, &quot; Eighteen&quot;, &quot; Nineteen&quot;&#125;;</span><br><span class="line">    vector&lt;string&gt; dict2 = &#123;&quot; Twenty&quot;, &quot; Thirty&quot;, &quot; Forty&quot;,</span><br><span class="line">                            &quot; Fifty&quot;,  &quot; Sixty&quot;,  &quot; Seventy&quot;,</span><br><span class="line">                            &quot; Eighty&quot;, &quot; Ninety&quot;, &quot; Hundred&quot;&#125;;</span><br><span class="line">    vector&lt;string&gt; dict3 = &#123;&quot;&quot;,  // dict3[0]占位</span><br><span class="line">                            &quot; Thousand&quot;, &quot; Million&quot;, &quot; Billion&quot;&#125;;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    string numberToWords(int num) &#123;</span><br><span class="line">        if (num == 0) return dict1[0];  // 0, 特别处理</span><br><span class="line"></span><br><span class="line">        string str;</span><br><span class="line">        size_t i = 0;  // 10^3, ^6, ^9</span><br><span class="line">        while (num) &#123;  // 大于0时循环处理</span><br><span class="line">            string ts = getStringof3Nums(num % 1000);</span><br><span class="line">            if (!ts.empty())  // 返回空, 说明此3位全是0</span><br><span class="line">                str.assign(ts.append(dict3[i]) + str);</span><br><span class="line">            num /= 1000;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return str.substr(1);  // 去掉最前面的空格</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * @brief 3个数一组进行处理</span><br><span class="line">     *</span><br><span class="line">     * @param n</span><br><span class="line">     * @return string</span><br><span class="line">     */</span><br><span class="line">    string getStringof3Nums(int n) &#123;  // 1000</span><br><span class="line">        string str = &quot;&quot;;</span><br><span class="line">        // 处理百位</span><br><span class="line">        if (n / 100) str += dict1[n / 100] + dict2[8];</span><br><span class="line">        n %= 100;</span><br><span class="line">        if (n == 0) return str;</span><br><span class="line"></span><br><span class="line">        // 处理 0 &lt; n &lt;= 19</span><br><span class="line">        if (n &lt;= 19) return str += dict1[n];</span><br><span class="line"></span><br><span class="line">        // 处理20 &lt; n &lt; 99</span><br><span class="line">        str += dict2[n / 10 - 2];</span><br><span class="line">        if (n % 10) str += dict1[n % 10];</span><br><span class="line"></span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int num = 12345;</span><br><span class="line">    Solution solution;</span><br><span class="line">    string ans(solution.numberToWords(num));</span><br><span class="line">    cout &lt;&lt; &quot;ans = &quot; &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="282-给表达式添加运算符"><a href="#282-给表达式添加运算符" class="headerlink" title="282_给表达式添加运算符"></a>282_给表达式添加运算符</h2><ul>
<li><p>通过递归…应该是回溯，算出每一种情况，这并不难（每次都有四种选择）</p>
</li>
<li><p>最麻烦的在于数字0</p>
<ul>
<li>如果第一个就是0，那么后面只有放置运算符 </li>
<li>如果0前面紧挨着的是运算符，那么也只有在后面放置运算符！</li>
</ul>
</li>
<li><p>上面的问题解决后，测试的答案，为什么会有重复的？？黑人问号</p>
<ul>
<li>思考了半天——为什么要有循环呢，参数不是已经有了<code>pos</code>么，一直递归下去，<code>tmp</code>字符串也是会慢慢增加的；循环的话，从递归开始到结束，会进入下一个循环（没错，从第二个字符开始递归，而且之前的<code>tmp</code>没有弹出，只有排列组合才需循环！！）</li>
<li>怪不得，在递归位置加一的时候，有种违和感——直接<code>pos + 1</code>，写<code>i + 1</code>时，愣了一下…</li>
</ul>
</li>
<li><p>最终，还是有一个问题，那就是字符串超出<code>int</code>整数边界！不知道<code>long long</code>与<code>int</code>作比较会怎么样</p>
<ul>
<li>改成<code>long long</code>后，直接超出时间限制了…是写成死循环了，还是复杂度太高？</li>
</ul>
</li>
<li><p>题解没有C++版的——粘贴了一位大佬的，<code>function + Lambda</code>——用了一个变量来临时记录目前的运算总和</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;iterator&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//大佬写的</span><br><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; addOperators(string num, int target)</span><br><span class="line">    &#123;</span><br><span class="line">        int n = num.size();</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        string path = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">        std::function&lt;void(int, long long, long long)&gt; backtrace = [&amp;] (int idx, long long cur_res, long long pre_add)</span><br><span class="line">        &#123;</span><br><span class="line">            if (idx == n)</span><br><span class="line">            &#123;</span><br><span class="line">                if (cur_res == target)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(path);</span><br><span class="line">                    return ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            int pn = path.size();</span><br><span class="line">            for (int i = idx; i &lt; n; i ++)</span><br><span class="line">            &#123;</span><br><span class="line">                string x_str = num.substr(idx, i - idx + 1);</span><br><span class="line">                //这里改成long long 而不是int</span><br><span class="line">                long long x = stoll(x_str);</span><br><span class="line"></span><br><span class="line">                if (idx == 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    path += x_str;</span><br><span class="line">                    backtrace(i + 1, x, x);</span><br><span class="line">                    path.resize(pn);</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    path += &apos;+&apos; + x_str;</span><br><span class="line">                    backtrace(i + 1, cur_res + x, x);</span><br><span class="line">                    path.resize(pn);</span><br><span class="line"></span><br><span class="line">                    path += &apos;-&apos; + x_str;</span><br><span class="line">                    backtrace(i + 1, cur_res - x, -1 * x);</span><br><span class="line">                    path.resize(pn);</span><br><span class="line"></span><br><span class="line">                    path += &apos;*&apos; + x_str;</span><br><span class="line">                    backtrace(i + 1, cur_res - pre_add + pre_add * x, pre_add * x);</span><br><span class="line">                    path.resize(pn);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (x == 0)</span><br><span class="line">                    return ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        backtrace(0, 0, 0);</span><br><span class="line">        return res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string num(&quot;2147483648&quot;);</span><br><span class="line">    int target = -2147483648;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;string&gt; ans(solution.addOperators(num, target));</span><br><span class="line">    cout &lt;&lt; &quot; ans =  &quot;;</span><br><span class="line">    copy(ans.begin(), ans.end(), ostream_iterator&lt;string&gt;(cout, &quot; &quot;));</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="290-单词规律"><a href="#290-单词规律" class="headerlink" title="290_单词规律"></a>290_单词规律</h2><ul>
<li>感觉就是映射！遇到空格要跳过</li>
<li>容易出错的点<ul>
<li>映射是双向的，如果某个字符串已经对应了一个字符，那么其就不能再对应另一个字符了</li>
<li>还有，字符数与对应的以空格为间隔的字符串数目必须一样！</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">#include &lt;unordered_set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool wordPattern(string pattern, string s) &#123;</span><br><span class="line">        //开头再来一个补丁</span><br><span class="line">        if((pattern.empty() &amp;&amp; !s.empty()) || (!pattern.empty() &amp;&amp; s.empty()))</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        //截取单词，以空格为间隔——每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。</span><br><span class="line">        unordered_map&lt;char, string&gt; map;</span><br><span class="line">        unordered_set&lt;string&gt; set;</span><br><span class="line">        int i = 0, j = 0;</span><br><span class="line">        while(i &lt; pattern.size() &amp;&amp; j &lt; s.size())&#123;</span><br><span class="line">            //先取出对应的字符串</span><br><span class="line">            int pos = j;</span><br><span class="line">            //找出空格</span><br><span class="line">            while(s[pos] != &apos; &apos; &amp;&amp; pos &lt; s.size())&#123;</span><br><span class="line">                ++pos;</span><br><span class="line">            &#125;</span><br><span class="line">            //对应的字符串，这里的pos已经是空格所在的位置了，无需再加一</span><br><span class="line">            string tmp(s.substr(j, pos - j));</span><br><span class="line"></span><br><span class="line">            if(map.find(pattern[i]) == map.end())&#123;</span><br><span class="line">                //加之前，先判断是不是用过了</span><br><span class="line">                if(set.find(tmp) != set.end())</span><br><span class="line">                    return false;</span><br><span class="line">                set.insert(tmp);</span><br><span class="line">                pair&lt;char, string&gt; p = make_pair(pattern[i], tmp);</span><br><span class="line">                map.insert(p);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                if(map[pattern[i]] != tmp)&#123;</span><br><span class="line">//                    cout &lt;&lt; pattern[i] &lt;&lt; &quot; &quot; &lt;&lt; map[pattern[i]] &lt;&lt; &quot;!=&quot; &lt;&lt; tmp &lt;&lt; endl;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++i;</span><br><span class="line">            j = pos + 1;</span><br><span class="line">            //这里再加一个补丁</span><br><span class="line">            if((i &lt; pattern.size() &amp;&amp; j &gt;= s.size()) || (i &gt;= pattern.size() &amp;&amp; j &lt; s.size()))</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string pattern(&quot;abba&quot;), str(&quot;dog cat cat dog&quot;);</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.wordPattern(pattern, str) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="299-猜数字游戏"><a href="#299-猜数字游戏" class="headerlink" title="299_猜数字游戏"></a>299_猜数字游戏</h2><ul>
<li>直接用两个数组看看，不用哈希表了——可以，一次过！<ul>
<li>没有官方题解，其余思路差不多</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string getHint(string secret, string guess) &#123;</span><br><span class="line">        //先计算对应位置上一样的数字？之后去除，再看看又几个重复的？</span><br><span class="line">        //想到一个好方法，既然都是数字，那肯定在0~9范围之内！用两个数组！不，三个，不用哈希表了，还是两个</span><br><span class="line"></span><br><span class="line">        int n = secret.size();</span><br><span class="line">        //类似于计数排序</span><br><span class="line">        vector&lt;int&gt; sec(10, 0), gue(10, 0);</span><br><span class="line">        int a = 0, b = 0;</span><br><span class="line"></span><br><span class="line">        for(int i = 0; i &lt; n; ++i)&#123;</span><br><span class="line">            if(secret[i] == guess[i])&#123;</span><br><span class="line">                ++a;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                sec[secret[i] - &apos;0&apos;]++;</span><br><span class="line">                gue[guess[i] - &apos;0&apos;]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i = 0; i &lt; 10; ++i)&#123;</span><br><span class="line">            if(sec[i] &amp;&amp; gue[i])&#123;</span><br><span class="line">                //有重复</span><br><span class="line">                b += min(sec[i], gue[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        string ans;</span><br><span class="line">        //to_string返回的是右值，不能+=</span><br><span class="line">        ans += to_string(a) + &quot;A&quot; + to_string(b) + &quot;B&quot;;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="301-删除无效的括号"><a href="#301-删除无效的括号" class="headerlink" title="301_删除无效的括号"></a>301_删除无效的括号</h2><ul>
<li>这题不好写，不太会<ul>
<li>我总觉得加字母，是故意为难人！</li>
<li>看评论，雾草，这题面试居然会问！</li>
<li>记录下之前的思路，看了题解想手撕，但是撕不出来0.0，会有一个问题——计算出最小的左右括号删除数量，那么在用哈希表去重的时候，如何保证删除后的字符串括号是有效的呢<ul>
<li>删除最小数量的括号，首先要确保括号成对；最小数量，应该使用BFS，那一层上的所有的可行解；就算括号成对，但也不一定有效，每一层应该都是删一个括号；有些是必须删除的，而有些则是有多种选择；还有字母会碍点事</li>
</ul>
</li>
<li>还有两个变量，已经遍历的左右括号的数量<ul>
<li>若是前面的左右括号相等，再遇到右括号的话，则必须删除这个右括号！！！</li>
</ul>
</li>
<li>每次递归应该只删除一个括号<ul>
<li>遇到括号，都可以选择删或者不删，在某些条件下是必须删的，在某些条件下不能删</li>
</ul>
</li>
<li>递归条件还有漏洞<ul>
<li>输入<code>&quot;)()(&quot;</code>；输出<code>[&quot;)(&quot;,&quot;()&quot;]</code>；——必须删、不能删，产生矛盾，也要返回</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void dfs(string&amp; tmp, int leftSeen, int rightSeen, int leftDel, int rightDel, string&amp; s, int pos, int n)&#123;</span><br><span class="line">        //出口条件首先是，要删除的左右括号数量满足最小条件；其次遍历到的左右括号一一对应，这样就判断是否重复</span><br><span class="line">        if(pos == n)&#123;</span><br><span class="line">            //这里判断是否有效且不重复</span><br><span class="line">            if(leftSeen == rightSeen &amp;&amp; leftDel == left_parenthesis &amp;&amp; rightDel == right_parenthesis &amp;&amp; record.find(tmp) == record.end())&#123;</span><br><span class="line">                ans.emplace_back(tmp);</span><br><span class="line">                //保存记录</span><br><span class="line">                record.insert(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //若还没有遍历结束，删多了</span><br><span class="line">        if(leftDel &gt; left_parenthesis || rightDel &gt; right_parenthesis)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //因为是递归，只用到s[pos]，无需for循环，之后就根据已有的左右括号数量判断能不能删除</span><br><span class="line">        //字母也需要弹入、弹出</span><br><span class="line">        if(isalpha(s[pos]))&#123;</span><br><span class="line">            tmp.push_back(s[pos]);</span><br><span class="line">            dfs(tmp, leftSeen, rightSeen, leftDel, rightDel, s, pos + 1, n);</span><br><span class="line">            tmp.pop_back();</span><br><span class="line">        &#125;else if(s[pos] == &apos;(&apos;)&#123;</span><br><span class="line">            //先看看能不能删</span><br><span class="line">            //不删，左括号似乎没有硬性要求——就算是第一个也可以删</span><br><span class="line">            if(leftDel == left_parenthesis)&#123;</span><br><span class="line">                tmp.push_back(s[pos]);</span><br><span class="line">                dfs(tmp, leftSeen + 1, rightSeen, leftDel, rightDel, s, pos + 1, n);</span><br><span class="line">                tmp.pop_back();</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                //删</span><br><span class="line">                dfs(tmp, leftSeen, rightSeen, leftDel + 1, rightDel, s, pos + 1, n);</span><br><span class="line">                //也可以不删</span><br><span class="line">                tmp.push_back(s[pos]);</span><br><span class="line">                dfs(tmp, leftSeen + 1, rightSeen, leftDel, rightDel, s, pos + 1, n);</span><br><span class="line">                tmp.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else if(s[pos] == &apos;)&apos;)&#123;</span><br><span class="line">            //这里有两个条件是重叠的，加个补丁</span><br><span class="line">            if(rightDel == right_parenthesis &amp;&amp; leftSeen == rightSeen)&#123;</span><br><span class="line">                //矛盾，也是一个返回条件</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if(rightDel == right_parenthesis)&#123;</span><br><span class="line">                //不能删</span><br><span class="line">                tmp.push_back(s[pos]);</span><br><span class="line">                dfs(tmp, leftSeen, rightSeen + 1, leftDel, rightDel, s, pos + 1, n);</span><br><span class="line">                tmp.pop_back();</span><br><span class="line">            &#125;else if(leftSeen == rightSeen)&#123;</span><br><span class="line">                //必须删</span><br><span class="line">                dfs(tmp, leftSeen, rightSeen, leftDel, rightDel + 1, s, pos + 1, n);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                //既可以删，也可以不删</span><br><span class="line">                dfs(tmp, leftSeen, rightSeen, leftDel, rightDel + 1, s, pos + 1, n);</span><br><span class="line">                tmp.push_back(s[pos]);</span><br><span class="line">                dfs(tmp, leftSeen, rightSeen + 1, leftDel, rightDel, s, pos + 1, n);</span><br><span class="line">                tmp.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;string&gt; removeInvalidParentheses(string s) &#123;</span><br><span class="line">        int n = s.size();</span><br><span class="line">        //计算出最小删除的左括号、右括号数量</span><br><span class="line">        for(int i = 0; i &lt; n; ++i)&#123;</span><br><span class="line">            //必须要有左括号，遇到右括号才能相互抵消</span><br><span class="line">            if(s[i] == &apos;(&apos;)&#123;</span><br><span class="line">                ++left_parenthesis;</span><br><span class="line">            &#125;else if(s[i] == &apos;)&apos;)&#123;</span><br><span class="line">                if(left_parenthesis == 0)&#123;</span><br><span class="line">                    ++right_parenthesis;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    --left_parenthesis;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //如何用哈希表去重，因为删除了某几个括号，剩下来的不一定有效</span><br><span class="line">        //保持有效，就是让已经遍历到的左右括号一一对应，或者个数相等</span><br><span class="line">        //去重是删除之后剩下来的结果</span><br><span class="line">        string tmp;</span><br><span class="line">        dfs(tmp, 0, 0, 0, 0, s, 0, n);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    unordered_set&lt;string&gt; record;</span><br><span class="line">    int left_parenthesis = 0;</span><br><span class="line">    int right_parenthesis = 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>这题差点忘了要写在IDE里的</p>
<ul>
<li>我是根据字符的种类分三种情况，然后又细分为删或者不删，必须删，不能删</li>
<li>题解是根据删，不删两种情况，再来细分字符的种类以及特殊情况，还可以再优化下</li>
</ul>
</li>
<li><p>还有因为是最短路径，所以一般采用广度优先搜索，这种比较暴力，没有DFS剪枝来进行优化</p>
<ul>
<li>暴力的地方在于，删除之后要额外判断剩下来的字符串是否有效——还是用最小删除的括号方法来判断</li>
</ul>
</li>
</ul>
<h2 id="306-累加数"><a href="#306-累加数" class="headerlink" title="306_累加数"></a>306_累加数</h2><ul>
<li><p>这题没有官方题解</p>
<ul>
<li>得要回溯，代码量比较多</li>
<li>这里的坑在于前两个数不一定都是一位数，也可能是多位，所以得罗列所有的情况</li>
<li>一遇到对的就返回，循环的时候得看剩余的数字个数够不够（前面数字相加的长度）</li>
</ul>
</li>
<li><p>这里直接 CV 了</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /*功能说明:接受两个数字字符串作为输入，输出他们和的字符串*/</span><br><span class="line">    string addString(const string&amp; a, const string&amp; b) &#123;</span><br><span class="line">        int length = (a.size() &gt; b.size()) ? a.size() : b.size();</span><br><span class="line">        string c(length + 1, &apos; &apos;);</span><br><span class="line">        int ptr1 = a.size() - 1, ptr2 = b.size() - 1, ptr3 = c.size() - 1, carryNum = 0, thisSum = 0;</span><br><span class="line">        while (ptr1 &gt;= 0 || ptr2 &gt;= 0) &#123;</span><br><span class="line">            int numA = (ptr1 &gt;= 0) ? a[ptr1--] - &apos;0&apos; : 0;</span><br><span class="line">            int numB = (ptr2 &gt;= 0) ? b[ptr2--] - &apos;0&apos; : 0;</span><br><span class="line">            thisSum = numA + numB + carryNum;</span><br><span class="line">            if (thisSum &gt;= 10) &#123;</span><br><span class="line">                carryNum = 1;</span><br><span class="line">                thisSum %= 10;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                carryNum = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            c[ptr3--] = thisSum + &apos;0&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        if (carryNum &gt; 0) &#123;</span><br><span class="line">            c[0] = &apos;1&apos;;</span><br><span class="line">            return c;</span><br><span class="line">        &#125;</span><br><span class="line">        else </span><br><span class="line">            return c.substr(1);   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*回溯模版</span><br><span class="line">      参数说明:</span><br><span class="line">      num:目标字符串</span><br><span class="line">      startIndex:当前开始回溯的下标</span><br><span class="line">      res:保存结果</span><br><span class="line">      endIndex:当前step用到的终点下标(也就是字符串c的下一个开始)*/</span><br><span class="line">    void backtrack(const string&amp; num, int startIndex, bool&amp; res, int endIndex) &#123;</span><br><span class="line">        //如果已经到达目标字符串的末端，则成功，该字符串是一个累加序列</span><br><span class="line">        if (endIndex &gt;= num.size()) &#123;</span><br><span class="line">            res = true;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //选择第一个数a，开始下标为startIndex，长度为lengthOfa</span><br><span class="line">        for (int lengthOfa = 1; startIndex + lengthOfa &lt;= num.size(); ++lengthOfa) &#123;</span><br><span class="line">            //选择第二个数b，开始下标为startIndex + lengthOfa，长度为lengthOfb</span><br><span class="line">            for (int lengthOfb = 1; startIndex + lengthOfa + lengthOfb &lt;= num.size(); ++lengthOfb) &#123;</span><br><span class="line">                string a = num.substr(startIndex, lengthOfa);</span><br><span class="line">                string b = num.substr(startIndex + lengthOfa, lengthOfb);</span><br><span class="line"></span><br><span class="line">                //如果字符串长度大于1，且以0开头，则跳过当前结果不做考虑（题目规定）</span><br><span class="line">                if ((a.size() &gt; 1 &amp;&amp; a[0] == &apos;0&apos;) || (b.size() &gt; 1 &amp;&amp; b[0] == &apos;0&apos;))</span><br><span class="line">                    continue;</span><br><span class="line"></span><br><span class="line">                //a + b 的字符串结果</span><br><span class="line">                string sum = addString(a, b);</span><br><span class="line"></span><br><span class="line">                //将剩余的字符串赋给c</span><br><span class="line">                string c = num.substr(startIndex + lengthOfa + lengthOfb);</span><br><span class="line"></span><br><span class="line">                //判断sum和c的开始部分是否相等</span><br><span class="line">                if (sum.size() &gt; c.size() || sum != c.substr(0, sum.size()))</span><br><span class="line">                    continue;</span><br><span class="line"></span><br><span class="line">                //相等表示可以进入下一个step的回溯了，注意，本阶段到字符串c的下标处我们都已经使用过了,</span><br><span class="line">                //所以让endIndex = startIndex + lengthOfa + lengthOfb + sum.size()</span><br><span class="line">                backtrack(num, startIndex + lengthOfa, res, startIndex + lengthOfa + lengthOfb + sum.size());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    bool isAdditiveNumber(string num) &#123;</span><br><span class="line">        if (num.size() == 0)</span><br><span class="line">            return false;</span><br><span class="line">        bool res = false;</span><br><span class="line">        backtrack(num, 0, res, 0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94_二叉树的中序遍历"></a>94_二叉树的中序遍历</h2><ul>
<li>这还是第一次正式对二叉树排序，之前都是回溯+剪枝找可行解来着</li>
<li>既然学了中序，那把先序和后序也做了，提前把递归理解还真的是如虎添翼</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">//    先序：考察到一个节点后，即刻输出该节点的值，并继续遍历其左右子树。(根左右)</span><br><span class="line">//    中序：考察到一个节点后，将其暂存，遍历完左子树后，再输出该节点的值，然后遍历右子树。(左根右)</span><br><span class="line">//    后序：考察到一个节点后，将其暂存，遍历完左右子树后，再输出该节点的值。(左右根)</span><br><span class="line">    //中序</span><br><span class="line">    void dfs0(TreeNode* root, vector&lt;int&gt; &amp;res)&#123;</span><br><span class="line">        if(root == nullptr)</span><br><span class="line">            return;</span><br><span class="line">        dfs(root-&gt;left, res);   //中序的输出顺序是左子树的值、根节点的值、右子树的值</span><br><span class="line">        res.emplace_back(root-&gt;val);</span><br><span class="line">        dfs(root-&gt;right, res);</span><br><span class="line">//        res.emplace_back(root-&gt;val);  //这里会出现放了两次数字的情况</span><br><span class="line">    &#125;</span><br><span class="line">    //先序</span><br><span class="line">    void dfs1(TreeNode* root, vector&lt;int&gt; &amp;res)&#123;</span><br><span class="line">        if(root == nullptr) //先序的输出顺序是根节点的值、左子树的值、右子树的值</span><br><span class="line">            return;</span><br><span class="line">        res.emplace_back(root-&gt;val);    //先放根节点的值</span><br><span class="line">        dfs(root-&gt;left, res);</span><br><span class="line">        dfs(root-&gt;right, res);</span><br><span class="line">    &#125;</span><br><span class="line">    //后序</span><br><span class="line">    void dfs(TreeNode* root, vector&lt;int&gt; &amp;res)&#123;</span><br><span class="line">        if(root == nullptr) //先序的输出顺序是左子树的值、右子树的值、根节点的值</span><br><span class="line">            return;</span><br><span class="line">        dfs(root-&gt;left, res);</span><br><span class="line">        dfs(root-&gt;right, res);</span><br><span class="line">        res.emplace_back(root-&gt;val);    //最后放根节点的值</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        dfs(root, res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    auto *root = new TreeNode(1);</span><br><span class="line">    root-&gt;left = new TreeNode(2);</span><br><span class="line">    root-&gt;right = new TreeNode(3);</span><br><span class="line">    root-&gt;left-&gt;left = new TreeNode(4);</span><br><span class="line">    root-&gt;left-&gt;left-&gt;right = new TreeNode(6);</span><br><span class="line">    root-&gt;left-&gt;left-&gt;right-&gt;left = new TreeNode(7);</span><br><span class="line">    root-&gt;left-&gt;left-&gt;right-&gt;right = new TreeNode(8);</span><br><span class="line">    root-&gt;right-&gt;right = new TreeNode(5);</span><br><span class="line"></span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;int&gt; res = solution.inorderTraversal(root);</span><br><span class="line">    for(const auto &amp;r : res)</span><br><span class="line">        cout &lt;&lt; r &lt;&lt; &quot; &quot;;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="95-不同的二叉搜索树-II"><a href="#95-不同的二叉搜索树-II" class="headerlink" title="95_不同的二叉搜索树_II"></a>95_不同的二叉搜索树_II</h2><ul>
<li>注意审题，结构不同，与数字的顺序无关</li>
<li>错了错了，二叉搜索树关键的性质是根节点的值大于左子树所有节点的值，小于右子树所有节点的值，且左子树和右子树也同样为二叉搜索树。</li>
<li>虽然想到用递归但是，就算解出来也是错的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void dfs_cout(TreeNode* root)&#123;</span><br><span class="line">    if(root == nullptr)</span><br><span class="line">        return;</span><br><span class="line">    dfs_cout(root-&gt;left);</span><br><span class="line">    cout &lt;&lt; root-&gt;val &lt;&lt; &quot; &quot;;</span><br><span class="line">    dfs_cout(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;TreeNode*&gt; generateTrees(int start, int end) &#123;</span><br><span class="line">        if (start &gt; end)</span><br><span class="line">            return &#123; nullptr &#125;; //这里返回nullptr,而不是&#123;&#125;</span><br><span class="line">        vector&lt;TreeNode*&gt; allTrees;</span><br><span class="line">        // 枚举可行根节点</span><br><span class="line">        for (int i = start; i &lt;= end; i++) &#123;</span><br><span class="line">            // 获得所有可行的左子树集合</span><br><span class="line">            vector&lt;TreeNode*&gt; leftTrees = generateTrees(start, i - 1);</span><br><span class="line">            // 获得所有可行的右子树集合</span><br><span class="line">            vector&lt;TreeNode*&gt; rightTrees = generateTrees(i + 1, end);</span><br><span class="line">            // 从左子树集合中选出一棵左子树，从右子树集合中选出一棵右子树，拼接到根节点上</span><br><span class="line">            for (auto&amp; left : leftTrees) &#123;</span><br><span class="line">                for (auto&amp; right : rightTrees) &#123;</span><br><span class="line">                    TreeNode* currTree = new TreeNode(i);</span><br><span class="line">                    currTree-&gt;left = left;</span><br><span class="line">                    currTree-&gt;right = right;</span><br><span class="line">                    allTrees.emplace_back(currTree);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return allTrees;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;TreeNode*&gt; generateTrees(int n) &#123;</span><br><span class="line">        if (!n)</span><br><span class="line">            return &#123;&#125;;</span><br><span class="line">        return generateTrees(1, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;TreeNode*&gt; res = solution.generateTrees(3);</span><br><span class="line">    //输出二叉树就用之前的先序遍历吧</span><br><span class="line">    for(auto r : res)&#123;</span><br><span class="line">        cout &lt;&lt; &quot;r.val = &quot; &lt;&lt; r-&gt;val &lt;&lt; &quot; &quot; &lt;&lt; (r-&gt;right == nullptr) &lt;&lt; endl;</span><br><span class="line">        dfs_cout(r);</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96_不同的二叉搜索树"></a>96_不同的二叉搜索树</h2><ul>
<li>这题还是上题的灵感，但是超出时间限制了…算出来的答案应该没问题</li>
<li>用动态规划可以大幅缩减时间；总结规律很重要</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int numTrees(int n) &#123;</span><br><span class="line">        vector&lt;int&gt; dp(n + 1, 0);</span><br><span class="line">        dp[0] = 1; dp[1] = 1;</span><br><span class="line">        for(int i = 2; i &lt;= n; ++i)&#123;</span><br><span class="line">            for(int j = 1; j &lt;= i; ++j)&#123;</span><br><span class="line">                dp[i] += dp[j - 1] * dp[i - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.numTrees(3) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98_验证二叉搜索树"></a>98_验证二叉搜索树</h2><ul>
<li>看了答案才知道递归要有两个值，</li>
<li>一开始是直接判断子节点是否是二叉搜索树，后来发现所有的左子树节点都要小于跟节点的值，右边那就是都要大于，不能等于；取巧了下，将二叉树中序遍历出来，得到一维数组，并且这个数组是严格升序的，还是题解更好</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void dfs(vector&lt;int&gt; &amp;nums, TreeNode* root)&#123;</span><br><span class="line">        if(root == nullptr) return;</span><br><span class="line">        dfs(nums, root-&gt;left);</span><br><span class="line">        nums.emplace_back(root-&gt;val);</span><br><span class="line">        dfs(nums, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool isValidBST(TreeNode* root) &#123;</span><br><span class="line">        if(root == nullptr) return true;</span><br><span class="line">        bool flag = true;</span><br><span class="line">        vector&lt;int&gt; nums;</span><br><span class="line">        dfs(nums, root);</span><br><span class="line">        int tmp = nums[0];</span><br><span class="line">        for(int i = 0; i &lt; nums.size(); ++i)&#123;</span><br><span class="line">            if(i == 0) continue;</span><br><span class="line">            if(tmp &gt;= nums[i])&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                tmp = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    //TODO</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="99-恢复二叉搜索树"><a href="#99-恢复二叉搜索树" class="headerlink" title="99_恢复二叉搜索树"></a>99_恢复二叉搜索树</h2><ul>
<li>这题忘了容器<code>vector</code>是可以存放<code>Treenode*</code>类型的，思维僵化；不过题解还是用的<code>int</code>类型</li>
<li>这题就不写输入输出了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void dfs(vector&lt;TreeNode*&gt; &amp;ans, TreeNode* root)&#123;</span><br><span class="line">        if(!root) return;</span><br><span class="line">        dfs(ans, root-&gt;left);</span><br><span class="line">        ans.emplace_back(root);</span><br><span class="line">        dfs(ans, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    void recoverTree(TreeNode* root) &#123;</span><br><span class="line">       vector&lt;TreeNode*&gt; ans;</span><br><span class="line">        dfs(ans, root);</span><br><span class="line">        for(const auto &amp;a : ans)&#123;</span><br><span class="line">            cout &lt;&lt; a-&gt;val &lt;&lt; &quot; &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        int prev = -1, curr = -1;</span><br><span class="line">        for(int i = 0; i &lt; ans.size() - 1; ++i)&#123;</span><br><span class="line">            if(ans[i]-&gt;val &gt; ans[i + 1]-&gt;val)&#123;</span><br><span class="line">                prev = prev &lt; 0 ? i : prev;</span><br><span class="line">                curr = (curr &lt; 0 &amp;&amp; prev != i) ? i : curr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(prev &lt; 0 &amp;&amp; curr &lt; 0) return;</span><br><span class="line">        if(prev &gt;= 0 &amp;&amp; curr &gt;= 0)&#123;</span><br><span class="line">            int tmp = ans[prev]-&gt;val;</span><br><span class="line">            ans[prev]-&gt;val = ans[curr + 1]-&gt;val;</span><br><span class="line">            ans[curr + 1]-&gt;val = tmp;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">             int tmp = ans[prev]-&gt;val;</span><br><span class="line">             ans[prev]-&gt;val = ans[prev + 1]-&gt;val;</span><br><span class="line">             ans[prev + 1]-&gt;val = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100_相同的树"></a>100_相同的树</h2><ul>
<li>思路应该很简单；中序在手，天下我有</li>
<li>还是要认真看题解，这种方法叫做深度优先搜索，仔细看才知道直接用本函数就可以递归</li>
<li>再学习下广度优先搜索</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool dfs(TreeNode* p, TreeNode* q)&#123;</span><br><span class="line">        if(p == nullptr &amp;&amp; q == nullptr) return true;</span><br><span class="line">        if((p != nullptr &amp;&amp; q == nullptr) || (p == nullptr &amp;&amp; q != nullptr))&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(p-&gt;val != q-&gt;val) return false;</span><br><span class="line">        return dfs(p-&gt;left, q-&gt;left) &amp;&amp; dfs(p-&gt;right, q-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool isSameTree(TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        return dfs(p,q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101_对称二叉树"></a>101_对称二叉树</h2><ul>
<li>这题应该用广度优先搜索；不递归，维护两个队列，不停的将节点放入队列再弹出，最后判断两个都是否为空；在<code>whlie</code>循环内，先判断节点值是否相等，再判断左右子节点，不为空就分别放入两个队列中，注意顺序</li>
<li>我还是想的复杂了，题解的递归写的很简洁</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isSymmetric(TreeNode* root) &#123;</span><br><span class="line">        if(root == nullptr)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;else if(root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;else if(root-&gt;left == nullptr || root-&gt;right == nullptr)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; r1,r2;</span><br><span class="line">        r1.push(root-&gt;left);</span><br><span class="line">        r2.push(root-&gt;right);</span><br><span class="line">        while(!r1.empty() &amp;&amp; !r2.empty())&#123;</span><br><span class="line">            auto l = r1.front();</span><br><span class="line">            r1.pop();</span><br><span class="line">            auto r = r2.front();</span><br><span class="line">            r2.pop();</span><br><span class="line">            if(l-&gt;val != r-&gt;val)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            auto left1 = l-&gt;left, right1 = l-&gt;right;</span><br><span class="line">            auto left2 = r-&gt;left, right2 = r-&gt;right;</span><br><span class="line">            if((left1 == nullptr &amp;&amp; right2 != nullptr) || (left1 != nullptr &amp;&amp; right2 == nullptr) )</span><br><span class="line">                return false;</span><br><span class="line">            if((left2 == nullptr &amp;&amp; right1 != nullptr) || (left2 != nullptr &amp;&amp; right1 == nullptr) )</span><br><span class="line">                return false;</span><br><span class="line"></span><br><span class="line">            if (left1 != nullptr) &#123;</span><br><span class="line">                r1.push(left1);</span><br><span class="line">            &#125;</span><br><span class="line">            if (right1 != nullptr) &#123;</span><br><span class="line">                r1.push(right1);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if (right2 != nullptr) &#123;</span><br><span class="line">                r2.push(right2);</span><br><span class="line">            &#125;</span><br><span class="line">            if (left2 != nullptr) &#123;</span><br><span class="line">                r2.push(left2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return r1.empty() &amp;&amp; r2.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution_ &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isSymmetric(TreeNode* r1, TreeNode* r2)&#123;</span><br><span class="line">        if(!r1 &amp;&amp; !r2) return true;</span><br><span class="line">        if(!r1 || !r2) return false;</span><br><span class="line"></span><br><span class="line">        return r1-&gt;val == r2-&gt;val &amp;&amp; isSymmetric(r1-&gt;left, r2-&gt;right) &amp;&amp; isSymmetric(r2-&gt;left, r1-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    bool isSymmetric(TreeNode* root) &#123;</span><br><span class="line">        return isSymmetric(root, root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102_二叉树的层序遍历"></a>102_二叉树的层序遍历</h2><ul>
<li>刚开始想用递归来着，后来觉得应该用广度优先搜索，维护一个队列</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return &#123;&#125;;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        vector&lt;int&gt; tmp;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            int n = q.size();</span><br><span class="line">            while(n &gt; 0)&#123;</span><br><span class="line">                //cout &lt;&lt; &quot;n = &quot; &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">                auto r = q.front();</span><br><span class="line">                tmp.emplace_back(r-&gt;val);</span><br><span class="line">                q.pop();</span><br><span class="line">                if(r-&gt;left)&#123;</span><br><span class="line">                    q.push(r-&gt;left);</span><br><span class="line">                    //cout &lt;&lt; &quot;r-&gt;left = &quot; &lt;&lt; r-&gt;left-&gt;val &lt;&lt; endl; </span><br><span class="line">                &#125; </span><br><span class="line">                if(r-&gt;right)&#123;</span><br><span class="line">                    //cout &lt;&lt; &quot;r-&gt;right = &quot; &lt;&lt; r-&gt;right-&gt;val &lt;&lt; endl; </span><br><span class="line">                    q.push(r-&gt;right);</span><br><span class="line">                &#125; </span><br><span class="line">                --n;</span><br><span class="line">                //cout &lt;&lt; &quot;--n = &quot; &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">            tmp.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="103-二叉树的锯齿形层序遍历"><a href="#103-二叉树的锯齿形层序遍历" class="headerlink" title="103_二叉树的锯齿形层序遍历"></a>103_二叉树的锯齿形层序遍历</h2><ul>
<li>有点纳闷，为啥二叉树题都放一起了</li>
<li>暂时还没了解二叉树是如何手动删除的，所以就没有在IDE上输入输出</li>
<li>这题思路应该上题差不多，目测需要一个方向布尔值，取反注意逻辑取反和按位取反</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void reverse(vector&lt;int&gt; &amp;tmp)&#123;</span><br><span class="line">        int prev = 0, curr = tmp.size();</span><br><span class="line">        --curr;</span><br><span class="line">        while(prev &lt; curr)&#123;</span><br><span class="line">            int ans = tmp[prev];</span><br><span class="line">            tmp[prev] = tmp[curr];</span><br><span class="line">            tmp[curr] = ans;</span><br><span class="line">            ++prev;</span><br><span class="line">            --curr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return &#123;&#125;;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        vector&lt;int&gt; tmp;</span><br><span class="line">        bool flag = false;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            int n = q.size();</span><br><span class="line">            while(n &gt; 0)&#123;</span><br><span class="line">                auto r = q.front();</span><br><span class="line">                tmp.emplace_back(r-&gt;val);</span><br><span class="line">                q.pop();</span><br><span class="line">                if(r-&gt;left) q.push(r-&gt;left);</span><br><span class="line">                if(r-&gt;right) q.push(r-&gt;right);</span><br><span class="line">                --n;</span><br><span class="line">            &#125;</span><br><span class="line">            //cout &lt;&lt; tmp[0] &lt;&lt; &quot;----&quot; &lt;&lt; endl;</span><br><span class="line">            if(flag)&#123;   //一开始是1，无需反转</span><br><span class="line">                //cout &lt;&lt; flag &lt;&lt; endl;</span><br><span class="line">                reverse(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            flag = !flag;</span><br><span class="line">            </span><br><span class="line">            //cout &lt;&lt; flag &lt;&lt; endl;</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">            tmp.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104_二叉树的最大深度"></a>104_二叉树的最大深度</h2><ul>
<li>BFS永远的神</li>
<li>看了题解才知道，小丑竟是我自己,递归就两行代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxDepth(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return 0;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            int n = q.size();</span><br><span class="line">            while(n &gt; 0)&#123;</span><br><span class="line">                auto r = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                if(r-&gt;left) q.push(r-&gt;left);</span><br><span class="line">                if(r-&gt;right) q.push(r-&gt;right);</span><br><span class="line">                --n;</span><br><span class="line">            &#125;</span><br><span class="line">            ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105_从前序与中序遍历序列构造二叉树"></a>105_从前序与中序遍历序列构造二叉树</h2><ul>
<li>这题虽然用递归做出来了，但时间和内存消耗都很低，都是5%多一点</li>
<li>学习下题解是怎么做的，第一个方法思路一样，第二个是迭代</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;</span><br><span class="line">        //preorder第一个数是根节点</span><br><span class="line">        //inorder第一个数是左子树尽头的节点</span><br><span class="line">        if(preorder.empty() || inorder.empty()) return nullptr;</span><br><span class="line">        TreeNode* root = new TreeNode(preorder[0]); //根节点</span><br><span class="line">        </span><br><span class="line">        vector&lt;int&gt; pre, ino;</span><br><span class="line">        int pos = 0;</span><br><span class="line">        for(; pos &lt; preorder.size(); ++pos)&#123;</span><br><span class="line">            if(pos &gt; 0)</span><br><span class="line">                pre.push_back(preorder[pos]);</span><br><span class="line">            if(root-&gt;val == inorder[pos])</span><br><span class="line">                break;</span><br><span class="line">            ino.push_back(inorder[pos]);</span><br><span class="line">        &#125;</span><br><span class="line">        preorder.erase(preorder.begin(), preorder.begin() + pos + 1);</span><br><span class="line">        inorder.erase(inorder.begin(), inorder.begin() + pos + 1);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        root-&gt;left = buildTree(pre, ino);</span><br><span class="line">        root-&gt;right = buildTree(preorder, inorder);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106_从中序与后序遍历序列构造二叉树"></a>106_从中序与后序遍历序列构造二叉树</h2><ul>
<li>这题解法跟上题一样，就是有些细节需要注意</li>
<li>试了下迭代的算法，，，赶紧学习下，看不懂也要看！！</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123;</span><br><span class="line">        if(postorder.empty() || inorder.empty()) return nullptr;</span><br><span class="line">        int n = postorder.size();</span><br><span class="line">        TreeNode* root = new TreeNode(postorder[n - 1]); //根节点</span><br><span class="line">        </span><br><span class="line">        vector&lt;int&gt; pre, ino;</span><br><span class="line">        int pos = 0;</span><br><span class="line">        for(; pos &lt; n; ++pos)&#123;</span><br><span class="line">            if(root-&gt;val == inorder[pos])</span><br><span class="line">                break;</span><br><span class="line">            pre.push_back(inorder[pos]);</span><br><span class="line">            ino.push_back(postorder[pos]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        inorder.erase(inorder.begin(), inorder.begin() + pos + 1);</span><br><span class="line">        postorder.erase(postorder.begin(), postorder.begin() + pos);</span><br><span class="line">        postorder.pop_back();</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        root-&gt;left = buildTree(pre, ino);</span><br><span class="line">        root-&gt;right = buildTree(inorder, postorder);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="107-二叉树的层序遍历-II"><a href="#107-二叉树的层序遍历-II" class="headerlink" title="107-二叉树的层序遍历 II"></a>107-二叉树的层序遍历 II</h2><ul>
<li>这题虽然与l一样，但消耗不够看；得认真看下题解</li>
<li>淦，直接用<code>reverse(res.begin(), res.end());</code>函数在头文件<code>#include &lt;algorithm&gt;</code>中，，，，这消耗真是天壤之别</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return &#123;&#125;;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        vector&lt;int&gt; tmp;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            int n = q.size();</span><br><span class="line">            while(n &gt; 0)&#123;</span><br><span class="line">                auto r = q.front();</span><br><span class="line">                tmp.emplace_back(r-&gt;val);</span><br><span class="line">                q.pop();</span><br><span class="line">                if(r-&gt;left)&#123;</span><br><span class="line">                    q.push(r-&gt;left);</span><br><span class="line">                &#125; </span><br><span class="line">                if(r-&gt;right)&#123;</span><br><span class="line">                    q.push(r-&gt;right);</span><br><span class="line">                &#125; </span><br><span class="line">                --n;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">            tmp.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(res.begin(), res.end());</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108_将有序数组转换为二叉搜索树"></a>108_将有序数组转换为二叉搜索树</h2><ul>
<li>这题比较简单，但消耗中等偏下</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if(nums.empty()) return nullptr;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        int mid = n / 2;</span><br><span class="line">        TreeNode *root = new TreeNode(nums[mid]);</span><br><span class="line">        vector&lt;int&gt; pre;</span><br><span class="line">        for(int i = 0; i &lt; mid; ++i)</span><br><span class="line">            pre.push_back(nums[i]);</span><br><span class="line">        nums.erase(nums.begin(), nums.begin() + mid + 1);</span><br><span class="line">        root-&gt;left = sortedArrayToBST(pre);</span><br><span class="line">        root-&gt;right = sortedArrayToBST(nums);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="109-有序链表转换二叉搜索树"><a href="#109-有序链表转换二叉搜索树" class="headerlink" title="109_有序链表转换二叉搜索树"></a>109_有序链表转换二叉搜索树</h2><ul>
<li>有点小问题，在计算链表的长度时，我说呢<code>while(!carry)</code>的意思是当他是空的时候，找中位数的时候也可以用两个指针，快指针每次移动两格，慢指针每次移动一格</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* sortedListToBST(ListNode* head) &#123;</span><br><span class="line">        if(!head) return nullptr;</span><br><span class="line">        int len = 1;</span><br><span class="line">        auto carry = head, mid = head;</span><br><span class="line">        while(carry-&gt;next)&#123;</span><br><span class="line">            carry = carry-&gt;next;</span><br><span class="line">            ++len;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(len == 1) return new TreeNode(head-&gt;val);</span><br><span class="line">        int m = len / 2;</span><br><span class="line">        while(m &gt; 0)&#123;</span><br><span class="line">            carry = mid;</span><br><span class="line">            mid = mid-&gt; next;</span><br><span class="line">            --m;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* root = new TreeNode(mid-&gt;val);</span><br><span class="line">        root-&gt;right = sortedListToBST(mid-&gt;next);</span><br><span class="line">        </span><br><span class="line">        carry-&gt;next = nullptr;</span><br><span class="line">        root-&gt;left = sortedListToBST(head);</span><br><span class="line">        </span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110_平衡二叉树"></a>110_平衡二叉树</h2><ul>
<li>这次用深度优先搜索来计算二叉树的层数，之前的一题题解里有参考，默写下，就当复习了！</li>
<li>思路还是很清晰的，最主要的是计算最大深度，然后每个递归每个节点，也就是每个节点都要计算最大深度</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int nums(TreeNode* root)&#123;   </span><br><span class="line">        if(!root) return 0;</span><br><span class="line">        return max(nums(root-&gt;left), nums(root-&gt;right)) + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool deep(TreeNode* root)&#123;</span><br><span class="line">        if(!root) return true;</span><br><span class="line">        int l = nums(root-&gt;left);</span><br><span class="line">        int r = nums(root-&gt;right);</span><br><span class="line">        bool flag = false;</span><br><span class="line">        if(abs(l - r) &lt;= 1)</span><br><span class="line">            flag = true;</span><br><span class="line">        return flag &amp;&amp; deep(root-&gt;left) &amp;&amp; deep(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool isBalanced(TreeNode* root) &#123;</span><br><span class="line">        return deep(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111_二叉树的最小深度"></a>111_二叉树的最小深度</h2><ul>
<li>最小深度如果出现根节点的一个子树为空，那就考虑另一边的最小长度再加一；之后逻辑就跟最大深度一样，只不过要用<code>min()</code>函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minDepth(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return 0;</span><br><span class="line">        if(!root-&gt;left) </span><br><span class="line">            return minDepth(root-&gt;right) + 1;</span><br><span class="line">        else if(!root-&gt;right)</span><br><span class="line">            return minDepth(root-&gt;left) + 1;</span><br><span class="line">        else    </span><br><span class="line">            return min(minDepth(root-&gt;left), minDepth(root-&gt;right)) + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112_路径总和"></a>112_路径总和</h2><ul>
<li>主要是要考虑特殊情况，即一开始就是空节点和0，这种情况下是<code>false</code></li>
<li>对，这题用深度优先搜索</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool hasPathSum(TreeNode* root, int targetSum) &#123;</span><br><span class="line">        if(!root) </span><br><span class="line">            return false;</span><br><span class="line">        else if(!root-&gt;left &amp;&amp; !root-&gt;right)&#123;</span><br><span class="line">            if(targetSum - root-&gt;val == 0)</span><br><span class="line">                return true;</span><br><span class="line">            else</span><br><span class="line">                return false;</span><br><span class="line">        &#125; </span><br><span class="line">        return hasPathSum(root-&gt;left, targetSum - root-&gt;val) || hasPathSum(root-&gt;right, targetSum - root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="113-路径总和-II"><a href="#113-路径总和-II" class="headerlink" title="113_路径总和_II"></a>113_路径总和_II</h2><ul>
<li>这个是要找出所有的路径，这题思路和以前某题很像，方法叫做回溯加剪枝来着，复习下</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void dfs(vector&lt;vector&lt;int&gt;&gt; &amp;res, vector&lt;int&gt; &amp;tmp, TreeNode* root, int targetSum)&#123;</span><br><span class="line">        if(!root)</span><br><span class="line">            return;</span><br><span class="line">        tmp.push_back(root-&gt;val);</span><br><span class="line">        dfs(res, tmp, root-&gt;left, targetSum - root-&gt;val);    </span><br><span class="line">        dfs(res, tmp, root-&gt;right, targetSum - root-&gt;val);</span><br><span class="line">        if(!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; targetSum == root-&gt;val)//到达最后一个节点时，不应该判断是否为0，而是判断是否相等</span><br><span class="line">                res.push_back(tmp);</span><br><span class="line">        tmp.pop_back();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        vector&lt;int&gt; tmp;</span><br><span class="line">        dfs(res, tmp, root, targetSum);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114_二叉树展开为链表"></a>114_二叉树展开为链表</h2><ul>
<li>有点奇怪，节点不能相互赋予么</li>
<li>那就先一个数组保存先序遍历的节点，再遍历数组逐步生成新的节点</li>
<li>再学习下新的方法，不用数组维护，直接在原二叉树嫁接</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void dfs(TreeNode* root, vector&lt;int&gt; &amp;tmp) &#123;</span><br><span class="line">        if(!root) return;</span><br><span class="line">        tmp.emplace_back(root-&gt;val);</span><br><span class="line">        dfs(root-&gt;left, tmp);</span><br><span class="line">        dfs(root-&gt;right, tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void flatten(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return;</span><br><span class="line">        vector&lt;int&gt; tmp;</span><br><span class="line">        dfs(root, tmp);</span><br><span class="line">        root-&gt;left = nullptr;</span><br><span class="line">        root-&gt;right = nullptr;</span><br><span class="line">        tmp.erase(tmp.begin());</span><br><span class="line">        auto carry = root;</span><br><span class="line">        for(auto t : tmp)&#123;</span><br><span class="line">            carry-&gt;right = new TreeNode(t);</span><br><span class="line">            carry = carry-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>法二</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void flatten(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return;</span><br><span class="line">        auto curr = root;</span><br><span class="line">        while(curr)&#123;</span><br><span class="line">            if(curr-&gt;left)&#123;</span><br><span class="line">                auto next = curr-&gt;left;</span><br><span class="line">            auto prev = next;</span><br><span class="line">            while(prev-&gt;right)&#123;</span><br><span class="line">                prev = prev-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            prev-&gt;right = curr-&gt;right;</span><br><span class="line">            curr-&gt;left = nullptr;</span><br><span class="line">            curr-&gt;right = next;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116_填充每个节点的下一个右侧节点指针"></a>116_填充每个节点的下一个右侧节点指针</h2><ul>
<li>这题我用了广度优先搜索（使用队列来保存每一层的节点，每一层最后一个节点需要注意不能连到下一层的起始节点），但是使用的额外空间不是常量级，学习下题解</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//广度有限搜索</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    Node* connect(Node* root) &#123;</span><br><span class="line">        if(!root) return nullptr;</span><br><span class="line">        queue&lt;Node*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            int n = q.size();</span><br><span class="line">            while(n &gt; 0)&#123;</span><br><span class="line">                auto r = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                r-&gt;next = n == 1 ? nullptr : q.front();</span><br><span class="line">                --n;</span><br><span class="line">                if(r-&gt;left) q.push(r-&gt;left);</span><br><span class="line">                if(r-&gt;right) q.push(r-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//常量级额外空间</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    Node* connect(Node* root) &#123;</span><br><span class="line">        if(!root) return nullptr;</span><br><span class="line">        auto h = root;</span><br><span class="line">        while(h-&gt;left)&#123;</span><br><span class="line">            auto head = h;</span><br><span class="line">            while(head)&#123;</span><br><span class="line">                head-&gt;left-&gt;next = head-&gt;right;</span><br><span class="line">                if(head-&gt;next)</span><br><span class="line">                    head-&gt;right-&gt;next = head-&gt;next-&gt;left;</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            h = h-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="117-填充每个节点的下一个右侧节点指针-ll"><a href="#117-填充每个节点的下一个右侧节点指针-ll" class="headerlink" title="117_填充每个节点的下一个右侧节点指针_ll"></a>117_填充每个节点的下一个右侧节点指针_ll</h2><ul>
<li>这题是普通的二叉树，不是完全二叉树；使用广度优先搜索的话，代码无需任何改变，再试试第二种方法，额，第二种方法属实有点繁琐</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//广度优先搜索代码同上</span><br></pre></td></tr></table></figure>

<h2 id="124-二叉树中的最大路径和"><a href="#124-二叉树中的最大路径和" class="headerlink" title="124_二叉树中的最大路径和"></a>124_二叉树中的最大路径和</h2><ul>
<li>最大流算法作业还没写呢</li>
<li>这题我完全没有思路，但题解评论好多都说简单…难点在于根节点并不一定经过，目前来看，对二叉树的处理无非是广度优先和深度优先，但这两个方法都需要从根节点开始，每次只有选择左边或者右边这两种情况，这就是矛盾所在，如何转化矛盾，二叉树的最小构造-二叉树单元；根节点上方连着父节点（如果有的话），还有左节点和右节点。</li>
<li>除了两种情况，还有第三种情况，那就是左右一起选，这三种情况都连着根节点，所以只需递归比较左右两边的最大值，再加上判断根节点的值</li>
<li>有位大佬写的很清晰：枚举节点</li>
</ul>
<p><img src="/pictrues/%E4%BA%8C%E5%8F%89%E6%A0%911.png" alt="二叉树" title="二叉树"><br><img src="/pictrues/%E4%BA%8C%E5%8F%89%E6%A0%912.png" alt="二叉树" title="二叉树"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    int maxSum = INT_MIN;</span><br><span class="line">public:</span><br><span class="line">    int maxGain(TreeNode* node) &#123;</span><br><span class="line">        if(!node) return 0;</span><br><span class="line">        int l = max(maxGain(node-&gt;left), 0);</span><br><span class="line">        int r = max(maxGain(node-&gt;right), 0);</span><br><span class="line"></span><br><span class="line">        int path = l + r + node-&gt;val;</span><br><span class="line">        maxSum = max(maxSum, path);</span><br><span class="line">        return max(l, r) + node-&gt;val;//当前根节点下，只能返回两条路的一条</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int maxPathSum(TreeNode* root) &#123;</span><br><span class="line">        maxGain(root);</span><br><span class="line">        return maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="129-求根节点到叶节点数字之和"><a href="#129-求根节点到叶节点数字之和" class="headerlink" title="129_求根节点到叶节点数字之和"></a>129_求根节点到叶节点数字之和</h2><ul>
<li>这题题目考虑了整数范围，所以写代码的时候可以不用考虑整数边界的问题，应该吧，</li>
<li>这题我用了深度优先搜索，就是回溯的时候要对<code>tmp</code>进行恢复；还有就是不一定在节点为空的时候所得的和就是符合条件的答案</li>
<li>如果是将<code>tmp</code>为形参的话，可以不用恢复，因为回溯后还是原来的值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void dfs(TreeNode* root)&#123;</span><br><span class="line">        if(!root) return;</span><br><span class="line">        tmp = tmp * 10 + root-&gt;val;</span><br><span class="line">        //cout &lt;&lt; tmp &lt;&lt; endl;</span><br><span class="line">        dfs(root-&gt;left);</span><br><span class="line">        dfs(root-&gt;right);</span><br><span class="line">        if(!root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class="line">            ans += tmp;</span><br><span class="line">        tmp = (tmp - root-&gt;val) / 10;</span><br><span class="line">        //cout &lt;&lt; &quot;--- &quot; &lt;&lt; tmp &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int sumNumbers(TreeNode* root) &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    int ans = 0;</span><br><span class="line">    int tmp = 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144_二叉树的前序遍历"></a>144_二叉树的前序遍历</h2><ul>
<li>他来了他来了</li>
<li>学习下迭代的算法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void dfs(TreeNode* root)&#123;</span><br><span class="line">        if(!root) return;</span><br><span class="line">        res.emplace_back(root-&gt;val);</span><br><span class="line">        dfs(root-&gt;left);</span><br><span class="line">        dfs(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line">&#125;;</span><br><span class="line">//迭代</span><br><span class="line">class Solution_ &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        if (root == nullptr) &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        TreeNode* node = root;</span><br><span class="line">        while (!stk.empty() || node != nullptr) &#123;</span><br><span class="line">            while (node != nullptr) &#123;</span><br><span class="line">                res.emplace_back(node-&gt;val);</span><br><span class="line">                stk.emplace(node);</span><br><span class="line">                node = node-&gt;left;  //先一路往左</span><br><span class="line">            &#125;</span><br><span class="line">            node = stk.top();//弹出节点</span><br><span class="line">            stk.pop();</span><br><span class="line">            node = node-&gt;right; //再往右</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145_二叉树的后序遍历"></a>145_二叉树的后序遍历</h2><ul>
<li>正好默写下迭代的算法</li>
<li>…不会写…</li>
<li>一开始把<code>res.emplace_back(node-&gt;val);</code>改成<code>res.insert(res.begin(), node-&gt;val);</code>根节点的位置对了，但是左右位置反了；机智的我又改了下遍历顺序，先右再左；居然对了</li>
<li>但是这么写，属于旁门左道；而且c++的vector从头部添加时间复杂度O(n)</li>
<li>回过头来，再看看中序是如何迭代的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; postorderTraversal(TreeNode *root) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        if (root == nullptr) &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack&lt;TreeNode *&gt; stk;</span><br><span class="line">        TreeNode *prev = nullptr;   //判断节点的右边是不是已访问过</span><br><span class="line">        while (root != nullptr || !stk.empty()) &#123;</span><br><span class="line">            while (root != nullptr) &#123;</span><br><span class="line">                stk.emplace(root);</span><br><span class="line">                root = root-&gt;left;  //与前序一样都是先往左</span><br><span class="line">            &#125;</span><br><span class="line">            root = stk.top();</span><br><span class="line">            stk.pop();  //然后弹出</span><br><span class="line">            //之后就要开始判断了，何时放入数组</span><br><span class="line">            if (root-&gt;right == nullptr || root-&gt;right == prev) &#123;</span><br><span class="line">                res.emplace_back(root-&gt;val);</span><br><span class="line">                prev = root;</span><br><span class="line">                root = nullptr; //这一步是为了弹出栈顶元素，返回上一层</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                stk.emplace(root);</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//中序遍历</span><br><span class="line">class Solution_ &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        if (root == nullptr) &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        stack&lt;TreeNode *&gt; stk;</span><br><span class="line"></span><br><span class="line">        while (root != nullptr || !stk.empty()) &#123;</span><br><span class="line">            while (root != nullptr) &#123;</span><br><span class="line">                stk.emplace(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">            res.emplace_back(root-&gt;val);</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="173-二叉搜索树迭代器"><a href="#173-二叉搜索树迭代器" class="headerlink" title="173_二叉搜索树迭代器"></a>173_二叉搜索树迭代器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int i = -1;</span><br><span class="line">vector&lt;int&gt;::size_type s = 0;</span><br><span class="line">std::cout &lt;&lt; (i &lt; s) &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面这个会显示0，因为类型不一样</li>
<li>用了<code>vector</code>在构造函数里就将中序序列保存在数组里，内存消耗排倒数….</li>
<li>迭代还是永远的神！——模拟栈，复习下怎么迭代的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class BSTIterator &#123;</span><br><span class="line">public:</span><br><span class="line">    BSTIterator(TreeNode* root) &#123;</span><br><span class="line">        r = root;</span><br><span class="line">        i = -1;</span><br><span class="line">        tmp_init(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int next() &#123;</span><br><span class="line">        ++i;</span><br><span class="line">        return i &lt; tmp.size() ? tmp[i]-&gt;val : -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool hasNext() &#123;</span><br><span class="line">        return i &lt; tmp.size() - 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void tmp_init(TreeNode* root)&#123;</span><br><span class="line">        if(!root) return;</span><br><span class="line">        tmp_init(root-&gt;left);</span><br><span class="line">        tmp.push_back(root);</span><br><span class="line">        tmp_init(r-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    TreeNode* r;</span><br><span class="line">    int i;</span><br><span class="line">    vector&lt;TreeNode*&gt; tmp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class BSTIterator_ &#123;</span><br><span class="line">public:</span><br><span class="line">    BSTIterator_(TreeNode* root) &#123;</span><br><span class="line">        cur = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int next() &#123;</span><br><span class="line">        while (cur != nullptr)&#123;</span><br><span class="line">            stk.push(cur);</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = stk.top();</span><br><span class="line">        stk.pop();</span><br><span class="line">        int tmp = cur-&gt;val;</span><br><span class="line">        cur = cur-&gt;right;</span><br><span class="line">        return tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool hasNext() &#123;</span><br><span class="line">        //如果是模拟栈，该怎么判断是否还有下一个节点呢</span><br><span class="line">        return cur != nullptr || !stk.empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    stack&lt;TreeNode*&gt; stk;</span><br><span class="line">    TreeNode* cur;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your BSTIterator object will be instantiated and called as such:</span><br><span class="line"> * BSTIterator* obj = new BSTIterator(root);</span><br><span class="line"> * int param_1 = obj-&gt;next();</span><br><span class="line"> * bool param_2 = obj-&gt;hasNext();</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">/*    int i = -1;</span><br><span class="line">    vector&lt;int&gt;::size_type s = 0;</span><br><span class="line">    std::cout &lt;&lt; (i &lt; s) &lt;&lt; std::endl;*/</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199_二叉树的右视图"></a>199_二叉树的右视图</h2><ul>
<li>一次通过，广度优先搜索，记录下每层的最后一个元素。</li>
<li>题解也用了深度优先搜索，要先访问右边子节点</li>
<li>还是忍不住又刷了一题…</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//dfs</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; ans;</span><br><span class="line">    void dfs(TreeNode* root, int d)&#123;</span><br><span class="line">        if(!root)return;</span><br><span class="line">        //d是深度，也防止回溯时（回到左孩子节点）添加不符合条件的左边的值</span><br><span class="line">        if(ans.size() &lt; d)ans.push_back(root-&gt;val);</span><br><span class="line">        dfs(root-&gt;right, d+1);</span><br><span class="line">        dfs(root-&gt;left, d+1);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt; rightSideView(TreeNode* root) &#123;</span><br><span class="line">        dfs(root, 1);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//bfs, 可以先放右孩子这样每一层第一个节点就是要找的值</span><br><span class="line">class Solution1 &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; rightSideView(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return &#123;&#125;;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            int n = q.size();</span><br><span class="line">            int tmp = 0;</span><br><span class="line">            while(n &gt; 0)&#123;</span><br><span class="line">                auto r = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                tmp = r-&gt;val;</span><br><span class="line">                if(r-&gt;left != nullptr)</span><br><span class="line">                    q.push(r-&gt;left);</span><br><span class="line">                if(r-&gt;right != nullptr)</span><br><span class="line">                    q.push(r-&gt;right);</span><br><span class="line">                --n;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="208-实现Trie-前缀树"><a href="#208-实现Trie-前缀树" class="headerlink" title="208_实现Trie(前缀树)"></a>208_实现Trie(前缀树)</h2><ul>
<li>这题看不懂</li>
<li>字典树，是一棵有根树；这题面试会问到</li>
<li>题解用的数组，每个数组存放</li>
<li>26个指向Trie的指针；原来的类至始至终都是根节点？</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Trie &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;Trie*&gt; children;</span><br><span class="line">    bool isEnd;</span><br><span class="line"></span><br><span class="line">    Trie* searchPrefix(string prefix) &#123;</span><br><span class="line">        Trie* node = this;</span><br><span class="line">        for (char ch : prefix) &#123;</span><br><span class="line">            ch -= &apos;a&apos;;</span><br><span class="line">            if (node-&gt;children[ch] == nullptr) &#123;</span><br><span class="line">                return nullptr;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;children[ch];</span><br><span class="line">        &#125;</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    Trie() : children(26), isEnd(false) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    void insert(string word) &#123;</span><br><span class="line">        Trie* node = this;</span><br><span class="line">        //对于字符串的每个字母</span><br><span class="line">        for (char ch : word) &#123;</span><br><span class="line">            //每次循坏都会将node更新到对应的字母上</span><br><span class="line">            ch -= &apos;a&apos;;</span><br><span class="line">            if (node-&gt;children[ch] == nullptr) &#123;</span><br><span class="line">                node-&gt;children[ch] = new Trie();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;children[ch];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;isEnd = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool search(string word) &#123;</span><br><span class="line">        Trie* node = this-&gt;searchPrefix(word);</span><br><span class="line">        return node != nullptr &amp;&amp; node-&gt;isEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool startsWith(string prefix) &#123;</span><br><span class="line">        return this-&gt;searchPrefix(prefix) != nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="211-添加与搜索单词-数据结构设计"><a href="#211-添加与搜索单词-数据结构设计" class="headerlink" title="211_添加与搜索单词 - 数据结构设计"></a>211_添加与搜索单词 - 数据结构设计</h2><ul>
<li>想不通，为什么<code>.</code>不能搜索到；难道是只能有一个字母么</li>
<li><code>.</code>的话，要继续搜索不为空的<code>dic</code>，继续递归；回溯的时候，要判断最终结果是否为真，因为只需找到一个就可以了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class WordDictionary &#123;</span><br><span class="line">public:</span><br><span class="line">    /** Initialize your data structure here. */</span><br><span class="line">    WordDictionary() :  dic(26, nullptr), is_end(false) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void addWord(string word) &#123;</span><br><span class="line">        WordDictionary *node = this;</span><br><span class="line">        for (char c : word) &#123;</span><br><span class="line">            auto pos = c - &apos;a&apos;;</span><br><span class="line">            if (node-&gt;dic[pos] == nullptr)</span><br><span class="line">                node-&gt;dic[pos] = new WordDictionary;</span><br><span class="line">            node = node-&gt;dic[pos];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;is_end = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool search(string word) &#123;</span><br><span class="line">        bool result = false;</span><br><span class="line">        search(this, 0, word, result);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void search(WordDictionary *root, int start, string &amp;word, bool &amp;result) &#123;</span><br><span class="line">        if (start == word.size()) &#123;</span><br><span class="line">            if (root-&gt;is_end)</span><br><span class="line">                result = true;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //记录初始位置的参数，比substr好多了</span><br><span class="line">        char ch = word[start];</span><br><span class="line">        ++start;</span><br><span class="line">        if (ch != &apos;.&apos;) &#123;</span><br><span class="line">            // 当前层的字符不是通配符, 只检查当前字符是否存在</span><br><span class="line">            WordDictionary *node = root-&gt;dic[ch - &apos;a&apos;];</span><br><span class="line">            if (node != nullptr)</span><br><span class="line">                search(node, start, word, result);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            auto candicates = root-&gt;dic;</span><br><span class="line">            // 当前层是通配符, 所以需要把dic中不为空的都尝试一遍</span><br><span class="line">            for (auto candicate : candicates) &#123;</span><br><span class="line">                if (candicate != nullptr) &#123;</span><br><span class="line">                    search(candicate, start, word, result); // 搜索下一层</span><br><span class="line">                    if (result) // 找到一个即可退出</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;WordDictionary *&gt; dic;</span><br><span class="line">    bool is_end;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="212-单词搜索-II"><a href="#212-单词搜索-II" class="headerlink" title="212_单词搜索_II"></a>212_单词搜索_II</h2><ul>
<li>这其实也是一个前缀树；我不会举一反三0.0</li>
<li>这里代码是将字母临时更改为<code>#</code>，然后在回溯的时候恢复</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct Trie &#123;</span><br><span class="line">    Trie* next[26];</span><br><span class="line">//    注意在这里是字符串而不是布尔值</span><br><span class="line">    string word;</span><br><span class="line"></span><br><span class="line">    Trie() &#123;</span><br><span class="line">        for (auto &amp; i : next) &#123;</span><br><span class="line">            i = nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        word = &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    Trie root;</span><br><span class="line">    int m = 0;</span><br><span class="line">    int n = 0;</span><br><span class="line">    int d[4][2] = &#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    void insert(string &amp;word) &#123;</span><br><span class="line">        Trie* cur = &amp;root;</span><br><span class="line"></span><br><span class="line">        for (char c : word) &#123;</span><br><span class="line">            if (cur-&gt;next[c - &apos;a&apos;] == nullptr) &#123;</span><br><span class="line">                cur-&gt;next[c - &apos;a&apos;] = new Trie();</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next[c - &apos;a&apos;];</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;word = word;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void dfs(vector&lt;string&gt;&amp; ans, vector&lt;vector&lt;char&gt;&gt;&amp; board, int x, int y, Trie* r) &#123;</span><br><span class="line">        char c = board[x][y];</span><br><span class="line">        if (c == &apos;#&apos;) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (r-&gt;next[c - &apos;a&apos;] == nullptr) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        r = r-&gt;next[c - &apos;a&apos;];</span><br><span class="line">        if (!r-&gt;word.empty()) &#123;</span><br><span class="line">            ans.push_back(r-&gt;word);</span><br><span class="line">            r-&gt;word = &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        board[x][y] = &apos;#&apos;;</span><br><span class="line"></span><br><span class="line">        for (auto &amp; i : d) &#123;</span><br><span class="line">            int newx = x + i[0];</span><br><span class="line">            int newy = y + i[1];</span><br><span class="line"></span><br><span class="line">            if (newx &gt;= 0 &amp;&amp; newx &lt; m &amp;&amp; newy &gt;= 0 &amp;&amp; newy &lt; n &amp;&amp; board[newx][newy] != &apos;#&apos;) &#123;</span><br><span class="line">                dfs(ans, board, newx, newy, r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        board[x][y] = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;string&gt; findWords(vector&lt;vector&lt;char&gt;&gt;&amp; board, vector&lt;string&gt;&amp; words) &#123;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        m = static_cast&lt;int&gt;(board.size());</span><br><span class="line">        n = static_cast&lt;int&gt;(board[0].size());</span><br><span class="line"></span><br><span class="line">        //在这里是先对所有的提供的单词建立前缀树</span><br><span class="line">        for (auto &amp;word : words) &#123;</span><br><span class="line">            insert(word);</span><br><span class="line">        &#125;</span><br><span class="line">        //然后根据前缀树搜索，妙啊</span><br><span class="line">        for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">                dfs(ans, board, i, j, &amp;root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222_完全二叉树的节点个数"></a>222_完全二叉树的节点个数</h2><ul>
<li>什么叫做完全二叉树？</li>
<li>一棵深度为<code>k</code>的有<code>n</code>个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为<code>i（1≤i≤n）</code>的结点与满二叉树中编号为<code>i</code>的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。</li>
<li>完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2^h 个节点。</li>
<li>二分法我是没想到的</li>
</ul>
<p><img src="/pictrues/222.png" alt="二进制" title="如何二分"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//BFS</span><br><span class="line">class Solution1 &#123;</span><br><span class="line">public:</span><br><span class="line">    int countNodes(TreeNode* root) &#123;</span><br><span class="line">        if(!root)</span><br><span class="line">            return 0;</span><br><span class="line">        //所以这题是计算出层数+最后一层的节点数？</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        int ans = 1;</span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            int n = q.size();</span><br><span class="line">            while(n &gt; 0)&#123;</span><br><span class="line">                auto node = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                if(node-&gt;left != nullptr)&#123;</span><br><span class="line">                    ++ans;</span><br><span class="line">                    q.push(node-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                if(node-&gt;right != nullptr)&#123;</span><br><span class="line">                    ++ans;</span><br><span class="line">                    q.push(node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">                --n;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//DFS</span><br><span class="line">class Solution2 &#123;</span><br><span class="line">public:</span><br><span class="line">   void dfs(int &amp;depth, int &amp;last, int tmp, TreeNode* root)&#123;</span><br><span class="line">       if(!root)</span><br><span class="line">           return;</span><br><span class="line">       depth = max(depth, tmp);</span><br><span class="line">       if(!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; depth == tmp)&#123;</span><br><span class="line">           //说明这是最后一个节点，而且深度必须是最后一层</span><br><span class="line">           ++last;</span><br><span class="line">       &#125;</span><br><span class="line">       dfs(depth, last, tmp + 1, root-&gt;left);</span><br><span class="line">       dfs(depth, last, tmp + 1, root-&gt;right);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   int countNodes(TreeNode* root) &#123;</span><br><span class="line">       if(!root)</span><br><span class="line">           return 0;</span><br><span class="line">       int depth = 0, last = 0;</span><br><span class="line">       dfs(depth, last, 0, root);</span><br><span class="line">       //cout &lt;&lt; &quot;depth = &quot; &lt;&lt; depth &lt;&lt; &quot; last = &quot; &lt;&lt; last &lt;&lt; endl;</span><br><span class="line">       return static_cast&lt;int&gt;(pow(2, depth) - 1 + last);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int countNodes(TreeNode* root) &#123;</span><br><span class="line">        if (root == nullptr) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int level = 0;</span><br><span class="line">        TreeNode* node = root;</span><br><span class="line">        while (node-&gt;left != nullptr) &#123;</span><br><span class="line">            //这里深度只需一直判断左节点是什么为空即可</span><br><span class="line">            level++;</span><br><span class="line">            node = node-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        int low = 1 &lt;&lt; level, high = (1 &lt;&lt; (level + 1)) - 1;</span><br><span class="line">        while (low &lt; high) &#123;</span><br><span class="line">            int mid = (high - low + 1) / 2 + low;</span><br><span class="line">            if (exists(root, level, mid)) &#123;</span><br><span class="line">                low = mid;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                high = mid - 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return low;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool exists(TreeNode* root, int level, int k) &#123;</span><br><span class="line">        int bits = 1 &lt;&lt; (level - 1);</span><br><span class="line">        TreeNode* node = root;</span><br><span class="line">        while (node != nullptr &amp;&amp; bits &gt; 0) &#123;</span><br><span class="line">            if (!(bits &amp; k)) &#123;</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                node = node-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            bits &gt;&gt;= 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return node != nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226_翻转二叉树"></a>226_翻转二叉树</h2><ul>
<li>师兄说了，这个题目别用递归，让我再想想；那就…再想想</li>
<li>递归、BFS、DFS（迭代），完了迭代有点不会写了…要把之前的前序、中序、后序遍历都得好好复习</li>
<li>不太对，栈模拟跟队列极为相似</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//dfs和递归有点区别，这个方法应该是递归</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* invertTree(TreeNode* root) &#123;</span><br><span class="line">        if(!root)</span><br><span class="line">            return nullptr;</span><br><span class="line"></span><br><span class="line">        auto tmp = root-&gt;left;</span><br><span class="line">        root-&gt;left = root-&gt;right;</span><br><span class="line">        root-&gt;right = tmp;</span><br><span class="line">        root-&gt;left = invertTree(root-&gt;left);</span><br><span class="line">        root-&gt;right = invertTree(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//bfs</span><br><span class="line">class Solution1 &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* invertTree(TreeNode* root) &#123;</span><br><span class="line">        if(!root)</span><br><span class="line">            return nullptr;</span><br><span class="line">        //不改变指针，只改变数值？不知是否可行，不行，空指针无法改变值</span><br><span class="line">        //反转只能改变指针</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            int n = q.size();</span><br><span class="line">            while(n &gt; 0)&#123;</span><br><span class="line">                auto node = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                auto l = node-&gt;left;</span><br><span class="line">                node-&gt;left = node-&gt;right;</span><br><span class="line">                node-&gt;right = l;</span><br><span class="line">                if(l != nullptr)&#123;</span><br><span class="line">                    q.push(l);</span><br><span class="line">                &#125;</span><br><span class="line">                if(node-&gt;left != nullptr)&#123;</span><br><span class="line">                    q.push(node-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                --n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="230-二叉搜索树中第K小的元素"><a href="#230-二叉搜索树中第K小的元素" class="headerlink" title="230_二叉搜索树中第K小的元素"></a>230_二叉搜索树中第K小的元素</h2><ul>
<li>复习下前序遍历，递归+迭代、还好，前序迭代还没忘</li>
<li>不愧是大佬，可以进行剪枝进行优化</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//递归</span><br><span class="line">class Solution1 &#123;</span><br><span class="line">public:</span><br><span class="line">    void dfs(TreeNode* root)&#123;</span><br><span class="line">        if(!root)</span><br><span class="line">            return;</span><br><span class="line">        dfs(root-&gt;left);</span><br><span class="line">        ans.emplace_back(root-&gt;val);</span><br><span class="line">        dfs(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int kthSmallest(TreeNode* root, int k) &#123;</span><br><span class="line">        //进阶感觉我想不出来，还是先复习下前序遍历吧</span><br><span class="line">        dfs(root);</span><br><span class="line">        return ans[k - 1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    vector&lt;int&gt; ans;</span><br><span class="line">&#125;;</span><br><span class="line">//迭代</span><br><span class="line">class Solution2 &#123;</span><br><span class="line">public:</span><br><span class="line">    int kthSmallest(TreeNode* root, int k) &#123;</span><br><span class="line">        vector&lt;int&gt; ans;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        stk.push(root);</span><br><span class="line">        auto node = root-&gt;left;</span><br><span class="line">        while(!stk.empty() || node != nullptr)&#123;</span><br><span class="line">            while (node != nullptr)&#123;</span><br><span class="line">                stk.push(node);</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            //这里node为空</span><br><span class="line">            node = stk.top();</span><br><span class="line">            ans.emplace_back(node-&gt;val);</span><br><span class="line">            stk.pop();</span><br><span class="line">            //这里向右</span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans[k - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//递归剪枝——不用数组，直接进行计数；除了n以外，还需要tmp来记录第k个最小的元素</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void dfs(TreeNode* root, int k)&#123;</span><br><span class="line">        if(!root || n &gt; k)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root-&gt;left, k);</span><br><span class="line">        ++n;</span><br><span class="line">        if(n == k)</span><br><span class="line">            ans = root-&gt;val;</span><br><span class="line">        dfs(root-&gt;right, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int kthSmallest(TreeNode* root, int k) &#123;</span><br><span class="line">        dfs(root, k);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int n = 0;</span><br><span class="line">    int ans = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235_二叉搜索树的最近公共祖先"></a>235_二叉搜索树的最近公共祖先</h2><ul>
<li>递归！</li>
<li>因为是二叉搜索树！如果一个小于等于根节点，另一个大于等于根节点，那最近公共祖先就是根节点</li>
<li>注意的是，给的参数不一定是分左右的；要先区分下；不能直接更换节点的值</li>
<li>题解是直接遍历的，那这里就献丑了：）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        auto l = p-&gt;val &gt; q-&gt;val ? q : p;</span><br><span class="line">        auto r = p-&gt;val &gt; q-&gt;val ? p : q;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        if(root-&gt;val &gt;= l-&gt;val &amp;&amp; root-&gt;val &lt;= r-&gt;val)&#123;</span><br><span class="line">            return root;</span><br><span class="line">        &#125;else if(root-&gt;val &lt; l-&gt;val &amp;&amp; root-&gt;val &lt; r-&gt;val)&#123;</span><br><span class="line">            return lowestCommonAncestor(root-&gt;right, l, r);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return lowestCommonAncestor(root-&gt;left, l, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236_二叉树的最近公共祖先"></a>236_二叉树的最近公共祖先</h2><ul>
<li>这就不是二叉搜索树了</li>
<li>用递归可以写出来，从上倒下存储父节点，还用了三个数组…；题解的两个方法都是从下到上，一个是条件判断，一个是用了哈希</li>
</ul>
<p><img src="/pictrues/236.png" alt="回溯" title="回溯"></p>
<ul>
<li>我还是太菜了，从下到上遍历，应该是回溯</li>
<li>就是这个判断条件不容易想到，，，</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//自己手撕</span><br><span class="line">class Solution1 &#123;</span><br><span class="line">public:</span><br><span class="line">    void dfs(TreeNode* root, TreeNode* p, TreeNode* q)&#123;</span><br><span class="line">        if(!root || (!t1.empty() &amp;&amp; !t2.empty()))&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp.emplace_back(root);</span><br><span class="line">        if(root-&gt;val == p-&gt;val)&#123;</span><br><span class="line">            t1 = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        if(root-&gt;val == q-&gt;val)&#123;</span><br><span class="line">            t2 = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root-&gt;left, p, q);</span><br><span class="line">        dfs(root-&gt;right, p, q);</span><br><span class="line">        tmp.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        dfs(root, p, q);</span><br><span class="line">        //同时遍历两个数组，共同祖先都是根节点</span><br><span class="line">        int n1 = t1.size(), n2 = t2.size();</span><br><span class="line">        int n = min(n1, n2);</span><br><span class="line">        TreeNode* ans = nullptr;</span><br><span class="line">        for(int i = 0; i &lt; n; ++i)&#123;</span><br><span class="line">            if(t1[i]-&gt;val == t2[i]-&gt;val)&#123;</span><br><span class="line">                ans = t1[i];</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    vector&lt;TreeNode*&gt; t1;</span><br><span class="line">    vector&lt;TreeNode*&gt; t2;</span><br><span class="line">    vector&lt;TreeNode*&gt; tmp;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//题解1</span><br><span class="line">class Solution2 &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* ans = nullptr;</span><br><span class="line">    //这里是返回布尔值！</span><br><span class="line">    bool dfs(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        //这里出口是!root，那么会全部递归一边，可以剪个枝来优化下</span><br><span class="line">        if(!root || ans != nullptr)</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        //可以这样理解，这两条代码放在一起，就是话不多说，先递归到最左边的一个节点，这时再往下（无论左右）都是空指针，都会返回false</span><br><span class="line">        bool lson = dfs(root-&gt;left, p, q);</span><br><span class="line">        bool rson = dfs(root-&gt;right, p, q);</span><br><span class="line"></span><br><span class="line">        if ((lson &amp;&amp; rson) || ((root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val) &amp;&amp; (lson || rson))) &#123;</span><br><span class="line">            ans = root;</span><br><span class="line">        &#125;</span><br><span class="line">        return lson || rson || (root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        dfs(root, p, q);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//题解2</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    unordered_map&lt;int, TreeNode*&gt; fa;</span><br><span class="line">    unordered_map&lt;int, bool&gt; vis;</span><br><span class="line">    void dfs(TreeNode* root)&#123;</span><br><span class="line">        if (root-&gt;left != nullptr) &#123;</span><br><span class="line">            fa[root-&gt;left-&gt;val] = root;</span><br><span class="line">            dfs(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        if (root-&gt;right != nullptr) &#123;</span><br><span class="line">            fa[root-&gt;right-&gt;val] = root;</span><br><span class="line">            dfs(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        //根节点的父节点为空</span><br><span class="line">        fa[root-&gt;val] = nullptr;</span><br><span class="line">        //这个dfs是用来存储每个节点的父节点</span><br><span class="line">        dfs(root);</span><br><span class="line"></span><br><span class="line">        while (p != nullptr) &#123;</span><br><span class="line">            vis[p-&gt;val] = true;</span><br><span class="line">            //存储的好处是，可以直接访问p的父节点</span><br><span class="line">            p = fa[p-&gt;val];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (q != nullptr) &#123;</span><br><span class="line">            if (vis[q-&gt;val])</span><br><span class="line">                return q;</span><br><span class="line"></span><br><span class="line">            q = fa[q-&gt;val];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257_二叉树的所有路径"></a>257_二叉树的所有路径</h2><ul>
<li>这题采用分治递归的思路，没有用<code>void dfs(...)</code></li>
<li>有个注意点，就是<code>if else</code>，有的条件就算写了也达不到，因为必须要让上面的<code>if else</code>都不成立才行，容易漏掉情况，之后改成了三个<code>if</code></li>
<li>也可以用广度优先搜索</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//dfs</span><br><span class="line">class Solution1 &#123;</span><br><span class="line">public:</span><br><span class="line">    //这里换个递归思路，参考昨天的分治递归</span><br><span class="line">    vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123;</span><br><span class="line">        if(!root)</span><br><span class="line">            return vector&lt;string&gt;();</span><br><span class="line"></span><br><span class="line">        string s = to_string(root-&gt;val);</span><br><span class="line">        vector&lt;string&gt; l(binaryTreePaths(root-&gt;left));</span><br><span class="line">        vector&lt;string&gt; r(binaryTreePaths(root-&gt;right));</span><br><span class="line"></span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        //这里两个都必须为空才行</span><br><span class="line">        if(l.empty() &amp;&amp; r.empty())&#123;</span><br><span class="line">            ans.emplace_back(s);</span><br><span class="line">        &#125;</span><br><span class="line">        if(!l.empty())&#123;</span><br><span class="line">            for(const auto&amp; tmp : l)&#123;</span><br><span class="line">                ans.emplace_back(s + &quot;-&gt;&quot; + tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!r.empty())&#123;</span><br><span class="line">            for(const auto&amp; tmp : r)&#123;</span><br><span class="line">                ans.emplace_back(s + &quot;-&gt;&quot; + tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//bfs</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;string&gt; paths;</span><br><span class="line">        if (root == nullptr) &#123;</span><br><span class="line">            return paths;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; node_queue;</span><br><span class="line">        queue&lt;string&gt; path_queue;</span><br><span class="line"></span><br><span class="line">        node_queue.push(root);</span><br><span class="line">        path_queue.push(to_string(root-&gt;val));</span><br><span class="line"></span><br><span class="line">        while (!node_queue.empty()) &#123;</span><br><span class="line">            TreeNode* node = node_queue.front();</span><br><span class="line">            string path = path_queue.front();</span><br><span class="line">            node_queue.pop();</span><br><span class="line">            path_queue.pop();</span><br><span class="line"></span><br><span class="line">            if (node-&gt;left == nullptr &amp;&amp; node-&gt;right == nullptr) &#123;</span><br><span class="line">                paths.push_back(path);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (node-&gt;left != nullptr) &#123;</span><br><span class="line">                    node_queue.push(node-&gt;left);</span><br><span class="line">                    path_queue.push(path + &quot;-&gt;&quot; + to_string(node-&gt;left-&gt;val));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (node-&gt;right != nullptr) &#123;</span><br><span class="line">                    node_queue.push(node-&gt;right);</span><br><span class="line">                    path_queue.push(path + &quot;-&gt;&quot; + to_string(node-&gt;right-&gt;val));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return paths;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="297-二叉树的序列化与反序列化"><a href="#297-二叉树的序列化与反序列化" class="headerlink" title="297_二叉树的序列化与反序列化"></a>297_二叉树的序列化与反序列化</h2><ul>
<li><p>昨天刚做过剑指Offer37题，哈哈，今天再复习下</p>
<ul>
<li>就用字符串、链表的形式来吧</li>
<li>还可以，一次过——看看哪里再优化下</li>
<li>题解将字符串转为链表是，用了一个临时字符串<code>str</code>，每次遇到<code>&#39;,&#39;</code>，就先放入链表，再清空；最后循环结束，也要判断字符串<code>str</code>是否不为空，以免遗漏</li>
<li>跟题解消耗差不多，就不放题解了！</li>
</ul>
</li>
<li><p>做完发现，</p>
</li>
<li><p>中位数那题还没有整理好！！</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//手撕版</span><br><span class="line">class Codec &#123;</span><br><span class="line">public:</span><br><span class="line">    string serialize(TreeNode* root) &#123;</span><br><span class="line">        if(!root)&#123;</span><br><span class="line">            return &quot;n,&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        string s;</span><br><span class="line">        s += to_string(root-&gt;val);</span><br><span class="line">        s.push_back(&apos;,&apos;);</span><br><span class="line"></span><br><span class="line">        s += serialize(root-&gt;left);</span><br><span class="line">        s += serialize(root-&gt;right);</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode* deserialize(string data) &#123;</span><br><span class="line">        //先转为双向链表</span><br><span class="line">        list&lt;string&gt; l(convert(data));</span><br><span class="line">        return deserialize(l);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    list&lt;string&gt; convert(string&amp; data)&#123;</span><br><span class="line">        //字符串中的数字或者n都是以&apos;,&apos;分隔的</span><br><span class="line">        list&lt;string&gt; l;</span><br><span class="line">        //这里应该用while循环比较好</span><br><span class="line">        int i = 0;</span><br><span class="line">        while(i &lt; data.size())&#123;</span><br><span class="line">            if(data[i] == &apos;n&apos;)&#123;</span><br><span class="line">                l.emplace_back(&quot;n&quot;);</span><br><span class="line">            &#125;else if(data[i] == &apos;-&apos; || isdigit(data[i]))&#123;</span><br><span class="line">                int j = i + 1;</span><br><span class="line">                while(isdigit(data[j]))&#123;</span><br><span class="line">                    ++j;</span><br><span class="line">                &#125;</span><br><span class="line">                //循环结束j指向的应是逗号</span><br><span class="line">                l.emplace_back(data.substr(i, j - i));</span><br><span class="line">                //更新下标</span><br><span class="line">                i = j;</span><br><span class="line">            &#125;</span><br><span class="line">            //若是逗号，直接跳过</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        return l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode* deserialize(list&lt;string&gt;&amp; l)&#123;</span><br><span class="line">        //这个链表都是一个一个数字，每次都要删除开头的数字</span><br><span class="line">        if(l.empty() || *l.begin() == &quot;n&quot;)&#123;</span><br><span class="line">            if(!l.empty()) l.erase(l.begin());</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        //生成二叉树</span><br><span class="line">        TreeNode* head = new TreeNode(stoi(*l.begin()));</span><br><span class="line">        //进入下一个递归，要删除第一个，出口也是一样，用一个扔一个</span><br><span class="line">        l.erase(l.begin());</span><br><span class="line">        head-&gt;left = deserialize(l);</span><br><span class="line">        //这边回溯回来后，已经删除了</span><br><span class="line">        head-&gt;right = deserialize(l);</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="897-递增顺序搜索树"><a href="#897-递增顺序搜索树" class="headerlink" title="897_递增顺序搜索树"></a>897_递增顺序搜索树</h2><ul>
<li>这题感觉做过，正好复习下中序的递归和迭代</li>
<li>迭代的话，应该是后序比较复杂；已经忘了怎么写了，判断条件写的不对</li>
<li>题解还有一次遍历原地更改指针的方法，学习下</li>
<li>后序迭代需要一个指针来记录访问过的右节点，如果没有访问那就入栈，并更新当前节点为右节点；若是以访问过或者为空，更新记录的节点，并令当前节点为空</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution_ &#123;</span><br><span class="line">public:</span><br><span class="line">    void bst(TreeNode* root)&#123;</span><br><span class="line">        if(!root) return;</span><br><span class="line">        bst(root-&gt;left);</span><br><span class="line">        head-&gt;right = new TreeNode(root-&gt;val);</span><br><span class="line">        head = head-&gt;right;</span><br><span class="line">        bst(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode* increasingBST(TreeNode* root) &#123;</span><br><span class="line">        auto res = head;</span><br><span class="line">        bst(root);</span><br><span class="line">        return res-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    TreeNode* head = new TreeNode();// 初始化，如果不写，为什么不会调用TreeNode的构造函数呢；因为默认构造！！指针默认初始化为nullptr</span><br><span class="line">&#125;;</span><br><span class="line">//迭代</span><br><span class="line">class Solution1 &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* increasingBST(TreeNode* root) &#123;</span><br><span class="line">        TreeNode* head = new TreeNode();</span><br><span class="line">        auto carry = head;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        //判断条件还要再加上一句</span><br><span class="line">        while (!stk.empty() || root != nullptr)&#123;</span><br><span class="line">            while (root != nullptr)&#123;</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">                stk.push(root);</span><br><span class="line">            &#125;</span><br><span class="line">            //root为nullptr，这样写的话根节点弹出后，栈为空就结束了，之前是怎么写来着？</span><br><span class="line">            root = stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">            head-&gt;right = new TreeNode(root-&gt;val);</span><br><span class="line">            head = head-&gt;right;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        return carry -&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">//原地修改</span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    TreeNode *resNode;</span><br><span class="line">public:</span><br><span class="line">    void inorder(TreeNode *node) &#123;</span><br><span class="line">        if (node == nullptr) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(node-&gt;left);</span><br><span class="line"></span><br><span class="line">        // 在中序遍历的过程中修改节点指向</span><br><span class="line">        resNode-&gt;right = node;</span><br><span class="line">        node-&gt;left = nullptr;</span><br><span class="line">        resNode = node;</span><br><span class="line"></span><br><span class="line">        inorder(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode *increasingBST(TreeNode *root) &#123;</span><br><span class="line">        TreeNode *dummyNode = new TreeNode(-1);</span><br><span class="line">        resNode = dummyNode;</span><br><span class="line">        inorder(root);</span><br><span class="line">        return dummyNode-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="938-二叉搜索树的范围和"><a href="#938-二叉搜索树的范围和" class="headerlink" title="938_二叉搜索树的范围和"></a>938_二叉搜索树的范围和</h2><ul>
<li>感觉就是边遍历边判断条件</li>
<li>但还有个二叉搜索树这个条件，二叉搜索树右子树上所有节点的值均大于根节点的值；二叉搜索树左子树上所有节点的值均小于根节点的值</li>
<li>直接全部遍历会浪费一些不必要的时间，结果来看，时间只减小了一部分</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">/*class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int rangeSumBST(TreeNode* root, int low, int high) &#123;</span><br><span class="line">        if(!root) return 0;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        if(root-&gt;val &gt;= low &amp;&amp; root-&gt;val &lt;= high)&#123;</span><br><span class="line">            //cout &lt;&lt; &quot;root-&gt;val = &quot; &lt;&lt; root-&gt;val &lt;&lt; endl;</span><br><span class="line">            ans += root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += rangeSumBST(root-&gt;left, low, high);</span><br><span class="line">        ans += rangeSumBST(root-&gt;right, low, high);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">/*class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int rangeSumBST(TreeNode *root, int low, int high) &#123;</span><br><span class="line">        if (root == nullptr) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (root-&gt;val &gt; high) &#123;</span><br><span class="line">            return rangeSumBST(root-&gt;left, low, high);</span><br><span class="line">        &#125;</span><br><span class="line">        if (root-&gt;val &lt; low) &#123;</span><br><span class="line">            return rangeSumBST(root-&gt;right, low, high);</span><br><span class="line">        &#125;</span><br><span class="line">        return root-&gt;val + rangeSumBST(root-&gt;left, low, high) + rangeSumBST(root-&gt;right, low, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int rangeSumBST(TreeNode *root, int low, int high) &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        queue&lt;TreeNode*&gt; q(&#123;root&#125;);</span><br><span class="line">        while (!q.empty()) &#123;</span><br><span class="line">            auto node = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            if (node == nullptr) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if (node-&gt;val &gt; high) &#123;</span><br><span class="line">                q.push(node-&gt;left);</span><br><span class="line">            &#125; else if (node-&gt;val &lt; low) &#123;</span><br><span class="line">                q.push(node-&gt;right);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                sum += node-&gt;val;</span><br><span class="line">                q.push(node-&gt;left);</span><br><span class="line">                q.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="133-克隆图"><a href="#133-克隆图" class="headerlink" title="133_克隆图"></a>133_克隆图</h2><ul>
<li>无向连通图、深拷贝</li>
<li>深拷贝不能拷贝节点列表吗，这题有点心力憔悴，不知道哪里除了问题</li>
<li>我知道了，这题不能用<code>set</code>，因为<code>set</code>只能存储一个关键字信息，不能重复，存放的是<code>res</code>，所以在递归作比较的时候，应该比较的是原来的节点之间，而不是和<code>res</code>作比较，因为此时 <code>res</code>的邻居节点容器为空，所以肯定找不到<code>set.find(node)</code>，会一直无限循环下去</li>
<li>广度优先搜索还是离不开队列啊</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Node &#123;</span><br><span class="line">public:</span><br><span class="line">    int val;</span><br><span class="line">    vector&lt;Node*&gt; neighbors;</span><br><span class="line">    Node() &#123;</span><br><span class="line">        val = 0;</span><br><span class="line">        neighbors = vector&lt;Node*&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    Node(int _val) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        neighbors = vector&lt;Node*&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    Node(int _val, vector&lt;Node*&gt; _neighbors) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        neighbors = _neighbors;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    unordered_map&lt;Node*, Node*&gt; visited;</span><br><span class="line">    Node* cloneGraph(Node* node) &#123;</span><br><span class="line">        if (node == nullptr)</span><br><span class="line">            return node;</span><br><span class="line">        // 如果该节点已经被访问过了，则直接从哈希表中取出对应的克隆节点返回</span><br><span class="line">        if (visited.find(node) != visited.end())</span><br><span class="line">            return visited[node];</span><br><span class="line">        // 克隆节点，注意到为了深拷贝我们不会克隆它的邻居的列表</span><br><span class="line">        Node* cloneNode = new Node(node-&gt;val);</span><br><span class="line">        // 哈希表存储</span><br><span class="line">        visited[node] = cloneNode;</span><br><span class="line">        // 遍历该节点的邻居并更新克隆节点的邻居列表</span><br><span class="line">        for (auto&amp; neighbor: node-&gt;neighbors)</span><br><span class="line">            cloneNode-&gt;neighbors.emplace_back(cloneGraph(neighbor));</span><br><span class="line"></span><br><span class="line">        return cloneNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207_课程表"></a>207_课程表</h2><ul>
<li>我猜这是判断有向图是否有环</li>
<li>没有出现在图中的数字，可以不用管他，因为肯定可以学完</li>
<li>无从下手，学习下拓扑排序：对于图G中的任意一条有向边 (u, v)，u在排列中都出现在v的前面。</li>
<li>深度优先搜索，是将状态分为三个部分，而不是两个；虽然说是栈，但在实现的时候，用的都是数组</li>
<li>在广度优先搜索中，主要是找出队首的点</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//深度优先搜索</span><br><span class="line">class Solution_ &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; edges;</span><br><span class="line">    vector&lt;int&gt; visited;</span><br><span class="line">    bool valid = true;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    void dfs(int u) &#123;</span><br><span class="line">        //u是对应的课程</span><br><span class="line">        visited[u] = 1;         //标记已访问——搜索中</span><br><span class="line">        for (int v: edges[u]) &#123;</span><br><span class="line">            if (visited[v] == 0) &#123;</span><br><span class="line">                dfs(v);</span><br><span class="line">                if (!valid) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (visited[v] == 1) &#123;</span><br><span class="line">                valid = false;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[u] = 2;     //标记已访问——搜索结束</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123;</span><br><span class="line">        edges.resize(numCourses);</span><br><span class="line">        visited.resize(numCourses);</span><br><span class="line">        for (const auto&amp; info: prerequisites) &#123;</span><br><span class="line">            //这里对应的索引对应课程</span><br><span class="line">            edges[info[1]].push_back(info[0]);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; numCourses &amp;&amp; valid; ++i) &#123;</span><br><span class="line">            if (!visited[i]) &#123;</span><br><span class="line">                dfs(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return valid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//广度优先搜索</span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; edges;</span><br><span class="line">    vector&lt;int&gt; indeg;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123;</span><br><span class="line">        edges.resize(numCourses);</span><br><span class="line">        indeg.resize(numCourses);</span><br><span class="line">        for (const auto&amp; info: prerequisites) &#123;</span><br><span class="line">            edges[info[1]].push_back(info[0]);</span><br><span class="line">            //这里是对应的个数，而不是对应的课程号</span><br><span class="line">            ++indeg[info[0]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue&lt;int&gt; q;</span><br><span class="line">        for (int i = 0; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            //先放入没有边的节点，不太对，这里是图的起点</span><br><span class="line">            if (indeg[i] == 0) &#123;</span><br><span class="line">                q.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int visited = 0;</span><br><span class="line">        while (!q.empty()) &#123;</span><br><span class="line">            ++visited;</span><br><span class="line">            int u = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            for (int v: edges[u]) &#123;</span><br><span class="line">                --indeg[v];</span><br><span class="line">                if (indeg[v] == 0) &#123;</span><br><span class="line">                    q.push(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return visited == numCourses;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; prerequisites(</span><br><span class="line">            &#123;</span><br><span class="line">                    &#123;1,4&#125;,</span><br><span class="line">                    &#123;2,4&#125;,</span><br><span class="line">                    &#123;3,1&#125;,</span><br><span class="line">                    &#123;3,2&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            );</span><br><span class="line">    int numCourses = 5;</span><br><span class="line">    Solution solution;</span><br><span class="line">    auto ans = solution.canFinish(numCourses, prerequisites);</span><br><span class="line">    cout &lt;&lt; &quot;ans = &quot; &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="210-课程表-II"><a href="#210-课程表-II" class="headerlink" title="210_课程表_II"></a>210_课程表_II</h2><ul>
<li>完了，课程表I已经忘了怎么写了…</li>
<li>应该先找出图的根节点，然后反向广度搜索输出答案，当然图的根节点可能有多个</li>
<li>给<code>vector</code>设置大小时，可以直接用<code>resize()</code>，参数是一个数</li>
<li>淦！把拓扑排序给忘了…</li>
<li>之前那题是无需数据结构记录，如果要用数据结构记录我觉得得用队列，方便在头部添加元素</li>
<li>题解用的栈…存储所有已访问的节点；对图进行一遍深度优先搜索。当每个节点进行回溯的时候，我们把该节点放入栈中。最终从栈顶到栈底的序列就是一种拓扑排序。学到了，回溯的时候放入栈中；虽说是用栈，但还是用的<code>vector</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;iterator&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//dfs</span><br><span class="line">class Solution_ &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; edges;</span><br><span class="line">    vector&lt;int&gt; visited;</span><br><span class="line">    vector&lt;int&gt; ans;</span><br><span class="line">    bool valid = true;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    void dfs(int u)&#123;</span><br><span class="line">        visited[u] = 1;</span><br><span class="line">        for(auto v : edges[u])&#123;</span><br><span class="line">            if(visited[v] == 0)&#123;</span><br><span class="line">                dfs(v);</span><br><span class="line">                if(!valid)</span><br><span class="line">                    return;</span><br><span class="line">            &#125; else if(visited[v] == 1)&#123;</span><br><span class="line">                valid = false;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[u] = 2;</span><br><span class="line">        ans.push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; findOrder(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123;</span><br><span class="line">        //应该先判断是否有环，在判断的过程中，找出根节点，之后用bfs，最后还要考虑单独的课程</span><br><span class="line">        //之前的dfs无法判断出哪个是根节点，得用bfs</span><br><span class="line">        //回溯的时候，如果没有相邻节点，那么就是根节点，最后再反转一下即可</span><br><span class="line">        edges.resize(numCourses);</span><br><span class="line">        for(const auto &amp;p : prerequisites)&#123;</span><br><span class="line">            edges[p[1]].push_back(p[0]);</span><br><span class="line">        &#125;</span><br><span class="line">        visited.resize(numCourses);</span><br><span class="line">        for(int i = 0; i &lt; numCourses; ++i)&#123;</span><br><span class="line">            if(visited[i] == 0)&#123;</span><br><span class="line">                dfs(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!valid)&#123;</span><br><span class="line">            return vector&lt;int&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(ans.begin(), ans.end());</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//bfs</span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    // 存储有向图</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; edges;</span><br><span class="line">    // 存储每个节点的入度</span><br><span class="line">    vector&lt;int&gt; indeg;</span><br><span class="line">    // 存储答案</span><br><span class="line">    vector&lt;int&gt; result;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; findOrder(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123;</span><br><span class="line">        edges.resize(numCourses);</span><br><span class="line">        indeg.resize(numCourses);</span><br><span class="line">        for (const auto&amp; info: prerequisites) &#123;</span><br><span class="line">            edges[info[1]].push_back(info[0]);</span><br><span class="line">            //对应课程有几个依赖</span><br><span class="line">            ++indeg[info[0]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue&lt;int&gt; q;</span><br><span class="line">        // 将所有入度为 0 的节点放入队列中</span><br><span class="line">        for (int i = 0; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            if (indeg[i] == 0) &#123;</span><br><span class="line">                q.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (!q.empty()) &#123;</span><br><span class="line">            // 从队首取出一个节点</span><br><span class="line">            int u = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            // 放入答案中</span><br><span class="line">            result.push_back(u);</span><br><span class="line">            for (int v: edges[u]) &#123;</span><br><span class="line">                --indeg[v];</span><br><span class="line">                // 如果相邻节点 v 的入度为 0，就可以选 v 对应的课程了</span><br><span class="line">                if (indeg[v] == 0) &#123;</span><br><span class="line">                    q.push(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (result.size() != numCourses) &#123;</span><br><span class="line">            return &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; prerequisites(&#123;&#123;1,0&#125;,&#123;2,0&#125;,&#123;3,1&#125;,&#123;3,2&#125;&#125;);</span><br><span class="line">    int numCourses = 4;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;int&gt; ans = solution.findOrder(numCourses, prerequisites);</span><br><span class="line">    copy(ans.begin(), ans.end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot;));</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h1><h2 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155_最小栈"></a>155_最小栈</h2><ul>
<li>寻找最小数要常数时间，难道又要建立一个双向链表吗，最小的放在最前面？试试</li>
<li>雾草，每个元素 a 与其相应的最小值 m 时刻保持一一对应。绝了…</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class MinStack &#123;</span><br><span class="line">    stack&lt;int&gt; x_stack;</span><br><span class="line">    stack&lt;int&gt; min_stack;</span><br><span class="line">public:</span><br><span class="line">    MinStack() &#123;</span><br><span class="line">        min_stack.push(INT_MAX);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void push(int x) &#123;</span><br><span class="line">        x_stack.push(x);</span><br><span class="line">        min_stack.push(min(min_stack.top(), x));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void pop() &#123;</span><br><span class="line">        x_stack.pop();</span><br><span class="line">        min_stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int top() &#123;</span><br><span class="line">        return x_stack.top();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int getMin() &#123;</span><br><span class="line">        return min_stack.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225_用队列实现栈"></a>225_用队列实现栈</h2><ul>
<li>虽然写出来了，但是感觉比较笨，就是不停地将一个队列放到另一个队列里，来回放；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class MyStack &#123;</span><br><span class="line">public:</span><br><span class="line">    /** Initialize your data structure here. */</span><br><span class="line">    MyStack() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** Push element x onto stack. */</span><br><span class="line">    void push(int x) &#123;</span><br><span class="line">        if(q1.empty())&#123;</span><br><span class="line">            q2.push(x);</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">            q1.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** Removes the element on top of the stack and returns that element. */</span><br><span class="line">    int pop() &#123;</span><br><span class="line">        //原来pop是有返回值的啊</span><br><span class="line">        int tmp = 0;</span><br><span class="line">        if(q1.empty())&#123;</span><br><span class="line">            while (!q2.empty())&#123;</span><br><span class="line">                if(q2.size() != 1)&#123;</span><br><span class="line">                    q1.push(q2.front());</span><br><span class="line">                &#125; else&#123;</span><br><span class="line">                    tmp = q2.front();</span><br><span class="line">                &#125;</span><br><span class="line">                q2.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">            while (!q1.empty())&#123;</span><br><span class="line">                if(q1.size() != 1)&#123;</span><br><span class="line">                    q2.push(q1.front());</span><br><span class="line">                &#125; else&#123;</span><br><span class="line">                    tmp = q1.front();</span><br><span class="line">                &#125;</span><br><span class="line">                q1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** Get the top element. */</span><br><span class="line">    int top() &#123;</span><br><span class="line">        if(q1.empty())&#123;</span><br><span class="line">            return q2.back();</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">            return q1.back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** Returns whether the stack is empty. */</span><br><span class="line">    bool empty() &#123;</span><br><span class="line">        return q1.empty() &amp;&amp; q2.empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    queue&lt;int&gt; q1;</span><br><span class="line">    queue&lt;int&gt; q2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your MyStack object will be instantiated and called as such:</span><br><span class="line"> * MyStack* obj = new MyStack();</span><br><span class="line"> * obj-&gt;push(x);</span><br><span class="line"> * int param_2 = obj-&gt;pop();</span><br><span class="line"> * int param_3 = obj-&gt;top();</span><br><span class="line"> * bool param_4 = obj-&gt;empty();</span><br><span class="line"> */</span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232_用栈实现队列"></a>232_用栈实现队列</h2><ul>
<li>有好多细节需要注意，比如另一个栈是用来缓冲的，那就要考虑到（在恢复时数据时）是否为空</li>
<li>还有判断是否是队列的第一个数字时，直接判断主栈是否为空！！</li>
<li>题解有个优点——不用每次都倒来倒去！！</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class MyQueue &#123;</span><br><span class="line">private:</span><br><span class="line">    stack&lt;int&gt; inStack, outStack;</span><br><span class="line"></span><br><span class="line">    void in2out() &#123;</span><br><span class="line">        while (!inStack.empty()) &#123;</span><br><span class="line">            outStack.push(inStack.top());</span><br><span class="line">            inStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    MyQueue() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    void push(int x) &#123;</span><br><span class="line">        inStack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int pop() &#123;</span><br><span class="line">        if (outStack.empty()) &#123;</span><br><span class="line">            in2out();</span><br><span class="line">        &#125;</span><br><span class="line">        int x = outStack.top();</span><br><span class="line">        outStack.pop();</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int peek() &#123;</span><br><span class="line">        if (outStack.empty()) &#123;</span><br><span class="line">            in2out();</span><br><span class="line">        &#125;</span><br><span class="line">        return outStack.top();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool empty() &#123;</span><br><span class="line">        return inStack.empty() &amp;&amp; outStack.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><ul>
<li>是先跳过SQL题目；还是学习下？</li>
<li>本地运行需要环境，直接在网页运行吧</li>
</ul>
<h2 id="175-组合两个表"><a href="#175-组合两个表" class="headerlink" title="175_组合两个表"></a>175_组合两个表</h2><ul>
<li></li>
</ul>
<h2 id="176-第二高的薪水"><a href="#176-第二高的薪水" class="headerlink" title="176_第二高的薪水"></a>176_第二高的薪水</h2><ul>
<li></li>
</ul>
<hr>
<h1 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h1><ul>
<li>bash脚本</li>
</ul>
<h2 id="192-统计词频"><a href="#192-统计词频" class="headerlink" title="192_统计词频"></a>192_统计词频</h2><ul>
<li></li>
</ul>
<hr>
<h1 id="整数边界"><a href="#整数边界" class="headerlink" title="整数边界"></a>整数边界</h1><ul>
<li>注意<font color="#FF0000">int</font>是否溢出，<code>INT32_MAX</code>、<code>INT32_MIN</code></li>
<li><code>if(add &lt; INT32_MAX / 10 || (add == INT32_MAX / 10 &amp;&amp; (int)(l[i] - &#39;0&#39;) &lt; 8))</code></li>
<li><code>if(add &gt; INT32_MIN / 10 || (add == INT32_MIN / 10 &amp;&amp; (int)(l[i] - &#39;0&#39;) &lt; 9))</code></li>
<li>回文数要考虑是否溢出</li>
</ul>
<h2 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="7_整数反转"></a>7_整数反转</h2><ul>
<li>给出一个32位的有符号整数，<code>123</code></li>
<li>输出<code>321</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int reverse(int x) &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        int s = x;</span><br><span class="line">        x = abs(x);</span><br><span class="line">        while (x &gt; 0) &#123;</span><br><span class="line">            if(sum &gt; INT32_MAX / 10 || (sum == INT32_MAX / 10 &amp;&amp; x &gt; 7))&#123;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">            sum = sum * 10 + x % 10;    // sum乘以10之前，先判断是否会溢出</span><br><span class="line">            x /= 10;</span><br><span class="line">        &#125;</span><br><span class="line">        if(s &gt;= 0)&#123;</span><br><span class="line">            return sum;</span><br><span class="line">        &#125; else return sum * (-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int x = 153;</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.reverse(x) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9_回文数"></a>9_回文数</h2><ul>
<li>输入121，输出true</li>
<li>输入-121，输出false</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isPalindrome(int x) &#123;</span><br><span class="line">        if(x &lt; 0)&#123;return false;&#125;</span><br><span class="line">        int y = 0, z = x;</span><br><span class="line">        while (z &gt; 0)&#123;</span><br><span class="line">	// 判断是否溢出</span><br><span class="line">            if(y &gt; INT32_MAX / 10 || (y == INT32_MAX / 10 &amp;&amp; z % 10 &gt; 7))&#123;return false;&#125;</span><br><span class="line">            y = y * 10 + z % 10;</span><br><span class="line">            z = z / 10;</span><br><span class="line">        &#125;</span><br><span class="line">        if(x != y)&#123;return false;&#125; else return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int x = 998765432;</span><br><span class="line">    Solution solution;</span><br><span class="line">    std::cout &lt;&lt; solution.isPalindrome(x) &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="29-两数相除"><a href="#29-两数相除" class="headerlink" title="29_两数相除"></a>29_两数相除</h2><ul>
<li>核心思路是不停的相减，直到减不动为止，但不是一个一个减，而是<font color="#FF0000">成倍</font>地减<code>divisor</code></li>
<li><code>ans = divisor</code>、<code>ans += ans</code></li>
<li>考虑整数<font color="#FF0000">溢出</font>，并且正数边界比较麻烦，改用负数来算</li>
<li>在<code>while</code>循环中，要考虑<code>ans+ans</code>不能小于<code>INT32_MIN</code>、<code>res</code>我这里用的是正数，<code>res+res</code>不能小大于<code>INT32_MAX</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int divide(int dividend, int divisor) &#123;</span><br><span class="line">        // 正数边界问题比较麻烦，改用负数计算</span><br><span class="line">        if(dividend == 0)&#123;return 0;&#125;</span><br><span class="line">        if(dividend == INT32_MIN &amp;&amp; divisor == -1)&#123;return INT32_MAX;&#125;</span><br><span class="line">        int sign = ((dividend &gt; 0 &amp;&amp; divisor &gt; 0) || dividend &lt; 0 &amp;&amp; divisor &lt; 0) ? 1 : -1;</span><br><span class="line">        dividend = dividend &gt; 0 ? -dividend : dividend;</span><br><span class="line">        divisor = divisor &gt; 0 ? -divisor : divisor;</span><br><span class="line">        if(dividend &gt; divisor)&#123;return 0;&#125;   // 递归出口</span><br><span class="line">        int ans = divisor, res = 1;</span><br><span class="line">        while (ans &gt;= (INT32_MIN &gt;&gt; 1) &amp;&amp; dividend &lt;= ans + ans)&#123;  // 直接翻倍判断</span><br><span class="line">            ans += ans;</span><br><span class="line">            if(res &gt; (INT32_MAX &gt;&gt; 1))&#123;return INT32_MIN;&#125;</span><br><span class="line">            res += res;</span><br><span class="line">        &#125;</span><br><span class="line">        res += divide(dividend - ans, divisor);</span><br><span class="line">        return sign &gt; 0 ? res : -res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int dividend = 10, divisor = 3;</span><br><span class="line">    Solution solution;</span><br><span class="line">    std::cout &lt;&lt; solution.divide(dividend, divisor) &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="50-Pow-x-n"><a href="#50-Pow-x-n" class="headerlink" title="50_Pow(x,n)"></a>50_Pow(x,n)</h2><ul>
<li>递归，跟加法题差不多，不是每次都乘x，而是将上一次的结果直接平方，要考虑<code>n</code>的奇偶性，这题我没有做出来</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    double quickMul(double x, long long N) &#123;</span><br><span class="line">        if (N == 0) &#123;</span><br><span class="line">            return 1.0;</span><br><span class="line">        &#125;</span><br><span class="line">        double y = quickMul(x, N / 2);</span><br><span class="line">        return N % 2 == 0 ? y * y : y * y * x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    double myPow(double x, int n) &#123;</span><br><span class="line">        long long N = n;</span><br><span class="line">        return N &gt;= 0 ? quickMul(x, N) : 1.0 / quickMul(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    double x = 99;</span><br><span class="line">    int n = 5;</span><br><span class="line">    Solution solution;</span><br><span class="line">    double res = solution.myPow(x, n);</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; &quot; &quot; &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62_不同路径"></a>62_不同路径</h2><ul>
<li>这是比较典型的一道排列组合题目，可直接计算出结果(m+n-2)!/(m-1)!(n-1)!，但是计算过程会超出整数<code>int</code>边界，得优化下，边化简边计算</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int uniquePaths(int m, int n) &#123;</span><br><span class="line">        long long den = 1, mol = 1;</span><br><span class="line">        int ma = max(m, n), mi = min(m, n);</span><br><span class="line">        while (mi - 1 &gt; 0)&#123;</span><br><span class="line">            den *= ma + mi - 2;   //分母</span><br><span class="line">            mol *= mi - 1;   //分子</span><br><span class="line">            mi--;</span><br><span class="line">        &#125;</span><br><span class="line">        return den / mol;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.uniquePaths(10, 10) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="69-x的平方根"><a href="#69-x的平方根" class="headerlink" title="69_x的平方根"></a>69_x的平方根</h2><ul>
<li>一开始是想从1开始遍历，每次都将上一个值翻倍，然后判断其平方是否小于x</li>
<li>还是二分法好用，超出整数边界用<code>long long</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int mySqrt(int x) &#123;</span><br><span class="line">        int l = 0, r = x, ans;</span><br><span class="line">        while (l &lt;= r)&#123;</span><br><span class="line">            long long mid = (l + r) / 2;</span><br><span class="line">            if(mid * mid &gt; x)&#123;</span><br><span class="line">                r = mid - 1;</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                l = mid + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.mySqrt(2147395600);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70_爬楼梯"></a>70_爬楼梯</h2><ul>
<li>思路很简单，先算2的个数和1的个数有几种情况，然后每种情况都要排列组合，最后一起加起来</li>
<li>用到62_不同路径的阶乘函数，还是要注意整数边界问题</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int uniquePaths(int m, int n) &#123;</span><br><span class="line">        if(m == 0 || n == 0)&#123;return 1;&#125;</span><br><span class="line">        unsigned long long den = 1, mol = 1;</span><br><span class="line">        int ma = max(m, n), mi = min(m, n);</span><br><span class="line">        while (mi &gt; 0)&#123;</span><br><span class="line">            den *= ma + mi;   //分母</span><br><span class="line">            mol *= mi;   //分子</span><br><span class="line">            while (den % 2 == 0 &amp;&amp; mol % 2 == 0)&#123;</span><br><span class="line">                den /= 2;</span><br><span class="line">                mol /= 2;</span><br><span class="line">            &#125;</span><br><span class="line">            while (den % 3 == 0 &amp;&amp; mol % 3 == 0)&#123;</span><br><span class="line">                den /= 3;</span><br><span class="line">                mol /= 3;</span><br><span class="line">            &#125;</span><br><span class="line">            while (den % 5 == 0 &amp;&amp; mol % 5 == 0)&#123;</span><br><span class="line">                den /= 5;</span><br><span class="line">                mol /= 5;</span><br><span class="line">            &#125;</span><br><span class="line">            while (den % 7 == 0 &amp;&amp; mol % 7 == 0)&#123;</span><br><span class="line">                den /= 7;</span><br><span class="line">                mol /= 7;</span><br><span class="line">            &#125;</span><br><span class="line">            mi--;</span><br><span class="line">        &#125;</span><br><span class="line">        return den / mol;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int climbStairs(int n) &#123;</span><br><span class="line">        if(n &lt; 2)&#123;return n;&#125;</span><br><span class="line">        int res = 0, two_n = n / 2, one_n = n % 2 == 0 ? 0 : 1;</span><br><span class="line">        for(int i = 0; i &lt;= two_n; i++)&#123;</span><br><span class="line">            if(i &gt; 0)&#123;one_n += 2;&#125;</span><br><span class="line">            res += uniquePaths(two_n - i, one_n);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.climbStairs(45) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="172-阶乘后的零"><a href="#172-阶乘后的零" class="headerlink" title="172_阶乘后的零"></a>172_阶乘后的零</h2><ul>
<li>不用想了，肯定会超出整数边界、但也不一定要计算出结果</li>
<li>完美！不用计算最终结果，而是直接考虑5的倍数还有10的倍数</li>
<li>小丑竟是我自己，只要考虑5即可</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int trailingZeroes(int n) &#123;</span><br><span class="line">        //如果同时有2和5、或者他俩最小公倍数的倍数</span><br><span class="line">        //也相当于一串连续数组，有多少个10的倍数</span><br><span class="line">//        if(n &lt; 5) return 0;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        for(int i = 5; i &lt; n + 1; i += 5)&#123;</span><br><span class="line">            int tmp = i;</span><br><span class="line">            /*if(tmp % 10 == 0)&#123;</span><br><span class="line">                while (tmp % 10 == 0)&#123;</span><br><span class="line">                    ++ans;</span><br><span class="line">                    tmp /= 10;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;*/</span><br><span class="line">            if(tmp % 5 == 0)&#123;</span><br><span class="line">                //这里不用考虑2的个数，因为偶数肯定一大把</span><br><span class="line">                while (tmp % 5 == 0)&#123;</span><br><span class="line">                    ++ans;</span><br><span class="line">                    tmp /= 5;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="204-计数质数"><a href="#204-计数质数" class="headerlink" title="204_计数质数"></a>204_计数质数</h2><ul>
<li>这题好像和整数边界没什么关系，得了解如何判定一个质数</li>
<li>不对，有关系</li>
<li>质数首先个位数只能是奇数，之后要排除3、5、7、…的倍数，不对，还有11、13…</li>
<li>所以题解第一种方法就是枚举法，先枚举所有范围里的数，再判断是否为质数；判断质数的时候，也要从2开始判断能否整除….这里可以优化下，x能整除、那么y/x也能整除，两者取小</li>
<li>厄拉多塞筛法，简称埃氏筛：如果x是质数，那么大于x的x的倍数2x,3x,… 一定不是质数，</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution_ &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isPrime(int x) &#123;</span><br><span class="line">        for (int i = 2; i * i &lt;= x; ++i) &#123;</span><br><span class="line">            if (x % i == 0) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int countPrimes(int n) &#123;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        for (int i = 2; i &lt; n; ++i) &#123;</span><br><span class="line">            ans += isPrime(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int countPrimes(int n) &#123;</span><br><span class="line">        //动态规划，无需另外函数来判断是否为质数</span><br><span class="line">        vector&lt;int&gt; isPrime(n, 1);</span><br><span class="line">        int ans = 0;</span><br><span class="line">        for (int i = 2; i &lt; n; ++i) &#123;</span><br><span class="line">            if (isPrime[i]) &#123;</span><br><span class="line">                ans += 1;</span><br><span class="line">                if ((long long)i * i &lt; n) &#123;</span><br><span class="line">                    for (int j = i * i; j &lt; n; j += i) &#123;</span><br><span class="line">                        isPrime[j] = 0;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n = 5000000; //ans = 348513</span><br><span class="line">    Solution solution;</span><br><span class="line">    int ans = solution.countPrimes(n);</span><br><span class="line">    cout &lt;&lt; &quot;ans = &quot; &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="233-数字-1-的个数"><a href="#233-数字-1-的个数" class="headerlink" title="233_数字 1 的个数"></a>233_数字 1 的个数</h2><ul>
<li>这题真的是…绞尽脑汁；要考虑的情况太多</li>
<li>这题没有超出整数边界，放在位运算也不太好，还是放在整数边界吧；毕竟不停的除以十</li>
<li>看了题解发现，，，我是谁，我在哪儿，，，我在做什么</li>
</ul>
<p><img src="/pictrues/233.png" alt="1的个数" title="1的个数"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution1 &#123;</span><br><span class="line">public:</span><br><span class="line">    int countDigitOne(int n) &#123;</span><br><span class="line">        //要考虑很多种情况，比较繁琐</span><br><span class="line">        if(n &lt; 1)</span><br><span class="line">            return 0;</span><br><span class="line"></span><br><span class="line">        /*这几行还是注释掉，不然显得我的代码不够鲁棒:)</span><br><span class="line">        if(n &gt; 0 &amp;&amp; n &lt; 10)</span><br><span class="line">            return 1;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">        //有点思路了；从低到高或者从高到低，计算出每一位是1的个数，比如个位数是1的情况有几种，十位数等等；</span><br><span class="line">        //最终算出来的，有重复的就是最终答案；有一点需要注意，就是xx1yy，yy的范围可能是00-99；也可能是00-zz</span><br><span class="line">        int ans = 0;</span><br><span class="line">        int i = 0, later = 0;</span><br><span class="line"></span><br><span class="line">        while (n &gt; 0)&#123;</span><br><span class="line">            //从个位数开始</span><br><span class="line">            int tmp = n % 10, former = n / 10;</span><br><span class="line"></span><br><span class="line">            if(tmp == 0)&#123;</span><br><span class="line">                //说明former得减一；不然令这位为1，会大于原来的数字；这里former肯定不为0； 而且，后面有几位就是10的几次方</span><br><span class="line">                ans += (former * static_cast&lt;int&gt;(pow(10, i)));</span><br><span class="line"></span><br><span class="line">            &#125; else if(tmp == 1)&#123;</span><br><span class="line"></span><br><span class="line">                //加later之前，得看后面是否没有数字  latter在former减1前，是不能大于原来的数的，还要考虑0</span><br><span class="line">                if(former == 0) &#123;</span><br><span class="line">                    //前不着村，后不着店</span><br><span class="line">                    ans += (i == 0 ? 1 : later + 1);</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    //前面的不受约束；0——former-1都可；但是，这里有问题；(i == 0 ? 0 : later + 1)</span><br><span class="line"></span><br><span class="line">                    ans += (former * static_cast&lt;int&gt;(pow(10, i)) + (i == 0 ? 1 : later + 1));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                ans += ((former + 1) * static_cast&lt;int&gt;(pow(10, i)));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            n = former;</span><br><span class="line">            later += tmp * static_cast&lt;int&gt;(pow(10, i));</span><br><span class="line">            ++i;</span><br><span class="line">            cout &lt;&lt; &quot;ans = &quot; &lt;&lt; ans &lt;&lt; &quot; n = &quot; &lt;&lt; n &lt;&lt; &quot; later = &quot; &lt;&lt; later &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//题解</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int countDigitOne(int n)</span><br><span class="line">    &#123;</span><br><span class="line">        int countr = 0;</span><br><span class="line">        for (long long i = 1; i &lt;= n; i *= 10) &#123;</span><br><span class="line">            long long divider = i * 10;</span><br><span class="line">            countr += (n / divider) * i + min(max(n % divider - i + 1, 0LL), i);</span><br><span class="line">        &#125;</span><br><span class="line">        return countr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n = 11;    //234——154个1</span><br><span class="line">    Solution solution;</span><br><span class="line">    int ans = solution.countDigitOne(n);</span><br><span class="line">    cout &lt;&lt; &quot;ans = &quot; &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="263-丑数"><a href="#263-丑数" class="headerlink" title="263_丑数"></a>263_丑数</h2><ul>
<li>要不要另辟一个归类？数学…这题，我不知道该放哪儿了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isUgly(int n) &#123;</span><br><span class="line">        //不停地取余？最后查看余数是否为1</span><br><span class="line">        //先都转成负数——雾草，丑数是正整数！！！</span><br><span class="line">        if(n &lt; 1)</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        while(n % 5 == 0)&#123;</span><br><span class="line">            n /= 5;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while(n % 3 == 0)&#123;</span><br><span class="line">            n /= 3;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while(n % 2 == 0)&#123;</span><br><span class="line">            n /= 2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return n == 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="264-丑数-II"><a href="#264-丑数-II" class="headerlink" title="264_丑数_II"></a>264_丑数_II</h2><ul>
<li>每次都判断是否为丑数，这么做超时了！…</li>
<li>学习下最小堆、动态规划！——最小堆是优先级队列嘛、那是不是也叫做最小根？<ul>
<li>原来最小堆还能这么用！！学到了，每次只弹出一个，那么最后弹出的就是答案！</li>
<li>动态规划的状态转移方程，情理之中、意料之外——<code>dp[i]=min(dp[p2]×2,dp[p3]×3,dp[p5]×5)</code></li>
</ul>
</li>
<li>这里动规，截下大佬的解释</li>
</ul>
<p><img src="/pictrues/264.png" alt title="动态规划"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;unordered_set&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//最小堆</span><br><span class="line">class Solution1 &#123;</span><br><span class="line">public:</span><br><span class="line">    int nthUglyNumber(int n) &#123;</span><br><span class="line">        vector&lt;int&gt; factors = &#123;2, 3, 5&#125;;</span><br><span class="line">        unordered_set&lt;long&gt; seen;</span><br><span class="line"></span><br><span class="line">        //最小堆是从小到大</span><br><span class="line">        priority_queue&lt;long, vector&lt;long&gt;, greater&lt;&gt;&gt; heap;</span><br><span class="line">        seen.insert(1L);</span><br><span class="line">        heap.push(1L);</span><br><span class="line">        int ugly = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            long curr = heap.top();</span><br><span class="line"></span><br><span class="line">            heap.pop();</span><br><span class="line">            ugly = (int)curr;</span><br><span class="line">            //因为要让最小堆的最前面是答案，所以不管放了多少个，我每次都只弹出一个！</span><br><span class="line">            //这里哈希是防止重复放进元素！！</span><br><span class="line">            for (int factor : factors) &#123;</span><br><span class="line">                long next = curr * factor;</span><br><span class="line">                if (!seen.count(next)) &#123;</span><br><span class="line">                    seen.insert(next);</span><br><span class="line">                    heap.push(next);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ugly;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//动态规划</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int nthUglyNumber(int n) &#123;</span><br><span class="line">        vector&lt;int&gt; dp(n + 1);</span><br><span class="line">        dp[1] = 1;</span><br><span class="line">        int p2 = 1, p3 = 1, p5 = 1;</span><br><span class="line">        for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">            int num2 = dp[p2] * 2, num3 = dp[p3] * 3, num5 = dp[p5] * 5;</span><br><span class="line">            dp[i] = min(min(num2, num3), num5);</span><br><span class="line">            if (dp[i] == num2) &#123;</span><br><span class="line">                p2++;</span><br><span class="line">            &#125;</span><br><span class="line">            if (dp[i] == num3) &#123;</span><br><span class="line">                p3++;</span><br><span class="line">            &#125;</span><br><span class="line">            if (dp[i] == num5) &#123;</span><br><span class="line">                p5++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="633-平方数之和"><a href="#633-平方数之和" class="headerlink" title="633_平方数之和"></a>633_平方数之和</h2><ul>
<li>超出整数边界报错…</li>
<li>这题用了双指针，，看看题解，一样，还有种数学方法</li>
<li>费马平方和定理：一个非负整数c如果能够表示为两个整数的平方和，当且仅当c的所有形如4k+3的质因子的幂均为偶数。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool judgeSquareSum(int c) &#123;</span><br><span class="line">        auto r = static_cast&lt;long long&gt;(sqrt(c));</span><br><span class="line">        long long l = 0;</span><br><span class="line">        while (l &lt;= r)&#123;</span><br><span class="line">            if(r * r + l * l &lt;= INT32_MAX &amp;&amp; r * r + l * l == c)</span><br><span class="line">                return true;</span><br><span class="line">            else if(r * r + l * l &lt; c)&#123;</span><br><span class="line">                ++l;</span><br><span class="line">            &#125; else</span><br><span class="line">                --r;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><ul>
<li>这里还是单独列出来吧</li>
</ul>
<h2 id="190-颠倒二进制位"><a href="#190-颠倒二进制位" class="headerlink" title="190_颠倒二进制位"></a>190_颠倒二进制位</h2><ul>
<li>递归…自底向上，那还叫递归么，认真学习下</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution1 &#123;</span><br><span class="line">public:</span><br><span class="line">    uint32_t reverseBits(uint32_t n) &#123;</span><br><span class="line">        uint32_t rev = 0;</span><br><span class="line">        for (int i = 0; i &lt; 32 &amp;&amp; n &gt; 0; ++i) &#123;</span><br><span class="line">            rev |= (n &amp; 1) &lt;&lt; (31 - i); //(n &amp; 1)应该是转化成二进制；rev |= xx 确保了rev位数也是32位</span><br><span class="line">            n &gt;&gt;= 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return rev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    const uint32_t M1 = 0x55555555; // 01010101010101010101010101010101</span><br><span class="line">    const uint32_t M2 = 0x33333333; // 00110011001100110011001100110011</span><br><span class="line">    const uint32_t M4 = 0x0f0f0f0f; // 00001111000011110000111100001111</span><br><span class="line">    const uint32_t M8 = 0x00ff00ff; // 00000000111111110000000011111111</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    uint32_t reverseBits(uint32_t n) &#123;</span><br><span class="line">        n = n &gt;&gt; 1 &amp; M1 | (n &amp; M1) &lt;&lt; 1;</span><br><span class="line">        n = n &gt;&gt; 2 &amp; M2 | (n &amp; M2) &lt;&lt; 2;</span><br><span class="line">        n = n &gt;&gt; 4 &amp; M4 | (n &amp; M4) &lt;&lt; 4;</span><br><span class="line">        n = n &gt;&gt; 8 &amp; M8 | (n &amp; M8) &lt;&lt; 8;</span><br><span class="line">        return n &gt;&gt; 16 | n &lt;&lt; 16;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution2 &#123;</span><br><span class="line">public:</span><br><span class="line">    uint32_t reverseBits(uint32_t n) &#123;</span><br><span class="line">        //32位二进制</span><br><span class="line">        uint32_t ans = 0;</span><br><span class="line">        int i = 0;</span><br><span class="line">        while(n &gt; 0)&#123;</span><br><span class="line">            auto tmp = n % 2;</span><br><span class="line">            //cout &lt;&lt; &quot; &quot; &lt;&lt; tmp &lt;&lt; &quot; &quot;;</span><br><span class="line">            ans = ans * 2 + tmp;</span><br><span class="line">            n = (n - tmp) / 2;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        //cout &lt;&lt; endl;</span><br><span class="line">        while(i &lt; 32)&#123;</span><br><span class="line">            ans *= 2;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="191-位1的个数"><a href="#191-位1的个数" class="headerlink" title="191_位1的个数"></a>191_位1的个数</h2><ul>
<li>还是循环了</li>
<li>递归分治没想出来；不过优化真的厉害，不断地将n与n-1做与运算，可以不断地将最低位的1变成0</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//题解</span><br><span class="line">class Solution1 &#123;</span><br><span class="line">public:</span><br><span class="line">    int hammingWeight(uint32_t n) &#123;</span><br><span class="line">        int ret = 0;</span><br><span class="line">        for (int i = 0; i &lt; 32; i++) &#123;</span><br><span class="line">            if (n &amp; (1 &lt;&lt; i)) &#123;</span><br><span class="line">                ret++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution_ &#123;</span><br><span class="line">public:</span><br><span class="line">    int hammingWeight(uint32_t n) &#123;</span><br><span class="line">        //还是循环32次？</span><br><span class="line">        int ans = 0;</span><br><span class="line">        while(n &gt; 0)&#123;</span><br><span class="line">            if(n % 2 == 1)</span><br><span class="line">                ++ans;</span><br><span class="line">            n &gt;&gt;= 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int hammingWeight(uint32_t n) &#123;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        while (n)&#123;</span><br><span class="line">            n &amp;= (n - 1);</span><br><span class="line">            ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="201-数字范围按位与"><a href="#201-数字范围按位与" class="headerlink" title="201_数字范围按位与"></a>201_数字范围按位与</h2><ul>
<li>审题不清，明明只能整数、正整数；但思路还是可以的</li>
<li>看了题解之后…自己还是菜；题目要理解为找公共前缀</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution1 &#123;</span><br><span class="line">public:</span><br><span class="line">    int rangeBitwiseAnd(int left, int right) &#123;</span><br><span class="line">        if(left &lt; 1) return 0;</span><br><span class="line">        int n = 0;</span><br><span class="line">        auto tmp = pow(2, n);</span><br><span class="line">        //这一步复杂度，就可以解出答案</span><br><span class="line">        while (tmp &lt;= left)&#123;</span><br><span class="line">            ++n;</span><br><span class="line">            tmp = pow(2, n);</span><br><span class="line">        &#125;</span><br><span class="line">        if(right &gt;= pow(2, n))</span><br><span class="line">            return 0;</span><br><span class="line">        //更新left、right；到这一步说明两者在同一个级别大小</span><br><span class="line">        int ans = 0;</span><br><span class="line">        left -= pow(2, n - 1);</span><br><span class="line">        right -= pow(2, n - 1);</span><br><span class="line">        ans += pow(2, n - 1);</span><br><span class="line">//        cout &lt;&lt; &quot;ans = &quot; &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">        return ans + rangeBitwiseAnd(left, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//移位，找相同前缀</span><br><span class="line">class Solution2 &#123;</span><br><span class="line">public:</span><br><span class="line">    int rangeBitwiseAnd(int m, int n) &#123;</span><br><span class="line">        int shift = 0;</span><br><span class="line">        // 找到公共前缀</span><br><span class="line">        while (m &lt; n) &#123;</span><br><span class="line">            m &gt;&gt;= 1;</span><br><span class="line">            n &gt;&gt;= 1;</span><br><span class="line">            ++shift;</span><br><span class="line">        &#125;</span><br><span class="line">        return m &lt;&lt; shift;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//连续数字相乘可以消除末位1 Brian Kernighan 算法</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int rangeBitwiseAnd(int m, int n) &#123;</span><br><span class="line">        while (m &lt; n) &#123;</span><br><span class="line">            // 抹去最右边的 1</span><br><span class="line">            n = n &amp; (n - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int left = 519, right = 1023;</span><br><span class="line">    Solution solution;</span><br><span class="line">    int ans = solution.rangeBitwiseAnd(left, right);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="231-2-的幂"><a href="#231-2-的幂" class="headerlink" title="231_2 的幂"></a>231_2 的幂</h2><ul>
<li>2的0次方也是幂！！！这题每日一题做过，就当复习了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution2 &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isPowerOfTwo(int n) &#123;</span><br><span class="line">        //二进制1的个数只能是一个，但是要考虑正负号</span><br><span class="line">        if(n &lt; 0)</span><br><span class="line">            return false;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        while(n)&#123;</span><br><span class="line">            n &amp;= (n - 1);</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans == 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//这个方法是直接判断约数</span><br><span class="line">class Solution1 &#123;</span><br><span class="line">private:</span><br><span class="line">    static constexpr int BIG = 1 &lt;&lt; 30;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    bool isPowerOfTwo(int n) &#123;</span><br><span class="line">        return n &gt; 0 &amp;&amp; BIG % n == 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isPowerOfTwo(int n) &#123;</span><br><span class="line">        if(n &lt; 2)</span><br><span class="line">            return false;</span><br><span class="line">        //2的幂，不是2的倍数</span><br><span class="line">        for(int i = 1; i &lt; 32; ++i)&#123;</span><br><span class="line">            if((n &amp; (~(1 &lt;&lt; i))) == 0)&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="258-各位相加"><a href="#258-各位相加" class="headerlink" title="258_各位相加"></a>258_各位相加</h2><ul>
<li>这其实应该算数学！</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int addDigits(int num) &#123;</span><br><span class="line">        //总感觉这一题做过，因为有个极限值，会坍缩！31位，每位都是数字9，加起来279</span><br><span class="line">        //不使用循环或者递归，且在 O(1) 时间复杂度内解决这个问题，那只能用数学方法了</span><br><span class="line">        //x*100+y*10+z=x*99+y*9+x+y+z这个是真的牛皮！！</span><br><span class="line">        return (num - 1) % 9 + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="会员专属"><a href="#会员专属" class="headerlink" title="会员专属"></a>会员专属</h1><ul>
<li>别看了，这些题要会员；贫穷限制了我…</li>
</ul>
<h2 id="156-上下翻转二叉树"><a href="#156-上下翻转二叉树" class="headerlink" title="156_上下翻转二叉树"></a>156_上下翻转二叉树</h2><ul>
<li>给定一个二叉树，其中所有右节点都是具有同级的叶节点（共享相同父节点的左节点）或为空，将其上下翻转并将其变成树，其中原始的右节点变为左叶节点 。 返回新的根。</li>
</ul>
<p><img src="/pictrues/156.png" alt="156" title="156题"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="157-用Read4读取N个字符"><a href="#157-用Read4读取N个字符" class="headerlink" title="157_用Read4读取N个字符"></a>157_用Read4读取N个字符</h2><h2 id="158-用Read4读取N个字符-ll"><a href="#158-用Read4读取N个字符-ll" class="headerlink" title="158_用Read4读取N个字符_ll"></a>158_用Read4读取N个字符_ll</h2><h2 id="159-至多包含两个不同字符的最长子串"><a href="#159-至多包含两个不同字符的最长子串" class="headerlink" title="159_至多包含两个不同字符的最长子串"></a>159_至多包含两个不同字符的最长子串</h2><h2 id="161-相隔为1的编辑距离"><a href="#161-相隔为1的编辑距离" class="headerlink" title="161_相隔为1的编辑距离"></a>161_相隔为1的编辑距离</h2><h2 id="163-缺失的区间"><a href="#163-缺失的区间" class="headerlink" title="163_缺失的区间"></a>163_缺失的区间</h2><h2 id="170-两数之和-lll-数据结构设计"><a href="#170-两数之和-lll-数据结构设计" class="headerlink" title="170_两数之和_lll-数据结构设计"></a>170_两数之和_lll-数据结构设计</h2><h2 id="186-翻转字符串里的单词-ll"><a href="#186-翻转字符串里的单词-ll" class="headerlink" title="186_翻转字符串里的单词_ll"></a>186_翻转字符串里的单词_ll</h2><h2 id="243-最短单词距离"><a href="#243-最短单词距离" class="headerlink" title="243_最短单词距离"></a>243_最短单词距离</h2><h2 id="244-最短单词距离-II"><a href="#244-最短单词距离-II" class="headerlink" title="244_最短单词距离_II"></a>244_最短单词距离_II</h2><h2 id="245-最短单词距离-III"><a href="#245-最短单词距离-III" class="headerlink" title="245_最短单词距离_III"></a>245_最短单词距离_III</h2><h2 id="246-中心对称数"><a href="#246-中心对称数" class="headerlink" title="246_中心对称数"></a>246_中心对称数</h2><h2 id="247-中心对称数-II"><a href="#247-中心对称数-II" class="headerlink" title="247_中心对称数_II"></a>247_中心对称数_II</h2><h2 id="248-中心对称数-III"><a href="#248-中心对称数-III" class="headerlink" title="248_中心对称数_III"></a>248_中心对称数_III</h2><h2 id="249-移位字符串分组"><a href="#249-移位字符串分组" class="headerlink" title="249_移位字符串分组"></a>249_移位字符串分组</h2><h2 id="250-统计同值子树"><a href="#250-统计同值子树" class="headerlink" title="250_统计同值子树"></a>250_统计同值子树</h2><h2 id="251-展开二维向量"><a href="#251-展开二维向量" class="headerlink" title="251_展开二维向量"></a>251_展开二维向量</h2><h2 id="252-会议室"><a href="#252-会议室" class="headerlink" title="252_会议室"></a>252_会议室</h2><h2 id="253-会议室-II"><a href="#253-会议室-II" class="headerlink" title="253_会议室_II"></a>253_会议室_II</h2><h2 id="254-因子的组合"><a href="#254-因子的组合" class="headerlink" title="254_因子的组合"></a>254_因子的组合</h2><h2 id="255-验证前序遍历序列二叉搜索树"><a href="#255-验证前序遍历序列二叉搜索树" class="headerlink" title="255_验证前序遍历序列二叉搜索树"></a>255_验证前序遍历序列二叉搜索树</h2><h2 id="256-粉刷房子"><a href="#256-粉刷房子" class="headerlink" title="256_粉刷房子"></a>256_粉刷房子</h2><h2 id="259-较小的三数之和"><a href="#259-较小的三数之和" class="headerlink" title="259_较小的三数之和"></a>259_较小的三数之和</h2><h2 id="261-以图判树"><a href="#261-以图判树" class="headerlink" title="261_以图判树"></a>261_以图判树</h2><h2 id="265-粉刷房子-II"><a href="#265-粉刷房子-II" class="headerlink" title="265_粉刷房子_II"></a>265_粉刷房子_II</h2><h2 id="266-回文排列"><a href="#266-回文排列" class="headerlink" title="266_回文排列"></a>266_回文排列</h2><h2 id="267-回文排列-II"><a href="#267-回文排列-II" class="headerlink" title="267_回文排列_II"></a>267_回文排列_II</h2><h2 id="269-火星词典"><a href="#269-火星词典" class="headerlink" title="269_火星词典"></a>269_火星词典</h2><h2 id="270-最接近的二叉搜索树值"><a href="#270-最接近的二叉搜索树值" class="headerlink" title="270_最接近的二叉搜索树值"></a>270_最接近的二叉搜索树值</h2><h2 id="271-字符串的编码与解码"><a href="#271-字符串的编码与解码" class="headerlink" title="271_字符串的编码与解码"></a>271_字符串的编码与解码</h2><h2 id="272-最接近的二叉搜索树值-II"><a href="#272-最接近的二叉搜索树值-II" class="headerlink" title="272_最接近的二叉搜索树值_II"></a>272_最接近的二叉搜索树值_II</h2><h2 id="276-栅栏涂色"><a href="#276-栅栏涂色" class="headerlink" title="276_栅栏涂色"></a>276_栅栏涂色</h2><h2 id="277-搜寻名人"><a href="#277-搜寻名人" class="headerlink" title="277_搜寻名人"></a>277_搜寻名人</h2><h2 id="280-摆动排序"><a href="#280-摆动排序" class="headerlink" title="280_摆动排序"></a>280_摆动排序</h2><h2 id="281-锯齿迭代器"><a href="#281-锯齿迭代器" class="headerlink" title="281_锯齿迭代器"></a>281_锯齿迭代器</h2><h2 id="285-二叉搜索树中的中序后继"><a href="#285-二叉搜索树中的中序后继" class="headerlink" title="285_二叉搜索树中的中序后继"></a>285_二叉搜索树中的中序后继</h2><h2 id="286-墙与门"><a href="#286-墙与门" class="headerlink" title="286_墙与门"></a>286_墙与门</h2><h2 id="288-单词的唯一缩写"><a href="#288-单词的唯一缩写" class="headerlink" title="288_单词的唯一缩写"></a>288_单词的唯一缩写</h2><h2 id="291-单词规律-II"><a href="#291-单词规律-II" class="headerlink" title="291_单词规律_II"></a>291_单词规律_II</h2><h2 id="293-翻转游戏"><a href="#293-翻转游戏" class="headerlink" title="293_翻转游戏"></a>293_翻转游戏</h2><h2 id="294-翻转游戏-II"><a href="#294-翻转游戏-II" class="headerlink" title="294_翻转游戏_II"></a>294_翻转游戏_II</h2><h2 id="296-最佳的碰头地点"><a href="#296-最佳的碰头地点" class="headerlink" title="296_最佳的碰头地点"></a>296_最佳的碰头地点</h2><h2 id="298-二叉树最长连续序列"><a href="#298-二叉树最长连续序列" class="headerlink" title="298_二叉树最长连续序列"></a>298_二叉树最长连续序列</h2><h2 id="302-包括全部黑色像素的最小矩形"><a href="#302-包括全部黑色像素的最小矩形" class="headerlink" title="302_包括全部黑色像素的最小矩形"></a>302_包括全部黑色像素的最小矩形</h2><h2 id="305-岛屿数量-II"><a href="#305-岛屿数量-II" class="headerlink" title="305_岛屿数量 II"></a>305_岛屿数量 II</h2><hr>
<h1 id="先后手"><a href="#先后手" class="headerlink" title="先后手"></a>先后手</h1><h2 id="292-Nim-游戏"><a href="#292-Nim-游戏" class="headerlink" title="292_Nim 游戏"></a>292_Nim 游戏</h2><ul>
<li>之前也做过类似的题，但是这跟数组没有多大关系，除非用动态规划</li>
<li>那么这一题，就正式放入新的类别</li>
<li>仔细思考了下<ul>
<li>如果一开始就是4的倍数，那铁定必输，因为对方只要拿的个数和你加起来是4就行，最后永远被对方拿走！</li>
<li>那么相反，如果是<code>4k+1</code>、<code>4k+2</code>、<code>4k+3</code>，那肯定稳赢，只要把多余的数拿走，把稳输的局面留给对方</li>
<li>代码可以再优化下</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool canWinNim(int n) &#123;</span><br><span class="line">        return (n % 4 != 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="LCP"><a href="#LCP" class="headerlink" title="LCP"></a>LCP</h1><ul>
<li>LCP是什么？</li>
<li>在每日一题里面遇到了…<ul>
<li>发现LCP在力扣1917最后面…</li>
</ul>
</li>
</ul>

    </div>

    <div>
      
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">本文结束<i class="fa fa-hand-peace-o" aria-hidden="true"></i></i> 转载请注明出处</div>
    
</div>
      
    </div>
    
    
    
    
        
      
        <div id="reward-container">
  <div>如果喜欢，请多多支持！</div>
  <button id="reward-button" disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
        
      
      <div style="display: inline-block">
        <img src="/images/pay2.jpg" alt="xingkang 微信支付">
        <p>微信支付</p>
      </div>
        
      
      <div style="display: inline-block">
        <img src="/images/pay.png" alt="xingkang 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/tags/C/" rel="tag"> <i class="fa fa-location-arrow" aria-hidden="true"></i> C++</a>

            
          </div>
        

        


          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2020/10/15/Linux-Command/" rel="next" title="Linux Command">
                  <i class="fa fa-chevron-left"></i> Linux Command
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/2020/11/19/VMware-Ubuntu/" rel="prev" title="VMware Ubuntu">
                  VMware Ubuntu <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          
    
    <div class="comments" id="comments"></div>
  

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/2.png"
      alt="xingkang">
  <p class="site-author-name" itemprop="name">xingkang</p>
  <div class="site-description motion-element" itemprop="description"></div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://space.bilibili.com/34033362" title="BiliBili &rarr; https://space.bilibili.com/34033362"><i class="fa fa-fw fa-globe"></i>BiliBili</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/cosmicxk" title="GitHub &rarr; https://github.com/cosmicxk" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
  </div>


  <div class="links-of-blogroll motion-element links-of-blogroll-block">
    <div class="links-of-blogroll-title">
      <i class="fa  fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://www.njupt.edu.cn/" title="http://www.njupt.edu.cn/" rel="noopener" target="_blank">University</a>
        </li>
      
    </ul>
  </div>


        </div>
      </div>
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#剑指-Offer"><span class="nav-number">1.</span> <span class="nav-text">剑指 Offer</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-赋值运算符函数"><span class="nav-number">1.1.</span> <span class="nav-text">1_赋值运算符函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-实现Singleton模式"><span class="nav-number">1.2.</span> <span class="nav-text">2_实现Singleton模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-数组中重复的数字"><span class="nav-number">1.3.</span> <span class="nav-text">3_数组中重复的数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-二维数组中的查找"><span class="nav-number">1.4.</span> <span class="nav-text">4_二维数组中的查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-替换空格"><span class="nav-number">1.5.</span> <span class="nav-text">5_替换空格</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-从尾到头打印链表"><span class="nav-number">1.6.</span> <span class="nav-text">6_从尾到头打印链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-重建二叉树"><span class="nav-number">1.7.</span> <span class="nav-text">7_重建二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#递归"><span class="nav-number">1.7.1.</span> <span class="nav-text">递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#迭代"><span class="nav-number">1.7.2.</span> <span class="nav-text">迭代</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-二叉树的下一个节点"><span class="nav-number">1.8.</span> <span class="nav-text">8_二叉树的下一个节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-用两个栈实现队列"><span class="nav-number">1.9.</span> <span class="nav-text">9_用两个栈实现队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-1-斐波那契数列"><span class="nav-number">1.10.</span> <span class="nav-text">10-1_斐波那契数列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-2-青蛙跳台阶问题"><span class="nav-number">1.11.</span> <span class="nav-text">10-2_青蛙跳台阶问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-旋转数组的最小数字"><span class="nav-number">1.12.</span> <span class="nav-text">11_旋转数组的最小数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-矩阵中的路径"><span class="nav-number">1.13.</span> <span class="nav-text">12_矩阵中的路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-机器人的运动范围"><span class="nav-number">1.14.</span> <span class="nav-text">13_机器人的运动范围</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-1-剪绳子"><span class="nav-number">1.15.</span> <span class="nav-text">14-1_剪绳子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-2-剪绳子-ll"><span class="nav-number">1.16.</span> <span class="nav-text">14-2_剪绳子_ll</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-二进制中1的个数"><span class="nav-number">1.17.</span> <span class="nav-text">15_二进制中1的个数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-数值的整数次方"><span class="nav-number">1.18.</span> <span class="nav-text">16_数值的整数次方</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17-打印从1到最大的n位数"><span class="nav-number">1.19.</span> <span class="nav-text">17_打印从1到最大的n位数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18-删除链表的节点"><span class="nav-number">1.20.</span> <span class="nav-text">18_删除链表的节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-正则表达式匹配"><span class="nav-number">1.21.</span> <span class="nav-text">19_正则表达式匹配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20-表示数值的字符串"><span class="nav-number">1.22.</span> <span class="nav-text">20_表示数值的字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21-调整数组顺序使奇数位于偶数前面"><span class="nav-number">1.23.</span> <span class="nav-text">21_调整数组顺序使奇数位于偶数前面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#22-链表中倒数第k个节点"><span class="nav-number">1.24.</span> <span class="nav-text">22_链表中倒数第k个节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#23-链表中环的入口节点"><span class="nav-number">1.25.</span> <span class="nav-text">23_链表中环的入口节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#24-反转链表"><span class="nav-number">1.26.</span> <span class="nav-text">24_反转链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#25-合并两个排序的链表"><span class="nav-number">1.27.</span> <span class="nav-text">25_合并两个排序的链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#26-树的子结构"><span class="nav-number">1.28.</span> <span class="nav-text">26_树的子结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#27-二叉树的镜像"><span class="nav-number">1.29.</span> <span class="nav-text">27_二叉树的镜像</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#28-对称的二叉树"><span class="nav-number">1.30.</span> <span class="nav-text">28_对称的二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#29-顺时针打印矩阵"><span class="nav-number">1.31.</span> <span class="nav-text">29_顺时针打印矩阵</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#30-包含min函数的栈"><span class="nav-number">1.32.</span> <span class="nav-text">30_包含min函数的栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#31-栈的压入、弹出序列"><span class="nav-number">1.33.</span> <span class="nav-text">31_栈的压入、弹出序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#32-1-从上到下打印二叉树"><span class="nav-number">1.34.</span> <span class="nav-text">32-1_从上到下打印二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#32-2-从上到下打印二叉树"><span class="nav-number">1.35.</span> <span class="nav-text">32-2_从上到下打印二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#32-3-从上到下打印二叉树"><span class="nav-number">1.36.</span> <span class="nav-text">32-3_从上到下打印二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#33-二叉搜索树的后序遍历序列"><span class="nav-number">1.37.</span> <span class="nav-text">33_二叉搜索树的后序遍历序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#34-二叉树中和为某一值的路径"><span class="nav-number">1.38.</span> <span class="nav-text">34_二叉树中和为某一值的路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#35-复杂链表的复制"><span class="nav-number">1.39.</span> <span class="nav-text">35_复杂链表的复制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#36-二叉搜索树与双向链表"><span class="nav-number">1.40.</span> <span class="nav-text">36_二叉搜索树与双向链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#37-序列化二叉树"><span class="nav-number">1.41.</span> <span class="nav-text">37_序列化二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#38-字符串的排列"><span class="nav-number">1.42.</span> <span class="nav-text">38_字符串的排列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#39-数组中出现次数超过一半的数字"><span class="nav-number">1.43.</span> <span class="nav-text">39_数组中出现次数超过一半的数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#40-最小的k个数"><span class="nav-number">1.44.</span> <span class="nav-text">40_最小的k个数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#41-数据流中的中位数"><span class="nav-number">1.45.</span> <span class="nav-text">41_数据流中的中位数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#42-连续子数组的最大和"><span class="nav-number">1.46.</span> <span class="nav-text">42_连续子数组的最大和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#43-1～n-整数中-1-出现的次数"><span class="nav-number">1.47.</span> <span class="nav-text">43_1～n 整数中 1 出现的次数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#44-数字序列中某一位的数字"><span class="nav-number">1.48.</span> <span class="nav-text">44_数字序列中某一位的数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#45-把数组排成最小的数"><span class="nav-number">1.49.</span> <span class="nav-text">45_把数组排成最小的数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#46-把数字翻译成字符串"><span class="nav-number">1.50.</span> <span class="nav-text">46_把数字翻译成字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#47-礼物的最大价值"><span class="nav-number">1.51.</span> <span class="nav-text">47_礼物的最大价值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#48-最长不含重复字符的子字符串"><span class="nav-number">1.52.</span> <span class="nav-text">48_最长不含重复字符的子字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#49-丑数"><span class="nav-number">1.53.</span> <span class="nav-text">49_丑数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#50-第一个只出现一次的字符"><span class="nav-number">1.54.</span> <span class="nav-text">50_第一个只出现一次的字符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#51-数组中的逆序对"><span class="nav-number">1.55.</span> <span class="nav-text">51_数组中的逆序对</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#52-两个链表的第一个公共节点"><span class="nav-number">1.56.</span> <span class="nav-text">52_两个链表的第一个公共节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#53-1-在排序数组中查找数字"><span class="nav-number">1.57.</span> <span class="nav-text">53-1_在排序数组中查找数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#53-2-0～n-1-中缺失的数字"><span class="nav-number">1.58.</span> <span class="nav-text">53_2_0～n-1 中缺失的数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#54-二叉搜索树的第-k-大节点"><span class="nav-number">1.59.</span> <span class="nav-text">54_二叉搜索树的第 k 大节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#55-1-二叉树的深度"><span class="nav-number">1.60.</span> <span class="nav-text">55-1_二叉树的深度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#55-2-平衡二叉树"><span class="nav-number">1.61.</span> <span class="nav-text">55-2_平衡二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#56-1-数组中数字出现的次数"><span class="nav-number">1.62.</span> <span class="nav-text">56-1_数组中数字出现的次数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#56-2-数组中数字出现的次数"><span class="nav-number">1.63.</span> <span class="nav-text">56-2_数组中数字出现的次数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#57-1-和为-s-的两个数字"><span class="nav-number">1.64.</span> <span class="nav-text">57-1_和为 s 的两个数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#57-2-和为-s-的连续正数序列"><span class="nav-number">1.65.</span> <span class="nav-text">57-2_和为 s 的连续正数序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#58-1-翻转单词顺序"><span class="nav-number">1.66.</span> <span class="nav-text">58-1_翻转单词顺序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#58-2-左旋转字符串"><span class="nav-number">1.67.</span> <span class="nav-text">58-2_左旋转字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#59-1-滑动窗口的最大值"><span class="nav-number">1.68.</span> <span class="nav-text">59-1_滑动窗口的最大值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#59-2-队列的最大值"><span class="nav-number">1.69.</span> <span class="nav-text">59-2_队列的最大值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#60-n-个骰子的点数"><span class="nav-number">1.70.</span> <span class="nav-text">60_ n 个骰子的点数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#61-扑克牌中的顺子"><span class="nav-number">1.71.</span> <span class="nav-text">61_扑克牌中的顺子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#62-圆圈中最后剩下的数字"><span class="nav-number">1.72.</span> <span class="nav-text">62_圆圈中最后剩下的数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#63-股票的最大利润"><span class="nav-number">1.73.</span> <span class="nav-text">63_股票的最大利润</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#64-求-1-2-…-n"><span class="nav-number">1.74.</span> <span class="nav-text">64_求 1 + 2 + … + n</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#65-不用加减乘除做加法"><span class="nav-number">1.75.</span> <span class="nav-text">65_不用加减乘除做加法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#66-构建乘积数组"><span class="nav-number">1.76.</span> <span class="nav-text">66_构建乘积数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#67-把字符串转换成整数"><span class="nav-number">1.77.</span> <span class="nav-text">67_把字符串转换成整数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#68-1-二叉搜索树的最近公共祖先"><span class="nav-number">1.78.</span> <span class="nav-text">68-1_二叉搜索树的最近公共祖先</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#68-2-二叉树的最近公共祖先"><span class="nav-number">1.79.</span> <span class="nav-text">68-2_二叉树的最近公共祖先</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数组"><span class="nav-number">2.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-两数之和"><span class="nav-number">2.1.</span> <span class="nav-text">1_两数之和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-正序数组中位数"><span class="nav-number">2.2.</span> <span class="nav-text">4_正序数组中位数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#归并法"><span class="nav-number">2.2.1.</span> <span class="nav-text">归并法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-盛最多水的容器"><span class="nav-number">2.3.</span> <span class="nav-text">10_盛最多水的容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-三数之和"><span class="nav-number">2.4.</span> <span class="nav-text">15_三数之和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-最接近的三数之和"><span class="nav-number">2.5.</span> <span class="nav-text">16_最接近的三数之和</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#暴力"><span class="nav-number">2.5.1.</span> <span class="nav-text">暴力</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#双指针"><span class="nav-number">2.5.2.</span> <span class="nav-text">双指针</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17-电话号码的字母组合"><span class="nav-number">2.6.</span> <span class="nav-text">17_电话号码的字母组合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18-四数之和"><span class="nav-number">2.7.</span> <span class="nav-text">18_四数之和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#22-括号生成"><span class="nav-number">2.8.</span> <span class="nav-text">22_括号生成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#26-删除排序数组中的重复项"><span class="nav-number">2.9.</span> <span class="nav-text">26_删除排序数组中的重复项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#27-移除元素"><span class="nav-number">2.10.</span> <span class="nav-text">27_移除元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#31-下一个排列"><span class="nav-number">2.11.</span> <span class="nav-text">31_下一个排列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#33-搜索旋转排序数组"><span class="nav-number">2.12.</span> <span class="nav-text">33_搜索旋转排序数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#二分法"><span class="nav-number">2.12.1.</span> <span class="nav-text">二分法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#34-在排序数组中查找元素的第一个和最后一个位置"><span class="nav-number">2.13.</span> <span class="nav-text">34_在排序数组中查找元素的第一个和最后一个位置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#二分法-1"><span class="nav-number">2.13.1.</span> <span class="nav-text">二分法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#35-搜索插入位置"><span class="nav-number">2.14.</span> <span class="nav-text">35_搜索插入位置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#二分法-2"><span class="nav-number">2.14.1.</span> <span class="nav-text">二分法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#36-有效的数独"><span class="nav-number">2.15.</span> <span class="nav-text">36_有效的数独</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#37-解数独"><span class="nav-number">2.16.</span> <span class="nav-text">37_解数独</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#递归-1"><span class="nav-number">2.16.1.</span> <span class="nav-text">递归</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#39-组合总和"><span class="nav-number">2.17.</span> <span class="nav-text">39_组合总和</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#回溯"><span class="nav-number">2.17.1.</span> <span class="nav-text">回溯</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#40-组合总和"><span class="nav-number">2.18.</span> <span class="nav-text">40_组合总和 ||</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#41-缺失的第一个正数"><span class="nav-number">2.19.</span> <span class="nav-text">41_缺失的第一个正数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#42-接雨水"><span class="nav-number">2.20.</span> <span class="nav-text">42_接雨水</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#栈"><span class="nav-number">2.20.1.</span> <span class="nav-text">栈</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#45-跳跃游戏"><span class="nav-number">2.21.</span> <span class="nav-text">45_跳跃游戏 ||</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#贪心算法"><span class="nav-number">2.21.1.</span> <span class="nav-text">贪心算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#46-全排列"><span class="nav-number">2.22.</span> <span class="nav-text">46_全排列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#47-全排列"><span class="nav-number">2.23.</span> <span class="nav-text">47_全排列 ||</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#48-旋转图像"><span class="nav-number">2.24.</span> <span class="nav-text">48_旋转图像</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#51-N皇后"><span class="nav-number">2.25.</span> <span class="nav-text">51_N皇后</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#52-N皇后"><span class="nav-number">2.26.</span> <span class="nav-text">52_N皇后 ||</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#53-最大子序和"><span class="nav-number">2.27.</span> <span class="nav-text">53_最大子序和</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#动态规划"><span class="nav-number">2.27.1.</span> <span class="nav-text">动态规划</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#54-螺旋矩阵"><span class="nav-number">2.28.</span> <span class="nav-text">54_螺旋矩阵</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#55-跳跃游戏"><span class="nav-number">2.29.</span> <span class="nav-text">55_跳跃游戏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#56-合并区间"><span class="nav-number">2.30.</span> <span class="nav-text">56_合并区间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#57-插入区间"><span class="nav-number">2.31.</span> <span class="nav-text">57_插入区间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#59-螺旋矩阵"><span class="nav-number">2.32.</span> <span class="nav-text">59_螺旋矩阵 ||</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#63-不同路径"><span class="nav-number">2.33.</span> <span class="nav-text">63_不同路径 ||</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#64-最小路径和"><span class="nav-number">2.34.</span> <span class="nav-text">64_最小路径和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#66-加一"><span class="nav-number">2.35.</span> <span class="nav-text">66_加一</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#68-文本左右对齐"><span class="nav-number">2.36.</span> <span class="nav-text">68_文本左右对齐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#73-矩阵置零"><span class="nav-number">2.37.</span> <span class="nav-text">73_矩阵置零</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#74-搜索二维矩阵"><span class="nav-number">2.38.</span> <span class="nav-text">74_搜索二维矩阵</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#75-数组"><span class="nav-number">2.39.</span> <span class="nav-text">75_数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#77-组合"><span class="nav-number">2.40.</span> <span class="nav-text">77_组合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#78-子集"><span class="nav-number">2.41.</span> <span class="nav-text">78_子集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#79-单词搜索"><span class="nav-number">2.42.</span> <span class="nav-text">79_单词搜索</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#80-删除排序数组中的重复项-II"><span class="nav-number">2.43.</span> <span class="nav-text">80_删除排序数组中的重复项_II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#81-搜索旋转排序数组-II"><span class="nav-number">2.44.</span> <span class="nav-text">81_搜索旋转排序数组_II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#84-柱状图中最大的矩形"><span class="nav-number">2.45.</span> <span class="nav-text">84_柱状图中最大的矩形</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#85-最大矩形"><span class="nav-number">2.46.</span> <span class="nav-text">85_最大矩形</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#88-合并两个有序数组"><span class="nav-number">2.47.</span> <span class="nav-text">88_合并两个有序数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#89-格雷编码"><span class="nav-number">2.48.</span> <span class="nav-text">89_格雷编码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#90-子集-II"><span class="nav-number">2.49.</span> <span class="nav-text">90_子集_II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#93-复原IP地址"><span class="nav-number">2.50.</span> <span class="nav-text">93_复原IP地址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#118-杨辉三角"><span class="nav-number">2.51.</span> <span class="nav-text">118_杨辉三角</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#119-杨辉三角-II"><span class="nav-number">2.52.</span> <span class="nav-text">119_杨辉三角_II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#120-三角形最小路径和"><span class="nav-number">2.53.</span> <span class="nav-text">120_三角形最小路径和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#121-买卖股票的最佳时机"><span class="nav-number">2.54.</span> <span class="nav-text">121_买卖股票的最佳时机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#122-买卖股票的最佳时机-ll"><span class="nav-number">2.55.</span> <span class="nav-text">122_买卖股票的最佳时机_ll</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#123-买卖股票的最佳时机-III"><span class="nav-number">2.56.</span> <span class="nav-text">123_买卖股票的最佳时机_III</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#128-最长连续序列"><span class="nav-number">2.57.</span> <span class="nav-text">128_最长连续序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#130-被围绕的区域"><span class="nav-number">2.58.</span> <span class="nav-text">130_被围绕的区域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#131-分割回文串"><span class="nav-number">2.59.</span> <span class="nav-text">131_分割回文串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#134-加油站"><span class="nav-number">2.60.</span> <span class="nav-text">134_加油站</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#135-分发糖果"><span class="nav-number">2.61.</span> <span class="nav-text">135_分发糖果</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#136-只出现一次的数字"><span class="nav-number">2.62.</span> <span class="nav-text">136_只出现一次的数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#137-只出现一次的数字-ll"><span class="nav-number">2.63.</span> <span class="nav-text">137_只出现一次的数字_ll</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#149-直线上最多的点数"><span class="nav-number">2.64.</span> <span class="nav-text">149_直线上最多的点数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#二刷"><span class="nav-number">2.64.1.</span> <span class="nav-text">二刷</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#150-逆波兰表达式求值"><span class="nav-number">2.65.</span> <span class="nav-text">150_逆波兰表达式求值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#152-乘积最大子数组"><span class="nav-number">2.66.</span> <span class="nav-text">152_乘积最大子数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#153-寻找旋转排序数组中的最小值"><span class="nav-number">2.67.</span> <span class="nav-text">153_寻找旋转排序数组中的最小值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#154-寻找旋转排序数组中的最小值-II"><span class="nav-number">2.68.</span> <span class="nav-text">154_寻找旋转排序数组中的最小值_II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#162-寻找峰值"><span class="nav-number">2.69.</span> <span class="nav-text">162_寻找峰值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#164-最大间距"><span class="nav-number">2.70.</span> <span class="nav-text">164_最大间距</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#167-两数之和-II-输入有序数组"><span class="nav-number">2.71.</span> <span class="nav-text">167_两数之和_II_输入有序数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#169-多数元素"><span class="nav-number">2.72.</span> <span class="nav-text">169_多数元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#174-地下城游戏"><span class="nav-number">2.73.</span> <span class="nav-text">174_地下城游戏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#187-重复的DNA序列"><span class="nav-number">2.74.</span> <span class="nav-text">187_重复的DNA序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#188-买卖股票的最佳时机-IV"><span class="nav-number">2.75.</span> <span class="nav-text">188_买卖股票的最佳时机_IV</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#189-旋转数组"><span class="nav-number">2.76.</span> <span class="nav-text">189_旋转数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#198-打家劫舍"><span class="nav-number">2.77.</span> <span class="nav-text">198_打家劫舍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#200-岛屿数量"><span class="nav-number">2.78.</span> <span class="nav-text">200_岛屿数量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#209-长度最小的子数组"><span class="nav-number">2.79.</span> <span class="nav-text">209_长度最小的子数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#213-打家劫舍-II"><span class="nav-number">2.80.</span> <span class="nav-text">213_打家劫舍_II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#215-数组中的第K个最大元素"><span class="nav-number">2.81.</span> <span class="nav-text">215_数组中的第K个最大元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#216-组合总和-III"><span class="nav-number">2.82.</span> <span class="nav-text">216_组合总和_III</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#217-存在重复元素"><span class="nav-number">2.83.</span> <span class="nav-text">217_存在重复元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#218-天际线问题"><span class="nav-number">2.84.</span> <span class="nav-text">218_天际线问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#二刷-1"><span class="nav-number">2.84.1.</span> <span class="nav-text">二刷</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#219-存在重复元素-II"><span class="nav-number">2.85.</span> <span class="nav-text">219_存在重复元素_II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#220-存在重复元素-III"><span class="nav-number">2.86.</span> <span class="nav-text">220_存在重复元素_III</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#221-最大正方形"><span class="nav-number">2.87.</span> <span class="nav-text">221_最大正方形</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#223-矩形面积"><span class="nav-number">2.88.</span> <span class="nav-text">223_矩形面积</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#228-汇总区间"><span class="nav-number">2.89.</span> <span class="nav-text">228_汇总区间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#229-求众数-II"><span class="nav-number">2.90.</span> <span class="nav-text">229_求众数_II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#238-除自身以外数组的乘积"><span class="nav-number">2.91.</span> <span class="nav-text">238_除自身以外数组的乘积</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#239-滑动窗口最大值"><span class="nav-number">2.92.</span> <span class="nav-text">239_滑动窗口最大值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#240-搜索二维矩阵-II"><span class="nav-number">2.93.</span> <span class="nav-text">240_搜索二维矩阵_II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#260-只出现一次的数字-III"><span class="nav-number">2.94.</span> <span class="nav-text">260_只出现一次的数字_III</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#268-丢失的数字"><span class="nav-number">2.95.</span> <span class="nav-text">268_丢失的数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#274-H-指数"><span class="nav-number">2.96.</span> <span class="nav-text">274_H 指数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#二刷-2"><span class="nav-number">2.96.1.</span> <span class="nav-text">二刷</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#275-H-指数-II"><span class="nav-number">2.97.</span> <span class="nav-text">275_H 指数_II</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#二刷-3"><span class="nav-number">2.97.1.</span> <span class="nav-text">二刷</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#278-第一个错误的版本"><span class="nav-number">2.98.</span> <span class="nav-text">278_第一个错误的版本</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#279-完全平方数"><span class="nav-number">2.99.</span> <span class="nav-text">279_完全平方数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#283-移动零"><span class="nav-number">2.100.</span> <span class="nav-text">283_移动零</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#284-顶端迭代器"><span class="nav-number">2.101.</span> <span class="nav-text">284_顶端迭代器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#287-寻找重复数"><span class="nav-number">2.102.</span> <span class="nav-text">287_寻找重复数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#289-生命游戏"><span class="nav-number">2.103.</span> <span class="nav-text">289_生命游戏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#295-数据流的中位数"><span class="nav-number">2.104.</span> <span class="nav-text">295_数据流的中位数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#300-最长递增子序列"><span class="nav-number">2.105.</span> <span class="nav-text">300_最长递增子序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#303-区域和检索-数组不可变"><span class="nav-number">2.106.</span> <span class="nav-text">303_区域和检索-数组不可变</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#304-二维区域和检索-矩阵不可变"><span class="nav-number">2.107.</span> <span class="nav-text">304_二维区域和检索-矩阵不可变</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#307-区域和检索-数组可修改"><span class="nav-number">2.108.</span> <span class="nav-text">307_区域和检索 - 数组可修改</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#363-矩形区域不超过K的最大数值和"><span class="nav-number">2.109.</span> <span class="nav-text">363_矩形区域不超过K的最大数值和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#368-最大整除子集"><span class="nav-number">2.110.</span> <span class="nav-text">368_最大整除子集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#377-组合总和-Ⅳ"><span class="nav-number">2.111.</span> <span class="nav-text">377_组合总和_Ⅳ</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#403-青蛙过河"><span class="nav-number">2.112.</span> <span class="nav-text">403_青蛙过河</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#690-员工的重要性"><span class="nav-number">2.113.</span> <span class="nav-text">690_员工的重要性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1011-在D天内送达包裹的能力"><span class="nav-number">2.114.</span> <span class="nav-text">1011_在D天内送达包裹的能力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1018-可被5整除的二进制前缀"><span class="nav-number">2.115.</span> <span class="nav-text">1018_可被5整除的二进制前缀</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1723-完成所有工作的最短时间"><span class="nav-number">2.116.</span> <span class="nav-text">1723_完成所有工作的最短时间</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#链表"><span class="nav-number">3.</span> <span class="nav-text">链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-两数相加"><span class="nav-number">3.1.</span> <span class="nav-text">2_两数相加</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-删除链表的倒数第N个节点"><span class="nav-number">3.2.</span> <span class="nav-text">19_删除链表的倒数第N个节点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#两次遍历"><span class="nav-number">3.2.1.</span> <span class="nav-text">两次遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#两个指针"><span class="nav-number">3.2.2.</span> <span class="nav-text">两个指针</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21-合并两个有序链表"><span class="nav-number">3.3.</span> <span class="nav-text">21_合并两个有序链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#迭代-1"><span class="nav-number">3.3.1.</span> <span class="nav-text">迭代</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#递归-2"><span class="nav-number">3.3.2.</span> <span class="nav-text">递归</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#23-合并K个升序链表"><span class="nav-number">3.4.</span> <span class="nav-text">23_合并K个升序链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#顺序合并"><span class="nav-number">3.4.1.</span> <span class="nav-text">顺序合并</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#24-两两交换链表中的节点"><span class="nav-number">3.5.</span> <span class="nav-text">24_两两交换链表中的节点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#递归-3"><span class="nav-number">3.5.1.</span> <span class="nav-text">递归</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#25-K-个一组翻转链表"><span class="nav-number">3.6.</span> <span class="nav-text">25_K 个一组翻转链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#递归-4"><span class="nav-number">3.6.1.</span> <span class="nav-text">递归</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#61-旋转链表"><span class="nav-number">3.7.</span> <span class="nav-text">61_旋转链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#82-删除排序链表中的重复元素-II"><span class="nav-number">3.8.</span> <span class="nav-text">82_删除排序链表中的重复元素_II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#83-删除排序链表中的重复元素"><span class="nav-number">3.9.</span> <span class="nav-text">83_删除排序链表中的重复元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#86-分隔链表"><span class="nav-number">3.10.</span> <span class="nav-text">86_分隔链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#92-反转链表-II"><span class="nav-number">3.11.</span> <span class="nav-text">92_反转链表_II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#138-复制带随机指针的链表"><span class="nav-number">3.12.</span> <span class="nav-text">138_复制带随机指针的链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#二刷-4"><span class="nav-number">3.12.1.</span> <span class="nav-text">二刷</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#141-环形链表"><span class="nav-number">3.13.</span> <span class="nav-text">141_环形链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#142-环形链表-II"><span class="nav-number">3.14.</span> <span class="nav-text">142_环形链表_II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#143-重排链表"><span class="nav-number">3.15.</span> <span class="nav-text">143_重排链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#146-LRU-缓存机制"><span class="nav-number">3.16.</span> <span class="nav-text">146_LRU 缓存机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#147-对链表进行插入排序"><span class="nav-number">3.17.</span> <span class="nav-text">147_对链表进行插入排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#148-排序链表"><span class="nav-number">3.18.</span> <span class="nav-text">148_排序链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#160-相交链表"><span class="nav-number">3.19.</span> <span class="nav-text">160_相交链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#二刷-5"><span class="nav-number">3.19.1.</span> <span class="nav-text">二刷</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#202-快乐数"><span class="nav-number">3.20.</span> <span class="nav-text">202_快乐数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#203-移除链表元素"><span class="nav-number">3.21.</span> <span class="nav-text">203_移除链表元素</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#二刷-6"><span class="nav-number">3.21.1.</span> <span class="nav-text">二刷</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#206-反转链表"><span class="nav-number">3.22.</span> <span class="nav-text">206_反转链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#234-回文链表"><span class="nav-number">3.23.</span> <span class="nav-text">234_回文链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#237-删除链表中的节点"><span class="nav-number">3.24.</span> <span class="nav-text">237_删除链表中的节点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#字符串"><span class="nav-number">4.</span> <span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-最长字串"><span class="nav-number">4.1.</span> <span class="nav-text">3_最长字串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#滑动窗口"><span class="nav-number">4.1.1.</span> <span class="nav-text">滑动窗口</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-最长回文字串"><span class="nav-number">4.2.</span> <span class="nav-text">5_最长回文字串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-Z形变换"><span class="nav-number">4.3.</span> <span class="nav-text">6_Z形变换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-字符串转整数"><span class="nav-number">4.4.</span> <span class="nav-text">8_字符串转整数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-正则表达式匹配"><span class="nav-number">4.5.</span> <span class="nav-text">10_正则表达式匹配</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#递归-5"><span class="nav-number">4.5.1.</span> <span class="nav-text">递归</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-整数转罗马数字"><span class="nav-number">4.6.</span> <span class="nav-text">12_整数转罗马数字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#贪心算法-1"><span class="nav-number">4.6.1.</span> <span class="nav-text">贪心算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-罗马数字转整数"><span class="nav-number">4.7.</span> <span class="nav-text">13_罗马数字转整数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-最长公共前缀"><span class="nav-number">4.8.</span> <span class="nav-text">14_最长公共前缀</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20-有效的括号"><span class="nav-number">4.9.</span> <span class="nav-text">20_有效的括号</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#递归-6"><span class="nav-number">4.9.1.</span> <span class="nav-text">递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#栈-1"><span class="nav-number">4.9.2.</span> <span class="nav-text">栈</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#28-实现strStr"><span class="nav-number">4.10.</span> <span class="nav-text">28_实现strStr()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#30-串联所有单词的字串"><span class="nav-number">4.11.</span> <span class="nav-text">30_串联所有单词的字串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#滑动窗口-1"><span class="nav-number">4.11.1.</span> <span class="nav-text">滑动窗口</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#32-最长有效括号"><span class="nav-number">4.12.</span> <span class="nav-text">32_最长有效括号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#38-外观数列"><span class="nav-number">4.13.</span> <span class="nav-text">38_外观数列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#递归-7"><span class="nav-number">4.13.1.</span> <span class="nav-text">递归</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#43-字符串相乘"><span class="nav-number">4.14.</span> <span class="nav-text">43_字符串相乘</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#44-通配符匹配"><span class="nav-number">4.15.</span> <span class="nav-text">44_通配符匹配</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#动态规划-1"><span class="nav-number">4.15.1.</span> <span class="nav-text">动态规划</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#49-字母异位词分组"><span class="nav-number">4.16.</span> <span class="nav-text">49_字母异位词分组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#58-最后一个单词的长度"><span class="nav-number">4.17.</span> <span class="nav-text">58_最后一个单词的长度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#60-排列序列"><span class="nav-number">4.18.</span> <span class="nav-text">60_排列序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#65-有效数字"><span class="nav-number">4.19.</span> <span class="nav-text">65_有效数字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#二刷-7"><span class="nav-number">4.19.1.</span> <span class="nav-text">二刷</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#67-二进制求和"><span class="nav-number">4.20.</span> <span class="nav-text">67_二进制求和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#71-简化路径"><span class="nav-number">4.21.</span> <span class="nav-text">71_简化路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#72-编辑距离"><span class="nav-number">4.22.</span> <span class="nav-text">72_编辑距离</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#76-最小覆盖字串"><span class="nav-number">4.23.</span> <span class="nav-text">76_最小覆盖字串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#87-扰乱字符串"><span class="nav-number">4.24.</span> <span class="nav-text">87_扰乱字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#91-解码方法"><span class="nav-number">4.25.</span> <span class="nav-text">91_解码方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#97-交错字符串"><span class="nav-number">4.26.</span> <span class="nav-text">97_ 交错字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#115-不同的子序列"><span class="nav-number">4.27.</span> <span class="nav-text">115_不同的子序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#125-验证回文串"><span class="nav-number">4.28.</span> <span class="nav-text">125_验证回文串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#126-单词接龙-II"><span class="nav-number">4.29.</span> <span class="nav-text">126_单词接龙_II</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#二刷-8"><span class="nav-number">4.29.1.</span> <span class="nav-text">二刷</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#127-单词接龙"><span class="nav-number">4.30.</span> <span class="nav-text">127_单词接龙</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#132-分割回文串-II"><span class="nav-number">4.31.</span> <span class="nav-text">132_分割回文串_II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#139-单词拆分"><span class="nav-number">4.32.</span> <span class="nav-text">139_单词拆分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#140-单词拆分-ll"><span class="nav-number">4.33.</span> <span class="nav-text">140_单词拆分_ll</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#151-翻转字符串里的单词"><span class="nav-number">4.34.</span> <span class="nav-text">151_翻转字符串里的单词</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#165-比较版本号"><span class="nav-number">4.35.</span> <span class="nav-text">165_比较版本号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#166-分数到小数"><span class="nav-number">4.36.</span> <span class="nav-text">166_分数到小数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#168-Excel表列名称"><span class="nav-number">4.37.</span> <span class="nav-text">168_Excel表列名称</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#二刷-9"><span class="nav-number">4.37.1.</span> <span class="nav-text">二刷</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#171-Excel表列序号"><span class="nav-number">4.38.</span> <span class="nav-text">171_Excel表列序号</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#二刷-10"><span class="nav-number">4.38.1.</span> <span class="nav-text">二刷</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#179-最大数"><span class="nav-number">4.39.</span> <span class="nav-text">179_最大数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#205-同构字符串"><span class="nav-number">4.40.</span> <span class="nav-text">205_同构字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#214-最短回文串"><span class="nav-number">4.41.</span> <span class="nav-text">214_最短回文串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#224-基本计算器"><span class="nav-number">4.42.</span> <span class="nav-text">224_基本计算器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#227-基本计算器-II"><span class="nav-number">4.43.</span> <span class="nav-text">227_基本计算器_II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#241-为运算表达式设计优先级"><span class="nav-number">4.44.</span> <span class="nav-text">241_为运算表达式设计优先级</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#242-有效的字母异位词"><span class="nav-number">4.45.</span> <span class="nav-text">242_有效的字母异位词</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#273-整数转换英文表示"><span class="nav-number">4.46.</span> <span class="nav-text">273_整数转换英文表示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#282-给表达式添加运算符"><span class="nav-number">4.47.</span> <span class="nav-text">282_给表达式添加运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#290-单词规律"><span class="nav-number">4.48.</span> <span class="nav-text">290_单词规律</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#299-猜数字游戏"><span class="nav-number">4.49.</span> <span class="nav-text">299_猜数字游戏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#301-删除无效的括号"><span class="nav-number">4.50.</span> <span class="nav-text">301_删除无效的括号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#306-累加数"><span class="nav-number">4.51.</span> <span class="nav-text">306_累加数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二叉树"><span class="nav-number">5.</span> <span class="nav-text">二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#94-二叉树的中序遍历"><span class="nav-number">5.1.</span> <span class="nav-text">94_二叉树的中序遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#95-不同的二叉搜索树-II"><span class="nav-number">5.2.</span> <span class="nav-text">95_不同的二叉搜索树_II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#96-不同的二叉搜索树"><span class="nav-number">5.3.</span> <span class="nav-text">96_不同的二叉搜索树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#98-验证二叉搜索树"><span class="nav-number">5.4.</span> <span class="nav-text">98_验证二叉搜索树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#99-恢复二叉搜索树"><span class="nav-number">5.5.</span> <span class="nav-text">99_恢复二叉搜索树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#100-相同的树"><span class="nav-number">5.6.</span> <span class="nav-text">100_相同的树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#101-对称二叉树"><span class="nav-number">5.7.</span> <span class="nav-text">101_对称二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#102-二叉树的层序遍历"><span class="nav-number">5.8.</span> <span class="nav-text">102_二叉树的层序遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#103-二叉树的锯齿形层序遍历"><span class="nav-number">5.9.</span> <span class="nav-text">103_二叉树的锯齿形层序遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#104-二叉树的最大深度"><span class="nav-number">5.10.</span> <span class="nav-text">104_二叉树的最大深度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#105-从前序与中序遍历序列构造二叉树"><span class="nav-number">5.11.</span> <span class="nav-text">105_从前序与中序遍历序列构造二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#106-从中序与后序遍历序列构造二叉树"><span class="nav-number">5.12.</span> <span class="nav-text">106_从中序与后序遍历序列构造二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#107-二叉树的层序遍历-II"><span class="nav-number">5.13.</span> <span class="nav-text">107-二叉树的层序遍历 II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#108-将有序数组转换为二叉搜索树"><span class="nav-number">5.14.</span> <span class="nav-text">108_将有序数组转换为二叉搜索树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#109-有序链表转换二叉搜索树"><span class="nav-number">5.15.</span> <span class="nav-text">109_有序链表转换二叉搜索树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#110-平衡二叉树"><span class="nav-number">5.16.</span> <span class="nav-text">110_平衡二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#111-二叉树的最小深度"><span class="nav-number">5.17.</span> <span class="nav-text">111_二叉树的最小深度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#112-路径总和"><span class="nav-number">5.18.</span> <span class="nav-text">112_路径总和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#113-路径总和-II"><span class="nav-number">5.19.</span> <span class="nav-text">113_路径总和_II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#114-二叉树展开为链表"><span class="nav-number">5.20.</span> <span class="nav-text">114_二叉树展开为链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#116-填充每个节点的下一个右侧节点指针"><span class="nav-number">5.21.</span> <span class="nav-text">116_填充每个节点的下一个右侧节点指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#117-填充每个节点的下一个右侧节点指针-ll"><span class="nav-number">5.22.</span> <span class="nav-text">117_填充每个节点的下一个右侧节点指针_ll</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#124-二叉树中的最大路径和"><span class="nav-number">5.23.</span> <span class="nav-text">124_二叉树中的最大路径和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#129-求根节点到叶节点数字之和"><span class="nav-number">5.24.</span> <span class="nav-text">129_求根节点到叶节点数字之和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#144-二叉树的前序遍历"><span class="nav-number">5.25.</span> <span class="nav-text">144_二叉树的前序遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#145-二叉树的后序遍历"><span class="nav-number">5.26.</span> <span class="nav-text">145_二叉树的后序遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#173-二叉搜索树迭代器"><span class="nav-number">5.27.</span> <span class="nav-text">173_二叉搜索树迭代器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#199-二叉树的右视图"><span class="nav-number">5.28.</span> <span class="nav-text">199_二叉树的右视图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#208-实现Trie-前缀树"><span class="nav-number">5.29.</span> <span class="nav-text">208_实现Trie(前缀树)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#211-添加与搜索单词-数据结构设计"><span class="nav-number">5.30.</span> <span class="nav-text">211_添加与搜索单词 - 数据结构设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#212-单词搜索-II"><span class="nav-number">5.31.</span> <span class="nav-text">212_单词搜索_II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#222-完全二叉树的节点个数"><span class="nav-number">5.32.</span> <span class="nav-text">222_完全二叉树的节点个数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#226-翻转二叉树"><span class="nav-number">5.33.</span> <span class="nav-text">226_翻转二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#230-二叉搜索树中第K小的元素"><span class="nav-number">5.34.</span> <span class="nav-text">230_二叉搜索树中第K小的元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#235-二叉搜索树的最近公共祖先"><span class="nav-number">5.35.</span> <span class="nav-text">235_二叉搜索树的最近公共祖先</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#236-二叉树的最近公共祖先"><span class="nav-number">5.36.</span> <span class="nav-text">236_二叉树的最近公共祖先</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#257-二叉树的所有路径"><span class="nav-number">5.37.</span> <span class="nav-text">257_二叉树的所有路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#297-二叉树的序列化与反序列化"><span class="nav-number">5.38.</span> <span class="nav-text">297_二叉树的序列化与反序列化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#897-递增顺序搜索树"><span class="nav-number">5.39.</span> <span class="nav-text">897_递增顺序搜索树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#938-二叉搜索树的范围和"><span class="nav-number">5.40.</span> <span class="nav-text">938_二叉搜索树的范围和</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#图"><span class="nav-number">6.</span> <span class="nav-text">图</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#133-克隆图"><span class="nav-number">6.1.</span> <span class="nav-text">133_克隆图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#207-课程表"><span class="nav-number">6.2.</span> <span class="nav-text">207_课程表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#210-课程表-II"><span class="nav-number">6.3.</span> <span class="nav-text">210_课程表_II</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#容器适配器"><span class="nav-number">7.</span> <span class="nav-text">容器适配器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#155-最小栈"><span class="nav-number">7.1.</span> <span class="nav-text">155_最小栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#225-用队列实现栈"><span class="nav-number">7.2.</span> <span class="nav-text">225_用队列实现栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#232-用栈实现队列"><span class="nav-number">7.3.</span> <span class="nav-text">232_用栈实现队列</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SQL"><span class="nav-number">8.</span> <span class="nav-text">SQL</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#175-组合两个表"><span class="nav-number">8.1.</span> <span class="nav-text">175_组合两个表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#176-第二高的薪水"><span class="nav-number">8.2.</span> <span class="nav-text">176_第二高的薪水</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Shell"><span class="nav-number">9.</span> <span class="nav-text">Shell</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#192-统计词频"><span class="nav-number">9.1.</span> <span class="nav-text">192_统计词频</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#整数边界"><span class="nav-number">10.</span> <span class="nav-text">整数边界</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-整数反转"><span class="nav-number">10.1.</span> <span class="nav-text">7_整数反转</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-回文数"><span class="nav-number">10.2.</span> <span class="nav-text">9_回文数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#29-两数相除"><span class="nav-number">10.3.</span> <span class="nav-text">29_两数相除</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#50-Pow-x-n"><span class="nav-number">10.4.</span> <span class="nav-text">50_Pow(x,n)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#62-不同路径"><span class="nav-number">10.5.</span> <span class="nav-text">62_不同路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#69-x的平方根"><span class="nav-number">10.6.</span> <span class="nav-text">69_x的平方根</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#70-爬楼梯"><span class="nav-number">10.7.</span> <span class="nav-text">70_爬楼梯</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#172-阶乘后的零"><span class="nav-number">10.8.</span> <span class="nav-text">172_阶乘后的零</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#204-计数质数"><span class="nav-number">10.9.</span> <span class="nav-text">204_计数质数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#233-数字-1-的个数"><span class="nav-number">10.10.</span> <span class="nav-text">233_数字 1 的个数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#263-丑数"><span class="nav-number">10.11.</span> <span class="nav-text">263_丑数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#264-丑数-II"><span class="nav-number">10.12.</span> <span class="nav-text">264_丑数_II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#633-平方数之和"><span class="nav-number">10.13.</span> <span class="nav-text">633_平方数之和</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#位运算"><span class="nav-number">11.</span> <span class="nav-text">位运算</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#190-颠倒二进制位"><span class="nav-number">11.1.</span> <span class="nav-text">190_颠倒二进制位</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#191-位1的个数"><span class="nav-number">11.2.</span> <span class="nav-text">191_位1的个数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#201-数字范围按位与"><span class="nav-number">11.3.</span> <span class="nav-text">201_数字范围按位与</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#231-2-的幂"><span class="nav-number">11.4.</span> <span class="nav-text">231_2 的幂</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#258-各位相加"><span class="nav-number">11.5.</span> <span class="nav-text">258_各位相加</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#会员专属"><span class="nav-number">12.</span> <span class="nav-text">会员专属</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#156-上下翻转二叉树"><span class="nav-number">12.1.</span> <span class="nav-text">156_上下翻转二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#157-用Read4读取N个字符"><span class="nav-number">12.2.</span> <span class="nav-text">157_用Read4读取N个字符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#158-用Read4读取N个字符-ll"><span class="nav-number">12.3.</span> <span class="nav-text">158_用Read4读取N个字符_ll</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#159-至多包含两个不同字符的最长子串"><span class="nav-number">12.4.</span> <span class="nav-text">159_至多包含两个不同字符的最长子串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#161-相隔为1的编辑距离"><span class="nav-number">12.5.</span> <span class="nav-text">161_相隔为1的编辑距离</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#163-缺失的区间"><span class="nav-number">12.6.</span> <span class="nav-text">163_缺失的区间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#170-两数之和-lll-数据结构设计"><span class="nav-number">12.7.</span> <span class="nav-text">170_两数之和_lll-数据结构设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#186-翻转字符串里的单词-ll"><span class="nav-number">12.8.</span> <span class="nav-text">186_翻转字符串里的单词_ll</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#243-最短单词距离"><span class="nav-number">12.9.</span> <span class="nav-text">243_最短单词距离</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#244-最短单词距离-II"><span class="nav-number">12.10.</span> <span class="nav-text">244_最短单词距离_II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#245-最短单词距离-III"><span class="nav-number">12.11.</span> <span class="nav-text">245_最短单词距离_III</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#246-中心对称数"><span class="nav-number">12.12.</span> <span class="nav-text">246_中心对称数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#247-中心对称数-II"><span class="nav-number">12.13.</span> <span class="nav-text">247_中心对称数_II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#248-中心对称数-III"><span class="nav-number">12.14.</span> <span class="nav-text">248_中心对称数_III</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#249-移位字符串分组"><span class="nav-number">12.15.</span> <span class="nav-text">249_移位字符串分组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#250-统计同值子树"><span class="nav-number">12.16.</span> <span class="nav-text">250_统计同值子树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#251-展开二维向量"><span class="nav-number">12.17.</span> <span class="nav-text">251_展开二维向量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#252-会议室"><span class="nav-number">12.18.</span> <span class="nav-text">252_会议室</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#253-会议室-II"><span class="nav-number">12.19.</span> <span class="nav-text">253_会议室_II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#254-因子的组合"><span class="nav-number">12.20.</span> <span class="nav-text">254_因子的组合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#255-验证前序遍历序列二叉搜索树"><span class="nav-number">12.21.</span> <span class="nav-text">255_验证前序遍历序列二叉搜索树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#256-粉刷房子"><span class="nav-number">12.22.</span> <span class="nav-text">256_粉刷房子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#259-较小的三数之和"><span class="nav-number">12.23.</span> <span class="nav-text">259_较小的三数之和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#261-以图判树"><span class="nav-number">12.24.</span> <span class="nav-text">261_以图判树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#265-粉刷房子-II"><span class="nav-number">12.25.</span> <span class="nav-text">265_粉刷房子_II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#266-回文排列"><span class="nav-number">12.26.</span> <span class="nav-text">266_回文排列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#267-回文排列-II"><span class="nav-number">12.27.</span> <span class="nav-text">267_回文排列_II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#269-火星词典"><span class="nav-number">12.28.</span> <span class="nav-text">269_火星词典</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#270-最接近的二叉搜索树值"><span class="nav-number">12.29.</span> <span class="nav-text">270_最接近的二叉搜索树值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#271-字符串的编码与解码"><span class="nav-number">12.30.</span> <span class="nav-text">271_字符串的编码与解码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#272-最接近的二叉搜索树值-II"><span class="nav-number">12.31.</span> <span class="nav-text">272_最接近的二叉搜索树值_II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#276-栅栏涂色"><span class="nav-number">12.32.</span> <span class="nav-text">276_栅栏涂色</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#277-搜寻名人"><span class="nav-number">12.33.</span> <span class="nav-text">277_搜寻名人</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#280-摆动排序"><span class="nav-number">12.34.</span> <span class="nav-text">280_摆动排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#281-锯齿迭代器"><span class="nav-number">12.35.</span> <span class="nav-text">281_锯齿迭代器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#285-二叉搜索树中的中序后继"><span class="nav-number">12.36.</span> <span class="nav-text">285_二叉搜索树中的中序后继</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#286-墙与门"><span class="nav-number">12.37.</span> <span class="nav-text">286_墙与门</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#288-单词的唯一缩写"><span class="nav-number">12.38.</span> <span class="nav-text">288_单词的唯一缩写</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#291-单词规律-II"><span class="nav-number">12.39.</span> <span class="nav-text">291_单词规律_II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#293-翻转游戏"><span class="nav-number">12.40.</span> <span class="nav-text">293_翻转游戏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#294-翻转游戏-II"><span class="nav-number">12.41.</span> <span class="nav-text">294_翻转游戏_II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#296-最佳的碰头地点"><span class="nav-number">12.42.</span> <span class="nav-text">296_最佳的碰头地点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#298-二叉树最长连续序列"><span class="nav-number">12.43.</span> <span class="nav-text">298_二叉树最长连续序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#302-包括全部黑色像素的最小矩形"><span class="nav-number">12.44.</span> <span class="nav-text">302_包括全部黑色像素的最小矩形</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#305-岛屿数量-II"><span class="nav-number">12.45.</span> <span class="nav-text">305_岛屿数量 II</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#先后手"><span class="nav-number">13.</span> <span class="nav-text">先后手</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#292-Nim-游戏"><span class="nav-number">13.1.</span> <span class="nav-text">292_Nim 游戏</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#LCP"><span class="nav-number">14.</span> <span class="nav-text">LCP</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xingkang</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>-->

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  
    <span class="post-meta-divider">|</span>
  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>








        
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        <span>0%</span>
      </div>

    

  </div>

  
    
    
  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  <script defer src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/three.min.js"></script>
  <script defer src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/three-waves.min.js"></script>

<script src="/js/utils.js?v=7.3.0"></script><script src="/js/motion.js?v=7.3.0"></script>

<script src="/js/schemes/pisces.js?v=7.3.0"></script>



<script src="/js/next-boot.js?v=7.3.0"></script>




  















  <script src="/js/local-search.js?v=7.3.0"></script>














  

  

  


  
  <script src="/js/scrollspy.js?v=7.3.0"></script><script src="/js/post-details.js?v=7.3.0"></script>



<script>
NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(item => {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'sRNVqcnF35U8nhpCJgDOwolP-gzGzoHsz',
    appKey: 'XhlTNU47NOUz6faJnfb6bfxJ',
    placeholder: '发表点什么吧^-^',
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: '' || 'zh-cn',
    path: location.pathname
  });
}, window.Valine);
</script>




</body>

</html>

<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/clicklove.js"></script>

