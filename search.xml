<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Algorithm</title>
    <url>/2019/08/26/Algorithm/</url>
    <content><![CDATA[<p>Continually Updated.(Just Kidding)</p>
<a id="more"></a>

<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><ul>
<li><p>学习下</p>
</li>
<li><p>跟之前学的堆排序有点类似</p>
<ul>
<li>即拿数组来表示二叉树</li>
</ul>
</li>
<li><p>这里有个关键点，就是合并两个子集需要分为两步</p>
<ul>
<li>先分别找出两个节点的父节点 <code>find</code></li>
<li>再将这两个父节点联合 <code>unite</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>Data Structure and Algorithm——参考labuladong算法小抄</p>
</blockquote>
<ul>
<li>时间复杂度：总运算次数表达式中受n的变化影响最大的那一项(不含系数)</li>
<li>空间复杂度：临时占用存储空间大小的量度</li>
</ul>
<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><ul>
<li>经典十大排序算法</li>
<li>遇到哪个就先学哪个</li>
</ul>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><blockquote>
<p>速度快、效率高！</p>
</blockquote>
<ul>
<li>分治法；将一个数组分为两个部分，并且选择一个数字作为基数</li>
<li>菜鸟网站的代码看的有点蒙，先看书上怎么写的<ul>
<li>一个是主函数<code>QuickSort</code>、一个是分区函数<code>Paritition</code></li>
<li>主函数里面是将分区函数返回的一个索引（位置），来分成两个数组（不包括索引本身！），然后两个数组递归！</li>
<li>排序的主体在分区函数，所以主要看分区函数，是如何将小的大的分别放两边的！<ul>
<li><code>Paritition</code>函数参数——数组（指针）、数组长度、起始点、结束点</li>
<li>判断是否为空、长度为负、两个标记点在不在数组边界内</li>
<li>书上还用了随机数函数，用来在两个标记点之间取随机数，力扣上没有随机函数</li>
<li>有个问题，<code>int small = start - 1;</code>为什么要减一呢，如果为0，岂不是-1……没事了</li>
<li>先把基数与最后一位交换，之后遍历到倒数第二位，遍历的时候用<code>small</code>来记录最后一个小于基数的位置，初始值为<code>start - 1</code>；如果这个数比基数（<code>end</code>所在的数）大，什么也不干，下一个；如果这个数小，<code>++small；</code>，如果<code>small</code>与遍历的位置相等，说明前面没有大的数字，若不等，说明<code>small</code>指的是大的数，与小的数交换，之后下一个</li>
</ul>
</li>
<li>总结，<code>small</code>在交换之后，总是指向小的数字，遍历结束之后，要<code>++small</code>与基数交换，最后返回<code>small</code>，也就是基数的位置</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/Algorithm/partition.png" alt></p>
<p><img src="/pictrues/Algorithm/quicksort.png" alt></p>
<ul>
<li>冒泡排序类似，每次把小的放前面…</li>
<li>力扣写的似乎更牛批点<ul>
<li>基数就是<code>int pivot = A[low]</code>，然后右标记点左移，直到小于<code>pivot</code></li>
<li>此时<code>A[high]</code>是小数，然后交换，或者赋值<code>A[low] = A[high];</code></li>
<li>之后左标记点右移，直到大于<code>pivot</code>，然后赋值<code>A[high] = A[low];</code></li>
<li>一直赋值，最终<code>A[low] = pivot;</code>，返回<code>low</code>，代码就不放了</li>
</ul>
</li>
</ul>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><ul>
<li>这个排序还有点印象，Leetcode做过一两道<ul>
<li>隔了一段时间看这个，哪两道？</li>
<li>看图懂了，分治 + 递归，只有一个数字时，本身不需要排序，两个数字，就看谁大谁小，然后两个两个合并</li>
</ul>
</li>
</ul>
<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><ul>
<li></li>
</ul>
<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><ul>
<li>特点就是 n 个 0 到 k 之间的整数！<ul>
<li>先生成足够长的数组，将整数当成下标，对应的元素是整数的个数！</li>
<li>时间消耗可以达到线性！</li>
<li>菜鸟网站上没有C++的代码，这里就不粘贴了！</li>
</ul>
</li>
</ul>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><ul>
<li>看好几遍，加深印象</li>
<li>每一次都从头开始，但是每一次遍历的长度会越来愈短，因为每一次遍历都会将（遍历的长度内的）最大的数放在最后，最后的数字无需再次遍历</li>
</ul>
<p><img src="/pictrues/Algorithm/bubbleSort.png" alt title="冒泡排序"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void bubbleSort(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">	int len = nums.size();</span><br><span class="line">	for (int i = 0; i &lt; len; ++i) &#123;</span><br><span class="line">		for (int j = 0; j &lt; len - 1 - i; ++j) &#123;</span><br><span class="line">			if (nums[j] &gt; nums[j + 1])</span><br><span class="line">				swap(nums[j], nums[j + 1]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><ul>
<li><p>大根堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；</p>
</li>
<li><p>小根堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；</p>
</li>
<li><p>实质是给数组排序</p>
<ul>
<li>建堆和交换得好好理解下</li>
<li>堆化的顺序得从下往上（就是交换节点，确保父节点值大于等于子节点值）</li>
<li>而且容易错，对于大根堆，如果根小于叶子，必须逐级递归调整才行</li>
</ul>
</li>
<li><p>注意标号</p>
<ul>
<li>完全二叉树是从上往下、从左往右；就从 0 开始吧，根数组下标对应起来</li>
<li>对于某个标号 <code>i</code> 也就是数组里的下标<ul>
<li>该左节点的标号为 <code>2 * i + 1</code></li>
<li>该右节点的标号为 <code>2 * i + 2</code></li>
<li>同样，给出下标 <code>i</code> 的节点，其父节点为 <code>(i - 1) / 2</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/Algorithm/215.png" alt title="堆排序"></p>
<ul>
<li><p>一般来说从堆顶开始堆化，不能确保最后的顺序是正确的</p>
<ul>
<li>而是要从最后一个非叶节点倒序进行堆化（这是一个完全二叉树）</li>
<li>正确来说是最后一个节点的父节点开始！</li>
</ul>
</li>
<li><p>堆化确保所有父节点的值大于等于子节点值即可，而不是严格降序</p>
<ul>
<li>之后排序，就是把最大值和最后一个节点进行交换，然后隔开最后一个节点（个数减一即可），再进行堆化</li>
</ul>
</li>
</ul>
<hr>
<h1 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h1><ul>
<li><p>这里参考labuladong的算法小抄；自己也是经常掉坑，知其然不知其所以然！</p>
</li>
<li><p>系统的复习一遍——可以分为三类</p>
</li>
<li><p>首先有个很有用的点，记录下——如何防止整数溢出</p>
<p><code>int mid = left + (right - left) / 2;</code></p>
</li>
<li><p>关键点在于 搜索区间 ，这样就不会漏解</p>
</li>
</ul>
<h2 id="寻找一个数"><a href="#寻找一个数" class="headerlink" title="寻找一个数"></a>寻找一个数</h2><ul>
<li>代码是用java写的，我用C++修改下</li>
<li>这里的<code>while</code>条件是小于等于；最后返回的是-1；而且<code>mid</code>都进行了加减一操作</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int binarySearch(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">    int left = 0;</span><br><span class="line">    int right = nums.size() - 1; // 注意</span><br><span class="line"></span><br><span class="line">    // 这里是闭区间[left, right]，而不是开区间！因为right是索引（长度减一）</span><br><span class="line">    // 访问区间为空时，停止寻找！</span><br><span class="line">    while(left &lt;= right) &#123;</span><br><span class="line">        int mid = left + (right - left) / 2;</span><br><span class="line"></span><br><span class="line">        if(nums[mid] == target)</span><br><span class="line">            return mid;</span><br><span class="line"></span><br><span class="line">        else if (nums[mid] &lt; target)</span><br><span class="line">            left = mid + 1; // 注意，已经搜索到的数字应该从区间去掉</span><br><span class="line"></span><br><span class="line">        else if (nums[mid] &gt; target)</span><br><span class="line">            right = mid - 1; // 注意，已经搜索到的数字应该从区间去掉</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果<code>while</code>条件去掉<code>=</code>，带个具体的数字进去如[2, 2]，这时候区间不空，还有个数字2，但此时 while 循环终止<ul>
<li>但是这么写，可以加个补丁</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/Algorithm/less.png" alt title="补丁"></p>
<ul>
<li>如果<code>mid</code>只有加一或者只有减一；那就是左边界以及右边界了<ul>
<li>这里是指有序数组中具有多个<code>target</code>；举个栗子</li>
<li>nums = [1,2,2,2,3] target为2</li>
</ul>
</li>
</ul>
<h2 id="寻找左侧边界"><a href="#寻找左侧边界" class="headerlink" title="寻找左侧边界"></a>寻找左侧边界</h2><ul>
<li>还是直接截图方便点！</li>
<li>这里的<code>right</code>写成长度而不是减一是具有普遍性的<ul>
<li>返回的是<code>left</code>，是指小于<code>target</code>的个数有几个！最小的值是0</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/Algorithm/left_border.png" alt title="左边界"></p>
<ul>
<li>分成两个区间</li>
</ul>
<p><img src="/pictrues/Algorithm/left_border1.png" alt title="两个区间"></p>
<ul>
<li>右端找到<code>target</code>时，没有立即返回！</li>
</ul>
<h2 id="寻找右侧边界"><a href="#寻找右侧边界" class="headerlink" title="寻找右侧边界"></a>寻找右侧边界</h2><ul>
<li>左端找到<code>target</code>时，没有立即返回！</li>
</ul>
<p><img src="/pictrues/Algorithm/right_border.png" alt title="右边界"></p>
<blockquote>
<p>最后总结下——判断条件都写成<code>else if</code>，最后一个<code>else</code>也要这样写，防止漏解！</p>
</blockquote>
<hr>
<h1 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h1><ul>
<li>这个应该放在动态规划下面，不过动态规划还没有整理，就先这样吧！</li>
<li>关键词——重量、价值</li>
<li>以下三类区别——（不一定满，价值最大）、（恰好装满，能或不能）、（恰好装满，一共多少种类）</li>
</ul>
<h2 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h2><ul>
<li>要么装进背包里，要么不装——非0即1</li>
<li>状态<ul>
<li>状态有两个，就是「背包的容量」和「可选择的物品」</li>
</ul>
</li>
<li>选择<ul>
<li>「装进背包」或者「不装进背包」</li>
</ul>
</li>
<li>套框架</li>
</ul>
<p><img src="/pictrues/Algorithm/01_backpack.png" alt title="0-1背包"></p>
<ul>
<li>明确dp数组的定义<ul>
<li>状态有两个，所以是两维——一维表示可选择的物品，一维表示背包的容量。</li>
<li><code>dp[i][w]</code>的定义如下：对于前<code>i</code>个物品，当前背包的容量为<code>w</code>，这种情况下可以装的最大价值是<code>dp[i][w]</code>。</li>
<li>这么定义，便于状态转移。别问，问就是不会！</li>
<li>最终答案就是最后一行最后一列的数</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/Algorithm/01_backpack1.png" alt title="0-1背包"></p>
<ul>
<li>之后关键点在于，选择了这个物体，转移方程是什么，对应的重量要减去这个物体——即在装第<code>i</code>个物品的前提下，背包能装的最大价值是多少</li>
</ul>
<blockquote>
<p>注意，这里背包的容量不一定是满的，而且物品有限</p>
</blockquote>
<h2 id="子集背包问题"><a href="#子集背包问题" class="headerlink" title="子集背包问题"></a>子集背包问题</h2><ul>
<li>这里就不是价值最大了，而是能不能！</li>
<li>因为分为两个子集，要让这两个子集总和相等，那就背包容量就是总和的一半</li>
</ul>
<p><img src="/pictrues/Algorithm/01_backpack2.png" alt title="0-1背包变体"></p>
<ul>
<li>这里动态规划的矩阵，也就变成了布尔值！但是也有共性，<code>dp[i][j]</code>就是只对前<code>i</code>个数进行取值</li>
<li>因为物品有限，这个数取完了，那么状态转移的时候，就变成了<code>dp[i - 1][j-nums[i-1]]</code>——如果物品无限，也就是完全背包，这个取走之后还有这个数，神不神奇！那就是<code>dp[i][j-nums[i-1]]</code></li>
</ul>
<p><img src="/pictrues/Algorithm/01_backpack3.png" alt title="是dp[i-1]而不是dp[i]"></p>
<ul>
<li>框架如下</li>
</ul>
<p><img src="/pictrues/Algorithm/01_backpack4.png" alt title="0-1背包变体框架"></p>
<ul>
<li>状态压缩！后序遍历是因为每个物品（数字）只能使用一次，以免之前的结果影响其他的结果——然而完全背包就不需要后序遍历了，因为物品无限，结果不影响</li>
</ul>
<p><img src="/pictrues/Algorithm/01_backpack5.png" alt title="状态压缩"></p>
<blockquote>
<p>注意，这里背包的容量必须是满的，而且物品有限</p>
</blockquote>
<h2 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h2><ul>
<li>区别是每个物品的数量无限；而且一般来讲，题目都会问给定容量（重量），然后恰好等于容量（重量）的物品种类！比如兑换硬币</li>
<li>但是，要会举一反三<ul>
<li>比如<a href="https://leetcode-cn.com/problems/perfect-squares/" target="_blank" rel="noopener">279.平方数</a>这题，这里就不是问多少种了，而是问最少的个数</li>
<li>因此，状态转移也会变，不是直接相加了——而是比较哪个小，对应的<code>dp[i][j]</code>含义也不一样，这里是最小的个数</li>
<li>最重要的就是边界，这决定了后面的状态！</li>
</ul>
</li>
<li>这里直接放代码了，与前两个背包问题相比，有两个注意点——<code>dp[i][j-nums[i-1]]</code>、正序遍历</li>
</ul>
<p><img src="/pictrues/Algorithm/01_backpack6.png" alt title="完全背包"></p>
<ul>
<li>状态压缩——这里的<code>if</code>也可以直接写在<code>for</code>循坏的条件里</li>
</ul>
<p><img src="/pictrues/Algorithm/01_backpack7.png" alt title="状态压缩"></p>
<blockquote>
<p>注意，这里背包的容量必须是满的，而且物品无限</p>
</blockquote>
]]></content>
      <categories>
        <category>Data structure and algorithm</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
        <tag>二分法</tag>
        <tag>背包问题</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp Projects</title>
    <url>/2021/07/12/Cpp-Projects/</url>
    <content><![CDATA[<p>Learning C++ Projects Record!!</p>
<a id="more"></a>

<blockquote>
<p>项目边做边学</p>
</blockquote>
<h1 id="安全传输项目"><a href="#安全传输项目" class="headerlink" title="安全传输项目"></a>安全传输项目</h1><h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><ul>
<li><p>应用场景</p>
<ul>
<li>文件加密、数据加密。</li>
</ul>
</li>
<li><p>密钥分发困难、不安全但是速度快、效率高</p>
</li>
<li><p>解决方法</p>
<ul>
<li>解密端与加密端，要确保这两个密钥密钥一样，不能直接发送密钥</li>
<li>而是各自发送一部分字符给对方，两者结合，再用固定的算法生成相同的密钥</li>
<li>解密端与加密端要建立通路 —— 套接字通信（用来分发密钥）</li>
</ul>
</li>
<li><p>相同的密钥产生之后是用来加密的，也就是说生成之后需要存储</p>
<ul>
<li>若是存在数据库，则打开、关闭数据库，效率太低（多次访问的话）</li>
<li>应该存在内存，然后应用程序在内存之间读取，实质是进程间通信！<ul>
<li>管道、信号、mmap、socket</li>
<li>mmap 最简单，直接用共享内存、提高访问效率</li>
</ul>
</li>
</ul>
</li>
<li><p>既然是对称加密，则两端要定期生成随机数、算法也要换！</p>
<ul>
<li>但是老的密钥要保存，这里可以用到数据库（持久化存储）、必须得做</li>
</ul>
</li>
</ul>
<h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><ul>
<li><p>应用场景</p>
<ul>
<li>进行身份鉴别、密钥保护。</li>
</ul>
</li>
<li><p>公钥、私钥</p>
</li>
</ul>
<blockquote>
<p>加密的过程不影响业务的逻辑，只是提供两个接口（不管内部怎么实现）<br>两个函数（一个加密、一个解密）</p>
</blockquote>
<h2 id="网点管理终端（界面）"><a href="#网点管理终端（界面）" class="headerlink" title="网点管理终端（界面）"></a>网点管理终端（界面）</h2><ul>
<li>类似于星型拓扑，中心节点或者总终端需要记录各个分端的编号、授权码之类的信息，防止其他恶意终端来接入、窃取信息或者更新已有（暂时）不能用的分端</li>
<li>curd<ul>
<li>增删改查操作</li>
</ul>
</li>
</ul>
<h2 id="其余注意点"><a href="#其余注意点" class="headerlink" title="其余注意点"></a>其余注意点</h2><ul>
<li><p>主要传输数据的进程需要用到接口来进行加密、解密</p>
</li>
<li><p>加密过程的两端（加密端、解密端）会定期使用不同的 IP 地址以及端口号（不能不会一直不变）</p>
<ul>
<li>这里也需要管理界面——管理服务器配置信息！之前的界面可以合在一起</li>
</ul>
</li>
<li><p>没有业务逻辑的界面模块</p>
<ul>
<li>客户端（解密端）不需要数据库、需要共享内存</li>
</ul>
</li>
<li><p>项目划分哪些子系统（模块）、各个模块之间如何进行业务通信</p>
</li>
<li><p>负责的模块中包含哪些技术点、碰到过什么问题以及解决的思路</p>
</li>
<li><p>该问题对项目开发构成哪些影响、对后续开发的影响。</p>
</li>
<li><p>win10 数据库连接器有点问题</p>
<ul>
<li>这里在 CentOS8 安装下 MySQL，为了一致，就暂时不用 Ubuntu 的环境了</li>
<li></li>
</ul>
</li>
</ul>
<h2 id="编码、解码"><a href="#编码、解码" class="headerlink" title="编码、解码"></a>编码、解码</h2><ul>
<li><p>为什么要进行这一步？</p>
</li>
<li><p>客户端要发送随机数给服务端、服务端也要发送给随机数给客户端；两者结合形成密钥</p>
<ul>
<li>其中服务端在 Linux 系统较好（安全、稳定），但是客户端得满足多个平台</li>
<li>socket 函数应该跨平台（这里类似于网络编程里的通用地址结构）（32 位、64 位）</li>
<li>解决思路：把所有类型数据转为字符串<ul>
<li>需要一定的格式进行储存。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><ul>
<li>TLV 格式<ul>
<li>基本上是通过值-结果参数（指针的指针）来获得编码后的结果</li>
<li>而函数的返回值（整形）是用来判断编码是否成功，例如分配内存报错等等</li>
<li>若报错，则用日志库的函数进行输出记录！</li>
<li>这里面有个技巧，若每次判断返回值是否成功都写在主函数里，会变得啰嗦，可以再写一个包裹函数（包括了判断），直接调用包裹函数即可</li>
</ul>
</li>
</ul>
<h3 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h3><ul>
<li>就是将一整个 TLV 嵌套的数据类型依次取出对应的数据</li>
<li>因为原数据是一个结构体，里面有几种类型的数据，在此之间要先给结构体分配空间<ul>
<li>若结构体内有指针（没有对应指向的空间）那么默认会分配一个字节的大小用来储存地址，这时另需分配额外的空间来存储（解码后的）内容</li>
</ul>
</li>
</ul>
<h3 id="内存释放"><a href="#内存释放" class="headerlink" title="内存释放"></a>内存释放</h3><ul>
<li><p>这里有个技巧</p>
<ul>
<li>一般来说，大多数函数里都会进行分配内存、释放内存的操作（手动调用），这些在函数外部是看不出来的</li>
<li>主要是从函数的参数（传出参数、指针的指针）进行判断<ul>
<li>若传出失败，只需要判断其余参数是否需要释放内存即可</li>
</ul>
</li>
</ul>
</li>
<li><p>不用了就释放</p>
<ul>
<li>除了结构体本身占据一定空间之外，包含的指针也会指向一片空间，需要释放</li>
<li>有点类似于释放链表，但是节点也有指针需要释放</li>
</ul>
</li>
<li><p>同时需要注意临时变量以及要输出的变量</p>
<ul>
<li>若输出成功，则临时变量开辟的空间也需要释放</li>
</ul>
</li>
</ul>
<ul>
<li><p>有一个问题</p>
<ul>
<li><code>void freeXXX (T *t)</code>、<code>void freeXXX (T **t)</code> 哪个好</li>
<li>视频上是说第二个好，因为可以赋值？？？没理解。。。</li>
<li>如果是内置类型的变量，可以直接强制转换为指针，比如 <code>int</code> 类型，传过去之后再强转回来</li>
<li>如果是结构体，那么必须得取地址再转为 <code>void *</code> 或者 <code>void **</code> 类型</li>
</ul>
</li>
<li><p>还有，结构体参数一般都是指针传递</p>
</li>
</ul>
<h3 id="统一上面三个函数"><a href="#统一上面三个函数" class="headerlink" title="统一上面三个函数"></a>统一上面三个函数</h3><ul>
<li><p>上面三个标题其实是三个函数</p>
<ul>
<li>对每种结构体来说，都需要有这三个函数</li>
<li>所以需要将这三个函数进行统一，使得对任意的结构体都能进行上述三个操作</li>
<li>emmmm，有点偏差，大意是一致的，需要封装接口<ul>
<li>对用户来说，只要三件事：编码、解码、释放</li>
</ul>
</li>
</ul>
</li>
<li><p><code>int TeacherEncode(Teacher *pThecher, unsigned char **out, int *outlen)</code></p>
</li>
<li><p><code>int MsgEncode(void *pMsg, unsigned char **out, int *outlen, int type)</code></p>
<ul>
<li>注意上面两个函数的区别</li>
<li>对每种结构体编号，类型要改为 <code>void *</code></li>
</ul>
</li>
<li><p>应用到服务端、客户端进行通信上（加密-协商、校验、注销、查看）（也可以说这四个结构体）也可以直接用 <code>type</code> 进行描述</p>
<ul>
<li>那么结构体应包含服务端 id、客户端 id、随机数这些基本的内容</li>
</ul>
</li>
<li><p>这里需要注意下</p>
<ul>
<li>除了对结构体 TLV 链表进行封装外、还需对 type TLV 进行封装！</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/Projects/secure_/MsgEncode.png" alt title="MsgEncode"></p>
<ul>
<li>这里面得用 <code>switch</code> 好一点<ul>
<li>应为客户端请求可能是协商、校验、注销、查看这里面的一种！</li>
</ul>
</li>
</ul>
<h2 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h2><h3 id="win10"><a href="#win10" class="headerlink" title="win10"></a>win10</h3><ul>
<li><p>这里是对上面的编码接口来制作动态库</p>
</li>
<li><p>win10 系统 VS2019</p>
<ul>
<li>因为函数是用 C 写的，但是默认预编译头是 C++ 的</li>
<li>为了方便我直接取消预编译了！</li>
<li>制作动态库的时候，无论是 <code>.h</code>、<code>.c</code> 文件，都需要在函数名（这里只需三种函数，即统一的编码、解码、内存释放，其余的不需要！）前添加 <code>__declspec(dllexport)</code></li>
<li>最后制作成功有两个文件 <code>.dll</code>、<code>.lib</code> (上一级目录的 Debug 里)</li>
</ul>
</li>
<li><p>测试的时候，除了库文件，头文件也需要（封装接口后的头文件，一个）</p>
<ul>
<li>这个头文件的函数之前不需要添加 <code>__declspec(dllexport)</code></li>
<li>xxxx.lib  —&gt; .c 源码 .h 头文件所在目录位置（必须）</li>
<li>xxxx.dll —&gt; .exe 可执行文件所在目录位置（非必须）</li>
<li>都放在同一个目录也可以，到时候需要在连接器里面添加 <code>.lib</code> 依赖项</li>
</ul>
</li>
</ul>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ul>
<li><p>这里之前对网络（系统）编程那边有过接触动态库的制作</p>
<ul>
<li><code>-fPIC</code> 生成与位置无关的代码 <code>gcc -c *.c -fPIC</code></li>
<li><code>gcc -shared  -o lib库名.so *.o</code></li>
<li>之后把 .so 文件放入 当前目录的 lib 文件夹下（要创建）</li>
<li>~/.bash_profile 这个配置文件似乎 Ubuntu、CentOS 不一样</li>
</ul>
</li>
<li><p>这是 Ubuntu 下的</p>
</li>
</ul>
<p><img src="/pictrues/Projects/secure_/libpath.png" alt title="LD_LIBRARY_PATH"></p>
<ul>
<li>写入 .bash_profile 是最有效的<ul>
<li>添加以下代码</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">umask 022</span><br><span class="line"></span><br><span class="line">PATH=$PATH:$HOME/bin</span><br><span class="line"></span><br><span class="line">LD_LIBRARY_PATH=./lib:$HOME/lib:/usr/lib</span><br><span class="line">export LD_LIBRARY_PATH PATH</span><br></pre></td></tr></table></figure>

<ul>
<li>这里写完之后要 <code>source .bash_profile</code> 刷新一下</li>
<li>再重开一个终端 <code>ldd a.out</code> 查看<ul>
<li>接下来在 CentOS 下测试看看</li>
</ul>
</li>
<li><code>gcc main.c -o a.out -L ./lib/ -lmymsg -I ./inc/</code></li>
</ul>
<h3 id="释放内存"><a href="#释放内存" class="headerlink" title="释放内存"></a>释放内存</h3><ul>
<li>动态库内存释放：遵循一个原则：谁分配，谁释放。</li>
<li>调用动态库函数分配的内存，也一定要调用动态库函数来释放内存。</li>
</ul>
<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><ul>
<li>若不用动态库，直接将所有的 .h、.c 文件放在同一目录下<ul>
<li><code>gcc *.c -o a.out</code> 这样也是可以运行的！</li>
<li>若直接写成这样的 makefile 那么修改一个文件，所有的文件都需要重新编译！</li>
<li>解决方法：可以先一个一个生成 .o 文件（预处理、编译、汇编），再将 .o 文件生成最终的 a.out（链接）</li>
<li><code>make clean -n</code> 模拟执行</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/Projects/secure_/makefile.png" alt title="makefile"></p>
<ul>
<li><p>规则</p>
<ul>
<li>目标：依赖</li>
<li>命令</li>
</ul>
</li>
<li><p>函数</p>
<ul>
<li><code>$(wildcard *.c)</code>:    获取指定类型特征的文件</li>
<li><code>$(patsubst %.c， %.o， $(src))</code>: 将参数3 中，包含参数1的部分，替换成参数2。</li>
</ul>
</li>
<li><p>自动变量</p>
<ul>
<li><code>$@</code>:    在规则的 命令中， 表示目标。</li>
<li><code>$^</code>:    在规则的 命令中， 表示 所有依赖条件</li>
<li><code>$&lt;</code>:    在规则的 命令中， 表示 第一个依赖条。 如果是模式规则，会将依赖条件依次取出。 执行命令。</li>
</ul>
</li>
<li><p>模式规则</p>
</li>
<li><p>%.o: %.c</p>
<ul>
<li>gcc -c $&lt; -o $@</li>
</ul>
</li>
<li><p>自动化思想</p>
</li>
</ul>
<p><img src="/pictrues/Projects/secure_/makefile1.png" alt title="makefile"></p>
<p><img src="/pictrues/Projects/secure_/phony.png" alt title="伪目标"></p>
<p><img src="/pictrues/Projects/secure_/phony1.png" alt title="伪目标"></p>
<ul>
<li>静态模式规则：指定，针对某一个变量，使用特定的模式规则。<ul>
<li><code>$(obj):%.o:%.c</code></li>
<li><code>gcc -c $&lt; -o $@</code></li>
</ul>
</li>
</ul>
<h3 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h3><ul>
<li><p>以上是将所有文件都存放在一个目录下，显得有些乱！</p>
</li>
<li><p>同样创建文件夹</p>
<ul>
<li>inc、src、obj</li>
</ul>
</li>
<li><p>要对之前的 makefile 进行读取路径</p>
<ul>
<li>所有的相对路径是相对于 makefile 来说的</li>
<li>要在对应的文件里添加路径，要仔细，不能漏 /</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/Projects/secure_/makefile2.png" alt title="makefile"></p>
<h2 id="数据通信"><a href="#数据通信" class="headerlink" title="数据通信"></a>数据通信</h2><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul>
<li>主要是设计下有哪些接口（运用线程池、句柄）<ul>
<li>句柄是用来使用、放回描述符的</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/Projects/secure_/sockpool.png" alt title="数据通信接口"></p>
<ul>
<li><p>试着将一些 .h、.c 文件编译了下</p>
<ul>
<li>发现不用动态库方法（makefile）怎么也链接不了（未定义的引用）</li>
<li>后来发现是 <code>pthread.h</code> 这个库的问题，得用 <code>-lpthread</code> 而且得放在 .o 之后！</li>
<li>还是得老老实实用动态库的方法来编译！</li>
</ul>
</li>
<li><p>记录下遇到的问题</p>
<ul>
<li>首先是 makefile 代码</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">src = $(wildcard *.c)</span><br><span class="line">obj = $(patsubst %.c, %, $(src))</span><br><span class="line"></span><br><span class="line">ALL:$(obj)</span><br><span class="line"># 注意 -lpthread </span><br><span class="line">CFLAGS = -Wall -g -lpthread </span><br><span class="line"># 这里需要这个动态库</span><br><span class="line">LIBNAME = -litcastsocket</span><br><span class="line"># 这里是动态库所在的路径，注意这里的路径与 ~/.bash_profile 里的路径有所不同</span><br><span class="line">LIBFLAGS = -L$(HOME)/lib</span><br><span class="line"></span><br><span class="line">$(obj):%:%.c</span><br><span class="line">	gcc $&lt; -o $@ $(CFLAGS) $(LIBNAME) $(LIBFLAGS)</span><br><span class="line">	</span><br><span class="line">clean:</span><br><span class="line">	-rm -rf $(obj)</span><br><span class="line">	</span><br><span class="line">PHONY: ALL clean</span><br></pre></td></tr></table></figure>

<ul>
<li><p>~/.bash_profile 里的动态库路径是在可执行文件运行时需要用到的，而 makefile 里的路径时制作可执行文件要用到的</p>
</li>
<li><p>测试客户、服务端的时候是在两个虚拟机里</p>
<ul>
<li>一个是服务端的 IP 地址需要改一下，服务端的防火墙也需要关闭</li>
<li>之后测试就没问题了</li>
</ul>
</li>
</ul>
<ul>
<li>若是觉得发送数据太快<ul>
<li>可以 <code>sleep()</code> 个几秒钟，但最好两边都 <code>sleep()</code> 一下</li>
</ul>
</li>
</ul>
<h3 id="多线程测试（连接池）"><a href="#多线程测试（连接池）" class="headerlink" title="多线程测试（连接池）"></a>多线程测试（连接池）</h3><ul>
<li><p>这里客户端 .c 文件跑不通，服务端倒是没问题</p>
<ul>
<li>我感觉动态库文件有问题！</li>
<li>主函数一直在报错，神奇的是没有 log 库输出？？？</li>
<li>原来是有两处 IP 地址，我只改了一处！！！</li>
</ul>
</li>
<li><p>还得再改改，到底哪里出了问题</p>
<ul>
<li>makeflie 文件里有将 libitcastsocket.so 复制到 <code>$(HOME)/lib</code> 下里，但是我没有！</li>
<li>试了之前跑过的 clent.c 文件发现链接不上，顿时心肺骤停0.0</li>
<li>焯！！！原因在于服务端防火墙没关！！！</li>
</ul>
</li>
</ul>
<ul>
<li>注意点</li>
<li>指针做函数参数<ul>
<li>函数返回值（传出参数）</li>
<li>在 A 栈空间内修改 B 栈空间变量值</li>
<li>回调函数</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/Projects/secure_/stack.png" alt title="指针传参问题"></p>
<ul>
<li>内存冗余法解决<ul>
<li>对应每个线程都用 malloc 新的（堆）内存来读取对应的数值</li>
<li>若是传递一般类型的变量，可以直接强转（void *）指针，这也是一种解决方法</li>
</ul>
</li>
</ul>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><ul>
<li>特征<ul>
<li>IPC（进程间通信）</li>
<li>管道 pipe：简单，只能在有血缘关系的进程间通信。</li>
<li>命名管道 fifo：在无血缘关系的进程间通信，内部数据只能读一次。</li>
<li>mmap：在无血缘关系的进程间通信。内部数据支持反复读取。</li>
<li>信号：开销小，携带数据简单。</li>
<li>本地 socket： 稳定性最好，实现复杂。</li>
<li>shared memory ： 类似于 mmap。  效率最高IPC。</li>
</ul>
</li>
</ul>
<ul>
<li>mmu<ul>
<li>物理内存、虚拟内存的映射关系</li>
<li>虚拟地址不存在（哪怕虚拟地址一样，物理地址也不一样（用户空间：0-3G））</li>
<li>内核空间映射：映射的物理地址是一样的，因为只有一个操作系统，也就只有一个内核，通过 PCB（描述符）来区分不同的进程</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/Projects/secure_/shared_mem.png" alt title="共享内存映射"></p>
<ul>
<li>常用 API <ul>
<li><code>int shmget(key_t key, size_t size, int shmflg);</code></li>
<li><code>void *shmat(int shmid, const void *shmaddr, int shmflg);</code></li>
<li><code>int shmdt(const void *shmaddr);</code></li>
<li><code>int shmctl(int shmid, int cmd, struct shmid_ds *buf);</code></li>
</ul>
</li>
</ul>
<ul>
<li>共享内存需要脚本去删（杀掉）<ul>
<li>不是，还好，不需要像视频那样 <code>ipcrm -m shm_id</code> 即可</li>
<li><code>ipcs</code> 查看</li>
</ul>
</li>
</ul>
<ul>
<li>多个进程使用同一个共享内存的时候<ul>
<li>其中一个进程关闭 <code>shmctl()</code> 内存的时候，只是 ‘mark’ 了一下，并没有真正的关闭内存</li>
<li>其次，共享内存的 key 会变为 0x0000 变成私有的，新的进程无法再次使用这片内存</li>
<li>引用计数会减一，为 0 会真正删除这个共享内存。</li>
</ul>
</li>
</ul>
<ul>
<li><p>Linux 内核管理共享内存的方法</p>
<ul>
<li>key 值 + 引用计数 技术。</li>
</ul>
</li>
<li><p>注</p>
<ul>
<li>socket 池是用用来拓展知识面的，实际用不到</li>
</ul>
</li>
</ul>
<h2 id="日志库"><a href="#日志库" class="headerlink" title="日志库"></a>日志库</h2><ul>
<li><p>要用守护进程</p>
</li>
<li><p>测试了下输出的日志</p>
<ul>
<li>一直在纳闷为什么没有 ~/log 这个目录</li>
<li>创建文件 <code>&quot;%s/log/%s&quot;, getenv(&quot;HOME&quot;), &quot;keymngclient.log&quot;</code>、<code>open(fileName, O_WRONLY|O_CREAT|O_APPEND, 0666);</code> 函数也没有问题</li>
<li>后来才知道。。。要先创建目录哈哈哈哈</li>
</ul>
</li>
</ul>
<h2 id="整合模块"><a href="#整合模块" class="headerlink" title="整合模块"></a>整合模块</h2><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><ul>
<li><p>这里要用到之前的动态库制作方法，顺便复习下</p>
<ul>
<li>注意，环境变量我只添加了当前目录的 lib 文件夹下，所以可执行文件所在的目录需要 lib 文件夹，且里面得有动态库文件</li>
<li>不过我记得有了动态库是不需要实现文件的，不过也确实，这两个动态库是在其他地方拷贝而来的，没有用到实现文件。</li>
</ul>
</li>
<li><p><code>-pthread</code></p>
<ul>
<li>又遇到问题了，之前是通过 makefile 来连接动态库的</li>
<li>跌跌撞撞又成功了</li>
</ul>
</li>
<li><p>一个 <code>client</code> 一个 <code>server</code> 如何成功生成可执行文件，总结一下</p>
</li>
<li><p>依赖关系不能少，这两个都需要三个 .c 文件进行链接，我之前少了一个</p>
</li>
<li><p>最好不要用 <code>gcc *.c -o server -lpthread ...</code> 因为前后存在依赖关系，老老实实写全了</p>
</li>
<li><p>目录树 <code>inc</code>、<code>lib</code>、<code>src</code> 然后切换到 <code>src</code> 目录下</p>
<ul>
<li>client</li>
<li>因为 lib 下有两个动态库文件了，所以编译只需一行命令即可</li>
<li><code>gcc keymngclient.c keymngclientop.c keymnglog.c -o client -L../lib -litcastsocket -lmessagereal -I../inc</code></li>
<li>生成的 client 可执行文件在 src 目录下，因为动态库路径我只添加了当前目录下的 lib 文件夹，所以需要移到上一层目录下才能执行。</li>
<li>server</li>
<li><code>gcc keymnglog.c keymngserverop.c keymngserver.c -o server -lpthread -litcastsocket -lmessagereal -I../inc -L../lib</code></li>
</ul>
</li>
<li><p>这里为了方便，IP 地址为本地地址，之后在多台服务器上测试需要修改一下</p>
</li>
</ul>
<h3 id="共享内存函数接口"><a href="#共享内存函数接口" class="headerlink" title="共享内存函数接口"></a>共享内存函数接口</h3><ul>
<li><p>上面编译的缺少将数据放入共享内存、放入数据库这两个操作</p>
<ul>
<li>只是确保客户端、服务端之间的通信、编解码、密钥、业务处理没问题</li>
</ul>
</li>
<li><p>接下来设计共享内存函数</p>
<ul>
<li>不能直接把 密钥 单独放入共享内存，之后取出的时候不知道取哪个</li>
<li>而是要附加很多信息（结构体），比如 客户 ID、服务器 ID、密钥的编号</li>
</ul>
</li>
</ul>
<h2 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h2><ul>
<li>不占用控制终端。不随用户的注销而结束、退出。</li>
</ul>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><ul>
<li>fork 子进程， 父进程 exit</li>
<li>子进程调用 <code>setsid()</code> 创建新会话，成为会长。进程组组长、子进程 pid</li>
</ul>
<h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><ul>
<li>成 一系列 shell 命令，组织到一个文件中，统一运行。</li>
<li>第一行： 指定解析器。  <code>#！/bin/bash   /bin/shell</code></li>
<li><code>awk</code> 处理列、<code>sed</code> 处理行 </li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"></span><br><span class="line">userN=`whoami`</span><br><span class="line"></span><br><span class="line">mypid=`ps -u <span class="variable">$&#123;userN&#125;</span> | grep keymngserver | awk <span class="string">'&#123;print $1&#125;'</span>`</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="variable">$&#123;mypid&#125;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"The process is not started."</span></span><br><span class="line">        <span class="built_in">exit</span> 1;</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">kill</span> -9 <span class="variable">$&#123;mypid&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"kill keymngserver successful"</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="异步日志库"><a href="#异步日志库" class="headerlink" title="异步日志库"></a>异步日志库</h1><ul>
<li><p>日志还是很重要的，上面这几个项目都用到了日志库</p>
<ul>
<li>遇到出错的情况是通过日志库里的函数或者宏来进行输出，而不是简单的 <code>printf</code> 或者 <code>cout</code></li>
</ul>
</li>
<li><p>上面的日志具有相似性</p>
<ul>
<li>都具有不同的输出级别 <code>LogLevel</code></li>
</ul>
</li>
</ul>
<h1 id="SimpleNES"><a href="#SimpleNES" class="headerlink" title="SimpleNES"></a>SimpleNES</h1><ul>
<li><p>这个是要下载rom(<a href="https://romsmania.cc/roms/nintendo/super-mario-bros-242404" target="_blank" rel="noopener">下载地址</a>，top10里都可以下)的，也使用了SFML库、C++11的基本语法和STL库</p>
<ul>
<li>使用了SFML的Graphics和System部分用于图像界面的显示和键盘的控制。</li>
<li>使用cmake进行编译管理</li>
</ul>
</li>
<li><p>这个项目类似于模拟器——红白机模拟</p>
<ul>
<li>这里再放下<a href="http://nesdev.com/" target="_blank" rel="noopener">NES的开发资料</a></li>
<li>下载rom的时候，选择slowest版本</li>
</ul>
</li>
</ul>
<h2 id="环境、编译"><a href="#环境、编译" class="headerlink" title="环境、编译"></a>环境、编译</h2><ul>
<li>Ubuntu</li>
<li>安装SFML库</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libsfml-dev</span><br><span class="line"># 下载，也可以放到Gitee来下</span><br><span class="line">git clone git@github.com:amhndu/SimpleNES.git</span><br><span class="line"></span><br><span class="line">cd SimpleNES</span><br><span class="line">mkdir build/ &amp;&amp; cd build/</span><br><span class="line">cmake -DCMAKE_BUILD_TYPE=Release ..</span><br><span class="line">make -j4   # Replace 4 with however many cores you have to spare</span><br></pre></td></tr></table></figure>

<ul>
<li>运行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 直接在build里运行，后面的文件就是自己下载的rom了</span><br><span class="line">./SimpleNES ~/Games/SuperMarioBros.nes</span><br><span class="line"># 设置窗口大小</span><br><span class="line">./SimpleNES -w 800 ~/Games/Contra.nes</span><br></pre></td></tr></table></figure>

<ul>
<li>Readme文件都有操作教程，WASD啥的</li>
</ul>
<h2 id="看代码"><a href="#看代码" class="headerlink" title="看代码"></a>看代码</h2><ul>
<li><p>20多个文件，先看一遍</p>
<ul>
<li>一般在项目里是不用<code>using namespace std;</code>的，都是写完整了</li>
<li><code>sf::</code>是SFML库里的，其余头文件里的定义基本上都在命名空间<code>sn::</code>里</li>
<li>去SFML官网看了下，都是hpp文件，没看到cpp文件，不知道具体是怎么定义的</li>
</ul>
</li>
<li><p>C++的文件输出输入流，有点傻傻分不清！</p>
</li>
</ul>
<h3 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a>main.cpp</h3><ul>
<li>这是运行的入口</li>
<li>里面有个<code>for</code>循环，<code>main</code>函数的参数<code>char** argv</code>，第一个是程序的名字，所以从<code>i=1</code>开始遍历<ul>
<li>看到<code>--help</code>就知道原来是这样！怪不得输入这个会弹出帮助信息！！</li>
<li><code>./SimpleNES</code>命令在<code>build</code>目录内，前提是要编译好！！</li>
<li>可以连续<code>\n\n</code>换两行</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/Projects/simpleNES/help.png" alt title="--help"></p>
<p><img src="/pictrues/Projects/simpleNES/SimpleNES.png" alt title="./SimpleNES"></p>
<ul>
<li><p><code>.h</code>文件和<code>.cpp</code>文件都要在同一命名空间内，或者说都要用<code>namespace sn{}</code>大括号包起来</p>
<ul>
<li><code>argv[i]</code>相当于<code>char*</code></li>
<li>其余判断条件没有返回值，仔细想想也对</li>
</ul>
</li>
<li><p>刚刚尝试了下，在SSH里运行，窗口会在Win10界面弹出来；若是在虚拟机终端，则是在虚拟机页面里弹出来</p>
<ul>
<li>在虚拟机里跑，比较流畅！！</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/Projects/simpleNES/log_cpu.png" alt title="--log-cpu"></p>
<ul>
<li>上面这个图，还不知道<code>--log-cpu</code>是怎么写入文件的<ul>
<li>命令行提示在<code>MainBus.cpp:84</code>这个cpp文件里</li>
<li>完整提示<code>[MainBus.cpp:84] No write callback registered for I/O register at: 4015</code></li>
<li><code>sn.cpudump</code>这个文件，看了一下，居然写入了两百多万行！！</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/Projects/simpleNES/sn_cpudump.png" alt title="sn.cpudump文件"></p>
<hr>
<h1 id="Coroutine"><a href="#Coroutine" class="headerlink" title="Coroutine"></a>Coroutine</h1><ul>
<li>纤程、协程 傻傻分不清</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>Projects</category>
      </categories>
      <tags>
        <tag>C++ Projects</tag>
      </tags>
  </entry>
  <entry>
    <title>Computer Network</title>
    <url>/2019/08/25/Computer-Network/</url>
    <content><![CDATA[<p>Three handshake and four waves between the server and the client.</p>
<a id="more"></a>
<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><h3 id="第一次握手"><a href="#第一次握手" class="headerlink" title="第一次握手"></a>第一次握手</h3><ul>
<li>客户端处于closed状态，服务器处于listen状态。此时由客户端发送SYN报文，并确认自己的初始化序列号ISN，之后客户端处于SYN-send状态。</li>
<li>SYN： 同步序列编号(Synchronize Sequence Numbers)</li>
</ul>
<h3 id="第二次握手"><a href="#第二次握手" class="headerlink" title="第二次握手"></a>第二次握手</h3><ul>
<li>服务器接受到报文后，将自己的SYN作为应答，并指定了自己的序列号ISN，同时把客户端序列号+1作为ACK的值发送，之后服务器处于SYN-received状态。</li>
</ul>
<p><img src="/pictrues/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.jpg" alt="三次握手"></p>
<h3 id="第三次握手"><a href="#第三次握手" class="headerlink" title="第三次握手"></a>第三次握手</h3><ul>
<li>客户端接受到SYN报文后，会发送ACK报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 establised 状态。</li>
<li>服务器收到 ACK 报文之后，也处于 establised 状态，此时，双方已建立起了链接。</li>
</ul>
<h3 id="三次握手的作用"><a href="#三次握手的作用" class="headerlink" title="三次握手的作用"></a>三次握手的作用</h3><ul>
<li>确认双方的接受能力、发送能力是否正常。</li>
<li>指定自己的初始化序列号，为后面的可靠传送做准备。</li>
<li>对于 HTTPS 协议，三次握手这个过程，会进行数字证书的验证以及加密密钥的生成。</li>
</ul>
<hr>
<hr>
<p><strong><em>注意事项</em></strong></p>
<pre><code>1.ISN不是固定的
    ISN的作用是让对方知道接下来接收数据的时候如何按序列号组装数据。
    如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。

2.半连接队列
    在第一次握手时，服务器收到客户端发来的报文，但两者还没有建立链接，服务器会把这种请求放入一个队
    列里，这队列就叫半链接队列。

3.携带数据
    第三次握手可以携带数据，第一次和第二次不可以。
    如果前两次可以携带数据，那么攻击者就会不停地发送SYN报文加大量垃圾数据给服务器，服务器就会不停地
    分配资源来处理数据。
    总而言之，资源是有限的。第三次客户端已经处于establised，对于客户端来说，服务器的接受、发送能力
    都正常，所以可以携带数据。</code></pre><hr>
<hr>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p><img src="/pictrues/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="四次挥手"></p>
<h3 id="第一次挥手"><a href="#第一次挥手" class="headerlink" title="第一次挥手"></a>第一次挥手</h3><ul>
<li>刚开始双方都处于 establised 状态，假如是客户端先发起关闭请求</li>
<li>客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。</li>
</ul>
<h3 id="第二次挥手"><a href="#第二次挥手" class="headerlink" title="第二次挥手"></a>第二次挥手</h3><ul>
<li>服务端收到 FIN 之后，将客户端的序列号值 +1 作为 ACK 报文发送，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。</li>
</ul>
<h3 id="第三次挥手"><a href="#第三次挥手" class="headerlink" title="第三次挥手"></a>第三次挥手</h3><ul>
<li>如果服务端也想断开连接了，也会发给客户端FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。</li>
</ul>
<h3 id="第四次挥手"><a href="#第四次挥手" class="headerlink" title="第四次挥手"></a>第四次挥手</h3><ul>
<li>客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。</li>
<li>需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态</li>
<li>服务端收到 ACK 报文之后，就关闭连接，处于 CLOSED 状态。</li>
</ul>
<hr>
<hr>
<p><strong><em>注意事项</em></strong></p>
<pre><code>第四次挥手时，客户端要等一段时间才会关闭链接，因为要确保服务器是否已经收到了我们的 ACK 报文，
如果没有收到的话，服务器会重新发 FIN 报文给客户端，客户端再次收到 ACK 报文之后，就知道之前
的 ACK 报文丢失了，然后再次发送 ACK 报文。

至于 TIME_WAIT 持续的时间至少是一个报文的来回时间。过了这段时间没有再次收到 FIN 报文，则代
表对方成功接收ACK 报文，此时处于 CLOSED 状态。</code></pre>]]></content>
      <categories>
        <category>Computer Network</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title>Database</title>
    <url>/2021/10/11/Database/</url>
    <content><![CDATA[<p>Learning Database Record!!</p>
<a id="more"></a>

<blockquote>
<p>虚拟机拍摄快照功能还是很好用的，方便备份恢复^-^！</p>
</blockquote>
<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><ul>
<li>下载更新时，将中科大源换成了阿里源！</li>
</ul>
<h2 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h2><ul>
<li>先在官网 <a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">MySQL</a> 下载 DEB Bundle 捆绑包，然后解压会有各种安装包。</li>
<li><code>sudo apt-get update</code></li>
<li>除了测试包其余都装上，需要依赖就安装依赖<ul>
<li><code>sudo dpkg -i xxx.deb</code></li>
</ul>
</li>
<li><code>sudo apt-get install libaio1 libmecab2</code> 或者 <code>sudo apt-get -f install</code></li>
</ul>
<blockquote>
<p>安装过程会弹出用户名密码，设置下就行</p>
</blockquote>
<ul>
<li>至此 MySQL 已安装完成<ul>
<li>启动服务 <code>service mysql start</code></li>
<li>检查服务状态 <code>systemctl status mysql.service</code></li>
<li>进入 MySQL <code>mysql -u root -p</code></li>
<li>-u 的用户是 root，-p 要输入密码</li>
</ul>
</li>
</ul>
<blockquote>
<p>还有一种方法是直接命令行下载，不过我没有成功，就不献丑了！</p>
</blockquote>
<h2 id="CentOS"><a href="#CentOS" class="headerlink" title="CentOS"></a>CentOS</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><ul>
<li><p>这里得选 RedHat Linux 版本，还是一样，继续下载 RPM 捆绑包</p>
</li>
<li><p>查询是否安装 <code>rpm -qa | grep mysql</code></p>
</li>
<li><p>解压 <code>tar -xvf mysql-8.0.27-1.el8.x86_64.rpm-bundle.tar</code></p>
<ul>
<li>这里注意 <code>-xvf</code> </li>
</ul>
</li>
<li><p>用 <code>rpm -ivh</code> 进行安装</p>
<ul>
<li>需要啥安装啥，这里就不一一列出了</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/Database/MySQL.png" alt title="安装"></p>
<ul>
<li>因为安装包很全面，就不需要在线安装命令了 <code>yum</code></li>
</ul>
<h3 id="更改密码"><a href="#更改密码" class="headerlink" title="更改密码"></a>更改密码</h3><ul>
<li><p>安装好后设置下权限 <code>chown -R mysql:mysql /var/lib/mysql</code></p>
<ul>
<li>启动服务 <code>systemctl start mysqld.service</code></li>
<li>查看状态 <code>systemctl status mysqld.service</code></li>
<li>查看 mysqladmin 工具版本 <code>mysqladmin --version</code></li>
</ul>
</li>
<li><p>注意这里，<code>mysql</code></p>
<ul>
<li>与 Ubuntu 安装不一样，没有弹出让你设置密码的界面，所以显示无权限</li>
<li>网上的解决方法真的是参差不齐</li>
<li>停止服务 <code>systemctl stop mysqld.service</code></li>
<li>先设置配置文件 <code>sudo vim /etc/my.cnf</code> 在最后加上一行 <code>skip-grant-tables</code> （这一行待会之后还要删除）</li>
<li><code>systemctl start mysqld.service</code></li>
<li>进入 mysql <code>mysql -u root</code></li>
</ul>
</li>
<li><p>修改密码</p>
<ul>
<li><code>use mysql;</code></li>
<li>想修改简单的密码得先更改安全变量值</li>
<li>查看安全系数 <code>SHOW VARIABLES LIKE &#39;validate_password%&#39;;</code></li>
<li>设置为最低 <code>set global validate_password.policy=0;</code>、<code>set global validate_password.length=4;</code></li>
<li>先把 root 密码置空 <code>UPDATE user SET authentication_string=&quot;&quot; WHERE user=&quot;root&quot;;</code></li>
<li>更新下 <code>flush privileges;</code></li>
<li><code>ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;xing&#39;;</code></li>
<li><code>quit</code></li>
<li>删除之前配置文件 <code>/etc/my.cnf</code> 新添加的一句</li>
<li>重启服务 <code>systemctl restart mysqld.service</code></li>
</ul>
</li>
</ul>
<h3 id="远程连接"><a href="#远程连接" class="headerlink" title="远程连接"></a>远程连接</h3><ul>
<li>用的是小海豚 SQLyog<ul>
<li>有点小问题，IP 地址的结尾不能是 0</li>
<li>连接的时候首先要关闭防火墙 <code>systemctl stop firewalld.service</code></li>
<li>然后进入 mysql 修改 user 表 <code>use mysql;</code>、<code>update user set host = &#39;%&#39; where user = &#39;root&#39;;</code></li>
<li>之后再重启下</li>
</ul>
</li>
</ul>
<h2 id="MySQL-命令"><a href="#MySQL-命令" class="headerlink" title="MySQL 命令"></a>MySQL 命令</h2><ul>
<li>切换数据库 <code>use mysql;</code></li>
<li>查询用户表 <code>select User,authentication_string,Host from user;</code><ul>
<li><code>select * from user;</code> 太多了</li>
</ul>
</li>
<li>查看状态 <code>select host,user,plugin from user;</code></li>
</ul>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo</title>
    <url>/2019/08/22/Hexo/</url>
    <content><![CDATA[<p>About Hexo introduction, Git, backup, recover and deployment.</p>
<a id="more"></a>

<blockquote>
<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
</blockquote>
<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><ul>
<li>创建新文章</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"my new post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<ul>
<li>创建分类、标签、关于</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo n page categories</span><br><span class="line">$ hexo n page tags</span><br><span class="line">$ hexo n page about</span><br></pre></td></tr></table></figure>

<ul>
<li>运行</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<ul>
<li>重新生成</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<ul>
<li>部署</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><blockquote>
<p>官网下载或者镜像 <a href="https://npm.taobao.org/mirrors/git-for-windows/" target="_blank" rel="noopener">git-for-windows</a></p>
</blockquote>
<ul>
<li>安装过程一路 next 注意添加环境变量</li>
</ul>
<h2 id="本地操作"><a href="#本地操作" class="headerlink" title="本地操作"></a>本地操作</h2><ul>
<li>先设置本地的用户签名，可以是虚拟的，只是方便标识提交者</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name yourName</span><br><span class="line">$ git config --global user.email yourEmail</span><br></pre></td></tr></table></figure>

<ul>
<li>初始化本地库，这里需要新建文件夹 <code>git init</code></li>
<li>查看本地库状态，是否有改动提交等 <code>git status</code></li>
<li>添加到暂存区即 .git 隐藏文件夹 <code>git add yourFile</code> or <code>git add .</code></li>
<li>提交到本地库 <code>git commit -m &quot;yourInfo&quot; yourFile</code></li>
<li>查看历史记录 <code>git reflog</code> or <code>git log</code></li>
<li>指定版本即移动 HEAD 指针 <code>git reset --hard versionNumber</code></li>
</ul>
<blockquote>
<p>分支</p>
</blockquote>
<ul>
<li>创建分支 <code>git branch branchName</code></li>
<li>查看分支 <code>git branch -v</code></li>
<li>切换分支 <code>git checkout branchName</code></li>
<li>将指定分支合并到当前分支上 <code>git merge branchName</code><ul>
<li>合并的时候，对应文件一般只有一方修改，若双方都修改了同一文件的不同地方，需手动合并。</li>
</ul>
</li>
</ul>
<blockquote>
<p>解决冲突</p>
</blockquote>
<ul>
<li>修改代码，会有符号提示 MERGING<ul>
<li><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;HEAD xxxCode ======= yyyCode &gt;&gt;&gt;&gt;&gt;&gt;&gt;hot-fix</code></li>
<li>手动删除不需要的代码</li>
</ul>
</li>
<li>添加到暂存区 <code>git add yourFile</code></li>
<li>提交，无需文件名 <code>git commit -m &quot;merge hot-fix&quot;</code></li>
<li>MERGING 消失</li>
</ul>
<h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><ul>
<li>查看当前所有远程地址别名 <code>git remote -v</code></li>
<li>添加远程地址并起别名一般都是 origin <code>git remote add aliasName yourAddress</code></li>
<li>推送本地分支上的内容到远程仓库 <code>git push aliasName yourBranch</code></li>
<li>下载 <code>git clone remoteAddress</code></li>
<li>拉取远程仓库对应分支的最新内容并与本地分支直接合并 <code>git pull aliasName branchName</code></li>
</ul>
<blockquote>
<p>SSH</p>
</blockquote>
<ul>
<li>之前的地址是 HTTPS 的需要登录，而 SSH 不需要</li>
<li>进入当前用户的主目录，随便哪个目录也行，生成密钥 <code>ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</code><ul>
<li>生成的密钥在 C 盘用户的主目录下</li>
</ul>
</li>
<li>将 id_rsa.pub 添加到 GitHub 即可</li>
</ul>
<h1 id="Backup"><a href="#Backup" class="headerlink" title="Backup"></a>Backup</h1><ul>
<li>新建一个仓库，将原来的备份仓库删除，新建的时候有提示如何备份<ul>
<li>如果上传找不到仓库，则没有建立连接</li>
<li>如果提示已存在仓库，则运行 <code>rm origin</code> 再重新建立连接</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/git.png" alt="git指令" title="git指令"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add . （所有文件）</span><br><span class="line">git add &quot;相对路径&quot;  -f(强制)   （具体文件，例如themes/next）</span><br><span class="line">git commit -m &quot;备注&quot;</span><br><span class="line">git status</span><br><span class="line">git remote rm origin(如果提示已存在仓库)</span><br><span class="line">git remote add origin git@github.com:xxx/yyy.git</span><br><span class="line">git push --set-upstream origin main</span><br><span class="line">git push  (本地同步github)</span><br><span class="line">git pull  (github同步本地)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>若是遇到其他问题，根据提示来即可。<a href="https://blog.csdn.net/qq_29525875/article/details/96598237" target="_blank" rel="noopener">参考链接</a></p>
</blockquote>
<h1 id="Recover"><a href="#Recover" class="headerlink" title="Recover"></a>Recover</h1><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><ul>
<li>下载仓库，本地 <code>git clone 地址</code> （先添加 SSH 公钥）</li>
<li>下载 node.js 并且勾选添加环境变量</li>
</ul>
<blockquote>
<p><a href="https://nodejs.org/en/" target="_blank" rel="noopener">node.js</a></p>
</blockquote>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul>
<li>查看 git 版本 <code>git --version</code></li>
<li>查看 node 版本 <code>node -v</code></li>
<li>查看 npm 插件版本 <code>npm -v</code></li>
</ul>
<ul>
<li>安装 Hexo，<code>npm install hexo-cli -g</code> 默认安装到 C 盘</li>
<li>新建文件夹，并运行 <code>hexo init</code> <strong>不要在备份的文件夹中使用</strong><ul>
<li>替换默认的 _config.yml、themes/、source/、scaffolds/、packagejson、.gitignore</li>
</ul>
</li>
<li>查看 hexo 版本 <code>hexo -v</code><ul>
<li>运行 <code>hexo g</code>、<code>hexo s</code> 是否成功，如不成功则根据提示来安装 node.js node_modules</li>
</ul>
</li>
<li>之前因为安装了几个插件，所以 <code>hexo s</code> 有点问题<ul>
<li>加密插件 <code>npm install --save hexo-blog-encrypt</code> 就不安装了，配置文件也恢复了</li>
<li>置顶插件 <code>npm install hexo-generator-topindex --save</code> 卸载 <code>npm uninstall hexo-generator-topindex</code></li>
</ul>
</li>
</ul>
<ul>
<li>总的来说，这里写的有点旧了，好多插件都更新会出现新的问题，需要跟上潮流、随机应变！</li>
</ul>
<blockquote>
<p><a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">Hexo 文档</a></p>
</blockquote>
<h1 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h1><h2 id="部署-GitHub"><a href="#部署-GitHub" class="headerlink" title="部署 GitHub"></a>部署 GitHub</h2><ul>
<li>插件：使用 <code>hexo d</code> 来部署到 git 上，需要安装 <code>npm install hexo-deployer-git --save</code></li>
</ul>
<ul>
<li>部署的时候会出现 node 版本过高的情况而无法部署，解决方法主要有两种，降低 node 版本以及使用 nvm 来控制 node 版本，这里选择第二种来记录下<ul>
<li>点击安装版本，会分别安装 nvm 以及 nodejs symbolic link （文件夹内不显示）不要出现空格</li>
<li><code>nvm -v</code>、<code>nvm ls</code>、<code>nvm list available</code>、<code>nvm install x.x.x</code></li>
<li>用管理员身份运行 <code>nvm use x.x.x</code></li>
<li>卸载 <code>nvm uninstall x.x.x</code></li>
<li><code>node -v</code></li>
</ul>
</li>
<li>还有个问题：npm 无法运行<ul>
<li>npm 高于 8.11 版本要下载安装包解压 <a href="https://nodejs.org/download/release/vx.x.x/" target="_blank" rel="noopener">https://nodejs.org/download/release/vx.x.x/</a></li>
<li>解压目录 nvm 安装路径，并将解压的文件夹命名 vx.x.x 格式</li>
<li>之后再用管理员打开 cmd 在重新 use 下版本 <code>node -v</code>、<code>npm -v</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>下载链接 <a href="https://github.com/coreybutler/nvm-windows/releases" target="_blank" rel="noopener">nvm</a><br>历史版本 <a href="https://nodejs.org/en/download/releases/" target="_blank" rel="noopener">nodejs</a></p>
</blockquote>
<blockquote>
<p>密钥</p>
</blockquote>
<ul>
<li><code>ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</code></li>
<li>在 C 盘找到 rsa.pub 并复制，应该有三个文件</li>
<li>验证是否链接成功 <code>ssh -T git@github.com</code></li>
</ul>
<blockquote>
<p>不要在 git 版本库中运行 ssh，然后又将它提交，这样就把密码泄露出去了。</p>
</blockquote>
<ul>
<li>GitHub 中新建一个仓库 <strong>用户名</strong> + github.io，并复制链接<ul>
<li>可以将之前的删除(看来必须删，不然部署不了)，重新创建一个。</li>
</ul>
</li>
<li>修改配置文件 _config.yml</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:yourname/yourname.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<ul>
<li>部署三步走</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>

<blockquote>
<p>访问 <strong>用户名</strong>.github.io 即可，我之前是绑定了域名，后来域名过期了，要解绑，先在域名解析那儿解绑；再将 soure 里的 CNAME 文件删除即可。</p>
</blockquote>
<h2 id="部署远程服务器"><a href="#部署远程服务器" class="headerlink" title="部署远程服务器"></a>部署远程服务器</h2><blockquote>
<p><a href="https://blog.csdn.net/StaunchKai/article/details/82878928" target="_blank" rel="noopener">参考文章</a></p>
</blockquote>
<h3 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h3><ul>
<li>安装依赖包、卸载旧版本的 Git</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel</span><br><span class="line">$ yum install  gcc perl-ExtUtils-MakeMaker</span><br><span class="line">$ git --version</span><br><span class="line">$ yum remove git</span><br></pre></td></tr></table></figure>

<ul>
<li>安装 git 选择较新的版本，也可以直接从官网下载</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd /usr/local/src </span><br><span class="line">$ wget https://mirrors.edge.kernel.org/pub/software/scm/git/git-x.x.x.tar.gz   </span><br><span class="line">$ tar -zxvf git-2.19.0.tar.gz</span><br><span class="line"></span><br><span class="line">$ cd git-2.19.0   </span><br><span class="line">$ make prefix=/usr/local/git all </span><br><span class="line">$ make prefix=/usr/local/git install</span><br></pre></td></tr></table></figure>

<ul>
<li>打开环境变量配置文件，在文件底部添加以下配置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ PATH=$PATH:/usr/local/git/bin  </span><br><span class="line">$ export PATH</span><br></pre></td></tr></table></figure>

<ul>
<li>使 git 环境变量生效 <code>source /etc/bashrc</code></li>
</ul>
<h3 id="git-新用户及配置"><a href="#git-新用户及配置" class="headerlink" title="git 新用户及配置"></a>git 新用户及配置</h3><h4 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h4><ul>
<li>这个方法需要密码，以后每次deploy都要输入密码不太方便</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ adduser git</span><br><span class="line">$ passwd git</span><br><span class="line">$ chmod 740 /etc/sudoers</span><br><span class="line">$ vim /etc/sudoers</span><br></pre></td></tr></table></figure>

<ul>
<li>增加一行代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root    ALL=(ALL)       ALL</span><br><span class="line">git ALL=(ALL) ALL(增加)</span><br></pre></td></tr></table></figure>

<ul>
<li>保存退出 <code>chmod 400 /etc/sudoers</code></li>
<li>本地密钥配置 <code>ssh-keygen -t rsa</code></li>
<li>服务器，将本地 .ssh 文件夹的 id_rsa.pub 文件内容粘贴到 authorized_keys，保存后退出</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo mkdir ~/.ssh</span><br><span class="line">$ vim ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure>

<ul>
<li>修改权限</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd ~</span><br><span class="line">$ chmod 600 .ssh/authorized_keys</span><br><span class="line">$ chmod 700 .ssh</span><br></pre></td></tr></table></figure>

<ul>
<li><p>本地测试是否能连接上服务器 <code>ssh -v git@服务器地址</code></p>
</li>
<li><p>创建网站目录</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ su root</span><br><span class="line">$ mkdir /home/hexo </span><br><span class="line">$ chown git:git -R /home/hexo</span><br></pre></td></tr></table></figure>

<h4 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h4><blockquote>
<p><a href="https://www.jianshu.com/p/271449df801f" target="_blank" rel="noopener">参考链接</a></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mkdir /home/git/</span><br><span class="line">$ chown -R $USER:$USER /home/git/</span><br><span class="line">$ chmod -R 755 /home/git/</span><br><span class="line"></span><br><span class="line">$ cd /home/git/</span><br><span class="line">$ git init --bare hexoBlog.git</span><br><span class="line"></span><br><span class="line">$ vim /home/hexo.git/hooks/post-receive</span><br></pre></td></tr></table></figure>

<ul>
<li>增加两行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	#!/bin/bash</span><br><span class="line">git --work-tree=/home/hexoBlog --git-dir=/home/git/hexoBlog.git checkout -f</span><br></pre></td></tr></table></figure>

<ul>
<li>修改文件权限 <code>chmod +x /home/git/hexoBlog.git/hooks/post-receive</code></li>
</ul>
<h3 id="云服务器端配置-Nginx"><a href="#云服务器端配置-Nginx" class="headerlink" title="云服务器端配置 Nginx"></a>云服务器端配置 Nginx</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ yum install -y nginx   </span><br><span class="line">$ systemctl start nginx.service</span><br></pre></td></tr></table></figure>

<ul>
<li>查看位置，并进行编辑</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ nginx -t (/etc/nginx/nginx.conf)</span><br><span class="line">$ vim /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure>

<ul>
<li>配置文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80 default_server;</span><br><span class="line">    listen       [::]:80 default_server;</span><br><span class="line">    server_name  staunchkai.com;    # 修改为自己的域名(没有就写服务器地址)</span><br><span class="line">    root         /home/hexo;    # 修改为网站的根目录</span><br><span class="line"></span><br><span class="line">    # Load configuration files for the default server block.</span><br><span class="line">    include /etc/nginx/default.d/*.conf;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page 404 /404.html;</span><br><span class="line">        location = /40x.html &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page 500 502 503 504 /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自动化部署"><a href="#自动化部署" class="headerlink" title="自动化部署"></a>自动化部署</h3><blockquote>
<p>建立 git 裸库</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ su root</span><br><span class="line">$ cd /home/git  </span><br><span class="line">$ git init --bare blog.git</span><br><span class="line"></span><br><span class="line">$ chown git:git -R blog.git</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 git-hooks 同步网站根目录</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vim blog.git/hooks/post-receive</span><br></pre></td></tr></table></figure>

<ul>
<li>填入</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	#!/bin/sh</span><br><span class="line">git --work-tree=/home/hexo --git-dir=/home/git/blog.git checkout -f</span><br></pre></td></tr></table></figure>

<ul>
<li>增加权限<code>chmod +x /home/git/blog.git/hooks/post-receive</code></li>
</ul>
<p><a href="https://blog.csdn.net/StaunchKai/article/details/82878928" target="_blank" rel="noopener">常见错误</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Introduction</tag>
        <tag>Git</tag>
        <tag>Backup</tag>
        <tag>Recover</tag>
        <tag>Deployment</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Command</title>
    <url>/2020/10/15/Linux-Command/</url>
    <content><![CDATA[<p>Linux Command！</p>
<a id="more"></a>

<blockquote>
<p>本文转摘自<a href="https://www.codesheep.cn/" target="_blank" rel="noopener">codesheep</a></p>
</blockquote>
<h2 id="date显示系统日期"><a href="#date显示系统日期" class="headerlink" title="date显示系统日期"></a>date显示系统日期</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cal 2007               显示2007年的日历表</span><br><span class="line">date 041217002007.00   设置日期和时间 - 月日时分年.秒</span><br><span class="line">clock -w               将时间修改保存到 BIOS</span><br></pre></td></tr></table></figure>

<h2 id="查看Linux系统信息"><a href="#查看Linux系统信息" class="headerlink" title="查看Linux系统信息"></a>查看Linux系统信息</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arch      				显示机器的处理器架构(1)</span><br><span class="line">uname -m  				显示机器的处理器架构(2)</span><br><span class="line">uname -r  				显示正在使用的内核版本</span><br><span class="line">dmidecode -q          	显示硬件系统部件 - (SMBIOS / DMI)</span><br><span class="line">hdparm -i /dev/hda    	罗列一个磁盘的架构特性</span><br><span class="line">hdparm -tT /dev/sda   	在磁盘上执行测试性读取操作</span><br><span class="line">cat /proc/cpuinfo     	显示CPU info的信息</span><br><span class="line">cat /proc/interrupts  	显示中断</span><br><span class="line">cat /proc/meminfo     	校验内存使用</span><br><span class="line">cat /proc/swaps       	显示哪些swap被使用</span><br><span class="line">cat /proc/version     	显示内核的版本</span><br><span class="line">cat /proc/net/dev     	显示网络适配器及统计</span><br><span class="line">cat /proc/mounts      	显示已加载的文件系统</span><br><span class="line">lspci -tv   			罗列PCI设备</span><br><span class="line">lsusb -tv   			显示USB设备</span><br></pre></td></tr></table></figure>

<h2 id="关机、重启、登出"><a href="#关机、重启、登出" class="headerlink" title="关机、重启、登出"></a>关机、重启、登出</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shutdown -h now    	关闭系统(1)</span><br><span class="line">init 0            	关闭系统(2)</span><br><span class="line">telinit 0         	关闭系统(3)</span><br><span class="line">shutdown -h hours:minutes &amp;   	按预定时间关闭系统</span><br><span class="line">shutdown -c       	取消按预定时间关闭系统</span><br><span class="line">shutdown -r now   	重启(1)</span><br><span class="line">reboot   			重启(2)</span><br><span class="line">logout   			注销</span><br></pre></td></tr></table></figure>

<h2 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /home    #进入 &apos;/ home&apos; 目录&apos;</span><br><span class="line">cd ..       #返回上一级目录</span><br><span class="line">cd ../..    #返回上两级目录</span><br><span class="line">cd          #进入个人的主目录</span><br><span class="line">cd ~user1   #进入个人的主目录</span><br><span class="line">cd -        #返回上次所在的目录</span><br><span class="line">pwd         #显示工作路径</span><br><span class="line"></span><br><span class="line">ls      	#查看目录中的文件</span><br><span class="line">ls -F   	#查看目录中的文件</span><br><span class="line">ls -l   	#显示文件和目录的详细资料</span><br><span class="line">ls -a   	#显示隐藏文件</span><br><span class="line">ls *[0-9]*  #显示包含数字的文件名和目录名</span><br><span class="line">tree        #显示文件和目录由根目录开始的树形结构(1)</span><br><span class="line">lstree      #显示文件和目录由根目录开始的树形结构(2)</span><br><span class="line"></span><br><span class="line">mkdir dir1         			#创建一个叫做 &apos;dir1&apos; 的目录&apos;</span><br><span class="line">mkdir dir1 dir2    			#同时创建两个目录</span><br><span class="line">mkdir -p /tmp/dir1/dir2  	#创建一个目录树</span><br><span class="line">rm -f file1    				#删除一个叫做 &apos;file1&apos; 的文件&apos;</span><br><span class="line">rmdir dir1     				#删除一个叫做 &apos;dir1&apos; 的目录&apos;</span><br><span class="line">rm -rf dir1    				#删除一个叫做 &apos;dir1&apos; 的目录并同时删除其内容</span><br><span class="line">rm -rf dir1 dir2    		#同时删除两个目录及它们的内容</span><br><span class="line">mv dir1 new_dir     		#重命名/移动 一个目录</span><br><span class="line"></span><br><span class="line">cp file1 file2     	#复制一个文件</span><br><span class="line">cp dir/* .         	#复制一个目录下的所有文件到当前工作目录</span><br><span class="line">cp -a /tmp/dir1 .   #复制一个目录到当前工作目录</span><br><span class="line">cp -a dir1 dir2     #复制一个目录</span><br><span class="line"></span><br><span class="line">ln -s file1 lnk1  	#创建一个指向文件或目录的软链接</span><br><span class="line">ln file1 lnk1     	#创建一个指向文件或目录的物理链接</span><br><span class="line"></span><br><span class="line">touch -t 0712250000 file1   #修改一个文件或目录的时间戳 - (YYMMDDhhmm)</span><br><span class="line">file file1 outputs the mime type of the file as text</span><br><span class="line">iconv -l   					#列出已知的编码</span><br><span class="line"></span><br><span class="line">iconv -f fromEncoding -t toEncoding inputFile &gt; outputFile creates a new from the given input file by assuming it is encoded in fromEncoding and converting it to toEncoding.</span><br><span class="line"></span><br><span class="line">find . -maxdepth 1 -name *.jpg -print -exec convert &quot;&#123;&#125;&quot; -resize 80x60 &quot;thumbs/&#123;&#125;&quot; \; batch resize files in the current directory and send them to a thumbnails directory (requires convert from Imagemagick)</span><br></pre></td></tr></table></figure>

<h2 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find / -name file1     #从 &apos;/&apos; 开始进入根文件系统搜索文件和目录</span><br><span class="line">find / -user user1     #搜索属于用户 &apos;user1&apos; 的文件和目录</span><br><span class="line">find /home/user1 -name \*.bin        #在目录 &apos;/ home/user1&apos; 中搜索带有&apos;.bin&apos; 结尾的文件</span><br><span class="line">find /usr/bin -type f -atime +100    #搜索在过去100天内未被使用过的执行文件</span><br><span class="line">find /usr/bin -type f -mtime -10     #搜索在10天内被创建或者修改过的文件</span><br><span class="line">find / -name \*.rpm -exec chmod 755 &apos;&#123;&#125;&apos; \;      #搜索以 &apos;.rpm&apos; 结尾的文件并定义其权限</span><br><span class="line">find / -xdev -name \*.rpm        #搜索以 &apos;.rpm&apos; 结尾的文件，忽略光驱、捷盘等可移动设备</span><br><span class="line">locate \*.ps       #寻找以 &apos;.ps&apos; 结尾的文件 - 先运行 &apos;updatedb&apos; 命令</span><br><span class="line">whereis halt       #显示一个二进制文件、源码或man的位置</span><br><span class="line">which halt         #显示一个二进制文件或可执行文件的完整路径</span><br></pre></td></tr></table></figure>

<h2 id="挂载文件系统"><a href="#挂载文件系统" class="headerlink" title="挂载文件系统"></a>挂载文件系统</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mount /dev/hda2 /mnt/hda2    #挂载一个叫做hda2的盘 - 确定目录 &apos;/ mnt/hda2&apos; 已经存在</span><br><span class="line">umount /dev/hda2            #卸载一个叫做hda2的盘 - 先从挂载点 &apos;/ mnt/hda2&apos; 退出</span><br><span class="line">fuser -km /mnt/hda2         #当设备繁忙时强制卸载</span><br><span class="line">umount -n /mnt/hda2         #运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用</span><br><span class="line">mount /dev/fd0 /mnt/floppy        #挂载一个软盘</span><br><span class="line">mount /dev/cdrom /mnt/cdrom       #挂载一个cdrom或dvdrom</span><br><span class="line">mount /dev/hdc /mnt/cdrecorder    #挂载一个cdrw或dvdrom</span><br><span class="line">mount /dev/hdb /mnt/cdrecorder    #挂载一个cdrw或dvdrom</span><br><span class="line">mount -o loop file.iso /mnt/cdrom    #挂载一个文件或ISO镜像文件</span><br><span class="line">mount -t vfat /dev/hda5 /mnt/hda5    #挂载一个Windows FAT32文件系统</span><br><span class="line">mount /dev/sda1 /mnt/usbdisk         #挂载一个usb 捷盘或闪存设备</span><br><span class="line">mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share      #挂载一个windows网络共享</span><br></pre></td></tr></table></figure>

<h2 id="磁盘空间相关"><a href="#磁盘空间相关" class="headerlink" title="磁盘空间相关"></a>磁盘空间相关</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df -h           #显示已经挂载的分区列表</span><br><span class="line">ls -lSr |more    #以尺寸大小排列文件和目录</span><br><span class="line">du -sh dir1      #估算目录 &apos;dir1&apos; 已经使用的磁盘空间&apos;</span><br><span class="line">du -sk * | sort -rn     #以容量大小为依据依次显示文件和目录的大小</span><br><span class="line">rpm -q -a --qf &apos;%10&#123;SIZE&#125;t%&#123;NAME&#125;n&apos; | sort -k1,1n </span><br><span class="line">#以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统)</span><br><span class="line">dpkg-query -W -f=&apos;$&#123;Installed-Size;10&#125;t$&#123;Package&#125;n&apos; | sort -k1,1n </span><br><span class="line">#以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统)</span><br></pre></td></tr></table></figure>

<h2 id="用户和群组"><a href="#用户和群组" class="headerlink" title="用户和群组"></a>用户和群组</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">groupadd group_name   #创建一个新用户组</span><br><span class="line">groupdel group_name   #删除一个用户组</span><br><span class="line">groupmod -n new_group_name old_group_name   #重命名一个用户组</span><br><span class="line">useradd -c &quot;Name Surname &quot; -g admin -d /home/user1 -s /bin/bash user1     #创建一个属于 &quot;admin&quot; 用户组的用户</span><br><span class="line">useradd user1      #创建一个新用户</span><br><span class="line">userdel -r user1   #删除一个用户 ( &apos;-r&apos; 排除主目录)</span><br><span class="line">usermod -c &quot;User FTP&quot; -g system -d /ftp/user1 -s /bin/nologin user1   #修改用户属性</span><br><span class="line"></span><br><span class="line">passwd         #修改口令</span><br><span class="line">passwd user1   #修改一个用户的口令 (只允许root执行)</span><br><span class="line">chage -E 2005-12-31 user1    #设置用户口令的失效期限</span><br><span class="line">pwck     #检查 &apos;/etc/passwd&apos; 的文件格式和语法修正以及存在的用户</span><br><span class="line">grpck    #检查 &apos;/etc/passwd&apos; 的文件格式和语法修正以及存在的群组</span><br><span class="line">newgrp group_name     #登陆进一个新的群组以改变新创建文件的预设群组</span><br></pre></td></tr></table></figure>

<h2 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用 &quot;+&quot; 设置权限，使用 &quot;-&quot; 用于取消</span><br><span class="line"></span><br><span class="line">ls -lh    #显示权限</span><br><span class="line">ls /tmp | pr -T5 -W$COLUMNS   #将终端划分成5栏显示</span><br><span class="line">chmod ugo+rwx directory1      #设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限</span><br><span class="line">chmod go-rwx directory1      #删除群组(g)与其他人(o)对目录的读写执行权限</span><br><span class="line">chown user1 file1            #改变一个文件的所有人属性</span><br><span class="line">chown -R user1 directory1    #改变一个目录的所有人属性并同时改变改目录下所有文件的属性</span><br><span class="line">chgrp group1 file1          #改变文件的群组</span><br><span class="line">chown user1:group1 file1     #改变一个文件的所有人和群组属性</span><br><span class="line">find / -perm -u+s           #罗列一个系统中所有使用了SUID控制的文件</span><br><span class="line">chmod u+s /bin/file1        #设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限</span><br><span class="line">chmod u-s /bin/file1        #禁用一个二进制文件的 SUID位</span><br><span class="line">chmod g+s /home/public      #设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的</span><br><span class="line">chmod g-s /home/public      #禁用一个目录的 SGID 位</span><br><span class="line">chmod o+t /home/public      #设置一个文件的 STIKY 位 - 只允许合法所有人删除文件</span><br><span class="line">chmod o-t /home/public      #禁用一个目录的 STIKY 位</span><br></pre></td></tr></table></figure>

<h2 id="文件的特殊属性"><a href="#文件的特殊属性" class="headerlink" title="文件的特殊属性"></a>文件的特殊属性</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用 &quot;+&quot; 设置权限，使用 &quot;-&quot; 用于取消</span><br><span class="line"></span><br><span class="line">chattr +a file1   #只允许以追加方式读写文件</span><br><span class="line">chattr +c file1   #允许这个文件能被内核自动压缩/解压</span><br><span class="line">chattr +d file1   #在进行文件系统备份时，dump程序将忽略这个文件</span><br><span class="line">chattr +i file1   #设置成不可变的文件，不能被删除、修改、重命名或者链接</span><br><span class="line">chattr +s file1   #允许一个文件被安全地删除</span><br><span class="line">chattr +S file1   #一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘</span><br><span class="line">chattr +u file1   #若文件被删除，系统会允许你在以后恢复这个被删除的文件</span><br><span class="line">lsattr           #显示特殊的属性</span><br></pre></td></tr></table></figure>

<h2 id="打包和压缩文件"><a href="#打包和压缩文件" class="headerlink" title="打包和压缩文件"></a>打包和压缩文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bunzip2 file1.bz2   #解压一个叫做 &apos;file1.bz2&apos;的文件</span><br><span class="line">bzip2 file1         #压缩一个叫做 &apos;file1&apos; 的文件</span><br><span class="line">gunzip file1.gz     #解压一个叫做 &apos;file1.gz&apos;的文件</span><br><span class="line">gzip file1          #压缩一个叫做 &apos;file1&apos;的文件</span><br><span class="line">gzip -9 file1       #最大程度压缩</span><br><span class="line"></span><br><span class="line">rar a file1.rar test_file          #创建一个叫做 &apos;file1.rar&apos; 的包</span><br><span class="line">rar a file1.rar file1 file2 dir1   #同时压缩 &apos;file1&apos;, &apos;file2&apos; 以及目录 &apos;dir1&apos;</span><br><span class="line">rar x file1.rar     #解压rar包</span><br><span class="line">unrar x file1.rar   #解压rar包</span><br><span class="line"></span><br><span class="line">tar -cvf archive.tar file1   #创建一个非压缩的 tarball</span><br><span class="line">tar -cvf archive.tar file1 file2 dir1  #创建一个包含了 &apos;file1&apos;, &apos;file2&apos; 以及 &apos;dir1&apos;的档案文件</span><br><span class="line">tar -tf archive.tar    #显示一个包中的内容</span><br><span class="line">tar -xvf archive.tar   #释放一个包</span><br><span class="line">tar -xvf archive.tar -C /tmp     #将压缩包释放到 /tmp目录下</span><br><span class="line">tar -cvfj archive.tar.bz2 dir1   #创建一个bzip2格式的压缩包</span><br><span class="line">tar -jxvf archive.tar.bz2        #解压一个bzip2格式的压缩包</span><br><span class="line">tar -cvfz archive.tar.gz dir1    #创建一个gzip格式的压缩包</span><br><span class="line">tar -zxvf archive.tar.gz         #解压一个gzip格式的压缩包</span><br><span class="line"></span><br><span class="line">zip file1.zip file1    #创建一个zip格式的压缩包</span><br><span class="line">zip -r file1.zip file1 file2 dir1    #将几个文件和目录同时压缩成一个zip格式的压缩包</span><br><span class="line">unzip file1.zip    #解压一个zip格式压缩包</span><br></pre></td></tr></table></figure>

<h2 id="RPM-包（Fedora-Redhat-及类似系统）"><a href="#RPM-包（Fedora-Redhat-及类似系统）" class="headerlink" title="RPM 包（Fedora, Redhat 及类似系统）"></a>RPM 包（Fedora, Redhat 及类似系统）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -ivh package.rpm    #安装一个rpm包</span><br><span class="line">rpm -ivh --nodeeps package.rpm   #安装一个rpm包而忽略依赖关系警告</span><br><span class="line">rpm -U package.rpm        #更新一个rpm包但不改变其配置文件</span><br><span class="line">rpm -F package.rpm        #更新一个确定已经安装的rpm包</span><br><span class="line">rpm -e package_name.rpm   #删除一个rpm包</span><br><span class="line">rpm -qa      #显示系统中所有已经安装的rpm包</span><br><span class="line">rpm -qa | grep httpd    #显示所有名称中包含 &quot;httpd&quot; 字样的rpm包</span><br><span class="line">rpm -qi package_name    #获取一个已安装包的特殊信息</span><br><span class="line">rpm -qg &quot;System Environment/Daemons&quot;     #显示一个组件的rpm包</span><br><span class="line">rpm -ql package_name       #显示一个已经安装的rpm包提供的文件列表</span><br><span class="line">rpm -qc package_name       #显示一个已经安装的rpm包提供的配置文件列表</span><br><span class="line">rpm -q package_name --whatrequires     #显示与一个rpm包存在依赖关系的列表</span><br><span class="line">rpm -q package_name --whatprovides    #显示一个rpm包所占的体积</span><br><span class="line">rpm -q package_name --scripts         #显示在安装/删除期间所执行的脚本l</span><br><span class="line">rpm -q package_name --changelog       #显示一个rpm包的修改历史</span><br><span class="line">rpm -qf /etc/httpd/conf/httpd.conf    #确认所给的文件由哪个rpm包所提供</span><br><span class="line">rpm -qp package.rpm -l    #显示由一个尚未安装的rpm包提供的文件列表</span><br><span class="line">rpm --import /media/cdrom/RPM-GPG-KEY    #导入公钥数字证书</span><br><span class="line">rpm --checksig package.rpm      #确认一个rpm包的完整性</span><br><span class="line">rpm -qa gpg-pubkey      #确认已安装的所有rpm包的完整性</span><br><span class="line">rpm -V package_name     #检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间</span><br><span class="line">rpm -Va                 #检查系统中所有已安装的rpm包- 小心使用</span><br><span class="line">rpm -Vp package.rpm     #确认一个rpm包还未安装</span><br><span class="line">rpm2cpio package.rpm | cpio --extract --make-directories *bin*   #从一个rpm包运行可执行文件</span><br><span class="line">rpm -ivh /usr/src/redhat/RPMS/`arch`/package.rpm    #从一个rpm源码安装一个构建好的包</span><br><span class="line">rpmbuild --rebuild package_name.src.rpm       #从一个rpm源码构建一个 rpm 包</span><br></pre></td></tr></table></figure>

<h2 id="YUM（Fedora-RedHat及类似系统）"><a href="#YUM（Fedora-RedHat及类似系统）" class="headerlink" title="YUM（Fedora, RedHat及类似系统）"></a>YUM（Fedora, RedHat及类似系统）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install package_name             #下载并安装一个rpm包</span><br><span class="line">yum localinstall package_name.rpm    #将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系</span><br><span class="line">yum update package_name.rpm    #更新当前系统中所有安装的rpm包</span><br><span class="line">yum update package_name        #更新一个rpm包</span><br><span class="line">yum remove package_name        #删除一个rpm包</span><br><span class="line">yum list                   #列出当前系统中安装的所有包</span><br><span class="line">yum search package_name     #在rpm仓库中搜寻软件包</span><br><span class="line">yum clean packages          #清理rpm缓存删除下载的包</span><br><span class="line">yum clean headers           #删除所有头文件</span><br><span class="line">yum clean all                #删除所有缓存的包和头文件</span><br></pre></td></tr></table></figure>

<h2 id="DEB包-Debian-Ubuntu及类似系统"><a href="#DEB包-Debian-Ubuntu及类似系统" class="headerlink" title="DEB包 (Debian, Ubuntu及类似系统)"></a>DEB包 (Debian, Ubuntu及类似系统)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dpkg -i package.deb     #安装/更新一个 deb 包</span><br><span class="line">dpkg -r package_name    #从系统删除一个 deb 包</span><br><span class="line">dpkg -l                 #显示系统中所有已经安装的 deb 包</span><br><span class="line">dpkg -l | grep httpd    #显示所有名称中包含 &quot;httpd&quot; 字样的deb包</span><br><span class="line">dpkg -s package_name    #获得已经安装在系统中一个特殊包的信息</span><br><span class="line">dpkg -L package_name    #显示系统中已经安装的一个deb包所提供的文件列表</span><br><span class="line">dpkg --contents package.deb    #显示尚未安装的一个包所提供的文件列表</span><br><span class="line">dpkg -S /bin/ping              #确认所给的文件由哪个deb包提供</span><br></pre></td></tr></table></figure>

<h2 id="APT软件工具-Debian-Ubuntu及类似系统"><a href="#APT软件工具-Debian-Ubuntu及类似系统" class="headerlink" title="APT软件工具 (Debian, Ubuntu及类似系统)"></a>APT软件工具 (Debian, Ubuntu及类似系统)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install package_name      #安装/更新一个 deb 包</span><br><span class="line">apt-cdrom install package_name    #从光盘安装/更新一个 deb 包</span><br><span class="line">apt-get update      #升级列表中的软件包</span><br><span class="line">apt-get upgrade     #升级所有已安装的软件</span><br><span class="line">apt-get remove package_name     #从系统删除一个deb包</span><br><span class="line">apt-get check     #确认依赖的软件仓库正确</span><br><span class="line">apt-get clean     #从下载的软件包中清理缓存</span><br><span class="line">apt-cache search searched-package    #返回包含所要搜索字符串的软件包名称</span><br></pre></td></tr></table></figure>

<h2 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat file1      #从第一个字节开始正向查看文件的内容</span><br><span class="line">tac file1      #从最后一行开始反向查看一个文件的内容</span><br><span class="line">more file1     #查看一个长文件的内容</span><br><span class="line">less file1     #类似于 &apos;more&apos; 命令，但是它允许在文件中和正向操作一样的反向操作</span><br><span class="line">head -2 file1    #查看一个文件的前两行</span><br><span class="line">tail -2 file1    #查看一个文件的最后两行</span><br><span class="line">tail -f /var/log/messages     #实时查看被添加到一个文件中的内容</span><br></pre></td></tr></table></figure>

<h2 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat file1 file2 ... | command &lt;&gt; file1_in.txt_or_file1_out.txt general syntax for text manipulation using PIPE, STDIN and STDOUT</span><br><span class="line"></span><br><span class="line">cat file1 | command( sed, grep, awk, grep, etc...) &gt; result.txt </span><br><span class="line">#合并一个文件的详细说明文本，并将简介写入一个新文件中</span><br><span class="line">cat file1 | command( sed, grep, awk, grep, etc...) &gt;&gt; result.txt </span><br><span class="line">#合并一个文件的详细说明文本，并将简介写入一个已有的文件中</span><br><span class="line"></span><br><span class="line">grep Aug /var/log/messages     #在文件 &apos;/var/log/messages&apos;中查找关键词&quot;Aug&quot;</span><br><span class="line">grep ^Aug /var/log/messages    #在文件 &apos;/var/log/messages&apos;中查找以&quot;Aug&quot;开始的词汇</span><br><span class="line">grep [0-9] /var/log/messages   #选择 &apos;/var/log/messages&apos; 文件中所有包含数字的行</span><br><span class="line">grep Aug -R /var/log/*         #在目录 &apos;/var/log&apos; 及随后的目录中搜索字符串&quot;Aug&quot;</span><br><span class="line"></span><br><span class="line">sed &apos;s/stringa1/stringa2/g&apos; example.txt </span><br><span class="line">#将example.txt文件中的 &quot;string1&quot; 替换成 &quot;string2&quot;</span><br><span class="line">sed &apos;/^$/d&apos; example.txt           #从example.txt文件中删除所有空白行</span><br><span class="line">sed &apos;/ *#/d; /^$/d&apos; example.txt   #从example.txt文件中删除所有注释和空白行</span><br><span class="line">echo &apos;esempio&apos; | tr &apos;[:lower:]&apos; &apos;[:upper:]&apos;    #合并上下单元格内容</span><br><span class="line">sed -e &apos;1d&apos; result.txt          #从文件example.txt 中排除第一行</span><br><span class="line">sed -n &apos;/stringa1/p&apos;            #查看只包含词汇 &quot;string1&quot;的行</span><br><span class="line">sed -e &apos;s/ *$//&apos; example.txt    #删除每一行最后的空白字符</span><br><span class="line">sed -e &apos;s/stringa1//g&apos; example.txt  </span><br><span class="line">#从文档中只删除词汇 &quot;string1&quot; 并保留剩余全部</span><br><span class="line">sed -n &apos;1,5p;5q&apos; example.txt     #查看从第一行到第5行内容</span><br><span class="line">sed -n &apos;5p;5q&apos; example.txt       #查看第5行</span><br><span class="line">sed -e &apos;s/00*/0/g&apos; example.txt   #用单个零替换多个零</span><br><span class="line"></span><br><span class="line">cat -n file1       #标示文件的行数</span><br><span class="line">cat example.txt | awk &apos;NR%2==1&apos;      #删除example.txt文件中的所有偶数行</span><br><span class="line">echo a b c | awk &apos;&#123;print $1&#125;&apos;        #查看一行第一栏</span><br><span class="line">echo a b c | awk &apos;&#123;print $1,$3&#125;&apos;     #查看一行的第一和第三栏</span><br><span class="line">paste file1 file2           #合并两个文件或两栏的内容</span><br><span class="line">paste -d &apos;+&apos; file1 file2    #合并两个文件或两栏的内容，中间用&quot;+&quot;区分</span><br><span class="line"></span><br><span class="line">sort file1 file2              #排序两个文件的内容</span><br><span class="line">sort file1 file2 | uniq       #取出两个文件的并集(重复的行只保留一份)</span><br><span class="line">sort file1 file2 | uniq -u    #删除交集，留下其他的行</span><br><span class="line">sort file1 file2 | uniq -d    #取出两个文件的交集(只留下同时存在于两个文件中的文件)</span><br><span class="line"></span><br><span class="line">comm -1 file1 file2    #比较两个文件的内容只删除 &apos;file1&apos; 所包含的内容</span><br><span class="line">comm -2 file1 file2    #比较两个文件的内容只删除 &apos;file2&apos; 所包含的内容</span><br><span class="line">comm -3 file1 file2    #比较两个文件的内容只删除两个文件共有的部分</span><br></pre></td></tr></table></figure>

<h2 id="字符设置和文件格式转换"><a href="#字符设置和文件格式转换" class="headerlink" title="字符设置和文件格式转换"></a>字符设置和文件格式转换</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dos2unix filedos.txt fileunix.txt      #将一个文本文件的格式从MSDOS转换成UNIX</span><br><span class="line">unix2dos fileunix.txt filedos.txt      #将一个文本文件的格式从UNIX转换成MSDOS</span><br><span class="line">recode ..HTML &lt; page.txt &gt; page.html   #将一个文本文件转换成html</span><br><span class="line">recode -l | more                       #显示所有允许的转换格式</span><br></pre></td></tr></table></figure>

<h2 id="文件系统分析"><a href="#文件系统分析" class="headerlink" title="文件系统分析"></a>文件系统分析</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">badblocks -v /dev/hda1    #检查磁盘hda1上的坏磁块</span><br><span class="line">fsck /dev/hda1            #修复/检查hda1磁盘上linux文件系统的完整性</span><br><span class="line">fsck.ext2 /dev/hda1       #修复/检查hda1磁盘上ext2文件系统的完整性</span><br><span class="line">e2fsck /dev/hda1          #修复/检查hda1磁盘上ext2文件系统的完整性</span><br><span class="line">e2fsck -j /dev/hda1       #修复/检查hda1磁盘上ext3文件系统的完整性</span><br><span class="line">fsck.ext3 /dev/hda1       #修复/检查hda1磁盘上ext3文件系统的完整性</span><br><span class="line">fsck.vfat /dev/hda1       #修复/检查hda1磁盘上fat文件系统的完整性</span><br><span class="line">fsck.msdos /dev/hda1      #修复/检查hda1磁盘上dos文件系统的完整性</span><br><span class="line">dosfsck /dev/hda1         #修复/检查hda1磁盘上dos文件系统的完整性                    #显示所有允许的转换格式</span><br></pre></td></tr></table></figure>

<h2 id="初始化一个文件系统"><a href="#初始化一个文件系统" class="headerlink" title="初始化一个文件系统"></a>初始化一个文件系统</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkfs /dev/hda1        #在hda1分区创建一个文件系统</span><br><span class="line">mke2fs /dev/hda1      #在hda1分区创建一个linux ext2的文件系统</span><br><span class="line">mke2fs -j /dev/hda1   #在hda1分区创建一个linux ext3(日志型)的文件系统</span><br><span class="line">mkfs -t vfat 32 -F /dev/hda1   #创建一个 FAT32 文件系统</span><br><span class="line">fdformat -n /dev/fd0           #格式化一个软盘</span><br><span class="line">mkswap /dev/hda3               #创建一个swap文件系统</span><br></pre></td></tr></table></figure>

<h2 id="SWAP文件系统"><a href="#SWAP文件系统" class="headerlink" title="SWAP文件系统"></a>SWAP文件系统</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkswap /dev/hda3             #创建一个swap文件系统</span><br><span class="line">swapon /dev/hda3             #启用一个新的swap文件系统</span><br><span class="line">swapon /dev/hda2 /dev/hdb3   #启用两个swap分区</span><br></pre></td></tr></table></figure>

<h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dump -0aj -f /tmp/home0.bak /home    #制作一个 &apos;/home&apos; 目录的完整备份</span><br><span class="line">dump -1aj -f /tmp/home0.bak /home    #制作一个 &apos;/home&apos; 目录的交互式备份</span><br><span class="line">restore -if /tmp/home0.bak          #还原一个交互式备份</span><br><span class="line"></span><br><span class="line">rsync -rogpav --delete /home /tmp    #同步两边的目录</span><br><span class="line">rsync -rogpav -e ssh --delete /home ip_address:/tmp           #通过SSH通道rsync</span><br><span class="line">rsync -az -e ssh --delete ip_addr:/home/public /home/local    #通过ssh和压缩将一个远程目录同步到本地目录</span><br><span class="line">rsync -az -e ssh --delete /home/local ip_addr:/home/public    #通过ssh和压缩将本地目录同步到远程目录</span><br><span class="line"></span><br><span class="line">dd bs=1M if=/dev/hda | gzip | ssh user@ip_addr &apos;dd of=hda.gz&apos;  </span><br><span class="line">#通过ssh在远程主机上执行一次备份本地磁盘的操作</span><br><span class="line">dd if=/dev/sda of=/tmp/file1 </span><br><span class="line">#备份磁盘内容到一个文件</span><br><span class="line">tar -Puf backup.tar /home/user 执行一次对 &apos;/home/user&apos; </span><br><span class="line">#目录的交互式备份操作</span><br><span class="line">( cd /tmp/local/ &amp;&amp; tar c . ) | ssh -C user@ip_addr &apos;cd /home/share/ &amp;&amp; tar x -p&apos; </span><br><span class="line">#通过ssh在远程目录中复制一个目录内容</span><br><span class="line">( tar c /home ) | ssh -C user@ip_addr &apos;cd /home/backup-home &amp;&amp; tar x -p&apos; </span><br><span class="line">#通过ssh在远程目录中复制一个本地目录</span><br><span class="line">tar cf - . | (cd /tmp/backup ; tar xf - ) </span><br><span class="line">#本地将一个目录复制到另一个地方，保留原有权限及链接</span><br><span class="line"></span><br><span class="line">find /home/user1 -name &apos;*.txt&apos; | xargs cp -av --target-directory=/home/backup/ --parents </span><br><span class="line">#从一个目录查找并复制所有以 &apos;.txt&apos; 结尾的文件到另一个目录</span><br><span class="line">find /var/log -name &apos;*.log&apos; | tar cv --files-from=- | bzip2 &gt; log.tar.bz2 </span><br><span class="line">#查找所有以 &apos;.log&apos; 结尾的文件并做成一个bzip包</span><br><span class="line"></span><br><span class="line">dd if=/dev/hda of=/dev/fd0 bs=512 count=1 </span><br><span class="line">#做一个将 MBR (Master Boot Record)内容复制到软盘的动作</span><br><span class="line">dd if=/dev/fd0 of=/dev/hda bs=512 count=1 </span><br><span class="line">#从已经保存到软盘的备份中恢复MBR内容</span><br></pre></td></tr></table></figure>

<h2 id="网络-（以太网和WIFI无线）"><a href="#网络-（以太网和WIFI无线）" class="headerlink" title="网络 - （以太网和WIFI无线）"></a>网络 - （以太网和WIFI无线）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ifconfig eth0    #显示一个以太网卡的配置</span><br><span class="line">ifup eth0        #启用一个 &apos;eth0&apos; 网络设备</span><br><span class="line">ifdown eth0      #禁用一个 &apos;eth0&apos; 网络设备</span><br><span class="line">ifconfig eth0 192.168.1.1 netmask 255.255.255.0     #控制IP地址</span><br><span class="line">ifconfig eth0 promisc     #设置 &apos;eth0&apos; 成混杂模式以嗅探数据包 (sniffing)</span><br><span class="line">dhclient eth0            #以dhcp模式启用 &apos;eth0&apos;</span><br><span class="line"></span><br><span class="line">route -n    #查看路由表</span><br><span class="line">route add -net 0/0 gw IP_Gateway    #配置默认网关</span><br><span class="line">route add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1 </span><br><span class="line">#配置静态路由到达网络&apos;192.168.0.0/16&apos;</span><br><span class="line">route del 0/0 gw IP_gateway        #删除静态路由</span><br><span class="line"></span><br><span class="line">hostname #查看机器名</span><br><span class="line">host www.example.com       #把一个主机名解析到一个网际地址或把一个网际地址解析到一个主机名。</span><br><span class="line">nslookup www.example.com   #用于查询DNS的记录，查看域名解析是否正常，在网络故障的时候用来诊断网络问题。</span><br><span class="line">ip link show            #查看网卡信息</span><br><span class="line">mii-tool                #用于查看、管理介质的网络接口的状态</span><br><span class="line">ethtool                 #用于查询和设置网卡配置</span><br><span class="line">netstat -tupl           #用于显示TCP/UDP的状态信息</span><br><span class="line">tcpdump tcp port 80     #显示所有http协议的流量</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Machine Learning</title>
    <url>/2021/03/25/Machine-Learning/</url>
    <content><![CDATA[<p>Record study Machine Learning!!!</p>
<a id="more"></a>

<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ul>
<li>anoconda，你值得拥有!</li>
</ul>
<h2 id="添加镜像"><a href="#添加镜像" class="headerlink" title="添加镜像"></a>添加镜像</h2><ul>
<li>如果出现找不到XXX模块，除了可能在不同文件路径，也可能是版本太高了</li>
<li>conda安装加速</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge </span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/</span><br><span class="line"> </span><br><span class="line">conda config --set show_channel_urls yes</span><br><span class="line"></span><br><span class="line"># 之后最好在C/用户/用户名/.condarc 将-default删掉</span><br></pre></td></tr></table></figure>

<ul>
<li>pip安装加速</li>
</ul>
<p><code>pip install XXX -i http://pypi.douban.com/simple --trusted-host pypi.douban.com</code></p>
<ul>
<li>或者</li>
</ul>
<p><code>pip install -i https://pypi.tuna.tsinghua.edu.cn/simple matplotlib</code><br><code>pip install -i  --default-timeout=1000 https://pypi.tuna.tsinghua.edu.cn/simple matplotlib</code></p>
<ul>
<li>国内镜像源</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">清华：https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line"></span><br><span class="line">阿里云：http://mirrors.aliyun.com/pypi/simple/</span><br><span class="line"></span><br><span class="line">中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/</span><br><span class="line"></span><br><span class="line">华中理工大学：http://pypi.hustunique.com/</span><br><span class="line"></span><br><span class="line">山东理工大学：http://pypi.sdutlinux.org/ </span><br><span class="line"></span><br><span class="line">豆瓣：http://pypi.douban.com/simple/</span><br></pre></td></tr></table></figure>

<ul>
<li>创建、删除镜像</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda create -n your_env_name python=X.X</span><br><span class="line">conda remove -n your_env_name --all</span><br><span class="line"># 删除环境的包</span><br><span class="line">conda remove --name $your_env_name  $package_name</span><br></pre></td></tr></table></figure>

<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul>
<li>conda常用命令</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建环境</span><br><span class="line">conda create –n xxx python=3.7</span><br><span class="line"></span><br><span class="line"># 查看conda版本，验证是否安装</span><br><span class="line">conda --version</span><br><span class="line"></span><br><span class="line"># 显示所有已经创建的环境</span><br><span class="line">conda env list </span><br><span class="line"></span><br><span class="line">#显示所有已经创建的环境</span><br><span class="line">conda info -e </span><br><span class="line"></span><br><span class="line"># 复制old_env_name为new_env_name</span><br><span class="line">conda create --name new_env_name --clone old_env_name </span><br><span class="line"></span><br><span class="line"># 进入到环境env_name</span><br><span class="line">activate env_name </span><br><span class="line"></span><br><span class="line"># 更新至最新版本，也会更新其它相关包</span><br><span class="line">conda update conda</span><br><span class="line">conda update anaconda</span><br><span class="line">conda update anaconda-navigator    //update最新版本的anaconda-navigator   </span><br><span class="line"></span><br><span class="line"># 更新所有包</span><br><span class="line">conda update --all </span><br><span class="line"></span><br><span class="line"># 更新指定的包</span><br><span class="line">conda update package_name </span><br><span class="line"></span><br><span class="line"># 查看所有已经安装的包</span><br><span class="line">conda list </span><br><span class="line"></span><br><span class="line"># windows系统中添加国内源</span><br><span class="line">conda config --add channels https://mirrors.aliyun.com/pypi/simple/ </span><br><span class="line"></span><br><span class="line"># 设置搜索时显示通道地址</span><br><span class="line">conda config --set show_channel_urls yes</span><br><span class="line"></span><br><span class="line"># 在当前环境中安装包</span><br><span class="line">conda install package_name </span><br><span class="line"></span><br><span class="line"># 用pip安装时，可以用 -i参数指定国内源,可以加快安装速度</span><br><span class="line">pip install tensorflow-cpu  -i https://mirrors.aliyun.com/pypi/simple/  </span><br><span class="line"></span><br><span class="line"># 在指定环境中安装包</span><br><span class="line">conda install --name env_name package_name </span><br><span class="line"></span><br><span class="line"># 删除当前环境中的包</span><br><span class="line">conda remove package </span><br><span class="line"></span><br><span class="line"># 退出当前虚拟环境</span><br><span class="line">deactivate </span><br><span class="line"></span><br><span class="line"># 删除环境</span><br><span class="line">conda env remove --name env_name</span><br></pre></td></tr></table></figure>

<h2 id="安装-Pytorch"><a href="#安装-Pytorch" class="headerlink" title="安装 Pytorch"></a>安装 Pytorch</h2><ul>
<li>清华源找不到包了，推荐国科大镜像源</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 删除已有的镜像源</span><br><span class="line">conda config --remove-key channels</span><br><span class="line"></span><br><span class="line"># 添加国科大源</span><br><span class="line">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/main/</span><br><span class="line">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/conda-forge/</span><br><span class="line">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/msys2/</span><br><span class="line">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/bioconda/</span><br><span class="line">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/menpo/</span><br><span class="line">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/pytorch/</span><br><span class="line">conda config --set show_channel_urls yes</span><br><span class="line"></span><br><span class="line"># 之后最好在C/用户/用户名/.condarc 将-default删掉</span><br><span class="line"></span><br><span class="line"># 验证通道</span><br><span class="line">conda info</span><br><span class="line"></span><br><span class="line"># 官方下载 少了个 -c</span><br><span class="line">conda install pytorch torchvision torchaudio cudatoolkit=10.2 pytorch</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="NP问题"><a href="#NP问题" class="headerlink" title="NP问题"></a>NP问题</h1><ul>
<li>P问题：如果一个问题可以找到一个能在多项式的时间里解决它的算法，那么这个问题就属于P问题</li>
<li>NP问题：不是非P类问题、指可以在多项式的时间里验证一个解的问题或者可以在多项式的时间里猜出一个解的问题。找一个解很困难，但验证一个解很容易；验证一个解只需要O(n)的时间复杂度，那么，只要猜得准，就一定能在多项式的时间里解决这个问题。这就是NP问题。</li>
<li>通常只有NP问题才可能找到多项式的算法。</li>
</ul>
<h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><ul>
<li>所有的P类问题都是NP问题。即能多项式地解决一个问题，必然能多项式地验证一个问题的解</li>
<li>反之，是否所有的NP问题都是P类问题——P=NP？</li>
<li>NPC问题：即NP-完全问题。要证明P=NP是否，关键在于NPC</li>
</ul>
<h2 id="约化"><a href="#约化" class="headerlink" title="约化"></a>约化</h2><ul>
<li>也叫归约</li>
<li>一个问题A可以约化为问题B的含义即是，可以用问题B的解法解决问题A，或者说，问题A可以“变成”问题B。</li>
<li>直观上来看：B的时间复杂度高于或者等于A的时间复杂度。若B的时间复杂度比A的时间复杂度还低了，那A的算法就可以改进为B的算法，两者的时间复杂度还是相同。</li>
<li>约化具有传递性。如果问题A可约化为问题B，问题B可约化为问题C，则问题A一定可约化为问题C。</li>
<li>“可约化”是指的可“多项式地”约化(Polynomial-time Reducible)，约化的过程只有用多项式的时间完成才有意义。</li>
</ul>
<h2 id="NPC"><a href="#NPC" class="headerlink" title="NPC"></a>NPC</h2><ul>
<li>存在这样一个NP问题，所有的NP问题都可以约化成它。换句话说，只要解决了这个问题，那么所有的NP问题都解决了。并且这种问题不只一个，它有很多个，它是一类问题。这一类问题就是传说中的NPC问题</li>
<li>NPC问题是最复杂的问题。</li>
<li>同时满足两个条件的问题就是NPC问题。首先，它得是一个NP问题；然后，所有的NP问题都可以约化到它。</li>
<li>NPC问题目前没有多项式的有效算法，只能用指数级甚至阶乘级复杂度的搜索。因此：正是NPC问题的存在，使人们相信P≠NP</li>
</ul>
<h2 id="NP-Hard"><a href="#NP-Hard" class="headerlink" title="NP-Hard"></a>NP-Hard</h2><ul>
<li>满足NPC问题定义的第二条但不一定要满足第一条（即NP-Hard问题要比 NPC问题的范围广）</li>
<li>NP-Hard问题同样难以找到多项式的算法；</li>
<li>NP-Hard不一定是NP问题。</li>
</ul>
<hr>
<h1 id="最优化算法"><a href="#最优化算法" class="headerlink" title="最优化算法"></a>最优化算法</h1><ul>
<li>了解下最优化算法</li>
</ul>
<h2 id="启发式算法（近似算法）"><a href="#启发式算法（近似算法）" class="headerlink" title="启发式算法（近似算法）"></a>启发式算法（近似算法）</h2><h3 id="SA"><a href="#SA" class="headerlink" title="SA"></a>SA</h3><ul>
<li>模拟退火算法</li>
</ul>
<h3 id="GA"><a href="#GA" class="headerlink" title="GA"></a>GA</h3><ul>
<li>遗传算法</li>
</ul>
<h3 id="EP"><a href="#EP" class="headerlink" title="EP"></a>EP</h3><ul>
<li>期望传播算法</li>
</ul>
<h3 id="ES"><a href="#ES" class="headerlink" title="ES"></a>ES</h3><ul>
<li>进化算法</li>
</ul>
<h3 id="TS"><a href="#TS" class="headerlink" title="TS"></a>TS</h3><ul>
<li>禁忌搜索算法</li>
</ul>
]]></content>
      <categories>
        <category>Machine_Learning</category>
      </categories>
      <tags>
        <tag>Python3</tag>
        <tag>TensorFlow</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown</title>
    <url>/2019/08/20/Markdown/</url>
    <content><![CDATA[<p>How to use Markdown.</p>
<a id="more"></a>

<h2 id="修改实时预览字体"><a href="#修改实时预览字体" class="headerlink" title="修改实时预览字体"></a>修改实时预览字体</h2><blockquote>
<p>Tools-Options-Stylesheets-Markdownpad github.css-edit</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  min-width: 32em;</span><br><span class="line">  max-width: 52em;</span><br><span class="line">  margin: 10px;</span><br><span class="line">  zoom:2; #第一个body即可</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;font  更改语法&gt;   你的内容   &lt;/font&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>具体用法</p>
</blockquote>
<ul>
<li><font color="#00ffff">字体改成蓝色了</font><br><code>&lt;font color=#00ffff&gt;字体改成蓝色了&lt;/font&gt;</code></li>
<li><font color="#FF0000">字体改成红色了</font><br><code>&lt;font color=#FF0000&gt;字体改成红色了&lt;/font&gt;</code></li>
</ul>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">color=#0099ff   更改字体颜色</span><br><span class="line">face=&quot;黑体&quot;   更改字体</span><br><span class="line">size= 7     更改字体大小</span><br><span class="line"></span><br><span class="line">&lt;font face=&quot;黑体&quot;&gt;我是黑体字&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">&lt;font face=&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">&lt;font face=&quot;STCAIYUN&quot;&gt;我是华文彩云&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">&lt;font color=#0099ff size=5 face=&quot;黑体&quot;&gt;color=#0099ff size=5 face=&quot;黑体&quot;&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">&lt;font color=#00ffff size=5&gt;color=#00ffff&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">&lt;font color=gray size=5&gt;color=gray&lt;/font&gt;</span><br></pre></td></tr></table></figure>

<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><pre><code># 一级标题</code></pre><h2 id="二级"><a href="#二级" class="headerlink" title="二级"></a>二级</h2><pre><code>## 二级</code></pre><h3 id="三级"><a href="#三级" class="headerlink" title="三级"></a>三级</h3><pre><code>### 三级</code></pre><ul>
<li>列表</li>
<li>列表</li>
</ul>
<h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![图片名字](图片地址 &quot;图片title&quot;)</span><br></pre></td></tr></table></figure>

<p><img src="/images/1.png" alt="卡哇伊" title="卡哇伊"></p>
<p><img src="/images/5.jpg" alt="四月是你的谎言" title="四月是你的谎言"></p>
<h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><hr>
<hr>
<h2 id="斜字体"><a href="#斜字体" class="headerlink" title="斜字体"></a><em>斜字体</em></h2><pre><code>*xingkong*</code></pre><h2 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a><strong>加粗</strong></h2><pre><code>**xingkong**</code></pre><h2 id="加粗斜体"><a href="#加粗斜体" class="headerlink" title="加粗斜体"></a><strong><em>加粗斜体</em></strong></h2><pre><code>***xingkong***</code></pre><h2 id="加删除线"><a href="#加删除线" class="headerlink" title="加删除线"></a><del>加删除线</del></h2><pre><code>~~xingkong~~</code></pre><h2 id="插入单行代码"><a href="#插入单行代码" class="headerlink" title="插入单行代码"></a>插入单行代码</h2><p><code>import *</code></p>
<h2 id="插入多行代码"><a href="#插入多行代码" class="headerlink" title="插入多行代码"></a>插入多行代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><pre><code>&gt;</code></pre><blockquote>
<p>引用内容</p>
<blockquote>
<p>2333</p>
<blockquote>
<p>66666</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p><a href="https://space.bilibili.com/34033362">bilibili</a></p>
<pre><code>[超链接名](超链接地址 &quot;超链接title&quot;)  </code></pre><h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><pre><code>1.列表内容
    二级
2.列表内容
    二级
3.列表内容
    二级</code></pre><h2 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h2><pre><code>上一级和下一级之间敲四个空格即可</code></pre><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><pre><code>姓名|技能|排行
--|:--:|--:
刘备|哭|大哥</code></pre><table>
<thead>
<tr>
<th>姓名</th>
<th align="center">技能</th>
<th align="right">排行</th>
</tr>
</thead>
<tbody><tr>
<td>刘备</td>
<td align="center">哭</td>
<td align="right">大哥</td>
</tr>
<tr>
<td>关羽</td>
<td align="center">打</td>
<td align="right">二哥</td>
</tr>
<tr>
<td>张飞</td>
<td align="center">骂</td>
<td align="right">三弟</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>介绍</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Preference</title>
    <url>/2019/08/20/Preference/</url>
    <content><![CDATA[<p>Hexo Personalization</p>
<a id="more"></a>

<h1 id="文件路径"><a href="#文件路径" class="headerlink" title="文件路径"></a>文件路径</h1><ul>
<li>\themes\next\ _config.yml</li>
</ul>
<h2 id="首页设置阅读全文"><a href="#首页设置阅读全文" class="headerlink" title="首页设置阅读全文"></a>首页设置阅读全文</h2><ul>
<li>法一：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">auto_excerpt（未成功）</span><br></pre></td></tr></table></figure>

<ul>
<li>法二：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- more --&gt;写在文章里</span><br></pre></td></tr></table></figure>

<h2 id="添加评论功能"><a href="#添加评论功能" class="headerlink" title="添加评论功能"></a>添加评论功能</h2><p>More info: <a href="https://leancloud.cn/dashboard/applist.html#/apps" target="_blank" rel="noopener">LeanCloud</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">valine</span><br></pre></td></tr></table></figure>

<h2 id="设置网站图标"><a href="#设置网站图标" class="headerlink" title="设置网站图标"></a>设置网站图标</h2><ul>
<li><p><em>图片分16 16、32 32</em></p>
</li>
<li><p><a href="https://www.easyicon.net/1149904-house_icon.html" target="_blank" rel="noopener">house</a>                </p>
</li>
<li><p><a href="https://www.easyicon.net/1192949-house_icon.html" target="_blank" rel="noopener">houselove</a></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">favicon</span><br></pre></td></tr></table></figure>

<h2 id="添加主题背景"><a href="#添加主题背景" class="headerlink" title="添加主题背景"></a>添加主题背景</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">canvas</span><br></pre></td></tr></table></figure>

<h2 id="访问数、记录"><a href="#访问数、记录" class="headerlink" title="访问数、记录"></a>访问数、记录</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">busuanzi_count</span><br></pre></td></tr></table></figure>

<h2 id="添加加载效果"><a href="#添加加载效果" class="headerlink" title="添加加载效果"></a>添加加载效果</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pace</span><br></pre></td></tr></table></figure>

<h2 id="开启订阅公众号"><a href="#开启订阅公众号" class="headerlink" title="开启订阅公众号"></a>开启订阅公众号</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wechat</span><br></pre></td></tr></table></figure>

<h2 id="设置打赏"><a href="#设置打赏" class="headerlink" title="设置打赏"></a>设置打赏</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reward</span><br></pre></td></tr></table></figure>

<h2 id="创建社交链接"><a href="#创建社交链接" class="headerlink" title="创建社交链接"></a>创建社交链接</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">social</span><br></pre></td></tr></table></figure>

<h2 id="设置头像"><a href="#设置头像" class="headerlink" title="设置头像"></a>设置头像</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">avatar</span><br></pre></td></tr></table></figure>

<h2 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接"></a>友情链接</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">blog rolls (  links   )</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<ul>
<li>_config.yml</li>
</ul>
<h2 id="文档加密"><a href="#文档加密" class="headerlink" title="文档加密"></a>文档加密</h2><ul>
<li>安装encrypt</li>
<li><code>npm install --save hexo-blog-encrypt</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Security</span><br><span class="line">encrypt: # hexo-blog-encrypt</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure>

<h2 id="设置网站名字"><a href="#设置网站名字" class="headerlink" title="设置网站名字"></a>设置网站名字</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title</span><br></pre></td></tr></table></figure>

<h2 id="设置主题"><a href="#设置主题" class="headerlink" title="设置主题"></a>设置主题</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">theme</span><br></pre></td></tr></table></figure>

<h2 id="添加搜索功能"><a href="#添加搜索功能" class="headerlink" title="添加搜索功能"></a>添加搜索功能</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br><span class="line"></span><br><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br><span class="line"></span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<ul>
<li>\themes\next\source\css_common\components\sidebar\sidebar-author.styl</li>
</ul>
<h2 id="设置头像为圆形可旋转"><a href="#设置头像为圆形可旋转" class="headerlink" title="设置头像为圆形可旋转"></a>设置头像为圆形可旋转</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">border-radius: 50%;</span><br><span class="line">transition: 2s all;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.site-author-image:hover&#123;</span><br><span class="line">  transform: rotate(360deg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>\themes\next\layout_layout.swig</li>
</ul>
<h2 id="右上角添加github图标"><a href="#右上角添加github图标" class="headerlink" title="右上角添加github图标"></a>右上角添加github图标</h2><ul>
<li>More info: <a href="http://tholman.com/github-corners" target="_blank" rel="noopener">github图标</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<ul>
<li>\themes\next\source\css_common\components\post\post.styl</li>
</ul>
<h2 id="设置文章内链接样式"><a href="#设置文章内链接样式" class="headerlink" title="设置文章内链接样式"></a>设置文章内链接样式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.post-body p a&#123;</span><br><span class="line">  color: #345;</span><br><span class="line">  border-bottom: none;</span><br><span class="line">  &amp;:hover&#123;</span><br><span class="line">    color: blue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<ul>
<li>\themes\next\layout_macro\post.swig</li>
</ul>
<h2 id="带-号的标签"><a href="#带-号的标签" class="headerlink" title="带#号的标签"></a>带#号的标签</h2><p>More info: <a href="https://fontawesome.com/v4.7.0/icons" target="_blank" rel="noopener">图标网址</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;&#123;&#123; url_for(tag.path) &#125;&#125;&quot; rel=&quot;tag&quot;&gt; &#123;&#123; tag_indicate &#125;&#125; &#123;&#123; tag.name &#125;&#125;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;a href=&quot;&#123;&#123; url_for(tag.path) &#125;&#125;&quot; rel=&quot;tag&quot;&gt; &lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; &#123;&#123; tag.name &#125;&#125;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;a href=&quot;&#123;&#123; url_for(tag.path) &#125;&#125;&quot; rel=&quot;tag&quot;&gt; &lt;i class=&quot;fa fa-location-arrow&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; &#123;&#123; tag.name &#125;&#125;&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>\themes\next\layout_partials\footer.swig</li>
</ul>
<h2 id="隐藏强力驱动"><a href="#隐藏强力驱动" class="headerlink" title="隐藏强力驱动"></a>隐藏强力驱动</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--&#123;%- if theme.footer.powered.enable %&#125;</span><br><span class="line">  &lt;div class=&quot;powered-by&quot;&gt;&#123;#</span><br><span class="line">  #&#125;&#123;&#123; __(&apos;footer.powered&apos;, next_url(&apos;https://hexo.io&apos;, &apos;Hexo&apos;, &#123;class: &apos;theme-link&apos;&#125;)) &#125;&#125;&#123;#</span><br><span class="line">  #&#125;&#123;%- if theme.footer.powered.version %&#125; v&#123;&#123; hexo_env(&apos;version&apos;) &#125;&#125;&#123;%- endif %&#125;&#123;#</span><br><span class="line"> #&#125;&lt;/div&gt;</span><br><span class="line">&#123;%- endif %&#125;</span><br><span class="line"></span><br><span class="line">&#123;%- if theme.footer.powered.enable and theme.footer.theme.enable %&#125;</span><br><span class="line">  &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;</span><br><span class="line">&#123;%- endif %&#125;--&gt;</span><br></pre></td></tr></table></figure>

<h2 id="字数统计和阅读时长"><a href="#字数统计和阅读时长" class="headerlink" title="字数统计和阅读时长"></a>字数统计和阅读时长</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-wordcount --save</span><br><span class="line"></span><br><span class="line">countword</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<ul>
<li>\themes\next\layout_macro\新建文件passage-end-tag.swig</li>
</ul>
<h2 id="在每篇文章末尾统一添加“本文结束”标记"><a href="#在每篇文章末尾统一添加“本文结束”标记" class="headerlink" title="在每篇文章末尾统一添加“本文结束”标记"></a>在每篇文章末尾统一添加“本文结束”标记</h2><ul>
<li>More info: <a href="https://fontawesome.com/v4.7.0/icons" target="_blank" rel="noopener">图标网址</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;% if not is_index %&#125;</span><br><span class="line">        &lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;本文结束&lt;i class=&quot;fa fa-hand-peace-o&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/i&gt;&lt;/div&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>\themes\next\layout_macro\post.swig</li>
<li>在post-body 之后， post-footer 之前添加如下代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &#123;% if not is_index %&#125;</span><br><span class="line">    &#123;% include &apos;passage-end-tag.swig&apos; %&#125;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<ul>
<li>\themes\next\source\css_custom\custom.styl</li>
</ul>
<h2 id="自定义鼠标样式（0-0）"><a href="#自定义鼠标样式（0-0）" class="headerlink" title="自定义鼠标样式（0.0）"></a>自定义鼠标样式（0.0）</h2><ul>
<li><a href="https://www.lixint.me/hexo-theme-diy.html" target="_blank" rel="noopener">个性设置</a></li>
<li><em>图片分16 16、32 32</em></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">     cursor: url(&quot;/images/xxx.ico&quot;),auto!important</span><br><span class="line"> &#125;</span><br><span class="line"> :active &#123;</span><br><span class="line">     cursor: url(&quot;/images/xxx.ico&quot;),auto!important</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<ul>
<li>\themes\next\source\js\新建文件clicklove.js</li>
<li>\themes\next\layout_layout.swig</li>
</ul>
<h2 id="鼠标点击出现桃心"><a href="#鼠标点击出现桃心" class="headerlink" title="鼠标点击出现桃心"></a>鼠标点击出现桃心</h2><ul>
<li>rgb是255位，本博客改为（0，0，0） </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">!function(e,t,a)&#123;function n()&#123;c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &apos;&apos;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=&quot;left:&quot;+d[e].x+&quot;px;top:&quot;+d[e].y+&quot;px;opacity:&quot;+d[e].alpha+&quot;;transform:scale(&quot;+d[e].scale+&quot;,&quot;+d[e].scale+&quot;) rotate(45deg);background:&quot;+d[e].color+&quot;;z-index:99999&quot;);requestAnimationFrame(r)&#125;function o()&#123;var t=&quot;function&quot;==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement(&quot;div&quot;);a.className=&quot;heart&quot;,d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement(&quot;style&quot;);a.type=&quot;text/css&quot;;try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)&#125;function s()&#123;return&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 页面点击小红心 --&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;/js/clicklove.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="萌萌的（todo）"><a href="#萌萌的（todo）" class="headerlink" title="萌萌的（todo）"></a>萌萌的（todo）</h2><ul>
<li><a href="https://www.lixint.me/hexo-theme-diy.html#%E7%BD%91%E7%AB%99%E6%A0%87%E9%A2%98%E6%A0%8F%E8%83%8C%E6%99%AF%E9%A2%9C%E8%89%B2" target="_blank" rel="noopener">模型</a></li>
</ul>
]]></content>
      <categories>
        <category>介绍</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>主题</tag>
        <tag>个性化</tag>
      </tags>
  </entry>
  <entry>
    <title>UNP</title>
    <url>/2021/06/28/UNP/</url>
    <content><![CDATA[<p>Learning UNP Record!!</p>
<a id="more"></a>

<blockquote>
<p>基本上就选择 TCP/UDP、一些常用的内容，什么 SCTP、IP 层的东西目前基本用不上的初学者就不看了！<br>因为代码比较多，就直接写在 Markdown 了</p>
</blockquote>
<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><h2 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h2><ul>
<li>这是在 Linux 下配置的，<a href="http://www.unpbook.com/src.html" target="_blank" rel="noopener">源码地址</a><ul>
<li>参照 <code>README</code> 进行编译进行编译的时候，第一步就出错</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/UNP/configure.png" alt title="./configure"></p>
<ul>
<li>一直在报错，找不到文件——我就纳闷了？后来是下载的版本问题，要下载源代码，而不是 GitHub 编译好的版本</li>
</ul>
<p><img src="/pictrues/UNP/configure1.png" alt title="./configure"></p>
<ul>
<li>源码下载好之后，解压缩 <code>tar zxvf unpv13e.tar.gz</code></li>
<li>进入 <code>unpv13e</code> 文件目录，之后根据 <code>README</code> 文件进行编译</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ./unpv13e</span><br><span class="line">./configure </span><br><span class="line">cd lib</span><br><span class="line">make </span><br><span class="line">cd ../libfree </span><br><span class="line">make		//报错</span><br></pre></td></tr></table></figure>

<p><img src="/pictrues/UNP/configure2.png" alt title="make报错"></p>
<ul>
<li><code>libfree/inet_ntop.c</code> 中的第 60 行  <code>size_t</code>  改成  <code>socklen_t</code></li>
<li><code>README</code> 后面两步 <code>make</code> 需要你的系统支持 4.4 BSD 和 XTI，Linux 系统直接跳过</li>
<li>拷贝 <code>libunp.a</code>，文件在主目录下</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ..</span><br><span class="line">sudo cp libunp.a /usr/lib</span><br><span class="line">sudo cp libunp.a /usr/lib64</span><br></pre></td></tr></table></figure>

<ul>
<li>修改 <code>unp.h</code> 文件，并拷贝 <code>unp.h</code> 和 <code>config.h</code> 文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd lib</span><br><span class="line">vim unp.h  //将 unp.h 中的 #include &quot;../config.h&quot; 改成 #include &quot;config.h&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/pictrues/UNP/configure3.png" alt title="../config.h"></p>
<p><img src="/pictrues/UNP/configure4.png" alt title="config.h"></p>
<ul>
<li>拷贝 unp.h 和 config.h 到 /usr/include</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo cp unp.h /usr/include</span><br><span class="line">cd ..</span><br><span class="line">sudo cp config.h /usr/include</span><br></pre></td></tr></table></figure>

<ul>
<li>为了防止文件名发生冲突，可以将 config.h 更名为 unp_config.h 后再进行拷贝，对应修改 unp.h</li>
<li>测试用例</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd intro</span><br><span class="line">make daytimetcpcli</span><br><span class="line">./daytimetcpcli 127.0.0.1</span><br></pre></td></tr></table></figure>

<ul>
<li>提示链接失败，<code>daytime</code> 服务没有打开<ul>
<li>网上搜了下发现 <code>/etc</code> 下没有 <code>xinetd.d</code>，原以为是版本问题，却发现是需要安装的！</li>
<li><code>sudo apt-get install xinetd</code></li>
<li>端口号 <code>cat /etc/services | grep &quot;daytime&quot;</code></li>
<li>启动服务 <code>sudo vim /etc/xinetd.d/daytime</code></li>
<li>将 disable 配置项修改由 yes -&gt; no</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/UNP/configure5.png" alt title="daytime"></p>
<ul>
<li>重启服务 <code>sudo /etc/init.d/xinetd restart</code></li>
<li>测试 <code>./daytimetcpcli 127.0.0.1</code></li>
</ul>
<ul>
<li>以后在代码中添加 <code>#include &quot;unp.h&quot;</code>，就可以调用 unp.h；另外编译时，需要添加 <code>-lunp</code> 编译选项</li>
</ul>
<h2 id="CentOS"><a href="#CentOS" class="headerlink" title="CentOS"></a>CentOS</h2><blockquote>
<p>make 是 gcc 的编译器，一定要安装</p>
</blockquote>
<h3 id="CentOS-安装-gcc、g"><a href="#CentOS-安装-gcc、g" class="headerlink" title="CentOS 安装 gcc、g++"></a>CentOS 安装 gcc、g++</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum -y install gcc automake autoconf libtool make</span><br><span class="line">sudo yum install gcc gcc-c++ //安装g++</span><br></pre></td></tr></table></figure>

<ul>
<li>CentOS 的 daytime 开启方式似乎不太一样</li>
<li><code>/etc/xinetd.d/</code> 目录存在，但是里面是空的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install xinetd</span><br><span class="line">sudo vim /etc/xinetd.d/daytime-stream  # disable的yes改为no</span><br><span class="line">sudo vim /etc/xinetd.d/ daytime-dgram  # disable的yes改为no</span><br><span class="line">service xinetd restart  # 重启xinetd服务</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><ul>
<li><code>socket</code> TCP 套接字</li>
</ul>
<p><img src="/pictrues/UNP/socketfd.png" alt title="socket"></p>
<h2 id="包裹函数"><a href="#包裹函数" class="headerlink" title="包裹函数"></a>包裹函数</h2><ul>
<li><p><code>unp.h</code> 声明了很多函数，但是没有定义</p>
</li>
<li><p>同在 <code>lib</code> 文件下的其余 <code>.c</code> 文件，是函数的定义，并不是写在一起的，而是分成了很多文件</p>
<ul>
<li>有的 <code>.c</code> 文件只有一个函数、有的有好几个</li>
</ul>
</li>
<li><p>包裹函数就是首字母大写的同名函数，与原本的函数区别就是多了异常检测（也是自己定义的函数）</p>
</li>
<li><p><code>lib</code> 文件下还有一些其他的 <code>.lc</code>、<code>.lh</code> 文件，估计就是链接文件了，还有 <code>Makefile</code></p>
<ul>
<li>函数太多了，以至于不知道在哪个文件定义的，</li>
</ul>
</li>
<li><p><code>errno</code> 在 <code>sys/errno.h</code> 定义，是全局变量（用来输出对应的错误信息），多线程的话全局变量就不合适了</p>
<ul>
<li>在网上找了下源码，用的是 <code>extern</code> 关键字</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/UNP/errno.png" alt title="errno"></p>
<ul>
<li>其他函数好多都是系统自带的库里面的，这个要注意！</li>
</ul>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><ul>
<li><p>书上的可以跑通，但是大佬写的硬是跑不通！</p>
<ul>
<li>搜了半天发现，<a href="https://blog.csdn.net/test1280/article/details/80642847" target="_blank" rel="noopener">监听套接字</a>这一部分有问题（大佬写的侦听地址还没有看！明天再搞），也跟防火墙有点关系（防火墙关了后，书上源码可以获取对应节点 IP 地址的时间，不限定 127.0.0.1 ）</li>
<li>还有就是编译、链接没搞懂，<code>.o</code> 是目标文件，还不能运行，跟 <code>make</code> 关系也没有搞懂！</li>
<li>记录下，自己的两个节点，防火墙都已经关闭</li>
</ul>
</li>
<li><p>想获取时间，首先得关闭防火墙</p>
</li>
</ul>
<h3 id="CentOS8-关闭防火墙"><a href="#CentOS8-关闭防火墙" class="headerlink" title="CentOS8 关闭防火墙"></a>CentOS8 关闭防火墙</h3><ul>
<li>查看状态、打开防火墙、关闭防火墙、开启防火墙、禁用防火墙</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl status firewalld.service</span><br><span class="line">systemctl start firewalld.service</span><br><span class="line">systemctl stop firewalld.service</span><br><span class="line">systemctl enable firewalld.service</span><br><span class="line">systemctl disable firewalld.service</span><br></pre></td></tr></table></figure>

<h3 id="编译、链接"><a href="#编译、链接" class="headerlink" title="编译、链接"></a>编译、链接</h3><ul>
<li>修改某个文件（头文件 <code>.c</code> ）后，不需要一个一个的编译<ul>
<li>如 <code>gcc daytimetcpcli.c -o daytimetcpcli</code></li>
</ul>
</li>
<li>而是直接 <code>make</code> 一下，全部搞定！！<ul>
<li>下面就是根据习题修改后的输出——多了次数</li>
<li>学习了 <code>Makefile</code> 一般要编译成目标文件的 <code>.c</code> 文件都有 <code>main</code> 函数</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/UNP/daytimetcpcli.png" alt></p>
<h3 id="htons"><a href="#htons" class="headerlink" title="htons()"></a>htons()</h3><ul>
<li>经过习题的测试，发现能不能连上，跟 <code>htons()</code> 函数里的数值有关！<ul>
<li>客户端、服务端的获取时间程序中 <code>htons(9999)</code> 时，是可以对指定服务端进行获取程序的，但是不能对 <code>127.0.0.1</code> 有效</li>
<li>之后将客户端改为 <code>htons(13)</code> 时，发现这是万能的，指定的服务端可以不用运行后台程序，之后再细细了解——为什么服务端不运行指定程序，照样可以获取到时间？</li>
</ul>
</li>
</ul>
<h2 id="网络拓扑"><a href="#网络拓扑" class="headerlink" title="网络拓扑"></a>网络拓扑</h2><ul>
<li>网络接口信息 <code>netstat -ni</code><ul>
<li>lo —— 环回 loopback</li>
<li>ens33 —— 以太网接口</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/UNP/netstat_ni.png" alt title="显示接口信息"></p>
<ul>
<li>展示路由表 <code>netstat -r</code></li>
<li>接口的详细信息 <code>ifconfig ens33</code></li>
</ul>
<h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><ul>
<li>基础知识，暂时先略过</li>
</ul>
<h1 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h1><ul>
<li>得做好笔记，要不然容易忘</li>
</ul>
<h2 id="套接字地址结构"><a href="#套接字地址结构" class="headerlink" title="套接字地址结构"></a>套接字地址结构</h2><ul>
<li><code>#define    SA    struct sockaddr</code> 这是通用的套接字地址结构<ul>
<li>在调用 <code>bind()</code> 函数，要进行类型强制转换，因为是指针，所以得先取地址再转换</li>
<li>有 5 种套接字地址结构 —— IPv4、IPv6、Unix 域、数据链路和存储 —— 长度不一样，所以也要传递长度这个参数</li>
<li>长度：结构体的大小</li>
</ul>
</li>
</ul>
<h2 id="套接字函数-——-值-结果参数"><a href="#套接字函数-——-值-结果参数" class="headerlink" title="套接字函数 —— 值 - 结果参数"></a>套接字函数 —— 值 - 结果参数</h2><ul>
<li><p>进程到内核</p>
<ul>
<li>bind、connect、sendto</li>
</ul>
</li>
<li><p>内核到进程</p>
<ul>
<li>accept、recvfrom、getsockname、getpeername</li>
</ul>
</li>
<li><p>套接字地址结构大小的类型 <code>socklen_t</code></p>
</li>
<li><p>上面两者区别是结构大小这个参数的类型不同，内核到进程是指针</p>
</li>
</ul>
<h2 id="字节排序函数"><a href="#字节排序函数" class="headerlink" title="字节排序函数"></a>字节排序函数</h2><ul>
<li>内存存储两字节的方法 —— 小端（低序字节在起始地址）、大端（高序字节在起始地址）<ul>
<li>下面的例子已经编译好了</li>
<li>字符类型与整数直接比较嘛，还有为什么一个是 1，一个是 2 呢<ul>
<li>因为 0x0102 这个，16 位两个字节，但还是想不明白这两个变量为什么会有关联</li>
<li><code>union</code> 允许在相同的内存位置存储不同的数据类型！所以任何时候只能有一个成员带有值</li>
</ul>
</li>
<li>网络协议必须指定一个网络字节序<ul>
<li>主机字节序 与 网络字节序 相互转换</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/UNP/3_10.png" alt></p>
<p><img src="/pictrues/UNP/3_10-1.png" alt></p>
<ul>
<li>4 个函数，h:host、n:network、s:short、l:long<ul>
<li>头文件 <code>&lt;netinet/in.h&gt;</code></li>
<li>htons、htonl —— 返回网络字节序的值</li>
<li>ntohs、ntohl —— 返回主机字节序的值</li>
</ul>
</li>
</ul>
<h2 id="bzreo"><a href="#bzreo" class="headerlink" title="bzreo"></a>bzreo</h2><ul>
<li>头文件 <code>&lt;strings.h&gt;</code><ul>
<li>目标字节串指定数目的字节置 0 </li>
</ul>
</li>
</ul>
<p><img src="/pictrues/UNP/bzero.png" alt></p>
<h2 id="地址转换函数"><a href="#地址转换函数" class="headerlink" title="地址转换函数"></a>地址转换函数</h2><ul>
<li><p>点分十进制数串 转为 32 位网络字节序二进制值</p>
</li>
<li><p>头文件 <code>&lt;arpa/inet.h&gt;</code></p>
<ul>
<li>inet_aton<ul>
<li>返回类型 <code>int</code>，成功转换返回 1，否则 0</li>
<li>两个参数，一个目标数串，另一个参数用来作为输出的结果 <code>in_addr</code> 指针类型</li>
</ul>
</li>
<li>inet_addr<ul>
<li>返回类型 <code>in_addr_t</code>，255.255.255.255 这个被占用，用来返回出错的，所以不能用来转为广播地址</li>
<li>只有一个参数，即目标数串</li>
<li>书上说已经被废弃……</li>
</ul>
</li>
</ul>
</li>
<li><p>32 位网络字节序二进制值 转为 点分十进制数串</p>
<ul>
<li>inet_ntoa<ul>
<li><code>char *inet_ntoa(struct in_addr inaddr);</code></li>
<li>参数不是指针</li>
</ul>
</li>
</ul>
</li>
<li><p>IPv4、IPv6 通用的两个函数</p>
</li>
<li><p>头文件也是 <code>&lt;arpa/inet.h&gt;</code></p>
<ul>
<li>inet_pton<ul>
<li><code>inet_pton(AF_INET, argv[1], &amp;servaddr.sin_addr)</code> 成功返回 1，表达式无效返回 0，出错返回 -1</li>
<li>第一个参数只能是 AF_INET、AF_INET6</li>
<li><code>servaddr.sin_addr</code> 是输出的结果，是一个结构里的变量</li>
</ul>
</li>
<li>inet_ntop<ul>
<li><code>const char * inet_ntop(int family, const void *addrptr, char *strptr, size_t len)</code></li>
<li><code>len</code> 参数要足以容纳结果</li>
<li><code>strptr</code> 是返回的结果，即点分十进制数串</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/UNP/inet_ntop.jpg" alt></p>
<ul>
<li>上面这张图里面，第二个参数，必须得对应 IPv4 或者 IPv6 这两个版本的结构体<ul>
<li>书上自定义了一个函数 <code>sock_ntop()</code> ，用来转化对应的结构体</li>
<li>还有其他的几个函数就不在这儿写了</li>
</ul>
</li>
</ul>
<h2 id="readn、writen、readline"><a href="#readn、writen、readline" class="headerlink" title="readn、writen、readline"></a>readn、writen、readline</h2><ul>
<li><p>字节流套接字、缓冲区满了、非阻塞 —— read、write —— 不让实现返回一个不足的字节计数值</p>
</li>
<li><p><code>ssize_t    readn(int fd, void *vptr, size_t n)</code></p>
<ul>
<li>从一个描述符读 n 个字节</li>
</ul>
</li>
<li><p><code>ssize_t    writen(int fd, const void *vptr, size_t n)</code></p>
<ul>
<li>往一个描述符写 n 个字节</li>
</ul>
</li>
<li><p><code>ssize_t readline(int fd, void *vptr, size_t maxlen)</code></p>
<ul>
<li>从一个描述符读文本行，一次一字节</li>
<li>这里用 read 太慢</li>
<li>用 stdio 太危险，因为 stdio 的缓冲区不可见</li>
<li>书上还提供了这个函数的改进版本，使用了内部缓冲区！并且使用 my_read 代替 read 函数<ul>
<li>但是使用了静态变量，函数就变得不可重入、非线程安全了</li>
</ul>
</li>
</ul>
</li>
<li><p>都有查找 EINTER 错误，详细在第五章</p>
</li>
</ul>
<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><ul>
<li>前两题书上有答案，主要是第三题<ul>
<li><code>telnet 0xe</code> 刚开始我还以为 <code>telnet</code> 是哪个文件里编译出来的呢，没想到是系统自带的</li>
<li>Ubuntu 系统里有，Centos8 里没有</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/UNP/telnet.png" alt title="telnet 0xe"></p>
<ul>
<li>师兄大佬真的厉害，习题代码都给整出来了</li>
</ul>
<p><img src="/pictrues/UNP/inet_pton_loose.png" alt title="inet_pton_loose 0xe"></p>
<h1 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h1><ul>
<li>上一章的习题还没有完全看懂，只知道大致思路，一些指针指向的长度之类的没有细看，时间不等人，继续看下去</li>
</ul>
<h2 id="socket-函数"><a href="#socket-函数" class="headerlink" title="socket 函数"></a>socket 函数</h2><ul>
<li>客户端、服务端都要用到这个函数</li>
<li>头文件 <code>#include    &lt;sys/socket.h&gt;</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// SOCK_STREAM 不知道什么类型</span><br><span class="line">if ( (sockfd = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0)</span><br><span class="line">	err_sys(&quot;socket error&quot;);</span><br></pre></td></tr></table></figure>

<ul>
<li>TCP 仅支持 SOCK_STREAM 套接字<ul>
<li>sockfd 是返回值，若为负数，说明失败</li>
<li>第一个参数基本上是以 AF_ 开头，很少出现 PF_</li>
</ul>
</li>
</ul>
<h2 id="connect-函数"><a href="#connect-函数" class="headerlink" title="connect 函数"></a>connect 函数</h2><ul>
<li>TCP 客户端需要用到这个函数，服务器不需要！</li>
<li>头文件也是 <code>#include    &lt;sys/socket.h&gt;</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (connect(sockfd, (SA *) &amp;servaddr, sizeof(servaddr)) &lt; 0)</span><br><span class="line">		err_sys(&quot;connect error&quot;);</span><br></pre></td></tr></table></figure>

<ul>
<li>(SA *) 强制转换成通用类型结构，之前提到过<ul>
<li>所以，套接字地址结构必须包含服务器的 IP 地址和端口号</li>
<li>这个函数会激发 TCP 三次握手，出错的情况有三种<ul>
<li>客户端没有接收到 SYN，超时，75s</li>
<li>服务器对客户端的响应是 RST</li>
<li>客户端显示目的地不可达（某个路由器）75s</li>
</ul>
</li>
<li>127.0.0.1 原来是本地主机……难怪，有一种出错情况——超时——一直试不出来，噢，原来是等的时间太久了</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/UNP/connect.png" alt title="三种错误情况"></p>
<ul>
<li>三种错误<ul>
<li>超时：不存在的一个 IP 地址，永远收不到 ARP 请求</li>
<li>连接拒绝：服务器没有运行对应的获取时间程序</li>
<li>路径不可达：IP 地址不可到达</li>
</ul>
</li>
<li>每次 connect 失败后，都必须 close 当前的套接字描述符，并重新调用 socket，但是书上源码都是一报错直接返回错误信息</li>
</ul>
<h2 id="bind-函数"><a href="#bind-函数" class="headerlink" title="bind 函数"></a>bind 函数</h2><ul>
<li><p>本地协议地址赋予一个套接字，这是服务器需要用到的！不对，客户端在 connect 之前，不必非得调用 bind 函数</p>
</li>
<li><p>头文件 <code>#include    &lt;sys/socket.h&gt;</code></p>
</li>
<li><p>bind 函数可以指定 IP 地址或者端口、可以两者都指定，可以都不指定</p>
</li>
</ul>
<p><img src="/pictrues/UNP/bind.jpg" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct sockaddr_in	servaddr;</span><br><span class="line">// 通配地址符 INADDR_ANY</span><br><span class="line">servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">// IPv6 需要用到 in6addr_any 结构体（全局的），书上 P83</span><br></pre></td></tr></table></figure>

<ul>
<li>htonl 按照主机字节序，对头文件 <code>&lt;netinet/in.h&gt;</code> 中的任何常数值都得应用<ul>
<li>之后讨论了 内核选临时端口号、进程捆绑非通配 IP 地址</li>
</ul>
</li>
</ul>
<h2 id="listen-函数"><a href="#listen-函数" class="headerlink" title="listen 函数"></a>listen 函数</h2><ul>
<li>仅由 TCP 服务器调用</li>
<li>头文件 <code>#include    &lt;sys/socket.h&gt;</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int listenfd = Socket(AF_INET, SOCK_STREAM, 0);</span><br><span class="line">// 大写表明是包裹函数，自带报错，LISTENQ 是环境变量</span><br><span class="line">Listen(listenfd, LISTENQ);</span><br></pre></td></tr></table></figure>

<ul>
<li>第二个参数是套接字排队的最大连接数<ul>
<li>在 socket、bind 之后调用，在 accept 之前</li>
<li>内核维护两个队列：已完成连接、未完成连接 —— 两个队列之和不超过最大连接数</li>
<li>这个最大连接数的定义不明确，具体多少不清楚，包裹函数 Listen 优化了下，使用环境变量 LISTENQ 来覆盖调用者的值</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/UNP/Listen.png" alt title="Listen"></p>
<h2 id="accept-函数"><a href="#accept-函数" class="headerlink" title="accept 函数"></a>accept 函数</h2><ul>
<li>由 TCP 服务器调用</li>
<li>头文件 <code>#include    &lt;sys/socket.h&gt;</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int listenfd = Socket(AF_INET, SOCK_STREAM, 0);</span><br><span class="line">int connfd = Accept(listenfd, (SA *) NULL, NULL);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第一个参数是 监听套接字，一般只有一个，并且在服务器的整个有效期内保持开放</p>
<ul>
<li>返回值是 已连接套接字，在循环内每次都会生成再关闭</li>
<li>若对客户协议地址不感兴趣，后两个参数 置空</li>
</ul>
</li>
<li><p>例子</p>
<ul>
<li>显示客户的 IP 地址、端口号</li>
<li>不过我一直报错，<code>bind error: Address already in use</code>，书上没提到，上网搜一下<ul>
<li>想到之前师兄大佬说的书上也有错误，然后比较了下 书上的源码 和 师兄的源码，服务端的程序确实不一样！</li>
<li>下面这张图是在网上找的</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/UNP/bind_error.png" alt title="bind error"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 这里应该就是释放端口的操作了，在 bind 之前</span><br><span class="line">if (setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;val, sizeof(int)) == -1)</span><br><span class="line">		err_sys(&quot;setsockopt error&quot;);</span><br></pre></td></tr></table></figure>

<ul>
<li>所以得自己修改下源码<ul>
<li>只修改 <code>vim daytimetcpsrv1.c</code> 试试看，之后再 <code>make</code> 一下</li>
<li>改了之后发现问题出在 <code>htons(13)</code>，还是提示 地址已经被使用，都改成 <code>htons(12000)</code> 试试 —— 是客户端的 daytimetcpcli.c 和服务端的 daytimetcpsrv1.c 这两个文件</li>
<li>成功了！</li>
<li>13 是需要超级用户权限的，12000 不需要</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/UNP/daytimetcpsrv1.png" alt title="daytimetcpsrv1"></p>
<h2 id="fork、exec-函数"><a href="#fork、exec-函数" class="headerlink" title="fork、exec 函数"></a>fork、exec 函数</h2><ul>
<li>主要介绍了这两个函数的特点，以及参数</li>
<li>头文件 <code>&lt;unistd.h&gt;</code><ul>
<li>fork<ul>
<li>返回值：子进程为 0，在父进程为子进程的 ID，若出错为 -1</li>
<li>一个进程创建自身的副本 —— 网络服务器</li>
<li>一个进程想要执行另一个程序</li>
</ul>
</li>
<li>exec<ul>
<li>居然有 6 个函数！</li>
<li>都是把当前进程映像替换成新的程序文件</li>
<li>具体的区别书上 P91</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="并发服务器"><a href="#并发服务器" class="headerlink" title="并发服务器"></a>并发服务器</h2><ul>
<li>同时服务多个客户，而不是只服务一个！<ul>
<li>有个点需要注意下，connfd 的引用计数，类似于智能指针，只有当引用计数为 0 时，<code>Close(connfd)</code> 才会关闭与客户的连接</li>
<li>循环里，调用子进程去服务客户端时，这时父进程不会等子进程执行完再去执行下面的，而是继续执行最后一行的 <code>Close(connfd)</code> </li>
<li>调用子进程时，connfd 的引用计数会加一变成 2，所以就算父进程关闭 connfd 后，也不会断开连接，而是继续侦听</li>
<li>监听套接字是进入子进程时关闭</li>
</ul>
</li>
</ul>
<h2 id="close-函数"><a href="#close-函数" class="headerlink" title="close 函数"></a>close 函数</h2><ul>
<li>关闭套接字</li>
<li>头文件 <code>&lt;unistd.h&gt;</code><ul>
<li>由 close 关闭的套接字，不能再被进程使用，也就不能作为 read 和 write 的第一个参数</li>
<li>若不关闭套接字，连接会一直保持，并且可用描述符会耗尽</li>
</ul>
</li>
</ul>
<h2 id="getsockname、getpeername-函数"><a href="#getsockname、getpeername-函数" class="headerlink" title="getsockname、getpeername 函数"></a>getsockname、getpeername 函数</h2><ul>
<li><p>头文件 <code>&lt;sys/socket.h&gt;</code></p>
</li>
<li><p><code>getsockname(sockfd, (SA *) &amp;ss, &amp;len)</code></p>
<ul>
<li>客户端、服务端都可以用</li>
<li>服务端（通配 IP 地址调用 bind 的 TCP 服务器），连接建立后，套接字必须是已连接的描述符，返回内核赋予的本地 IP 地址</li>
<li>客户端（没有调用 bind 的 TCP 客户），连接建立后，返回内核赋予的本地 IP 地址和本地端口号</li>
<li>客户端（端口号 0 调用 bind），返回内核赋予的本地端口号</li>
</ul>
</li>
<li><p><code>getsockname(sockfd, (SA *) &amp;ss, &amp;len)</code></p>
<ul>
<li>服务器（Telnet）获取客户的身份</li>
</ul>
</li>
<li><p>sockaddr_storage 支持任何套接字地址结构</p>
</li>
</ul>
<h2 id="习题-1"><a href="#习题-1" class="headerlink" title="习题"></a>习题</h2><ul>
<li>4.2 源码就是 /intro/daytimetcpcli3.c<ul>
<li><code>Getsockname(sockfd, (SA *) &amp;cliaddr, &amp;len);</code></li>
<li>len 是值-结果参数，调用之前必须初始化 <code>socklen_t len = sizeof(cliaddr)</code></li>
<li>要显示点分十进制就调用 sock_ntop 函数</li>
<li>端口号的范围 1 ~ 65535</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/UNP/daytimetcpcli3.png" alt title="daytimetcpcli3"></p>
<ul>
<li>若服务器不 listen 那么 accept 返回 EINVAL 因为第一个参数不是监听套接字描述符</li>
<li>若服务器不 bind 那么 listen 会赋予监听套接字一个临时端口</li>
</ul>
<h1 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h1><ul>
<li>这章就开始正儿八经的开始回射（不只是时间，而是任意文本发送再返回）！<ul>
<li>要想自定义，只需修改处理来自客户的输入</li>
<li>要考虑若干边界条件</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/UNP/5_1.png" alt title="回射"></p>
<h2 id="TCP-服务器-main-函数"><a href="#TCP-服务器-main-函数" class="headerlink" title="TCP 服务器 main 函数"></a>TCP 服务器 main 函数</h2><ul>
<li>这是并发的，跟之前的 fork 有点像，把子进程的处理变为了 str_echo</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include	&quot;unp.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">	int					listenfd, connfd;</span><br><span class="line">	pid_t				childpid;</span><br><span class="line">	socklen_t			clilen;</span><br><span class="line">	struct sockaddr_in	cliaddr, servaddr;</span><br><span class="line">	// 都得先创建套接字</span><br><span class="line">	listenfd = Socket(AF_INET, SOCK_STREAM, 0);</span><br><span class="line"></span><br><span class="line">	bzero(&amp;servaddr, sizeof(servaddr));</span><br><span class="line">	// 网际套接字地址结构、通配地址、众所周知的服务器端口 SERV_PORT == 9877</span><br><span class="line">	servaddr.sin_family      = AF_INET;</span><br><span class="line">	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">	servaddr.sin_port        = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">	Bind(listenfd, (SA *) &amp;servaddr, sizeof(servaddr));</span><br><span class="line">	// 把套接字转为监听套接字</span><br><span class="line">	Listen(listenfd, LISTENQ);</span><br><span class="line"></span><br><span class="line">	for ( ; ; ) &#123;</span><br><span class="line">		clilen = sizeof(cliaddr);</span><br><span class="line">		// 服务器在这里阻塞，等待客户连接</span><br><span class="line">		connfd = Accept(listenfd, (SA *) &amp;cliaddr, &amp;clilen);</span><br><span class="line"></span><br><span class="line">		if ( (childpid = Fork()) == 0) &#123;	/* child process */</span><br><span class="line">			Close(listenfd);	/* close listening socket */</span><br><span class="line">			str_echo(connfd);	/* process the request */</span><br><span class="line">			exit(0);</span><br><span class="line">		&#125;</span><br><span class="line">		Close(connfd);			/* parent closes connected socket */</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/pictrues/UNP/SERV_PORT.png" alt title="SERV_PORT"></p>
<h2 id="str-echo-函数"><a href="#str-echo-函数" class="headerlink" title="str_echo 函数"></a>str_echo 函数</h2><ul>
<li>这里居然用到了 <code>goto</code> <ul>
<li>只要 writen 即可，就可以发送，而不管 buf 在主函数还是子进程里</li>
<li>上面这句说的不对，buf 是 read 函数要用到的，先保存下来，再进行发送</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include	&quot;unp.h&quot;</span><br><span class="line"></span><br><span class="line">void str_echo(int sockfd)</span><br><span class="line">&#123;</span><br><span class="line">	ssize_t		n;</span><br><span class="line">	char		buf[MAXLINE];</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line">	while ( (n = read(sockfd, buf, MAXLINE)) &gt; 0)</span><br><span class="line">		Writen(sockfd, buf, n);</span><br><span class="line"></span><br><span class="line">	if (n &lt; 0 &amp;&amp; errno == EINTR)</span><br><span class="line">		goto again;</span><br><span class="line">	else if (n &lt; 0)</span><br><span class="line">		err_sys(&quot;str_echo: read error&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="TCP-客户-main-函数"><a href="#TCP-客户-main-函数" class="headerlink" title="TCP 客户 main 函数"></a>TCP 客户 main 函数</h2><ul>
<li>客户端要在连接成功后，进行输入操作</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include	&quot;unp.h&quot;</span><br><span class="line"></span><br><span class="line">int</span><br><span class="line">main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">	int					sockfd;</span><br><span class="line">	struct sockaddr_in	servaddr;</span><br><span class="line"></span><br><span class="line">	if (argc != 2)</span><br><span class="line">		err_quit(&quot;usage: tcpcli &lt;IPaddress&gt;&quot;);</span><br><span class="line"></span><br><span class="line">	sockfd = Socket(AF_INET, SOCK_STREAM, 0);</span><br><span class="line"></span><br><span class="line">	bzero(&amp;servaddr, sizeof(servaddr));</span><br><span class="line">	servaddr.sin_family = AF_INET;</span><br><span class="line">	servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line">	// argv[1] 手动输入的服务器 IP 地址，点分十进制</span><br><span class="line">	Inet_pton(AF_INET, argv[1], &amp;servaddr.sin_addr);</span><br><span class="line"></span><br><span class="line">	Connect(sockfd, (SA *) &amp;servaddr, sizeof(servaddr));</span><br><span class="line">	// 这里用到了 FILE 指针参数，用来输入</span><br><span class="line">	str_cli(stdin, sockfd);		/* do it all */</span><br><span class="line"></span><br><span class="line">	exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>书上的这些文件，放置的太分散了，Makefile 比较复杂！</li>
</ul>
<h2 id="str-cli-函数"><a href="#str-cli-函数" class="headerlink" title="str_cli 函数"></a>str_cli 函数</h2><ul>
<li>包裹函数 <code>char    *Fgets(char *, int, FILE *);</code>、<code>void     Fputs(const char *, FILE *);</code><ul>
<li>while 循环是用来输入文本的，之后开始发给服务器，再从服务器接收，最后输出在屏幕上</li>
<li>这里要注意，并不是发完就开始读的，而是阻塞？</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include	&quot;unp.h&quot;</span><br><span class="line"></span><br><span class="line">void str_cli(FILE *fp, int sockfd)</span><br><span class="line">&#123;</span><br><span class="line">	char	sendline[MAXLINE], recvline[MAXLINE];</span><br><span class="line"></span><br><span class="line">	while (Fgets(sendline, MAXLINE, fp) != NULL) &#123;</span><br><span class="line"></span><br><span class="line">		Writen(sockfd, sendline, strlen(sendline));</span><br><span class="line"></span><br><span class="line">		if (Readline(sockfd, recvline, MAXLINE) == 0)</span><br><span class="line">			err_quit(&quot;str_cli: server terminated prematurely&quot;);</span><br><span class="line"></span><br><span class="line">		Fputs(recvline, stdout);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="运行-1"><a href="#运行-1" class="headerlink" title="运行"></a>运行</h2><ul>
<li>至此一个非常简陋的例子写好了，但是没有考虑极端情况，不够健壮！<ul>
<li>先运行下试试</li>
<li>先启动服务器，再 netstat -a 查看监听套接字的状态</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/UNP/9877.png" alt title="正在监听的套接字"></p>
<ul>
<li>也可以直接在服务器上运行客户程序，地址写 127.0.0.1 即可，也可在另一个虚拟机运行客户程序</li>
</ul>
<p><img src="/pictrues/UNP/tcpcli01.png" alt title="tcpcli01"></p>
<p><img src="/pictrues/UNP/9877-2.png" alt title="正在监听的套接字"></p>
<ul>
<li>师兄大佬写的代码也很厉害！</li>
<li>终于知道书上是怎么显示子进程的状态了<ul>
<li><code>ps -t pts/0 -o pid,ppid,tty,stat,args,wchan</code></li>
<li>这个 pts/0 就是伪终端的编号，我是用了 SSH 来连接，那么只打开一个 session 终端就会显示 pts/0，如果再打开一个终端（之后在本地主机上测试会用到）就会显示 pts/1</li>
<li>tty 终端设备的统称</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/UNP/pts_0.png" alt title="pts/0"></p>
<ul>
<li>所以要测试进程的僵死状态，只需开两个终端就行<ul>
<li>在另一个终端运行 客户端 程序，之后结束，查看信息即可，我这里运行了三次，所以会有 3 个僵死进程，僵死进程会占用内核空间！</li>
<li>之后的信号处理，就要根据信号来关闭子进程以免僵死</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/UNP/tcpcli01-2.png" alt title="Z 表示僵死状态"></p>
<h2 id="POSIX-信号"><a href="#POSIX-信号" class="headerlink" title="POSIX 信号"></a>POSIX 信号</h2><ul>
<li>这一小节可能就不太好理解了<ul>
<li>说成 软件中断 异步 就好理解了</li>
<li>基本上信号都可以被捕获，只有两个不行 SIGKILL 和 SIGSTOP；捕获信号之后进行处理，没有返回值，只有一个整型参数</li>
</ul>
</li>
</ul>
<h3 id="signal-函数"><a href="#signal-函数" class="headerlink" title="signal 函数"></a>signal 函数</h3><ul>
<li>这个函数历史悠久，这个是自己定义的<ul>
<li>书上源码有个 <code>struct sigaction</code> 不知道什么结构，代码就不放了吧，反正也看不懂 0.0</li>
<li>要想根据信号来处理，首先得捕获信号 SIGCHLD，之后再 wait（对应 fork）</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/UNP/signal.png" alt title="Signal"></p>
<ul>
<li>这个信号处理函数的第二个参数、返回值都是一个函数指针<ul>
<li>这是定义 <code>Sigfunc *Signal(int, Sigfunc *);</code>，定义在 lib/signal.c </li>
<li>因为 sig_chld 函数里有输出，所以子进程结束的时候，父进程会输出对应的信息<ul>
<li>输出不建议用 printf 之后会提到！</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/UNP/tcpser02.png" alt title="tcpser02"></p>
<h3 id="处理被中断的系统调用"><a href="#处理被中断的系统调用" class="headerlink" title="处理被中断的系统调用"></a>处理被中断的系统调用</h3><ul>
<li>首先系统调用是会被其他程序中断的<ul>
<li>有的内核会自动重启被中断返回的系统调用，但不是所有内核</li>
<li>被中断后（如并发服务器，多个客户端同时运行），系统调用可能返回 EINTR 错误（全局变量 errno）</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 这里不是包裹函数，而是自己处理错误！</span><br><span class="line">	if ( (connfd = accept(listenfd, (SA *) &amp;cliaddr, &amp;clilen)) &lt; 0) &#123;</span><br><span class="line">		if (errno == EINTR)</span><br><span class="line">			continue;		/* back to for() */</span><br><span class="line">		else</span><br><span class="line">			err_sys(&quot;accept error&quot;);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="wait、waitpid-函数"><a href="#wait、waitpid-函数" class="headerlink" title="wait、waitpid 函数"></a>wait、waitpid 函数</h2><ul>
<li><p>头文件 <code>&lt;sys/wait.h&gt;</code></p>
</li>
<li><p>这节读完了，有几个问题，先整理下思路</p>
<ul>
<li>wait</li>
<li><code>pid_t wait(int *statloc)</code><ul>
<li>返回两个值，一个是返回终止子进程的进程 ID 号，一个就是输入的指针参数，会变为子进程终止状态（整数）</li>
<li>wait 会阻塞，有一个或多个子进程仍在运行没有终止，知道出现第一个子进程终止，这是固定的，不可变；waitpid 可以加上 WHOHANG 选项，告诉内核不要阻塞</li>
</ul>
</li>
<li>waitpid</li>
<li><code>pid_t waitpid(pid_t pid, int *statloc, int options)</code></li>
</ul>
</li>
<li><p>运行了书上的例子</p>
<ul>
<li>同时连接 5 个客户端的那个</li>
<li>为什么 5 个信号都在信号处理函数之前产生？<ul>
<li>信号处理要在 fork 子进程之前</li>
<li>只要有特定信号发生就会被调用……捕获信号</li>
<li>信号处理一旦安装，会一直安装</li>
<li>已捕获的信号是会被阻塞的，若信号在阻塞期间产生了多次，再被解阻塞后只能递交一次</li>
<li>捕获信号时，要处理被中断的系统调用 —— accept 函数</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/UNP/tcpcli04.png" alt></p>
<p><img src="/pictrues/UNP/tcpcli04-2.png" alt></p>
<ul>
<li>这两个图，只有 3 个僵死进程，释放了两个，但是书上只释放了一个</li>
<li>解决方法<ul>
<li>在循环内调用 waitpid，获取所有已终止子进程的状态，至于 wait 循不循环都一样，因为子进程没有终止时会阻塞</li>
<li>看了书上源码，调用 wait 和 waitpid 函数名、参数都一样，是怎么区分的呢？先运行下看看</li>
<li>师兄的代码是把 信号处理函数 直接写在对应的 main 之上，这样就不会冲突了</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/UNP/tcpser04.png" alt title="tcpser04"></p>
<ul>
<li>运行没问题，哦哦，原来是 Makefile 来加以区分</li>
</ul>
<p><img src="/pictrues/UNP/tcpser04-2.png" alt title="Makefile"></p>
<h2 id="各种终止"><a href="#各种终止" class="headerlink" title="各种终止"></a>各种终止</h2><ul>
<li>这里讨论各种突发情况</li>
</ul>
<h3 id="accept-返回前连接终止"><a href="#accept-返回前连接终止" class="headerlink" title="accept 返回前连接终止"></a>accept 返回前连接终止</h3><ul>
<li>除了中断要重启，还有一例，但是这里说的不够详细，在 16 章会再次讨论</li>
<li>TCP 连接建立后，客户却发了一个 RST</li>
</ul>
<h3 id="服务器进程终止"><a href="#服务器进程终止" class="headerlink" title="服务器进程终止"></a>服务器进程终止</h3><ul>
<li>书上说的很详细</li>
</ul>
<p><img src="/pictrues/UNP/tcpser04-3.png" alt title="连接正常"></p>
<ul>
<li>关闭服务器子进程后</li>
</ul>
<p><img src="/pictrues/UNP/tcpser04-4.png" alt title="连接正常"></p>
<ul>
<li>服务器进程终止，向客户端发送 FIN<ul>
<li>客户端收到后，正阻塞于 fgets 函数，还是可以单独向服务器发送，只是服务器不在发送，半关闭</li>
<li>TCP 服务器收到客户的数据时，发送 RST</li>
<li>客户进程看不到 RST，因为 writen 之后立即调用 readline，由于之前的 FIN 返回 0</li>
<li>下一章会学习 select 和 poll 函数</li>
</ul>
</li>
</ul>
<h3 id="SIGPIPE-信号"><a href="#SIGPIPE-信号" class="headerlink" title="SIGPIPE 信号"></a>SIGPIPE 信号</h3><ul>
<li>这里不理会 readline 函数返回的错误（这里的错误应该是 RST）<ul>
<li>一个进程 向 已收到 RST 的套接字 执行写操作，内核会向该进程发送 SIFPIPE 信号 —— 默认终止进程</li>
<li>这里书上提到，第一次写引发 RST 第二次写引发 SIGPIPE 信号</li>
<li>writen 函数被拆成两段，中间停顿 1 s</li>
<li>这节主要讲如何处理 SIGPIPE 信号</li>
</ul>
</li>
</ul>
<h3 id="服务器主机崩溃"><a href="#服务器主机崩溃" class="headerlink" title="服务器主机崩溃"></a>服务器主机崩溃</h3><ul>
<li>这里是从网络上断开服务器（客户端在另一个主机上）<ul>
<li>断网后，服务器不会发送任何数据</li>
<li>客户阻塞与 readline 调用，并且持续重传数据分节，等待接收 ACK</li>
<li>9 分钟后才会放弃重传，报错 —— 超时 或者 不可达</li>
<li>这里后面会提到两个点<ul>
<li>一是客户端想早点知道服务端崩溃，而不是等 9 分钟</li>
<li>二是客户端不主动发送数据也想检测出服务器崩溃</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="服务器主机崩溃后重启"><a href="#服务器主机崩溃后重启" class="headerlink" title="服务器主机崩溃后重启"></a>服务器主机崩溃后重启</h3><ul>
<li>服务器崩溃重启后，TCP 连接信息会全部丢失，收到客户数据会响应 RST<ul>
<li>客户正阻塞 readline 函数，返回 ECONNRESET 错误（跟之前进程终止有点不太一样）</li>
</ul>
</li>
</ul>
<h3 id="服务器主机关机"><a href="#服务器主机关机" class="headerlink" title="服务器主机关机"></a>服务器主机关机</h3><ul>
<li>这里关机与之前的断开网络（后重启）不一样<ul>
<li>关机时，init 进程给所有运行的进程发送 SIGTERM 信号（可被捕获），等待十几秒（留给进程处理），之后发送 SIGKILL 并终止</li>
<li>客户使用 select 和 poll 函数，可以检测服务器这一终止过程</li>
</ul>
</li>
</ul>
<h2 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h2><ul>
<li>上个例子服务器只管读入直到换行符的数据</li>
</ul>
<h3 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h3><ul>
<li>这里改成由空格隔开的两个整数，然后返回整数的和<ul>
<li>所有修改都在 str_echo 函数，里面多了两个函数 —— sscanf、snprintf</li>
<li><code>%1d\n</code>：数字表示如果输出的内容位数不足将会在左边补足空格</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/UNP/tcpser08.png" alt title="tcpser08"></p>
<ul>
<li>sscanf 函数，这里只能包含空格和两个整数！不能包含字母，因为有 <code>%1d%1d</code><ul>
<li>这个例子不管客户、服务器的主机字节序是否一样，因为不影响</li>
</ul>
</li>
</ul>
<h3 id="传递二进制"><a href="#传递二进制" class="headerlink" title="传递二进制"></a>传递二进制</h3><ul>
<li>这个例子没有 snprintf 转为文本串<ul>
<li>在 sscanf 转为二进制后（不是转为长整数么）直接 writen<ul>
<li>说是二进制，其实就是数字，只不过不是文本串，而且确实跟二进制字节序有关</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/UNP/str_cli09.png" alt title="str_cli09"></p>
<ul>
<li>上面这个图不太清楚，1080p 分辨率</li>
<li>下面两个图，一个在同一主机，一个在 Ubuntu 和 CentOS8</li>
</ul>
<p><img src="/pictrues/UNP/tcpcli09-1.png" alt title="同一个主机"></p>
<p><img src="/pictrues/UNP/tcpcli09-2.png" alt title="不同主机"></p>
<ul>
<li>解决方法之一就是把所有的数据转为文本串来传递</li>
</ul>
<h2 id="小结、习题"><a href="#小结、习题" class="headerlink" title="小结、习题"></a>小结、习题</h2><ul>
<li><p>每一端都得指定连接的套接字对：本地 IP 地址、本地端口、外地 IP 地址、外地端口</p>
<ul>
<li>外地 IP 地址、外地端口必须在客户调用 connect 时指定，这里会将命令行的 IP 地址（服务器的地址）作为参数</li>
</ul>
</li>
<li><p>题目太多了，要不要记呢？</p>
<ul>
<li>第一题：终止客户，然后每隔 5 s 用 netstat 查看 TIME_WAIT 状态何时结束</li>
<li>第二题：标准输入重定向一个二进制文件<ul>
<li>输入不再是命令行手动了，而是一个二进制文件，这里不是很懂，为什么前三个字节为二进制 1、0、一个换行符 —— strlen 返回 1（只计到一个空字节）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h1><ul>
<li><p>感觉看这章之前要把 通用的 I/O 模型 过一遍</p>
<ul>
<li>顺便赶赶系统编程进度</li>
<li>APUE 要不要跟 UNP 一样，写个博客？还是手撕代码？手撕代码吧，这样印象更深，顺便加深下 Makefile 语法</li>
<li>感觉别人的 思维导图 比我的还详细，我觉得自己写的就是一坨……</li>
</ul>
</li>
<li><p>回归正题</p>
<ul>
<li>上一章 TCP 客户端是同时处理两个描述符——标准输入、套接字，有点自顾不暇了</li>
<li>要腾出手来，即 I/O 复用</li>
</ul>
</li>
</ul>
<h2 id="I-O-模型"><a href="#I-O-模型" class="headerlink" title="I/O 模型"></a>I/O 模型</h2><ul>
<li>输入操作包含两个阶段<ul>
<li>等待数据准备好</li>
<li>内核向进程复制数据</li>
<li>下面这几个模型都是后面会详细讲，这里先简要概括下</li>
</ul>
</li>
</ul>
<h3 id="阻塞式-I-O-模型"><a href="#阻塞式-I-O-模型" class="headerlink" title="阻塞式 I/O 模型"></a>阻塞式 I/O 模型</h3><ul>
<li>这是最流行的<ul>
<li>下图 recvfrom 是会在应用进程空间和内核空间来回切换的</li>
<li>开始调用 recvfrom 到返回这段时间内是阻塞的，成功返回后，应用进程开始处理数据报</li>
<li>所有的套接字都是阻塞的</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/UNP/recvfrom.png" alt title="recvfrom"></p>
<ul>
<li>所以这个模型主要跟 recvfrom 函数有关？</li>
</ul>
<h3 id="非阻塞式-I-O-模型"><a href="#非阻塞式-I-O-模型" class="headerlink" title="非阻塞式 I/O 模型"></a>非阻塞式 I/O 模型</h3><ul>
<li>poll 原来是轮询的意思<ul>
<li>就是不停地调用 recvfrom 函数，直到数据准备好，否则返回 EWOULDBLOCK 错误（返回错误后，继续调用，否则怎么叫做轮询呢）</li>
<li>文件描述符为非阻塞</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/UNP/recvfrom2.png" alt title="recvfrom"></p>
<ul>
<li>轮询会耗费 CPU 的大量时间，</li>
</ul>
<h3 id="I-O-复用模型"><a href="#I-O-复用模型" class="headerlink" title="I/O 复用模型"></a>I/O 复用模型</h3><ul>
<li>在模型下这个使用 select 或者 poll 函数<ul>
<li>进程不再选择阻塞在 I/O 函数身上而是阻塞在向 select、poll 和 epoll 调用上。</li>
<li>当描述符变得可用时上述的函数会成功返回，并告知用户进程哪些描述符变得可用，之后再调用系统函数 recvfrom 复制数据报</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/UNP/recvfrom3.png" alt title="recvfrom"></p>
<ul>
<li>这个模型跟 多线程使用阻塞式 I/O 很像，每个文件描述符一个线程</li>
</ul>
<h3 id="信号驱动式-I-O-模型"><a href="#信号驱动式-I-O-模型" class="headerlink" title="信号驱动式 I/O 模型"></a>信号驱动式 I/O 模型</h3><ul>
<li>描述符准备就绪时，内核发送 SIGIO 信号<ul>
<li>进程不再会为描述符是否准备好而阻塞进程，因为信号处理函数会立即返回，进程继续工作</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/UNP/recvfrom4.png" alt title="recvfrom"></p>
<ul>
<li>但该模式的主要缺点在于：若用户进程在使用多个描述符，当信号 SIGIO 到来时用户很难知道到底是哪一个描述符变得可用</li>
</ul>
<h3 id="异步-I-O-模型"><a href="#异步-I-O-模型" class="headerlink" title="异步 I/O 模型"></a>异步 I/O 模型</h3><ul>
<li>这个模型跟信号驱动式 I/O 模型有点像<ul>
<li>信号驱动式 I/O 模型是由内核通知何时可以启动一个 I/O 操作</li>
<li>这个是内核通知一个 I/O 操作何时完成</li>
<li>aio_read 负主要责任、用户进程不需要进入阻塞状态</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/UNP/recvfrom5.png" alt title="recvfrom"></p>
<h3 id="五种模型的区别"><a href="#五种模型的区别" class="headerlink" title="五种模型的区别"></a>五种模型的区别</h3><p><img src="/pictrues/UNP/recvfrom6.png" alt title="五种模型的区别"></p>
<h2 id="IO-多路复用-select-poll-epoll-介绍"><a href="#IO-多路复用-select-poll-epoll-介绍" class="headerlink" title="IO 多路复用 select/poll/epoll 介绍"></a>IO 多路复用 select/poll/epoll 介绍</h2><h3 id="简单粗暴"><a href="#简单粗暴" class="headerlink" title="简单粗暴"></a>简单粗暴</h3><ul>
<li><p><a href="https://www.bilibili.com/video/BV1qJ411w7du" target="_blank" rel="noopener">IO 多路复用 select/poll/epoll 介绍</a></p>
</li>
<li><p>参考这个视频</p>
</li>
<li><p>高并发的一个解决方案——多线程</p>
<ul>
<li>缺点：上下文切换，客户越多，代价就越高</li>
</ul>
</li>
<li><p>单线程处理大量客户端连接</p>
<ul>
<li>DMA 控制器专门处理 I/O 控制器，在另一个客户请求连接时确保不丢失</li>
<li>简单粗暴的一种方法</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/UNP/free_coder.png" alt title="简单粗暴的一种方法"></p>
<h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><ul>
<li>select<ul>
<li>前半段是套接字、准备描述符</li>
<li>select 函数最关键的是 读入文件描述符（第二个参数），即 rset 是将 fds[] 整数数组转为 bitmap （哪一位文件描述符被占用就置 1，其余置 0）一般是 1024 位</li>
<li>判断是否有数据，是先复制到内核，再由内核来判断；与上面简单粗暴方法不同的是 select 是将所有描述符一起复制到内核，而不是复制一个判断一个</li>
<li>为什么要内核来判断，因为内核判断比用户态判断效率高</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/UNP/free_coder1.png" alt title="select 函数"></p>
<ul>
<li><p>没数据时 select 函数阻塞，有数据内核将 FD 置位（rset 对应的那一位），然后 select 返回（不再阻塞）</p>
<ul>
<li>返回后，判断哪一位置位了，然后进行读取、处理</li>
</ul>
</li>
<li><p>select 第一个参数为 max + 1（max 是最大的描述符），为什么加一，因为 bitmap 是从 0 开始的，这样写的好处就是不用 1024 位都复制，而是用到多少就到多少</p>
</li>
</ul>
<p><img src="/pictrues/UNP/free_coder2.png" alt title="max + 1"></p>
<ul>
<li>缺点<ul>
<li>bitmap 虽然可以限制大小，但上限是不变的</li>
<li>FD_SET 不可重用，每次 while 循环都要重新初始化（导致一部分开销）</li>
<li>rset 即 bitmap 虽然是整体拷贝，但是从用户态到内核态仍有一个开销</li>
<li>select 在返回的时候，肯定至少有一个是被置位的，但是不知道是哪一个，仍然要遍历所有的描述符（开销）</li>
</ul>
</li>
</ul>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><ul>
<li><p>poll</p>
<ul>
<li><code>poll(pollfds, 5, 50000)</code> 相比 select 传入的参数少了几个</li>
<li>pollfds（数组）自带的数据结构；5 代表 5 个元素；最后一个是超时时间</li>
<li>关键点在于用 pollfd 取代 bitmap</li>
</ul>
</li>
<li><p>置位是给 pollfd.revents 置位（一开始为 0，这个是一个反馈）成 POLLIN</p>
<ul>
<li>然后 poll 函数返回（之前阻塞）</li>
<li>接着判断 pollfds[i].revents 是否被置位、读数据、处理数据</li>
<li>这里只更改 revents，结构体的其余数据不变，也就是说只需初始化一次即可</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/UNP/free_coder3.png" alt title="poll 函数"></p>
<ul>
<li>解决了 select 的几个缺点<ul>
<li>bitmap 被替换为 pollfd，上限不止 1024</li>
<li>只需初始化一次，可重用</li>
<li>另外两点还是一样的，没有变化</li>
</ul>
</li>
</ul>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><ul>
<li><p>epoll</p>
<ul>
<li>这个函数目前比较新，首先使用 <code>epoll_create()</code>（这里面的参数没多大意义）来创建 epfd（int），理解成一个白板</li>
<li><code>epoll_ctl()</code> 类似于在白板上写字</li>
<li>epoll_event 结构体类似于 pollfd，但是没有 revent 字段</li>
<li>代码分为两段</li>
<li>epoll_wait 函数里，用户态和内核态是共享 epfd 内存的，即不用复制（省去一部分开销）</li>
</ul>
</li>
<li><p>没数据阻塞，有数据——也会“置位”，即重排（跟之前不一样，把有数据的放在前面），然后返回（有返回值）</p>
<ul>
<li>返回的是有数据的个数，之后遍历按照这个个数来</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/UNP/free_coder4.png" alt title="epoll 函数"></p>
<ul>
<li><p>解决了最后两个缺点</p>
<ul>
<li>不用复制</li>
<li>复杂度不再是 O(n)</li>
</ul>
</li>
<li><p>redis、nginx、javaNIO(Linux) 都使用了 epoll</p>
</li>
<li><p>提出了几个问题</p>
<ul>
<li>固态硬盘（SSD）为什么比机械硬盘快</li>
<li>哪些数据库（DB）对固态硬盘进行了优化</li>
<li>上面的优化原理是什么</li>
</ul>
</li>
<li><p>看评论说上面的 epoll 有争议，我目前比较菜，以后有机会再完善</p>
<ul>
<li>好像在共享内存那边，实际上并没有共享？</li>
<li>这样更能加深理解</li>
</ul>
</li>
</ul>
<h2 id="select-函数"><a href="#select-函数" class="headerlink" title="select 函数"></a>select 函数</h2><ul>
<li>头文件 <code>&lt;sys/select.h&gt;</code></li>
<li>关于 sd_set 整数数组，书上说的有点绕口！</li>
<li>这里主要讲 select、poll、epoll 函数，我记得有个 UP 主讲的很好，先看下视频，那就先放在前面<ul>
<li>书上对函数的四个参数说的很详细</li>
<li>若中间三个参数都为空指针，那就变成了一个计时器！哈哈哈哈哈哈哈</li>
</ul>
</li>
</ul>
<h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><ul>
<li>select 函数（和 poll）只工作在描述符上！</li>
<li>这几节的笔记好多！感觉没什么时间来记了<ul>
<li>最后一个时间参数需要用到头文件 <code>&lt;sys/time.h&gt;</code></li>
<li>重点是第二个读描述符 fd_set<ul>
<li>这个结构对应几个函数用来初始化、对应位置位、判断对应位是否置位；很奇怪这些函数名字母为什么都是大写？哦哦哦，原来是宏！</li>
</ul>
</li>
<li>第一个是参数是最大描述符 + 1，因为从 0 开始数</li>
</ul>
</li>
</ul>
<h3 id="描述符就绪条件"><a href="#描述符就绪条件" class="headerlink" title="描述符就绪条件"></a>描述符就绪条件</h3><ul>
<li>准备好读<ul>
<li>该套接字接收缓冲区的数据字节数 ≧ 套接字接收缓冲区低水位标记的当前大小</li>
<li>该连接的读 半部关闭</li>
<li>该套接字是一个监听套接字且内核 TCP 维护的已完成连接队列不为空</li>
<li>有一个套接字有错误待处理</li>
</ul>
</li>
</ul>
<h2 id="pselect-函数"><a href="#pselect-函数" class="headerlink" title="pselect 函数"></a>pselect 函数</h2><ul>
<li>头文件 <code>&lt;sys/select.h&gt;</code><ul>
<li>时间参数的结构体变了，这个新结构可以指定纳秒级！</li>
<li>还增加了第六个参数，用来屏蔽一些信号</li>
<li>这节没有细讲</li>
</ul>
</li>
</ul>
<h2 id="poll-函数"><a href="#poll-函数" class="headerlink" title="poll 函数"></a>poll 函数</h2><ul>
<li>终于看到这个函数了！</li>
<li>emmmmmm 书上就一两页纸，头文件 <code>&lt;poll.h&gt;</code><ul>
<li>第一个参数是数组指针，每个数组元素都是 pollfd 结构</li>
</ul>
</li>
</ul>
<h2 id="习题-2"><a href="#习题-2" class="headerlink" title="习题"></a>习题</h2><ul>
<li>1：C 语言允许结构跨等号赋值</li>
<li>2：select 返回可写时，必须把套接字设置成非阻塞</li>
<li>3：这里问的 if else 是判断两个描述符的，不能加 else ，因为这两个描述符必须要一个一个的判断！</li>
<li>4：这题没读懂……</li>
<li>5：这题的意思是端口号是跟某个服务有关</li>
<li>6：close 只在描述符引用计数为 1 的情况下，才发送 FIN</li>
</ul>
<h1 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h1><ul>
<li>套接字选项<ul>
<li>这章里面的 SCTP 先不看</li>
</ul>
</li>
</ul>
<h2 id="getsockopt、setsockopt-函数"><a href="#getsockopt、setsockopt-函数" class="headerlink" title="getsockopt、setsockopt 函数"></a>getsockopt、setsockopt 函数</h2><ul>
<li><p>头文件 <code>&lt;sys/socket.h&gt;</code></p>
<ul>
<li>我发现书上说的值 - 结果参数就是某个类型的指针</li>
<li>两个函数成功则返回 0 出错返回 -1</li>
<li>两个函数里的 *optval 有点不太理解<ul>
<li>对于 getsockopt() 而言是用来指向获取到套接字选项当前值欲被存放的内存起始地址</li>
<li>对于 setsockopt() 函数而言是用来指向套接字选项欲设置值的地址</li>
</ul>
</li>
</ul>
</li>
<li><p>下面开始检查选项是否受支持</p>
<ul>
<li>如果没有定义某个选项，那么对应的函数指针为空</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/UNP/opt_val_str.png" alt title="checkopts"></p>
<ul>
<li>再好好记忆下 snprintf 函数<ul>
<li>头文件 <code>&lt;cstdio&gt;</code></li>
<li><code>int snprintf ( char * s, size_t n, const char * format, ... );</code></li>
<li>雾草，书上的源码编译报错了！错误原因很简单，加上 #ifdef 即可</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/UNP/checkopts.png" alt title="SO_USELOOPBACK"></p>
<p><img src="/pictrues/UNP/checkopts1.png" alt title="编译成功！"></p>
<ul>
<li>虽说是跑起来了，但是还有几个结构体还不清楚</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">union val &#123;</span><br><span class="line">	int					i_val;</span><br><span class="line">	long				l_val;</span><br><span class="line">	struct linger		linger_val;</span><br><span class="line">	struct timeval		timeval_val;</span><br><span class="line">&#125; val;</span><br></pre></td></tr></table></figure>

<h2 id="套接字状态"><a href="#套接字状态" class="headerlink" title="套接字状态"></a>套接字状态</h2><ul>
<li>这这这，，，太多了吧，先大致过一遍！<ul>
<li>还是得记住常用的！</li>
</ul>
</li>
</ul>
<h3 id="SO-LINGER"><a href="#SO-LINGER" class="headerlink" title="SO_LINGER"></a>SO_LINGER</h3><ul>
<li>这个套接字用到了 <code>struct linger</code>，头文件 <code>&lt;sys/socket.h&gt;</code></li>
<li>这个用途是在 close 函数之后，不是立即返回，而是将留在套接字发送缓冲区的残留数据发给对方<ul>
<li>结构体有两个参数可以自己调</li>
</ul>
</li>
</ul>
<h2 id="fcntl-函数"><a href="#fcntl-函数" class="headerlink" title="fcntl 函数"></a>fcntl 函数</h2><ul>
<li><p>就是 file control</p>
<ul>
<li>唉，这第一章记的笔记有点拉跨啊，中间跳过了很多套接字选项</li>
</ul>
</li>
<li><p>书上没找到这个函数的例子</p>
</li>
<li><p>头文件 <code>&lt;fcntl.h&gt;</code></p>
<ul>
<li>出错返回 -1，至于成功取决于第二个参数 cmd</li>
<li>整型与标志符进行位运算</li>
</ul>
</li>
</ul>
<h2 id="习题-3"><a href="#习题-3" class="headerlink" title="习题"></a>习题</h2><ul>
<li>第一题题解给出了接收缓冲区的大小<ul>
<li>要用到 getsockopt 函数，之前看的都忘了，参数还用到了 SOL_SOCKET、SO_RCVBUF、IPPROTO_TCP、TCP_MAXSEG 这四个</li>
<li>下面还是用的 13 端口来获取服务端时间</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/UNP/rcvbuf.png" alt title="rcvbuf 程序"></p>
<ul>
<li><p>MSS 是 TCP 一端的最大分节大小</p>
<ul>
<li>这里 MSS 会在连接后变大</li>
</ul>
</li>
<li><p>第二题与第一题类似，MSS 为什么会变化</p>
<ul>
<li>在不是本地服务器运行时间程序时（CentOS 8）总是显示 bind 错误，于是换了个端口号 12000</li>
<li>无论是本地还是非本地，MSS 的值都会变</li>
</ul>
</li>
<li><p>第四题设置 SO_REUSEADDR 套接字选项</p>
<ul>
<li>多个用户调用 bind 会出现 EADDRINUSE 错误，因为当前服务端监听套接字正在处理其他客户的连接，这样只需多次调用 bind 即可</li>
</ul>
</li>
<li><p>sock 程序编译出错，有个函数明明声明了，却显示没有声明有点纳闷，关键是后面好几个习题都跟这个 sock 有关！先看下一章吧</p>
</li>
</ul>
<h1 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h1><ul>
<li>客户不与服务器建立连接，创建套接字之后直接 sendto 给指定服务器发送数据报</li>
<li>服务器不接受客户的连接，先创建套接字、bind，然后 recvfrom 客户的数据</li>
<li>客户端与 TCP 区别在于没有 connect 函数</li>
</ul>
<h2 id="recvfrom、sendto-函数"><a href="#recvfrom、sendto-函数" class="headerlink" title="recvfrom、sendto 函数"></a>recvfrom、sendto 函数</h2><ul>
<li><p>头文件 <code>sys/socket.h</code></p>
<ul>
<li>前三个参数分别是描述符、缓冲区指针、读写字节数</li>
<li>第四个参数 int flags 暂时置 0</li>
<li>第五个参数都是通用地址结构指针</li>
<li>最后一个 recvfrom 是地址结构长度指针，而 sendto 是整型</li>
<li>返回值都是读写数据的长度</li>
</ul>
</li>
<li><p>因为是 UDP</p>
<ul>
<li>所以是 <code>sockfd = Socket(AF_INET, SOCK_DGRAM, 0);</code> SOCK_DGRAM</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/UNP/udpcli01.png" alt title="udpcli01"></p>
<h2 id="dg-echo-函数"><a href="#dg-echo-函数" class="headerlink" title="dg_echo 函数"></a>dg_echo 函数</h2><ul>
<li>服务端处理程序</li>
<li>这个函数永不终止，读完直接发送<ul>
<li>书上说这个服务器是迭代的，有点理解了，相当于队列，先入先出，无论几个 UDP 客户端，迭代读取对应的数据报即可</li>
</ul>
</li>
</ul>
<h2 id="dg-cli-函数"><a href="#dg-cli-函数" class="headerlink" title="dg_cli 函数"></a>dg_cli 函数</h2><ul>
<li>这里有个注意点，在接收服务端数据后返回的是成功的字节数 n，要把缓冲区第 n 个位置置 0，然后再输出屏幕，手动终止<ul>
<li>两个函数都是协议无关的</li>
</ul>
</li>
</ul>
<h2 id="验证接收到的响应"><a href="#验证接收到的响应" class="headerlink" title="验证接收到的响应"></a>验证接收到的响应</h2><ul>
<li><p>这里没太看明白，再过一遍</p>
<ul>
<li>SERV_PORT 是 9877，这里直接用了 7 号端口，说是可以使用任何运行标准回射服务器的主机</li>
<li>memcmp 用来比较两个地址块是否相同</li>
<li>有个问题，这里客户端端口号改成了 7 那么对应的服务端程序是哪个呢？</li>
<li>这里运行没有成功 —— 没有显示 reply from …</li>
</ul>
</li>
<li><p>下一节讨论了 UDP 套接字的异步错误 —— 目的地不可达 ICMP 错误</p>
<ul>
<li>但是这个错误不会返回给进程，除非 UDP 套接字已连接</li>
</ul>
</li>
</ul>
<h2 id="connect-函数-1"><a href="#connect-函数-1" class="headerlink" title="connect 函数"></a>connect 函数</h2><ul>
<li><p>本来是没有的或者可有可无</p>
<ul>
<li>由 connect 函数连接好指定的 IP 地址和端口号后，不能用 sendto 了，而是直接 read 或者 write</li>
<li>异步错误会返回所在的进程</li>
</ul>
</li>
<li><p>UDP 套接字可以多次调用 connect 而 TCP 只能一次</p>
<ul>
<li>多次调用是为了断开链接</li>
</ul>
</li>
</ul>
<h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><ul>
<li>UDP 没有流量控制是不可靠的，若接收缓冲区满了，容易丢失数据<ul>
<li>UDP 默认接收缓冲区大小是 42080 字节</li>
<li>SO_RCVBUF 可以修改默认值</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/UNP/udpserv06.png" alt title="udpserv06"></p>
<ul>
<li>获取本地的 IP 地址以及端口号</li>
</ul>
<p><img src="/pictrues/UNP/udpcli09.png" alt title="udpcli09"></p>
<h2 id="TCP、UDP-回射服务器程序"><a href="#TCP、UDP-回射服务器程序" class="headerlink" title="TCP、UDP 回射服务器程序"></a>TCP、UDP 回射服务器程序</h2><ul>
<li>使用 select 函数</li>
<li>步骤<ul>
<li>先创建两个套接字，但是得一个一个来，因为创建套接字之后，还需要赋值 IP 结构地址，之后要进行绑定和监听</li>
<li>其中 IP 结构地址是复用的，因为前面已经创建了套接字并且监听，不影响后面的</li>
</ul>
</li>
</ul>
<h1 id="第十一章"><a href="#第十一章" class="headerlink" title="第十一章"></a>第十一章</h1><ul>
<li>这里的 DNS 在之前计算机网络自顶向下接触过<ul>
<li>这里更为详细</li>
<li>不使用 DNS 可以用静态主机文件 /etc/hosts </li>
</ul>
</li>
</ul>
<h2 id="gethostbyname、gethostbyaddr-函数"><a href="#gethostbyname、gethostbyaddr-函数" class="headerlink" title="gethostbyname、gethostbyaddr 函数"></a>gethostbyname、gethostbyaddr 函数</h2><ul>
<li><p>头文件 <code>&lt;netdb.h&gt;</code></p>
<ul>
<li>输入参数只有一个，就是命令行的字符指针</li>
<li>返回值是指向 hostent 结构的指针，里面是所有的 IPv4 地址</li>
<li>这个结构里由指针也有指针的指针，输出的时候需要注意</li>
<li><code>hstrerror(h_errno)</code> 用来返回错误相关信息；<code>const char *hstrerror(int err)</code></li>
</ul>
</li>
<li><p>gethostbyaddr</p>
<ul>
<li>正好相反，根据地址找名字</li>
<li>我得把系统调用的信息输出好好看看，各种 error functions</li>
</ul>
</li>
</ul>
<h2 id="getservbyname、getservbyport-函数"><a href="#getservbyname、getservbyport-函数" class="headerlink" title="getservbyname、getservbyport 函数"></a>getservbyname、getservbyport 函数</h2><ul>
<li><p>服务靠名字来认知</p>
</li>
<li><p>头文件 <code>&lt;netdb.h&gt;</code></p>
<ul>
<li>返回值是指向 servent 结构的指针，不是 hostent 了</li>
<li>不过输入参数有两个，第二个参数是协议指针，如 “tcp”、”udp”</li>
<li>servent 端口号是网络字节序，不能调用 htons</li>
</ul>
</li>
<li><p>getservbyport 根据端口号和协议来查找服务</p>
<ul>
<li>第一个 int port 参数必须是网络字节序</li>
</ul>
</li>
</ul>
<h2 id="getaddrinfo-函数"><a href="#getaddrinfo-函数" class="headerlink" title="getaddrinfo 函数"></a>getaddrinfo 函数</h2><ul>
<li>头文件 <code>&lt;netdb.h&gt;</code><ul>
<li>返回 int 类型，0 成功，否则失败</li>
<li>值-结果参数，addrinfo 结构指针</li>
</ul>
</li>
</ul>
<blockquote>
<p>TODO</p>
</blockquote>
<h2 id="习题-4"><a href="#习题-4" class="headerlink" title="习题"></a>习题</h2><ul>
<li><p>前面还没看的章节先省略，主要知识点字数比较多，又有现成的 Xmind 文件，节省时间，目前主要记录下做习题的过程</p>
</li>
<li><p>1</p>
<ul>
<li>一开始以为源码写错了，因为 <code>hptr-&gt;h_addrtype</code> 只能是 AF_INET，书上却把他放在了 <code>case AF_INET6:</code> 下</li>
<li>不过改完之后 <code>./hostent2 cnn.com</code> 还是 <code>gethostbyaddr failed</code></li>
<li>为什么呢，难道时间太过久远了？</li>
<li>跑了一下师兄的代码，也是同样的问题显示不出主机名</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/UNP/hostent2.png" alt title="hostent2"></p>
<p><img src="/pictrues/UNP/hostent2-1.png" alt title="师兄的代码"></p>
<ul>
<li><p><code>hptr = gethostbyaddr((const void*)*pptr, sizeof(struct in_addr), AF_INET);</code></p>
</li>
<li><p><code>hptr = gethostbyaddr(*pptr, hptr-&gt;h_length, hptr-&gt;h_addrtype)</code></p>
<ul>
<li>这两个都返回的是 NULL</li>
<li>不过这题的关键点在于那两个函数公用一个 hostent 结构</li>
<li>gethostbyaddr 会把之前的其余 IP 地址给覆盖掉，所以正确答案应该是只显示一个 IP 地址和一个主机名</li>
</ul>
</li>
<li><p>2</p>
<ul>
<li>修复 1 的问题</li>
<li>可重入性，那两个函数变为以 _r 结尾的函数</li>
<li>说是在调用 gethostbyaddr 之前复制 hostent 结构，但是就算复制了，也实现不了，因为 gethostbyaddr 返回 NULL，主机名都显示不出来，纳闷</li>
</ul>
</li>
<li><p>3</p>
<ul>
<li>这里只是改了服务名，然后再运行下，但是我连不上 unable to connect </li>
</ul>
</li>
<li><p>4</p>
<ul>
<li>首先判断主机名是 IP 地址还是名字，用了 inet_pton 而不是 inet_aton 来判断</li>
<li>之后判断第二个参数是端口号还是服务名字<ul>
<li>端口号要先 atoi 变为整数 n 若报错就当成名字用 getservbyname 再判断一次</li>
<li>记得端口号要转为网络字节序 <code>servaddr.sin_port = htons(n)</code></li>
</ul>
</li>
</ul>
</li>
<li><p>5</p>
<ul>
<li>还是得修改，不过要支持 IPv6，得用 getaddrinfo 函数</li>
<li>不过书上源码没有使用 getaddrinfo，而是继续判断 AF_INET 还是 AF_INET6；然后自定义了函数设置端口和地址，从而实现协议无关性。</li>
<li>师兄的代码是将 getaddrinfo 函数放入 tcp_connect 函数里，根据 &lt;IPaddress/hostname&gt; 和 &lt;server/port&gt; 来建立连接并返回已连接套接字，之后用 getpeername 获取地址并 sock_ntop 显示</li>
</ul>
</li>
<li><p>6</p>
<ul>
<li>反向查找 DNS ……</li>
<li>这里跟 recvfrom 似乎没有关系</li>
</ul>
</li>
<li><p>7</p>
<ul>
<li>如果不为空，那么会执行 <code>*addrlenp = res-&gt;ai_addrlen;</code> 来得到协议地址的大小</li>
<li>如果为空还是得用 getsockname 不过事先得分配一个足够大的缓冲区来存放地址</li>
</ul>
</li>
<li><p>8</p>
<ul>
<li>getnameinfo ……</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>UNIX 网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>VMware Ubuntu</title>
    <url>/2020/11/19/VMware-Ubuntu/</url>
    <content><![CDATA[<p>Notes on installing Ubuntu.</p>
<a id="more"></a>

<h2 id="Ubuntu20-04-1"><a href="#Ubuntu20-04-1" class="headerlink" title="Ubuntu20.04.1"></a>Ubuntu20.04.1</h2><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><ul>
<li>这里插个眼<ul>
<li>以下是设置的 NAT 模式</li>
<li>后来做项目的时候心血来潮，想着 NAT 模式只能是主机进行访问，改成 桥接 模式试试同一个局域网下笔记本也能连上岂不是 nice？</li>
<li>半天过去之后，我放弃了！<ul>
<li>电信的校园网可能不是局域网</li>
<li>改来改去，始终网络激活失败，原因未知</li>
<li>可能重新安装系统的时候会有用吧！</li>
<li>Ubuntu 应该不那么频繁用了，以后 CentOS8 居多</li>
<li>还有 CentOS8 没有 network.service 这个服务了，用 nmcli c reload !!!</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>有没有网络很重要！<ul>
<li>Ubuntu 17.10及更高版本使用 Netplan 作为默认网络管理工具。 先前的 Ubuntu版本使用ifconfig及其配置文件/etc/network/interfaces来配置网络。…</li>
</ul>
</li>
<li>第一步先设置虚拟机VM本身的网络连接模式，我这里是win10系统，选择NAT模式，与主机共享IP地址；<ul>
<li>桥接配置存在一个问题,那就是当宿主机网段发生改变后,比如使用无线网,之前是172.16.6的,后来变成了172.21.0的了,那之前的配置<a href="https://www.bilibili.com/video/BV1bA411b7vs?t=914" target="_blank" rel="noopener">CodeSheep</a>就需要全部改掉了</li>
</ul>
</li>
<li>如果<code>ping</code>显示没有网络，那就先<code>ifconfig</code>；如果只显示<code>lo</code>，没有网卡，如下图</li>
</ul>
<p><img src="/pictrues/Ubuntu/ifconfig.png" alt="lo" title="没有显示网卡"></p>
<ul>
<li>查看所有的网络设备，输入<code>ifconfig -a</code>命令</li>
</ul>
<p><img src="/pictrues/Ubuntu/ifconfig1.png" alt title="显示了网卡"></p>
<ul>
<li>启动网卡，输入<code>ifconfig xxx up</code>；xxx是自己的网络设备名字，如ens33</li>
<li>之后开始设置IP地址，使用<code>dhclient</code>工具自动设置IP地址</li>
</ul>
<p><img src="/pictrues/Ubuntu/dhclient.png" alt="dhclient" title="设置IP"></p>
<ul>
<li>这里的地址192.168.219.130是动态的，下次就会变化；接下来设置配置文件，将IP地址设置成静态！(因为远程连接的话，每次IP地址都会变，不适合学习)</li>
</ul>
<h4 id="yaml"><a href="#yaml" class="headerlink" title="yaml"></a>yaml</h4><ul>
<li>等等，能力有限，Centos、Ubuntu有点乱，先这样配置IP，是能上网的，这里打个连接是NAT模式下<a href="https://www.cnblogs.com/Stephen-Qin/p/12889358.html" target="_blank" rel="noopener">Centos多节点</a>网络配置</li>
<li><code>ip link</code>打印所有可用网络接口的列表<ul>
<li><code>yaml</code>基本语法——大小写敏感——使用缩进表示层级关系——缩进不允许使用tab，只允许空格——缩进的空格数不重要，只要相同层级的元素左对齐即可——<code>#</code>表示注释</li>
</ul>
</li>
<li>Netplan配置文件存储在<code>/etc/netplan</code>目录中，文件名可能有如下图所示</li>
</ul>
<p><img src="/pictrues/Ubuntu/netplan.png" alt="netplan" title="netplan"></p>
<ul>
<li>打开YAML配置文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo nano /etc/netplan/01-network-manager-all.yaml</span><br></pre></td></tr></table></figure>

<ul>
<li>编辑Yaml文件时，请确保遵循YAML代码缩进标准。 如果语法不正确，则更改将不会应用。</li>
</ul>
<p><img src="/pictrues/Ubuntu/nano.png" alt="nano" title="nano"></p>
<ul>
<li>保存文件并应用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo netplan apply</span><br></pre></td></tr></table></figure>

<ul>
<li>验证更改</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ip addr show dev ens33</span><br></pre></td></tr></table></figure>

<blockquote>
<p>虽然改完了，但还是每次开机都要重新配置，有点烦！！</p>
</blockquote>
<hr>
<hr>
<h4 id="CentOS8"><a href="#CentOS8" class="headerlink" title="CentOS8"></a>CentOS8</h4><ul>
<li>按照这个连接整理了下——<a href="https://www.cnblogs.com/Stephen-Qin/p/12889358.html" target="_blank" rel="noopener">Centos多节点</a>；</li>
<li>防止丢失，再记录下——虚拟机编辑、虚拟机网络编辑器</li>
</ul>
<p><img src="/pictrues/Ubuntu/VMnet8_NAT.png" alt title="VMnet8_NAT网络设置"></p>
<ul>
<li>修改配置文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/sysconfig/network-scripts/ifcfg-ens33</span><br><span class="line"></span><br><span class="line">BOOTPROTO=static       #把ip改为静态</span><br><span class="line"></span><br><span class="line">ONBOOT=yes             #改为系统启动时激活网卡</span><br><span class="line">IPADDR=192.168.219.131　 #配置虚拟机的IP</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">GATEWAY=192.168.219.2  #配置的和上面一致</span><br><span class="line">DNS1=119.29.29.29      #配置DNS</span><br></pre></td></tr></table></figure>

<p><img src="/pictrues/Ubuntu/ifcfg_ens33.png" alt title="ifcfg_ens33配置文件"></p>
<ul>
<li>DNS就是图片上的<code>DNS1=119.29.29.29</code>，其他的子网掩码、网关要跟虚拟机上的一样，IP地址就用<code>dhclient</code>分配一个，然后改成静态即可</li>
<li><code>systemctl restart network.service</code>重启网络失败，命令错误，对于CentOS8，应该是<ul>
<li><code>nmcli c reload</code></li>
</ul>
</li>
</ul>
<p><img src="/pictrues/Ubuntu/network.png" alt="network" title="network"></p>
<ul>
<li>但是在最后宿主机设置VM8虚拟网卡时，显示IP地址和子网掩码无效，，，重启下看看能不能上网<ul>
<li>注意——把它的IP地址设的和前面的网卡在同一个网段中,这里的Adapter VMnet8是为了实现主机和虚拟机之间的通讯；也方便进行SSH远程连接</li>
<li>默认网关要跟虚拟机的一样、还有DNS也要设置</li>
</ul>
</li>
<li>可以，搞定！</li>
</ul>
<hr>
<hr>
<h3 id="apt源-国内"><a href="#apt源-国内" class="headerlink" title="apt源(国内)"></a>apt源(国内)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo cp /etc/apt/sources.list /etc/apt/sources.list.backup</span><br><span class="line">sudo gedit /etc/apt/sources.list</span><br></pre></td></tr></table></figure>

<ul>
<li>删除所有，复制代码，以<a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/" target="_blank" rel="noopener">清华源</a>为例</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>

<h3 id="网速"><a href="#网速" class="headerlink" title="网速"></a>网速</h3><ul>
<li>若没有问题可跳过</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo lshw -numeric -class network</span><br><span class="line">sudo ip addr show</span><br><span class="line">sudo ip route show</span><br><span class="line">sudo tracepath forum.ubuntu.org.cn</span><br><span class="line">sudo apt-get install traceroute　　</span><br><span class="line">sudo traceroute forum.ubuntu.org.cn</span><br><span class="line">speedtest-cli</span><br></pre></td></tr></table></figure>

<h3 id="VMwareTools"><a href="#VMwareTools" class="headerlink" title="VMwareTools"></a>VMwareTools</h3><ul>
<li>安装之后可以拖拽文件来共享(物理机可跳过)</li>
</ul>
<hr>
<h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><h3 id="WPS"><a href="#WPS" class="headerlink" title="WPS"></a>WPS</h3><ul>
<li>卸载原生liboffice</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get remove liboffice-common	#与WPS不兼容</span><br><span class="line">sudo apt-get install liboffice	#以后安装执行此命令</span><br></pre></td></tr></table></figure>

<ul>
<li>下载<a href="https://www.wps.cn/product/wpslinux/" target="_blank" rel="noopener">WPS deb包</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd Downloads</span><br><span class="line">sudo dpkg -i wps-office_11.1.0.9719_amd64.deb	#注意版本数字</span><br></pre></td></tr></table></figure>

<ul>
<li>下载<a href="https://github.com/cosmicxk/Favorites/" target="_blank" rel="noopener">wps_symbol_fonts.zip</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo mv wps_symbol_fonts.zip /usr/share/fonts</span><br><span class="line">cd /usr/share/fonts</span><br><span class="line">sudo unzip wps_symbol_fonts.zip</span><br><span class="line">sudo rm wps_symbol_fonts.zip</span><br><span class="line">sudo mkfontscale	#生成字体的索引信息</span><br><span class="line">sudo mkfontdir</span><br><span class="line">sudo fc-cache	#更新字体缓存</span><br></pre></td></tr></table></figure>

<h3 id="Flashplayer"><a href="#Flashplayer" class="headerlink" title="Flashplayer"></a><a href="http://get.adobe.com/cn/flashplayer/" target="_blank" rel="noopener">Flashplayer</a></h3><ul>
<li>使用Chrome浏览器无需安装</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd Downloads</span><br><span class="line">tar -zxvf &lt;example&gt;.tar.gz	#找不到命令就安装tar</span><br><span class="line">sudo cp libflashplayer.so /usr/lib/mozilla/plugins/</span><br><span class="line">sudo chmod 755 /usr/lib/mozilla/plugins/libflashplayer.so</span><br><span class="line">sudo cp -r ./usr/* /usr/</span><br></pre></td></tr></table></figure>

<h3 id="搜狗输入法"><a href="#搜狗输入法" class="headerlink" title="搜狗输入法"></a>搜狗输入法</h3><ul>
<li>键盘输入法系统中，没有“fcitx”选项时，<code>sudo apt-get install fcitx</code>，安装成功之后点击“应用到整个系统”</li>
<li>下载<a href="https://pinyin.sogou.com/linux/" target="_blank" rel="noopener">搜狗输入法安装包</a>，再<code>sudo dpkg -i sogoupinyin_版本号_amd64.deb</code></li>
<li>如果安装过程中提示缺少相关依赖<code>sudo apt -f install</code></li>
<li>关闭窗口，重启电脑</li>
</ul>
<h3 id="electron-ssr"><a href="#electron-ssr" class="headerlink" title="electron-ssr"></a>electron-ssr</h3><ul>
<li><a href="https://github.com/qingshuisiyuan/electron-ssr-backup/blob/master/Ubuntu.md" target="_blank" rel="noopener">electron-ssr</a></li>
<li><img src="/pictrues/ip.png" alt="ip settings" title="ip settings"></li>
</ul>
<h3 id="Chrome"><a href="#Chrome" class="headerlink" title="Chrome"></a>Chrome</h3><ul>
<li><code>wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb</code></li>
<li><code>sudo apt install ./google-chrome-stable_current_amd64.deb</code></li>
</ul>
<hr>
<h2 id="个性化"><a href="#个性化" class="headerlink" title="个性化"></a>个性化</h2><ul>
<li><code>sudo apt install gnome-tweak-tool</code></li>
<li><code>sudo apt install gnome-shell-extensions</code></li>
<li><a href="https://extensions.gnome.org" target="_blank" rel="noopener">extensions.gnome.org</a>continue to installation</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Uesr Themes</span><br><span class="line">Frippery Move Clock		时间显示到顶部面板的右边</span><br><span class="line">Dynamic Panel Transparency</span><br><span class="line">Compiz windows effect	窗口波动效果</span><br><span class="line">Panel OSD	设置通知消息位置</span><br><span class="line">Coverflow Alt-Tab	Alt+Tab 切换应用的插件</span><br><span class="line">NetSpeed	顶部面板中实时显示网速</span><br><span class="line">TopIcons Plus	正在运行的程序的图标移动到顶部面板</span><br><span class="line">Unite	应用图标的菜单栏与顶部面板融合</span><br><span class="line">Lock screen background	锁屏壁纸</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://www.gnome-look.org/p/1241688/" target="_blank" rel="noopener">MacOs Themes</a>下载<code>McOs-CTLina-Gnome-x.x.tar.xz</code>，在home目录里创建<code>.themes</code>并解压到文件夹里</li>
<li><a href="https://www.gnome-look.org/p/1102582" target="_blank" rel="noopener">Icons</a>下载<code>Cupertino-Catalina.tar.xz</code>，在home目录里创建<code>.icons</code>并解压到文件夹里</li>
<li>gnome-tweaks-&gt;Windows Titlebars-&gt;Placement-&gt;left</li>
<li>gnome-tweaks-&gt;Windows-&gt;Center New Windows-&gt;on</li>
</ul>
<hr>
<h2 id="创建CA"><a href="#创建CA" class="headerlink" title="创建CA"></a>创建CA</h2><ul>
<li>不同版本的Linux创建CA都不太一样，主要是目录不太一样</li>
</ul>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><ul>
<li>参考<a href="https://www.bilibili.com/video/BV12z4y1m7GT?from=search&seid=13941566448446338710" target="_blank" rel="noopener">Debain10 私有CA认证机构</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt install openssl</span><br><span class="line">cd /etc/ssl/</span><br><span class="line">sudo vim /etc/ssl/openssl.cnf</span><br></pre></td></tr></table></figure>

<ul>
<li>要改两个地方</li>
</ul>
<p><img src="/pictrues/Ubuntu/CA.png" alt="CA" title="CA"></p>
<p><img src="/pictrues/Ubuntu/CA1.png" alt="CA1" title="CA"></p>
<ul>
<li>创建多个目录</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /etc/ssl/</span><br><span class="line">sudo mkdir CA</span><br><span class="line">cd CA</span><br><span class="line">sudo mkdir certs</span><br><span class="line">sudo mkdir crl</span><br><span class="line">sudo touch index.txt</span><br><span class="line"></span><br><span class="line">sudo mkdir newcerts</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 将字符串显示至定向文件；这里root以下，一直sudo不起作用了</span><br><span class="line">sudo su</span><br><span class="line">echo &quot;01&quot; &gt; serial</span><br><span class="line">mkdir private</span><br></pre></td></tr></table></figure>

<blockquote>
<p>目录名都是之前配置文件里的</p>
</blockquote>
<p><img src="/pictrues/Ubuntu/CAdirs.png" alt title="新建目录"></p>
<ul>
<li>生成密钥</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl genrsa -out private/cakey.pem</span><br></pre></td></tr></table></figure>

<p><img src="/pictrues/Ubuntu/genrsa.png" alt title="密钥"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl req -new -x509 -key private/cakey.pem -out cacert.pem</span><br><span class="line"></span><br><span class="line">Country name:CN</span><br><span class="line">...</span><br><span class="line">Common Name:ca.jnds.com   服务器的解析名称</span><br></pre></td></tr></table></figure>

<ul>
<li>查看证书</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat cacert.pem</span><br></pre></td></tr></table></figure>

<p><img src="/pictrues/Ubuntu/cacert_pem.png" alt title="证书"></p>
<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><ul>
<li>这里要用另一个虚拟机<ul>
<li>这是默认路径<code>/etc/apache2/ssl</code>，这里项目我没有，直接截视频里的图了——好像搞反了，这里才是服务端？</li>
</ul>
</li>
</ul>
<blockquote>
<p>TODO</p>
</blockquote>
<h3 id="mkcert"><a href="#mkcert" class="headerlink" title="mkcert"></a>mkcert</h3><ul>
<li>上面视频里给出方法暂时没有成功</li>
<li><a href="https://github.com/FiloSottile/mkcert" target="_blank" rel="noopener">mkcert 源码链接</a><ul>
<li>Go 语言写的</li>
<li>不建议在本地使用签名证书，会导致信任错误，而是应该生成本地信任的证书……这话怎么有点绕呢</li>
</ul>
</li>
<li>系统配置<ul>
<li>Go 1.13+（不过下面好像没有用到）、root</li>
<li>证书数据库工具（Certutil）</li>
</ul>
</li>
<li>按照下面来一步一步安装</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 更新安装工具</span><br><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line"># 首先安装证书数据库工具 Certutil （有多个方法，这里只写第一个）</span><br><span class="line">sudo apt install libnss3-tools</span><br><span class="line"></span><br><span class="line"># 使用 Linuxbrew 进行安装 mkcert 时，报错找不到 brew 命令（要不安装下？）</span><br><span class="line"># 下面这行代码可以成功，下载的二进制文件</span><br><span class="line">export VER=&quot;v1.3.0&quot; &amp;&amp; wget -O mkcert https://github.com/FiloSottile/mkcert/releases/download/$&#123;VER&#125;/mkcert-$&#123;VER&#125;-linux-amd64</span><br><span class="line"></span><br><span class="line"># 之后给 mkcert 增加可执行权限，并且放置在全局变量文件夹中</span><br><span class="line">chmod +x  mkcert</span><br><span class="line">sudo mv mkcert /usr/local/bin</span><br></pre></td></tr></table></figure>

<p><img src="/pictrues/Ubuntu/mkcert.png" alt title="mkcert 安装成功"></p>
<p><img src="/pictrues/Ubuntu/mkcert1.png" alt></p>
<ul>
<li>上面这一步已经生成好了 CA 文件（保存路径 /Home/.local/share/mkcert），之后就是怎么生成 SSL 证书了<ul>
<li>官网给出了例子，但是我没看懂！</li>
<li><code>mkcert -key-file key.pem -cert-file cert.pem example.com *.example.com</code></li>
<li>有点理解了，可以生成多域名证书（Apache、Nginx 都是用来测试的，因为这两个支持 PEM 格式的证书，既然是测试，用 Python 也可以！）</li>
<li>也可以签发一个仅本机访问的证书(可以通过 127.0.0.1 和 localhost，以及 ipv6 地址 ::1 访问)，先试试这个看能不能成功<ul>
<li>运行代码 <code>mkcert localhost 127.0.0.1 ::1</code></li>
<li>生成到是成功了，就是访问不了，因为还需要服务端使用两个文件 localhost+2.pem 证书文件和 localhost+2-key.pem 私钥文件（也就是需要本地运行服务端程序，然后再通过本地网址访问）</li>
<li>下面用 Python 来测试，先查看系统自带 Python 版本，我这里是 2.7 的</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/Ubuntu/python.png" alt title="版本"></p>
<ul>
<li>输入 <code>python</code> 查看版本，然后 <code>exit()</code> 退出<ul>
<li>创建 python 文件（直接就在主工作目录下创建了），用来跑服务端程序 <code>touch simple-https-server.py</code></li>
<li>然后添加代码 <code>vim simple-https-server.py</code></li>
<li>按下 <code>i</code> 进入编辑模式，然后直接复制下面的代码，之后按 <code>Esc</code> 退出编辑模式，按下 <code>:wq</code> 保存并退出！</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Python2 环境</span><br><span class="line">import BaseHTTPServer, SimpleHTTPServer</span><br><span class="line">import ssl</span><br><span class="line"></span><br><span class="line">httpd = BaseHTTPServer.HTTPServer((&apos;0.0.0.0&apos;, 443), SimpleHTTPServer.SimpleHTTPRequestHandler)</span><br><span class="line">httpd.socket = ssl.wrap_socket(httpd.socket, certfile=&apos;./localhost+2.pem&apos;, keyfile=&apos;./localhost+2-key.pem&apos;, server_side=True, ssl_version=ssl.PROTOCOL_TLSv1_2)</span><br><span class="line">httpd.serve_forever()</span><br><span class="line"></span><br><span class="line"># Python3 环境</span><br><span class="line">import http.server</span><br><span class="line">import ssl</span><br><span class="line"></span><br><span class="line">httpd = http.server.HTTPServer((&apos;0.0.0.0&apos;, 443), http.server.SimpleHTTPRequestHandler)</span><br><span class="line">httpd.socket = ssl.wrap_socket(httpd.socket, certfile=&apos;./localhost+2.pem&apos;, keyfile=&apos;./localhost+2-key.pem&apos;, server_side=True, ssl_version=ssl.PROTOCOL_TLSv1_2)</span><br><span class="line">httpd.serve_forever()</span><br></pre></td></tr></table></figure>

<ul>
<li>运行 <code>sudo python simple-https-server.py</code> 因为是端口号 443，所以得 root</li>
<li>输入网址测试 127.0.0.1 或者 localhost<ul>
<li>不过我用谷歌访问不了，估计得重启，用火绒可以</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/Ubuntu/python1.png" alt title="成功访问"></p>
<h4 id="局域网内使用"><a href="#局域网内使用" class="headerlink" title="局域网内使用"></a>局域网内使用</h4><ul>
<li><p>上面的代码成功后，接下来就是如何优化环境了，这部分给出参考链接，从 <a href="https://www.jianshu.com/p/7cb5c2cffaaa" target="_blank" rel="noopener">局域网内使用</a> 开始看</p>
<ul>
<li>直接在上面的例子中添加其余 IP 地址即可</li>
<li><code>mkcert localhost 127.0.0.1 ::1 192.168.xxx.xxx</code> 顺序影响的只是文件名，有几个地址就会出现 + n 的字样</li>
<li>这里重新生成的时候，注意测试样例的密钥文件也要变</li>
</ul>
</li>
<li><p>接下来分发证书并信任，然后通过对应的地址访问（由于端口问题，谷歌和 Edge 暂时还访问不了，用 IE 可以）</p>
<ul>
<li>进入 ~.local/share/mkcert/ 目录，将 rootCA.pem 拷贝一个副本 rootCA.crt </li>
<li>rootCA.crt 是分发的关键，下面写三个系统信任的方法</li>
</ul>
</li>
<li><p>Win 10</p>
<ul>
<li>直接托文件，然后双击，要将证书存储为 受信任的根证书颁发机构</li>
</ul>
</li>
<li><p>Ubuntu</p>
<ul>
<li>进入 rootCA.crt 所在的目录，然后拷贝 <code>sudo cp rootCA.crt /usr/local/share/ca-certificates/</code></li>
<li>更新并信任 <code>sudo update-ca-certificates</code></li>
<li>Ubuntu 下可以使用 <code>curl -I https://192.168.xxx.xxx</code> 来测试</li>
</ul>
</li>
<li><p>CentOS</p>
<ul>
<li><code>sudo cp rootCA.crt /etc/pki/ca-trust/source/anchors/</code></li>
<li><code>sudo update-ca-trust</code></li>
</ul>
</li>
<li><p>再记录下防火墙怎么查看状态开启关闭</p>
<ul>
<li>Ubuntu <ul>
<li><code>sudo ufw status</code>、<code>sudo ufw enable</code>、<code>sudo ufw disable</code></li>
</ul>
</li>
<li>CentOS<ul>
<li><code>systemctl status/start/enable/stop/disable firewalld.service</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li><p>其实按照上面步骤，我的电脑是没有问题的！不过经手我朋友（欣）的笔记本后，我发现了新天地！</p>
<ul>
<li>先配置静态 IP 地址，之后生成证书，服务器本地是可以访问的，分发给 Win10 不可信，分发给其余节点不可信……原因不明！</li>
<li>思索无果后，下午欣带回去准备重新生成一遍，之后主机无法访问虚拟机，但是虚拟机可以访问主机……原因不明！</li>
<li>晚上开始重点解决这个问题，半天没头绪后重启，居然又可以连了……为防止其他意外，一切重头开始！</li>
</ul>
</li>
<li><p>之后几经曲折，最终成功，我悟出了几个道理</p>
<ul>
<li>重启可以解决 90% 的问题</li>
<li>CA 证书生成一次即可，终生受用；需要改变的是服务端程序要用到的两个密钥文件</li>
<li>至于证书不可信，那是因为还没有添加信任，直接在浏览器里（什么谷歌、火狐、Edge 等等）添加证书，命令行不顶用，为什么？别问我，因为我不知道</li>
<li>之后添加域名，其实就是 IP 地址的别名，由于是自定义的，与网络上已有的无关（或者网络上没有），那么就需要添加 host 文件了，将服务器地址与域名绑定即可；注意任意需要通过域名来访问服务端都需要添加 host 文件</li>
</ul>
</li>
</ul>
<hr>
<h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><ul>
<li>用的　MobaXterm，一开始连半天没连上…</li>
</ul>
<h3 id="SSH服务"><a href="#SSH服务" class="headerlink" title="SSH服务"></a>SSH服务</h3><ul>
<li>首先查看SSH服务有没有安装或者运行<ul>
<li>这些命令是CentOS下的</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -qa | grep ssh   # 查看有没有安装SSH</span><br><span class="line">service sshd status	  # 查看SSH状态</span><br><span class="line">service sshd start		# 重启SSH</span><br></pre></td></tr></table></figure>

<ul>
<li>这个CentOS字体与Ubuntu相比不太清晰；将就着看吧<ul>
<li>不对，这个是被默认放大了</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/Ubuntu/ssh_grep.png" alt title="查看SSH安装"></p>
<p><img src="/pictrues/Ubuntu/ssh_status.png" alt title="查看SSH状态"></p>
<h3 id="VMnet8"><a href="#VMnet8" class="headerlink" title="VMnet8"></a>VMnet8</h3><ul>
<li>这里的设置就是之前的设置CentOS8多节点里的，要用到的</li>
<li>不再赘述</li>
</ul>
<p><img src="/pictrues/Ubuntu/VM8net_ssh.png" alt title="查看SSH状态"></p>
<h3 id="MobaXterm"><a href="#MobaXterm" class="headerlink" title="MobaXterm"></a>MobaXterm</h3><ul>
<li>注意，这里的名字得是你的一般账号名，之后要输入密码——之后改名是在session name</li>
</ul>
<p><img src="/pictrues/Ubuntu/session.png" alt title="session"></p>
<ul>
<li>之后，输入密码，愉快的玩耍吧！</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode</title>
    <url>/2020/10/30/leetcode/</url>
    <content><![CDATA[<p>Fighting LeetCode Record!!!</p>
<a id="more"></a>

<h1 id="剑指-Offer"><a href="#剑指-Offer" class="headerlink" title="剑指 Offer"></a>剑指 Offer</h1><blockquote>
<p>2021.6.22 启动。<br>这个系列就不在 <code>Clion</code> 写了，直接看书和 <code>LeetCode</code> 上写。</p>
</blockquote>
<h2 id="1-赋值运算符函数"><a href="#1-赋值运算符函数" class="headerlink" title="1_赋值运算符函数"></a>1_赋值运算符函数</h2><ul>
<li><p>力扣上没有第一第二道 剑指 Offer 题，为了保持一致性，这里按照书上，加上去</p>
</li>
<li><p>考点</p>
<ul>
<li>返回类型为引用 —— 这样就可以连续赋值</li>
<li>参数为常量引用 —— 减小无谓消耗</li>
<li>释放实例自身的内存</li>
<li>判断是否是自赋值</li>
</ul>
</li>
<li><p><a href="https://github.com/zhedahht/CodingInterviewChinese2/" target="_blank" rel="noopener">代码链接</a></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CMyString(<span class="keyword">char</span>* pData = <span class="literal">nullptr</span>);</span><br><span class="line">    CMyString(<span class="keyword">const</span> CMyString&amp; str);</span><br><span class="line">    ~CMyString(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line">    CMyString&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> CMyString&amp; str);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span>;</span><br><span class="line">      </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* m_pData;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CMyString::CMyString(<span class="keyword">char</span> *pData)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(pData == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_pData = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">        m_pData[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="built_in">strlen</span>(pData);</span><br><span class="line">        m_pData = <span class="keyword">new</span> <span class="keyword">char</span>[length + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(m_pData, pData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CMyString::CMyString(<span class="keyword">const</span> CMyString &amp;str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="built_in">strlen</span>(str.m_pData);</span><br><span class="line">    m_pData = <span class="keyword">new</span> <span class="keyword">char</span>[length + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(m_pData, str.m_pData);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CMyString::~CMyString()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] m_pData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值运算符</span></span><br><span class="line">CMyString&amp; CMyString::<span class="keyword">operator</span> = (<span class="keyword">const</span> CMyString&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;str)</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> []m_pData;</span><br><span class="line">    m_pData = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    m_pData = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str.m_pData) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(m_pData, str.m_pData);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面是应届生以及初级程序员的要求——高级的看这儿<ul>
<li>上面<code>new</code>字符串，不知道能不能成功分配，就把原来的内存释放掉，这样很危险</li>
<li>两种方法——先分配在释放——直接创建新的参数对象，调用构造函数（完整的构造一遍，而不是只构造字符串），交换对应的指针，赋值结束，临时对象调用析构函数，会释放掉原来的内存！！</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CMyString&amp; CMyString::<span class="keyword">operator</span> = (<span class="keyword">const</span> CMyString&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;str)&#123;</span><br><span class="line">		<span class="comment">//这里在构造的时候，会用new，如果出现异常，不会影响到已有的实例</span></span><br><span class="line">		CMyString tmp(str);</span><br><span class="line">		<span class="keyword">char</span>* ptmp = tmp.m_pData;</span><br><span class="line">		tmp.m_pData = m_pData;</span><br><span class="line">		m_pData = ptmp;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-实现Singleton模式"><a href="#2-实现Singleton模式" class="headerlink" title="2_实现Singleton模式"></a>2_实现Singleton模式</h2><ul>
<li>这是单例模式！设计模式还没怎么看呢…</li>
</ul>
<h2 id="3-数组中重复的数字"><a href="#3-数组中重复的数字" class="headerlink" title="3_数组中重复的数字"></a>3_数组中重复的数字</h2><ul>
<li>单例模式那题先跳过！</li>
<li>这题之前做的那个链表找环——也是找重复数，不知道在这儿好不好使</li>
<li>先哈希一遍！但是时间消耗不怎么好看——因为元素范围固定，也可以用数组，判断当前位置是否已经出现过，代码就不放了<ul>
<li>书上和题解大佬评论里出现了不同的方法，先整理下大佬的思路，再剖析书上的</li>
<li>一个小注意点——如果在循环里就返回值了，最后可以返回-1之类的，根据返回类型，<code>return -1;</code></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//会修改数组内容</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> k = nums[i];</span><br><span class="line">            <span class="comment">//这里要打打草稿，要不然看不懂!</span></span><br><span class="line">            <span class="keyword">if</span>(k &lt; <span class="number">0</span>) k += n;</span><br><span class="line">            <span class="comment">//这里如果之前遇到一次k，那么就会出现已经是负的</span></span><br><span class="line">            <span class="keyword">if</span>(nums[k] &lt; <span class="number">0</span>) <span class="keyword">return</span> k;</span><br><span class="line">            nums[k] -= n;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>书上思路，修改数组、不修改数组<ul>
<li>先判断下标与对应的数字是否相等，若不等，再和数字作为下标的元素相比较！</li>
<li>修改数组是不停地交换数字直到对应的下标与元素相等；前提就是长度为<code>n</code>，数字都在<code>0 ~ n-1</code>之间</li>
<li>下次遇到重复的数字时，就会发现不同的下标出现了相同的数字</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//书上交换——自己手撕版本</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findRepeatNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        //会修改数组内容</span><br><span class="line">        for(int i = 0; i &lt; nums.size(); ++i)&#123;</span><br><span class="line">            //先判断i与nums[i]是否相等</span><br><span class="line">            int m = nums[i];</span><br><span class="line">            if(i == m)&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                //再判断nums[i]与nums[nums[i]]是否相等</span><br><span class="line">                if(m == nums[m])&#123;</span><br><span class="line">                    //这里m重复</span><br><span class="line">                    return m;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    //一直交换，直到下标i与这个位置上的数字相等</span><br><span class="line">                    while(m != i)&#123;</span><br><span class="line">                        swap(nums[i], nums[m]);</span><br><span class="line">                        m = nums[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>不修改数组，但是这个方法有点繁琐，因为每次都要遍历一遍数组查看元素范围出现的总次数，就不粘贴代码了</li>
</ul>
<h2 id="4-二维数组中的查找"><a href="#4-二维数组中的查找" class="headerlink" title="4_二维数组中的查找"></a>4_二维数组中的查找</h2><ul>
<li>这题做过，印象比较深刻<ul>
<li>但当时比较稀里糊涂，没有理解透彻，今天再好好琢磨下</li>
<li>还是一开始想用二分，但是二分有横坐标、纵坐标，然后想着想着——搜索二叉树，从左下角开始，脑海里渐渐浮出了当时看题解的印象</li>
<li>除了一开始就比较最小和最大的元素，看目标值是否在二维数组内，但是在这之前，要先判断数组是否为空</li>
<li>二维数组——要判断两次是否为空</li>
</ul>
</li>
<li>但是最后显示错误——无符号溢出？？下标出现了小于0的数字-1，可是我在<code>while</code>循环里加了条件啊？<ul>
<li>测试了以下，之前写的是连续3个<code>if</code>语句，改成<code>if else</code>之后就可以了！！！这是为什么呢</li>
<li>嗷！因为之前小标减小后小于1，又在最后一个<code>if</code>语句比较了一遍！怪不得</li>
</ul>
</li>
<li>书上也是类似的思路——从右上角开始的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//自己手撕版本</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool findNumberIn2DArray(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123;</span><br><span class="line">        if(matrix.empty() || matrix[0].empty() || target &lt; matrix[0][0] || target &gt; matrix.back().back())&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int r = matrix.size(), c = matrix[0].size();</span><br><span class="line">        int i = r - 1, j = 0;</span><br><span class="line">        while(i &gt;= 0 &amp;&amp; j &lt; c)&#123;</span><br><span class="line">            if(matrix[i][j] == target)&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else if(matrix[i][j] &gt; target)&#123;</span><br><span class="line">                --i;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="5-替换空格"><a href="#5-替换空格" class="headerlink" title="5_替换空格"></a>5_替换空格</h2><ul>
<li>这题看起来很简单嘛，看看有没有什么坑在里面，这应该考察的是各个编程语言的字符串</li>
<li>如果使用字符数组，那就得考虑长度了<ul>
<li>这题考察的是合并两个数组！</li>
<li>书上是直接在原数组后面加长，一个空格就会变长2格，之后双指针（从后往前），其中一个一次移动一格，另一个在对方遇到空格时，移动三格，在移动的过程中，都要复制原来的字符或者要替换的字符</li>
<li>这题比较简单，再做一题吧</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string replaceSpace(string s) &#123;</span><br><span class="line">        if(s.empty()) return string();</span><br><span class="line">        //不知道这题有啥好的方法，先遍历吧</span><br><span class="line">        string ans;</span><br><span class="line">        for(auto ch : s)&#123;</span><br><span class="line">            if(ch == &apos; &apos;)&#123;</span><br><span class="line">                ans += &quot;%20&quot;;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                ans.push_back(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="6-从尾到头打印链表"><a href="#6-从尾到头打印链表" class="headerlink" title="6_从尾到头打印链表"></a>6_从尾到头打印链表</h2><ul>
<li>看了之前的引言，如果是要删除某个特定值的节点，那最后要<code>delete</code>一下，并置空</li>
<li>这题应该先反转，最后再顺序输出——出了点问题，没有一次性过，看来迭代反转链表还要再巩固下<ul>
<li><code>cur</code>明明在条件里判断不为空了，为空就会结束循环，为什么还会无限循环呢？</li>
<li>嗷，原来是输出数组的时候，忘记加<code>pre = pre-&gt;next;</code>了，难怪！</li>
<li>题解也用了栈，甚至有大佬直接用递归，厉害！因为题目可能不准修改原链表，所以这个鲁棒性好</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> //反转链表</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; reversePrint(ListNode* head) &#123;</span><br><span class="line">        if(!head) return vector&lt;int&gt;();</span><br><span class="line"></span><br><span class="line">        ListNode* pre = nullptr;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line"></span><br><span class="line">        while(cur != nullptr)&#123;</span><br><span class="line">            ListNode* tmp = cur-&gt;next;</span><br><span class="line"></span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        //pre是新的头节点</span><br><span class="line">        vector&lt;int&gt; ans;</span><br><span class="line">        while(pre != nullptr)&#123;</span><br><span class="line">            ans.emplace_back(pre-&gt;val);</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//递归</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; reversePrint(ListNode* head) &#123;</span><br><span class="line">        if(!head) return vector&lt;int&gt;();</span><br><span class="line">        vector&lt;int&gt; a = reversePrint(head-&gt;next);</span><br><span class="line">        //这里递归返回后是最后一个不为空的元素</span><br><span class="line">        a.emplace_back(head-&gt;val);</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="7-重建二叉树"><a href="#7-重建二叉树" class="headerlink" title="7_重建二叉树"></a>7_重建二叉树</h2><ul>
<li>给出前序遍历、中序遍历，然后恢复二叉树，之前师兄的面试题有这个，但那是填空题<ul>
<li>而且这居然是105题，果然不巩固就会忘</li>
<li>想起来了，当时应该用的是分治</li>
</ul>
</li>
<li>把这两个数组都分为三个部分——根节点、左子树、右子树，应该先构建根节点，再递归返回左右两边的节点<ul>
<li>这样应该要标记下下标，从哪儿到哪儿</li>
<li><code>vector</code>没有<code>find</code>函数，要找目标数字只能循环了吗</li>
<li>要不直接重新生成新的数组吧</li>
<li>用<code>copy</code>之前，要先将数组声明成一定大小，但是一直提示长度错误，那就换一种方法，用<code>copy(preorder.begin() + i + 1, preorder.end(), back_inserter(p2));</code>其中<code>p2</code>为空</li>
<li>再做的时候果然有好多问题，比如划分的时候；两个数组都是<code>[1,2]</code>，那么就没有左子树，而右子树是2，但是我的代码有漏洞，连右子树都没有了…而且递归的时候会出现一个数组有数字，另一个没有数字的情况！导致之后创建新节点的时候下标越界！</li>
<li>自己的代码就不放了，emmmm，那为什么我第一次做出来了？？</li>
</ul>
</li>
<li>题解用的是标记法，而且在这儿之前，用了哈希表来迅速定位根节点的位置，妙啊！</li>
<li>书上写的使用循环找到根节点的值</li>
</ul>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    unordered_map&lt;int, int&gt; index;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    TreeNode* myBuildTree(const vector&lt;int&gt;&amp; preorder, const vector&lt;int&gt;&amp; inorder, int preorder_left, int preorder_right, int inorder_left, int inorder_right) &#123;</span><br><span class="line">        if (preorder_left &gt; preorder_right) &#123;</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 前序遍历中的第一个节点就是根节点——下标</span><br><span class="line">        int preorder_root = preorder_left;</span><br><span class="line">        // 在中序遍历中定位根节点——下标</span><br><span class="line">        int inorder_root = index[preorder[preorder_root]];</span><br><span class="line">        </span><br><span class="line">        // 先把根节点建立出来</span><br><span class="line">        TreeNode* root = new TreeNode(preorder[preorder_root]);</span><br><span class="line">        // 得到左子树中的节点数目</span><br><span class="line">        int size_left_subtree = inorder_root - inorder_left;</span><br><span class="line">        // 递归地构造左子树，并连接到根节点</span><br><span class="line">        // 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素</span><br><span class="line">        root-&gt;left = myBuildTree(preorder, inorder, preorder_left + 1, preorder_left + size_left_subtree, inorder_left, inorder_root - 1);</span><br><span class="line">        // 递归地构造右子树，并连接到根节点</span><br><span class="line">        // 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素</span><br><span class="line">        root-&gt;right = myBuildTree(preorder, inorder, preorder_left + size_left_subtree + 1, preorder_right, inorder_root + 1, inorder_right);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;</span><br><span class="line">        int n = preorder.size();</span><br><span class="line">        // 构造哈希映射，帮助我们快速定位根节点</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            index[inorder[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        return myBuildTree(preorder, inorder, 0, n - 1, 0, n - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><ul>
<li>学习下迭代<ul>
<li>迭代——与栈联系紧密，栈中存放的应该是<code>TreeNode*</code>类型</li>
<li>言简意赅说一下步骤吧；将<code>preorder</code>遍历并且入栈，直到栈顶元素与<code>inorder</code>的初始指针0位置元素相等<ul>
<li>栈顶节点 4，也就是说 4 没有左儿子，那么 10 必须为栈中某个节点的右儿子。</li>
</ul>
</li>
<li>若<code>inorder</code>的指针指向的元素与栈顶元素相等，栈顶弹出，指针加一</li>
<li>直到不相等，将<code>inorder</code>的指针指向的元素10作为最后弹出的节点 8 的右儿子，并将 10 （<code>preorder</code>）入栈</li>
<li>10 入栈后与<code>inorder</code>的指针指向的元素10相等，继续弹，加一——指针只是起到加一的作用，入栈的还是<code>preorder</code>的数字</li>
<li>还有之后再次遍历的时候，若与指针指向的元素不等，要一直遍历入栈，直到相等</li>
<li>最后结束遍历，栈也为空</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/Offer/7_1.png" alt title="例子"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;</span><br><span class="line">        if (!preorder.size()) &#123;</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* root = new TreeNode(preorder[0]);</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        stk.push(root);</span><br><span class="line">        int inorderIndex = 0;</span><br><span class="line">        for (int i = 1; i &lt; preorder.size(); ++i) &#123;</span><br><span class="line">            //因为根节点已经入栈，所以从1开始</span><br><span class="line">            int preorderVal = preorder[i];</span><br><span class="line">            TreeNode* node = stk.top();</span><br><span class="line">            //这里比较的是栈顶节点与指针，而不是preorder[i]与指针</span><br><span class="line">            if (node-&gt;val != inorder[inorderIndex]) &#123;</span><br><span class="line">                node-&gt;left = new TreeNode(preorderVal);</span><br><span class="line">                stk.push(node-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                while (!stk.empty() &amp;&amp; stk.top()-&gt;val == inorder[inorderIndex]) &#123;</span><br><span class="line">                    //这里更新最后弹出的栈顶元素</span><br><span class="line">                    node = stk.top();</span><br><span class="line">                    stk.pop();</span><br><span class="line">                    ++inorderIndex;</span><br><span class="line">                &#125;</span><br><span class="line">                node-&gt;right = new TreeNode(preorderVal);</span><br><span class="line">                stk.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="8-二叉树的下一个节点"><a href="#8-二叉树的下一个节点" class="headerlink" title="8_二叉树的下一个节点"></a>8_二叉树的下一个节点</h2><ul>
<li><p>这题力扣上没有</p>
</li>
<li><p>题目的意思是，给一个二叉树，给定一个节点，然后写出按中序遍历原则的下一个节点</p>
<ul>
<li>分析——将给的节点当成根节点，然后下一个就是它的右子树的最左子节点！</li>
<li>如果没有右子树，那就看它的父节点是左还是右（这里的左右是参考本节点与父节点的位置）<ul>
<li>父节点为左：按照中序遍历原则，下一个节点就是父节点本身</li>
<li>父节点为右：这里要向上回溯，找到第一个节点（其父节点为左）</li>
</ul>
</li>
</ul>
</li>
<li><p>当然这个二叉树有三个指针——左、右、父</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct BinaryTreeNode</span><br><span class="line">&#123;</span><br><span class="line">    int                    m_nValue;</span><br><span class="line">    BinaryTreeNode*        m_pLeft;</span><br><span class="line">    BinaryTreeNode*        m_pRight;</span><br><span class="line">    BinaryTreeNode*        m_pParent;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">BinaryTreeNode* GetNext(BinaryTreeNode* pNode)</span><br><span class="line">&#123;</span><br><span class="line">    if(pNode == nullptr)</span><br><span class="line">        return nullptr;</span><br><span class="line">    //先声明为空</span><br><span class="line">    BinaryTreeNode* pNext = nullptr;</span><br><span class="line">    //有右子树——找到最左子节点</span><br><span class="line">    if(pNode-&gt;m_pRight != nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        BinaryTreeNode* pRight = pNode-&gt;m_pRight;</span><br><span class="line">        while(pRight-&gt;m_pLeft != nullptr)</span><br><span class="line">            pRight = pRight-&gt;m_pLeft;</span><br><span class="line"></span><br><span class="line">        pNext = pRight;</span><br><span class="line">    &#125;//没有右子树、并且父节点不为空</span><br><span class="line">    else if(pNode-&gt;m_pParent != nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        BinaryTreeNode* pCurrent = pNode;</span><br><span class="line">        BinaryTreeNode* pParent = pNode-&gt;m_pParent;</span><br><span class="line">        //一直找到第一个节点（其父节点为左）</span><br><span class="line">        while(pParent != nullptr &amp;&amp; pCurrent == pParent-&gt;m_pRight)</span><br><span class="line">        &#123;</span><br><span class="line">            pCurrent = pParent;</span><br><span class="line">            pParent = pParent-&gt;m_pParent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pNext = pParent;</span><br><span class="line">    &#125;</span><br><span class="line">    return pNext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-用两个栈实现队列"><a href="#9-用两个栈实现队列" class="headerlink" title="9_用两个栈实现队列"></a>9_用两个栈实现队列</h2><ul>
<li>印象深刻，记得当时是两个栈来回倒，一看题解发现，不需要来回倒，看看自己能不能再实现下<ul>
<li>专门用一个来当辅助（因为倒过去之后顺序是相反的）</li>
<li>可以，一次过</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//手撕</span><br><span class="line">class CQueue &#123;</span><br><span class="line">public:</span><br><span class="line">    CQueue() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void appendTail(int value) &#123;</span><br><span class="line">        stk.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int deleteHead() &#123;</span><br><span class="line">        if(stk.empty() &amp;&amp; stk_tmp.empty())&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;else if(!stk_tmp.empty())&#123;</span><br><span class="line">            int d = stk_tmp.top();</span><br><span class="line">            stk_tmp.pop();</span><br><span class="line">            return d;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            //stk_tmp为空、stk不为空</span><br><span class="line">            while(!stk.empty())&#123;</span><br><span class="line">                stk_tmp.push(stk.top());</span><br><span class="line">                stk.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            int d = stk_tmp.top();</span><br><span class="line">            stk_tmp.pop();</span><br><span class="line">            return d;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    stack&lt;int&gt; stk, stk_tmp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//题解——若stk_tmp为空，那么不管stk空不空，都倒进stk_tmp，若stk_tmp还是空，直接返回-1</span><br><span class="line">//这里就不放了</span><br></pre></td></tr></table></figure>

<ul>
<li>书差点忘记看了…<ul>
<li>思路是一样的，另外还提到了双队列实现栈，而这里面的双队列就是等价的了</li>
</ul>
</li>
</ul>
<h2 id="10-1-斐波那契数列"><a href="#10-1-斐波那契数列" class="headerlink" title="10-1_斐波那契数列"></a>10-1_斐波那契数列</h2><ul>
<li>递归就只有两三行代码，但我估计会溢出<ul>
<li>试了下，四十几就溢出了</li>
<li>因为每次都有两个递归，然后就会不停的重复，指数级别的重复！！</li>
</ul>
</li>
<li>试下动态规划！也就是循环，速度很快！——这题没有官方题解，看会儿书<ul>
<li>书上还提到了数学方法，也就是矩阵运算，但是需要自己实现矩阵运算</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//动规——也可以是循环</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int fib(int n) &#123;</span><br><span class="line">        if(n &lt; 2) return n;</span><br><span class="line">        //这里突然想到滚动数组的思想</span><br><span class="line">        int n2 = 0, n1 = 1;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        for(int i = 2; i &lt;= n; ++i)&#123;</span><br><span class="line">            ans = (n1 + n2) % 1000000007;</span><br><span class="line">            n2 = n1 % 1000000007;</span><br><span class="line">            n1 = ans;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="10-2-青蛙跳台阶问题"><a href="#10-2-青蛙跳台阶问题" class="headerlink" title="10-2_青蛙跳台阶问题"></a>10-2_青蛙跳台阶问题</h2><ul>
<li>这题也有点印象，记得当时是排列组合算出来的！</li>
<li>这次用动态规划看看、<ul>
<li><code>f(n)</code>是到当前台阶的跳法zongshu</li>
<li>那么<code>f(n)</code>与<code>f(n-1)</code>的关系就是<code>f(n)=f(n-1)</code></li>
<li>么<code>f(n)</code>与<code>f(n-2)</code>的关系就是两倍关系？不对，一步一步跳会与<code>f(n-1)</code>重复，所以只能两步跳</li>
<li>那么这一题与上一题就是初始状态不一样</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int numWays(int n) &#123;</span><br><span class="line">        //当前状态和前两个状态有关</span><br><span class="line">        if(n &lt; 2) return 1;</span><br><span class="line"></span><br><span class="line">        int ans = 0, n1 = 1, n2 = 1;</span><br><span class="line">        for(int i = 2; i &lt;= n; ++i)&#123;</span><br><span class="line">            ans = (n1 + n2) % 1000000007;</span><br><span class="line">            n2 = n1;</span><br><span class="line">            n1 = ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="11-旋转数组的最小数字"><a href="#11-旋转数组的最小数字" class="headerlink" title="11_旋转数组的最小数字"></a>11_旋转数组的最小数字</h2><ul>
<li><p>与154一样</p>
<ul>
<li>这题数字是可以重复的，但为什么这题简单，力扣154就是困难呢</li>
<li>有重复的，应该找二分法找左右边界？</li>
<li>最小数字的左边要是边界，要么比它大</li>
</ul>
</li>
<li><p>记得当时，没有绕明白，现在再理一遍</p>
<ul>
<li>一开始<code>l</code>在最左边，<code>r</code>在末尾（<code>end()</code>），左闭右开——等等，这里应该都是闭区间比较好写</li>
<li>最小值一定在两者之间，这种情况下，若<code>numbers[l] == numbers[r]</code>，就让<code>r--</code>；</li>
<li>至于加一还是减一，就看这个数是否判断过了</li>
<li>这题好难啊——最外层又套了个<code>if else</code>总算过了！！！</li>
</ul>
</li>
<li><p>题解记录</p>
<ul>
<li><code>l</code>和<code>r</code>都是闭区间</li>
<li><code>while</code>循环是<code>l &lt; r</code></li>
<li><code>if (numbers[m] &lt; numbers[r] r = m;</code> 这里没有减一，因为这个数字还没有判断，跟我写的不一样</li>
<li><code>else if (numbers[m] &gt; numbers[r]) l = m + 1;</code> 这里加一没问题</li>
<li><code>else --r;</code> 这么一写，妙到家了！相等的情况也考虑进去了！</li>
</ul>
</li>
<li><p>总结，我写的判断条件太多，比较乱！</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//手撕</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minArray(vector&lt;int&gt;&amp; numbers) &#123;</span><br><span class="line">        if(numbers.empty()) return -1;</span><br><span class="line">        int l = 0, r = numbers.size();</span><br><span class="line">        --r;</span><br><span class="line">        //这里的等于好像可以不加，因为就剩一个数了，只能是这个数？</span><br><span class="line">        while(l &lt; r)&#123;</span><br><span class="line">            if(numbers[l] == numbers[r])&#123;</span><br><span class="line">                --r;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                int m = (r - l) / 2 + l;</span><br><span class="line">                //这里的m == 0 有个条件</span><br><span class="line">                if((m == 0 &amp;&amp; numbers[m] &lt; numbers[r]) || (m != 0 &amp;&amp; numbers[m] &lt; numbers[m - 1]))&#123;</span><br><span class="line">                    return numbers[m];</span><br><span class="line">                    //numbers[m] == numbers[l]也有前提条件的</span><br><span class="line">                &#125;else if(numbers[m] &gt; numbers[r])&#123;</span><br><span class="line">                    //这里不管与左边是否相等，只要大于右边，那最小值就在右边；这里加一是因为判断过了？</span><br><span class="line">                    l = m + 1;</span><br><span class="line">                &#125;else if(numbers[m] &lt;= numbers[r])&#123;</span><br><span class="line">                    r = m - 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return numbers[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//题解</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minArray(vector&lt;int&gt;&amp; numbers) &#123;</span><br><span class="line">        int low = 0;</span><br><span class="line">        int high = numbers.size() - 1;</span><br><span class="line">        while (low &lt; high) &#123;</span><br><span class="line">            int pivot = low + (high - low) / 2;</span><br><span class="line">            if (numbers[pivot] &lt; numbers[high]) &#123;</span><br><span class="line">                high = pivot;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (numbers[pivot] &gt; numbers[high]) &#123;</span><br><span class="line">                low = pivot + 1;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                high -= 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return numbers[low];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>书上的条件是比较两个元素的大小<code>while(numbers[l] &gt;= numbers[r])</code>；这里前提是大于等于，若是小于则直接返回第一个数字<ul>
<li>当两个指针距离为1时，返回第二个指针指向的数字</li>
<li>之后更新中间指针时，左右两个指针都没有进行加减1</li>
<li>但是这里有个漏洞，当三个指针的元素都一样时，这时得用顺序查找（书上另外创建了函数），这点力扣写的比较清晰明了</li>
</ul>
</li>
</ul>
<h2 id="12-矩阵中的路径"><a href="#12-矩阵中的路径" class="headerlink" title="12_矩阵中的路径"></a>12_矩阵中的路径</h2><ul>
<li>79题</li>
<li>再次做的时候有几个注意点<ul>
<li>首先字母不能重复利用，也就是要生成另一个数组用来标记</li>
<li>上下左右可以用一个二维数组来表示加减一，之后循环，在循环内要判断新的坐标，是否符合多个条件，只有符合才能继续递归</li>
<li>若全局变量<code>ans</code>为真，那就直接返回，这个条件也加入递归出口里</li>
<li>也可以直接在原数组上改，改之前要先保存原字符</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; tmp, vector&lt;vector&lt;char&gt;&gt;&amp; board, string&amp; word, int x, int y, int p, int n)&#123;</span><br><span class="line">        if(p == n) ans = true;</span><br><span class="line">        if(ans) return;</span><br><span class="line">        //没有被标记、并且相等</span><br><span class="line">        for(auto&amp; os : pos)&#123;</span><br><span class="line">            int i = x + os[0], j = y + os[1];</span><br><span class="line">            //这里的条件应该是i、j</span><br><span class="line">            if(i &gt;= 0 &amp;&amp; i &lt; board.size() &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; board[0].size() &amp;&amp; board[i][j] == word[p] &amp;&amp; tmp[i][j] == 0)&#123;</span><br><span class="line">                tmp[i][j] = 1;</span><br><span class="line">                dfs(tmp, board, word, i, j, p + 1, n);</span><br><span class="line">                tmp[i][j] = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            if(ans) break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123;</span><br><span class="line">        if(board.empty() || board[0].empty() || word.empty()) return false;</span><br><span class="line">        int row = board.size(), col = board[0].size(), n = word.size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; tmp(row, vector&lt;int&gt;(col, 0));</span><br><span class="line">        for(int i = 0; i &lt; row; ++i)&#123;</span><br><span class="line">            for(int j = 0; j &lt; col; ++j)&#123;</span><br><span class="line">                if(board[i][j] == word[0])&#123;</span><br><span class="line">                    //标记</span><br><span class="line">                    tmp[i][j] = 1;</span><br><span class="line">                    //cout &lt;&lt; &quot;board[&quot; &lt;&lt; i &lt;&lt; &quot;][&quot; &lt;&lt; j &lt;&lt; &quot;] = &quot; &lt;&lt; board[i][j] &lt;&lt; endl;</span><br><span class="line">                    dfs(tmp, board, word, i, j, 1, n);</span><br><span class="line">                    if(ans) return ans;</span><br><span class="line">                    tmp[i][j] = 0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    bool ans = false;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; pos = &#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="13-机器人的运动范围"><a href="#13-机器人的运动范围" class="headerlink" title="13_机器人的运动范围"></a>13_机器人的运动范围</h2><ul>
<li><p>如果这个格子可以到达，那么全局变量加一</p>
<ul>
<li>这题递归前无需遍历整个二维数组？<ul>
<li>不对，从<code>(0,0)</code>开始确实有好多格子可以走，但不一定能走到最后</li>
<li>所以走过的格子要标记，这里就用哈希表了，这样，遍历的格子都标记，不然不能走的格子还是要判断</li>
</ul>
</li>
<li>标记之后再判断这个格子能不能走！</li>
<li>递归的出口就是四个方向都走过了</li>
<li>编译出错？？——看构造函数，是否所有的变量都初始化，没有初始化化就会报出样的错误<ul>
<li>这里错了<code>unordered_set&lt;pair&lt;int, int&gt;&gt; set;</code>，C++中没有给<code>pair</code>做Hash的函数，所以不能用<code>pair</code>作为<code>unordered_map</code>的key。<code>unordered_set</code>也是同理吧，改成<code>set</code>看看，可以了</li>
</ul>
</li>
</ul>
</li>
<li><p>提交之后发现报错了…</p>
<ul>
<li>我一度以为用例的答案错了？</li>
<li>我知道了，因为机器人是从<code>(0,0)</code>开始走的，所以只能从<code>(0,0)</code>递归！！，不能遍历二维数组！成功了</li>
<li>代码有点慢，看看题解<ul>
<li>广度优先似乎比深度优先快点儿</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//手撕</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int mysum(int i, int j)&#123;</span><br><span class="line">        //这里优化下</span><br><span class="line">        int sum = 0;</span><br><span class="line">        while(i &gt; 0)&#123;</span><br><span class="line">            sum += (i % 10);</span><br><span class="line">            i /= 10;</span><br><span class="line">        &#125;</span><br><span class="line">        while(j &gt; 0)&#123;</span><br><span class="line">            sum += (j % 10);</span><br><span class="line">            j /= 10;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void dfs(int x, int y, int k, int m, int n)&#123;</span><br><span class="line">        //遍历上下左右</span><br><span class="line">        for(auto&amp; p : pos)&#123;</span><br><span class="line">            int i = x + p[0], j = y + p[1];</span><br><span class="line">            if(i &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; n &amp;&amp; set.find(make_pair(i, j)) == set.end())&#123;</span><br><span class="line">                //先标记</span><br><span class="line">                set.insert(make_pair(i, j));</span><br><span class="line">                //再判断能不能走</span><br><span class="line">                if(mysum(i, j) &lt;= k)&#123;</span><br><span class="line">                    //这里递归</span><br><span class="line">                    ++ans;</span><br><span class="line">                    dfs(i, j, k, m, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int movingCount(int m, int n, int k) &#123;</span><br><span class="line">        if(k &lt; 0 || m &lt; 0 || n &lt; 0) return 0;</span><br><span class="line">        //(0,0)肯定可以走</span><br><span class="line">        set.insert(make_pair(0, 0));</span><br><span class="line">        ++ans;</span><br><span class="line">        dfs(0, 0, k, m, n);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int ans = 0;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; pos = &#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;;</span><br><span class="line">    set&lt;pair&lt;int, int&gt;&gt; set;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//题解</span><br><span class="line">class Solution &#123;</span><br><span class="line">    // 计算 x 的数位之和</span><br><span class="line">    int get(int x) &#123;</span><br><span class="line">        int res=0;</span><br><span class="line">        for (; x; x /= 10) &#123;</span><br><span class="line">            res += x % 10;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    int movingCount(int m, int n, int k) &#123;</span><br><span class="line">        if (!k) return 1;</span><br><span class="line">        queue&lt;pair&lt;int,int&gt; &gt; Q;</span><br><span class="line">        // 向右和向下的方向数组</span><br><span class="line">        int dx[2] = &#123;0, 1&#125;;</span><br><span class="line">        int dy[2] = &#123;1, 0&#125;;</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; vis(m, vector&lt;int&gt;(n, 0));</span><br><span class="line">        Q.push(make_pair(0, 0));</span><br><span class="line">        vis[0][0] = 1;</span><br><span class="line">        int ans = 1;</span><br><span class="line">        while (!Q.empty()) &#123;</span><br><span class="line">            auto [x, y] = Q.front();</span><br><span class="line">            Q.pop();</span><br><span class="line">            for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">                int tx = dx[i] + x;</span><br><span class="line">                int ty = dy[i] + y;</span><br><span class="line">                if (tx &lt; 0 || tx &gt;= m || ty &lt; 0 || ty &gt;= n || vis[tx][ty] || get(tx) + get(ty) &gt; k) continue;</span><br><span class="line">                Q.push(make_pair(tx, ty));</span><br><span class="line">                vis[tx][ty] = 1;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="14-1-剪绳子"><a href="#14-1-剪绳子" class="headerlink" title="14-1_剪绳子"></a>14-1_剪绳子</h2><ul>
<li><p>似乎有点难，343题还没有做到</p>
<ul>
<li>好好理解下动态规划</li>
<li>把一个绳子剪成两段，要是乘积最大，就要使这两段绳子的本身的乘积最大？</li>
<li>不对，要是只剪一刀呢，让这两段长度相等？若长度为奇数，那就相差为1</li>
<li>之后再减一刀，就是取其中一段（或者取长的一段？），就变成了子问题</li>
<li>手撕试一下<ul>
<li>数组定义很重要！</li>
</ul>
</li>
</ul>
</li>
<li><p>这题没做出来！总感觉隔了那么一层窗户纸！</p>
<ul>
<li>看了书才知道，一维数组就行，长度的绳子的长度（+1）！</li>
<li>然后，由下至上，长度为2，就只能在位置1剪，之后长度为3，就要<code>max(位置1剪，位置2剪)</code>了，不用二维数组</li>
<li>初始边界有点乱，<code>dp[0]=0;dp[1]=0;dp[2]=1;dp[3]=2</code></li>
<li>返回值和边界条件不太一致，因为边界条件是方便状态转移的</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int cuttingRope(int n) &#123;</span><br><span class="line">        if(n &lt; 2) return 0;</span><br><span class="line">        if(n == 2) return 1;</span><br><span class="line">        if(n == 3) return 2;</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt; dp(n + 1, 0);</span><br><span class="line">        //边界</span><br><span class="line">        dp[1] = 1;dp[2] = 2;</span><br><span class="line">        //dp[3]应该写成2</span><br><span class="line">        dp[3] = 3;</span><br><span class="line"></span><br><span class="line">        for(int i = 4; i &lt; n + 1; ++i)&#123;</span><br><span class="line">            //记录最大值，每个位置都剪</span><br><span class="line">            int m = 0;</span><br><span class="line">            for(int j = 1; j &lt; i; ++j)&#123;</span><br><span class="line">                m = max(m, dp[j] * dp[i - j]);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = m;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>贪心算法，<ul>
<li>在数学上，大佬证明比较繁琐，书上的比较清晰明了——尽可能多的剪成长度为3的一段段</li>
<li>前提<code>n&gt;=5</code>，<code>2(n-2)&gt;n</code>、<code>3(n-3)&gt;n</code>，当绳子长度大于等于5的时候，剪成长度为3或者2</li>
<li>又因为<code>3(n-3)&gt;=2(n-2)</code>，所以尽可能剪成长度为3的一段</li>
<li>最后也有特例</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/Offer/14-1.png" alt title="切分规则"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//贪心</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int cuttingRope(int n) &#123;</span><br><span class="line">        if(n &lt; 1) return 0;</span><br><span class="line">        if(n &lt; 4) return n - 1;</span><br><span class="line">        //计算商和余数</span><br><span class="line">        int a = n / 3, b = n % 3;</span><br><span class="line">        if(b == 0)&#123;</span><br><span class="line">            return static_cast&lt;int&gt;(pow(3, a));</span><br><span class="line">        &#125;else if(b == 1)&#123;</span><br><span class="line">            return static_cast&lt;int&gt;(pow(3, a - 1) * 4);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return static_cast&lt;int&gt;(pow(3, a) * 2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>真正的大佬只需要一行代码！</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int cuttingRope(int n) &#123;</span><br><span class="line">    return n &lt;= 3? n - 1 : pow(3, n / 3) * 4 / (4 - n % 3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="14-2-剪绳子-ll"><a href="#14-2-剪绳子-ll" class="headerlink" title="14-2_剪绳子_ll"></a>14-2_剪绳子_ll</h2><ul>
<li>看了题目之后，我甚至一度以为这不是一模一样吗<ul>
<li>后来才发现，绳子的长度范围变大了，最后可能的最大乘积需要取模！</li>
<li>那么动态规划可能会超时！</li>
<li>求幂都超出了<code>long long</code>的范围，有点牛皮！1000有333个3，而3^19次方就超过了1000000007</li>
<li>有点投机取巧了，应该一大于1000000007就取模，所以应该循环！</li>
<li>看下评论优化下！——循环求余！</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int cuttingRope(int n) &#123;</span><br><span class="line">        if(n &lt; 1) return 0;</span><br><span class="line">        if(n &lt; 4) return n - 1;</span><br><span class="line">        long long ans = 1;</span><br><span class="line">        int p = (int)1e9+7;</span><br><span class="line">        while(n &gt; 4)&#123;</span><br><span class="line">            ans = ans * 3 % p;</span><br><span class="line">            n -= 3;</span><br><span class="line">        &#125;</span><br><span class="line">        //最后还剩，2，3，4</span><br><span class="line">        return ans * n % p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="15-二进制中1的个数"><a href="#15-二进制中1的个数" class="headerlink" title="15_二进制中1的个数"></a>15_二进制中1的个数</h2><ul>
<li>这题之前做过几次，印象最深的就是那个不用循环、位移就能得出结果的算法，这里好好总结下<ul>
<li>如果是负数呢！发现剑指Offer的题看似简单，但都很有深度！！</li>
<li>书上详细介绍了三种——可能引起死循环、常规、惊喜的——算法</li>
<li>当然，也有大佬直接调库<code>__builtin_popcount()</code></li>
</ul>
</li>
<li>死循环是直接将数字<code>n</code>右移，依次判断最后一位是否位1，如果遇到负数，左移时，还是负数，但是最高位会逐渐变成1，从而引起死循环</li>
<li>常规方法时用1来左移，然后与<code>n</code>相与，这样就算是负数，依次判断也不会影响</li>
<li>惊喜的算法就是下面的代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int hammingWeight(uint32_t n) &#123;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        while(n != 0)&#123;</span><br><span class="line">            n &amp;= (n - 1);</span><br><span class="line">            ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="16-数值的整数次方"><a href="#16-数值的整数次方" class="headerlink" title="16_数值的整数次方"></a>16_数值的整数次方</h2><ul>
<li>50题<ul>
<li>印象比较深，一个一个乘太慢，每次都得翻倍，快一点</li>
<li>循环得仔细琢磨琢磨，还有正数边界问题<ul>
<li>我用了两个循环，却发现我第一次居然写的递归？？还写的贼好看，应该是参考的:)</li>
<li>这题明天再琢磨琢磨！！</li>
<li>递归没有写出来！<ul>
<li>首先，递归的话，应该写成<code>double y = quickMul(x, N / 2);</code>，之后再<code>y * y : y * y * x;</code>，这样可以省去一部分时间，而不是<code>ans *= (1 / double(x, n / 2)) * (1 / double(x, n / 2));</code></li>
<li>但是这样写会报错，<code>excess elements in scalar initializer</code>？？，难道是要自己写个递归函数么</li>
<li>这个一般是初始化数组忘了初始化大小了</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/Offer/16.png" alt title="报错"></p>
<ul>
<li>还是老老实实用<code>long long</code>吧</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//两个while循环</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    double myPow(double x, int n) &#123;</span><br><span class="line">        if(n == 0) return 1;</span><br><span class="line">        bool flag = n &lt; 0 ? true : false;</span><br><span class="line">        //无需考虑大数，那就都转为正数，话是这么说，但是范围还是给出了正数边界，应该都转为负数！！！</span><br><span class="line">        if(!flag) n *= -1;</span><br><span class="line">        //n为负数</span><br><span class="line"></span><br><span class="line">        int tmp = -1;</span><br><span class="line">        double ans = 1;</span><br><span class="line">        while(n &lt; 0)&#123;</span><br><span class="line">            //这里要定义个临时变量</span><br><span class="line">            double a = 1 / x;</span><br><span class="line">            //这里乘以2会超出正数边界！</span><br><span class="line">            while(tmp &gt;= n / 2)&#123;</span><br><span class="line">                a *= a;</span><br><span class="line">                tmp *= 2;</span><br><span class="line">            &#125;</span><br><span class="line">            //这里tmp再乘以2就大于n</span><br><span class="line">            n -= tmp;</span><br><span class="line">            //初始化tmp</span><br><span class="line">            tmp = -1;</span><br><span class="line">            //这里是乘，而不是加</span><br><span class="line">            ans *= a;</span><br><span class="line">        &#125;</span><br><span class="line">        return flag ? ans : 1 / ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//试下递归</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    double myPow(double x, int n) &#123;</span><br><span class="line">        //这里是都转为正数n，会报错，应该都转为负数，或者写成long long的形式</span><br><span class="line">        long long N = n;</span><br><span class="line">        return N &lt; 0 ? 1.0 / quickPow(x, -N) : quickPow(x, N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    double quickPow(double x, long long n)&#123;</span><br><span class="line">        if(n == 0) return 1.0;</span><br><span class="line">        double y = quickPow(x, n / 2);</span><br><span class="line">        return n % 2 == 0 ? y * y : x * y * y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="17-打印从1到最大的n位数"><a href="#17-打印从1到最大的n位数" class="headerlink" title="17_打印从1到最大的n位数"></a>17_打印从1到最大的n位数</h2><ul>
<li>看看这题有啥坑<ul>
<li>n很大，可能会超出整型、长整型的范围！书上用的是字符串</li>
<li>第二种方法用了递归全排列，每一位都可能是0~9的数字，出口条件是最后一位</li>
<li>这两中方法在输出的时候，都要将数前面的0去掉！</li>
<li>但是力扣上是<code>vector&lt;int&gt;</code>返回值，所以考虑大数又有点鸡肋，直接循环了</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//遍历</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; printNumbers(int n) &#123;</span><br><span class="line">        if(n &lt; 1) return vector&lt;int&gt;();</span><br><span class="line">        //范围10^n - 1，一次循环吧</span><br><span class="line">        long long tmp = static_cast&lt;long long&gt;(pow(10, n));</span><br><span class="line">        vector&lt;int&gt; ans;</span><br><span class="line">        for(int i = 1; i &lt; tmp; ++i)&#123;</span><br><span class="line">            ans.emplace_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="18-删除链表的节点"><a href="#18-删除链表的节点" class="headerlink" title="18_删除链表的节点"></a>18_删除链表的节点</h2><ul>
<li>这个我应该挺熟的<ul>
<li>在头节点再加个伪头节点，这样比较方便</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* deleteNode(ListNode* head, int val) &#123;</span><br><span class="line">        //给的值在节点内，就不判断是否为空了</span><br><span class="line">        //小技巧，添加伪头节点</span><br><span class="line">        ListNode* myHead = new ListNode(-1);</span><br><span class="line">        myHead-&gt;next = head;</span><br><span class="line">        auto carry = myHead;</span><br><span class="line">        while(carry-&gt;next != nullptr &amp;&amp; carry-&gt;next-&gt;val != val)&#123;</span><br><span class="line">            carry = carry-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        //carry-&gt;next-&gt;val == val</span><br><span class="line">        auto tmp = carry-&gt;next-&gt;next;</span><br><span class="line">        carry-&gt;next = tmp;</span><br><span class="line">        return myHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="19-正则表达式匹配"><a href="#19-正则表达式匹配" class="headerlink" title="19_正则表达式匹配"></a>19_正则表达式匹配</h2><ul>
<li><p>当时做的时候感觉这一题好难</p>
<ul>
<li>识别三日、当刮目相看</li>
<li>一个一个字符比较的话似乎会出现问题——<code>&quot;.*&quot;</code>出现在一起怎么办？不知道我的判断条件能不能处理</li>
<li>有问题，应该以<code>p.size()&gt;=2</code>来划分，因为考虑后一个字符是<code>&#39;*&#39;</code>、还是<code>&#39;.&#39;</code>；而不是<code>p[0]</code>为特殊字符再去找前一个字符是啥！</li>
<li>有个注意点应该是<code>isalnum(p[0])</code>而不是<code>isdigit(p[0])</code></li>
<li>还有注意点，如果字母后跟着<code>&#39;*&#39;</code>，比如<code>&quot;c*&quot;</code>，那么<code>&quot;c*&quot;</code>可以直接跳过</li>
<li>我写的好乱，打补丁容易出错！还是得以<code>p.size()&gt;=2</code>来划分，而不是在<code>if else</code>条件内再划分<ul>
<li>字母+<code>&#39;*&#39;</code>可有可无</li>
<li>若遇到<code>&#39;*&#39;</code>，该怎么判断呢，应该不会遇到<code>&#39;*&#39;</code>，除非<code>s</code>为空！或者<code>p[1] == &#39;*&#39;</code></li>
<li>总感觉对<code>&#39;*&#39;</code>的处理不够周全，但是最后也过了！</li>
</ul>
</li>
</ul>
</li>
<li><p>总结</p>
<ul>
<li>难点在<code>&#39;*&#39;</code>，而不是点，因为星号要跟前一个字符组成一个整体</li>
<li>第一遍看的大佬写的真好，再温习一遍，先粘贴下自己臃肿的代码</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//手撕版本</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isMatch(string s, string p) &#123;</span><br><span class="line">        //两个字符串，应该不停的用递归！每次递归都比较第一个字符</span><br><span class="line">        //既然用递归，那就得设置出口条件</span><br><span class="line">        if(s.empty() &amp;&amp; p.empty())&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;else if(!s.empty() &amp;&amp; p.empty())&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //接下来p不为空，s有可能为空</span><br><span class="line">        if(p.size() &lt; 2)&#123;</span><br><span class="line">            if(s.empty())&#123;</span><br><span class="line">                return p[0] == &apos;*&apos;;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                if(p[0] == s[0] || p[0] == &apos;.&apos;)&#123;</span><br><span class="line">                    return isMatch(s.substr(1), p.substr(1));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            if(s.empty())&#123;</span><br><span class="line">                //这里也要考虑*</span><br><span class="line">                return (p[0] == &apos;*&apos; &amp;&amp; isMatch(s, p.substr(1))) || (p[1] == &apos;*&apos; &amp;&amp; isMatch(s, p.substr(2)));</span><br><span class="line">            &#125;else if(!s.empty())&#123;</span><br><span class="line">                bool flag1 = (s[0] == p[0] || p[0] == &apos;.&apos;) &amp;&amp; isMatch(s.substr(1), p.substr(1));</span><br><span class="line">                bool flag2 = false;</span><br><span class="line">                if(p[1] == &apos;*&apos;)&#123;</span><br><span class="line">                    flag2 = isMatch(s, p.substr(2)) || ((s[0] == p[0] || p[0] == &apos;.&apos;) &amp;&amp; isMatch(s.substr(1), p));</span><br><span class="line">                &#125;</span><br><span class="line">                return flag1 || flag2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//大佬版本</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isMatch(string s, string p) &#123;</span><br><span class="line">		//这里就一句代码，非常简洁</span><br><span class="line">        if(p.empty()) return s.empty();</span><br><span class="line">		//第一个是否匹配！同时考虑了s是否为空</span><br><span class="line">        bool firstmatch = !s.empty() &amp;&amp; (s[0] == p[0] || p[0] == &apos;.&apos;);</span><br><span class="line">		//这里按长度来划分，并且明确p[1] == &apos;*&apos;的情况！</span><br><span class="line">        if(p.size() &gt;= 2 &amp;&amp; p[1] == &apos;*&apos;)&#123;</span><br><span class="line">			//要么0个，要么1个</span><br><span class="line">            return isMatch(s, p.substr(2, p.size() - 2)) || (firstmatch &amp;&amp; isMatch(s.substr(1, s.size() - 1), p));</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">			//这里也非常简洁，没有把p[0]分开讨论，因为firstmatch就已经讨论过了</span><br><span class="line">            return firstmatch &amp;&amp; isMatch(s.substr(1, s.size() - 1), p.substr(1, p.size() - 1));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>动态规划<ul>
<li>处理两个字符串，经常会用到</li>
<li><code>dp[m+1][n+1]</code>布尔值</li>
<li>初始化的时候，星号很重要，初始化为用0次</li>
<li>刚刚试了下，样例中并没有以’*’开头的字符串p，所以初始化边界的时候从<code>i = 1</code>开始（字符串的下标）</li>
<li>但是这里报了错<code>dp[i][j] = dp[i]dp[j - 1];</code>不知道为什么，以前没出现这种情况</li>
<li>我是傻子！！应该写成<code>dp[i][j] = dp[i][j - 1];</code></li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assigning to &apos;__gnu_cxx::__alloc_traits&lt;std::allocator&lt;int&gt;, int&gt;::value_type&apos; (aka &apos;int&apos;) from incompatible type &apos;__gnu_cxx::__alloc_traits&lt;std::allocator&lt;std::vector&lt;int, std::allocator&lt;int&gt;&gt;&gt;, std::vector&lt;int, std::allocator&lt;int&gt;&gt;&gt;::value_type&apos; (aka &apos;std::vector&lt;int, std::allocator&lt;int&gt;&gt;&apos;)</span><br><span class="line">         dp[i][j] = dp[i]dp[j - 1];</span><br></pre></td></tr></table></figure>

<p><img src="/pictrues/Offer/19.png" alt title="动态规划"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//手撕动态规划</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isMatch(string s, string p) &#123;</span><br><span class="line">        //动态规划似乎不需要这行代码了？</span><br><span class="line">        //if(p.empty()) return s.empty();</span><br><span class="line">        int n = s.size(), m = p.size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(m + 1, 0));</span><br><span class="line">        //边界条件</span><br><span class="line">        dp[0][0] = 1;</span><br><span class="line">        //行是字符串s，列是字符串p，列里面才有&apos;*&apos;</span><br><span class="line">        for(int i = 1; i &lt; m; ++i)&#123;</span><br><span class="line">            //aa</span><br><span class="line">            //a*</span><br><span class="line">            if(p[i] == &apos;*&apos;)&#123;</span><br><span class="line">                //为什么第一维是0呢，表示字符串s前0个字符，初始化为0个*前面的字符</span><br><span class="line">                dp[0][i + 1] = dp[0][i - 1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //状态转移——这里是二维数组的下标，转为字符串的下标要减一</span><br><span class="line">        for(int i = 1; i &lt; n + 1; ++i)&#123;</span><br><span class="line">            for(int j = 1; j &lt; m + 1; ++j)&#123;</span><br><span class="line"></span><br><span class="line">                if(s[i - 1] == p[j - 1] || p[j - 1] == &apos;.&apos;)&#123;</span><br><span class="line">                    //对应字母匹配，各往前退一个（传递），而不是直接赋值1</span><br><span class="line">                    dp[i][j] = dp[i - 1][j - 1];</span><br><span class="line">                &#125;else if(p[j - 1] == &apos;*&apos;)&#123;</span><br><span class="line">                    //这里不能拿前面的来赋值，而是要分情况，用还是不用</span><br><span class="line">                    if(dp[i][j - 2])&#123;</span><br><span class="line">                        dp[i][j] = 1;</span><br><span class="line">                    &#125;else if(s[i - 1] == p[j - 2] || p[j - 2] == &apos;.&apos;)&#123;</span><br><span class="line">                        //这里是要传递，并且是s往前一个，而不是p</span><br><span class="line">                        dp[i][j] = dp[i - 1][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="20-表示数值的字符串"><a href="#20-表示数值的字符串" class="headerlink" title="20_表示数值的字符串"></a>20_表示数值的字符串</h2><ul>
<li>再来复习一遍！！<ul>
<li>当时题解是用了有限状态自动机！</li>
<li>这题多了空格，更复杂点，还有其他的字母！</li>
<li>还是错了几次才过，关键点在于出现e之后，其余的正负号、数字、小数点都要初始化下！！</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isNumber(string s) &#123;</span><br><span class="line">        //先对字符串处理空格</span><br><span class="line">        while(!s.empty() &amp;&amp; s.back() == &apos; &apos;)&#123;</span><br><span class="line">            s.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        if(s.empty()) return false;</span><br><span class="line"></span><br><span class="line">        int pos = 0;</span><br><span class="line">        while(pos &lt; s.size() &amp;&amp; s[pos] == &apos; &apos;)&#123;</span><br><span class="line">            ++pos;</span><br><span class="line">        &#125;</span><br><span class="line">        s = s.substr(pos);</span><br><span class="line"></span><br><span class="line">        //一次遍历，根据已出现或者没有出现的数字、小数点、正负号、E/e来判断是否有效</span><br><span class="line">        bool numSeen = false;</span><br><span class="line">        bool dotSeen = false;</span><br><span class="line">        bool signSeen = false;</span><br><span class="line">        bool eSeen = false;</span><br><span class="line"></span><br><span class="line">        for(int i = 0; i &lt; s.size(); ++i)&#123;</span><br><span class="line">            //字符串里面还有空格</span><br><span class="line">            if(s[i] == &apos;-&apos; || s[i] == &apos;+&apos;)&#123;</span><br><span class="line">                //正负号（数字、小数点）会在e出现后初始化，没有出现就不会；还有前面不能有数字（以e分两段）</span><br><span class="line">                //也不能有小数点，那么这里的小数点就要在e之后初始化了</span><br><span class="line">                if(signSeen || numSeen || dotSeen) return false;</span><br><span class="line">                signSeen = true;</span><br><span class="line">            &#125;else if(isdigit(s[i]))&#123;</span><br><span class="line">                //这里数字应该没有什么情况会返回false</span><br><span class="line">                numSeen = true;</span><br><span class="line">            &#125;else if(s[i] == &apos;.&apos;)&#123;</span><br><span class="line">                //小数点只能出现在e前边，e之后会初始化，所以也不能出现e；还有小数点左右两边至少要有一个数字！！</span><br><span class="line">                //或者小数点在e出现不初始化eSeen必须得加上</span><br><span class="line">                if(dotSeen || eSeen) return false;</span><br><span class="line">                dotSeen = true;</span><br><span class="line">            &#125;else if(s[i] == &apos;e&apos; || s[i] == &apos;E&apos;)&#123;</span><br><span class="line">                //若前面没有数字、已经出现e</span><br><span class="line">                if(!numSeen || eSeen) return false;</span><br><span class="line">                eSeen = true;</span><br><span class="line">                signSeen = false;</span><br><span class="line">                numSeen = false;</span><br><span class="line">                dotSeen = false;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                //空格或者其他字符</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        //最后要看是否出现数字</span><br><span class="line">        return numSeen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>有限状态自动机——题解<ul>
<li>自动机的消耗更长一点儿</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	//enum是枚举类型！</span><br><span class="line">    enum State &#123;</span><br><span class="line">        STATE_INITIAL, 		//初始状态</span><br><span class="line">        STATE_INT_SIGN, 	//符号</span><br><span class="line">        STATE_INTEGER, 		//整数</span><br><span class="line">        STATE_POINT,</span><br><span class="line">        STATE_POINT_WITHOUT_INT,</span><br><span class="line">        STATE_FRACTION,</span><br><span class="line">        STATE_EXP,</span><br><span class="line">        STATE_EXP_SIGN,</span><br><span class="line">        STATE_EXP_NUMBER,</span><br><span class="line">        STATE_END</span><br><span class="line">    &#125;;</span><br><span class="line">	//这里也声明了枚举类型，这里对应的是内容</span><br><span class="line">    enum CharType &#123;</span><br><span class="line">        CHAR_NUMBER,</span><br><span class="line">        CHAR_EXP,</span><br><span class="line">        CHAR_POINT,</span><br><span class="line">        CHAR_SIGN,</span><br><span class="line">        CHAR_SPACE,</span><br><span class="line">        CHAR_ILLEGAL</span><br><span class="line">    &#125;;</span><br><span class="line">	//这里定义了一个对象？——自定义类型，只能赋值已经声明的，而不能赋值其余类型，返回类型是CharType，也就是自定义类型</span><br><span class="line">    CharType toCharType(char ch) &#123;</span><br><span class="line">        if (ch &gt;= &apos;0&apos; &amp;&amp; ch &lt;= &apos;9&apos;) &#123;</span><br><span class="line">            return CHAR_NUMBER;</span><br><span class="line">        &#125; else if (ch == &apos;e&apos; || ch == &apos;E&apos;) &#123;</span><br><span class="line">            return CHAR_EXP;</span><br><span class="line">        &#125; else if (ch == &apos;.&apos;) &#123;</span><br><span class="line">            return CHAR_POINT;</span><br><span class="line">        &#125; else if (ch == &apos;+&apos; || ch == &apos;-&apos;) &#123;</span><br><span class="line">            return CHAR_SIGN;</span><br><span class="line">        &#125; else if (ch == &apos; &apos;) &#123;</span><br><span class="line">            return CHAR_SPACE;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return CHAR_ILLEGAL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool isNumber(string s) &#123;</span><br><span class="line">		//这里用了双层unordered_map，有点像图，或者把所有的状态都罗列了出来，每一个状态的下一个状态是什么</span><br><span class="line">        unordered_map&lt;State, unordered_map&lt;CharType, State&gt;&gt; transfer&#123;</span><br><span class="line">            &#123;</span><br><span class="line">				//例如初始状态——可能有空格、数字、小数点、正负号</span><br><span class="line">                STATE_INITIAL, &#123;</span><br><span class="line">                    &#123;CHAR_SPACE, STATE_INITIAL&#125;,</span><br><span class="line">                    &#123;CHAR_NUMBER, STATE_INTEGER&#125;,</span><br><span class="line">                    &#123;CHAR_POINT, STATE_POINT_WITHOUT_INT&#125;,</span><br><span class="line">                    &#123;CHAR_SIGN, STATE_INT_SIGN&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                STATE_INT_SIGN, &#123;</span><br><span class="line">                    &#123;CHAR_NUMBER, STATE_INTEGER&#125;,</span><br><span class="line">                    &#123;CHAR_POINT, STATE_POINT_WITHOUT_INT&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                STATE_INTEGER, &#123;</span><br><span class="line">                    &#123;CHAR_NUMBER, STATE_INTEGER&#125;,</span><br><span class="line">                    &#123;CHAR_EXP, STATE_EXP&#125;,</span><br><span class="line">                    &#123;CHAR_POINT, STATE_POINT&#125;,</span><br><span class="line">                    &#123;CHAR_SPACE, STATE_END&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                STATE_POINT, &#123;</span><br><span class="line">                    &#123;CHAR_NUMBER, STATE_FRACTION&#125;,</span><br><span class="line">                    &#123;CHAR_EXP, STATE_EXP&#125;,</span><br><span class="line">                    &#123;CHAR_SPACE, STATE_END&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                STATE_POINT_WITHOUT_INT, &#123;</span><br><span class="line">                    &#123;CHAR_NUMBER, STATE_FRACTION&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                STATE_FRACTION,</span><br><span class="line">                &#123;</span><br><span class="line">                    &#123;CHAR_NUMBER, STATE_FRACTION&#125;,</span><br><span class="line">                    &#123;CHAR_EXP, STATE_EXP&#125;,</span><br><span class="line">                    &#123;CHAR_SPACE, STATE_END&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                STATE_EXP,</span><br><span class="line">                &#123;</span><br><span class="line">                    &#123;CHAR_NUMBER, STATE_EXP_NUMBER&#125;,</span><br><span class="line">                    &#123;CHAR_SIGN, STATE_EXP_SIGN&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                STATE_EXP_SIGN, &#123;</span><br><span class="line">                    &#123;CHAR_NUMBER, STATE_EXP_NUMBER&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                STATE_EXP_NUMBER, &#123;</span><br><span class="line">                    &#123;CHAR_NUMBER, STATE_EXP_NUMBER&#125;,</span><br><span class="line">                    &#123;CHAR_SPACE, STATE_END&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                STATE_END, &#123;</span><br><span class="line">                    &#123;CHAR_SPACE, STATE_END&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        int len = s.length();</span><br><span class="line">        State st = STATE_INITIAL;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">			//这里返回字符对应的名字——自定义的类型</span><br><span class="line">            CharType typ = toCharType(s[i]);</span><br><span class="line">			//st是初始状态，之后不停的迭代，总有一种情况是对应的，若没有就直接返回false;</span><br><span class="line">            if (transfer[st].find(typ) == transfer[st].end()) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                st = transfer[st][typ];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		//最后返回看是不是几种状态的一种</span><br><span class="line">        return st == STATE_INTEGER || st == STATE_POINT || st == STATE_FRACTION || st == STATE_EXP_NUMBER || st == STATE_END;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>感觉书上写的很精简<ul>
<li>就是有两个函数不太容易搞懂</li>
<li>指针的指针，在函数内对指针进行解引用可以对主函数的指针进行移动操作<ul>
<li>嗯，也可以直接用<code>while</code></li>
</ul>
</li>
<li>先判断正负号，在来判断若干数字（函数调用函数，一个是整数，一个是无符号整数），返回布尔值<code>numeric</code></li>
<li>返回之后，判断小数点，若是则继续判断数字，更新<code>numeric</code></li>
<li>之后判断<code>&#39;e&#39;、&#39;E&#39;</code>，再次更新<code>numeric</code></li>
<li>最后判断是不是末尾，以及<code>numeric</code>是否为真</li>
<li>感觉书上的思路跟第一种有点像！！！</li>
</ul>
</li>
</ul>
<h2 id="21-调整数组顺序使奇数位于偶数前面"><a href="#21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="21_调整数组顺序使奇数位于偶数前面"></a>21_调整数组顺序使奇数位于偶数前面</h2><ul>
<li>双指针是不是更快一点儿——第一个指针指向偶数，第二个指针指向奇数，就交换；为什么这是初级解法？<ul>
<li>我用的类似于冒泡算法，确切的说应该是快慢指针！</li>
<li>书上用了函数指针<ul>
<li>函数指针就是个名字，在主函数参数填入函数名，才是要调用的函数！</li>
<li>这样写具有鲁棒性</li>
<li>因为只需修改，函数指针指向的函数规则即可，而无需修改主函数，或者添加额外的函数，更容易重用</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; exchange(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        //我看看能不能一行代码解决，谓词好像要两个参数！</span><br><span class="line">        if(nums.empty()) return vector&lt;int&gt;();</span><br><span class="line">        //老老实实写交换</span><br><span class="line">        int pos = -1;</span><br><span class="line">        for(int i = 0; i &lt; nums.size(); ++i)&#123;</span><br><span class="line">            //这里写反了</span><br><span class="line">            if(nums[i] % 2 == 1)&#123;</span><br><span class="line">                //奇数，开始交换</span><br><span class="line">                ++pos;</span><br><span class="line">                //若不相等则交换</span><br><span class="line">                if(i &gt; pos)&#123;</span><br><span class="line">                    swap(nums[pos], nums[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="22-链表中倒数第k个节点"><a href="#22-链表中倒数第k个节点" class="headerlink" title="22_链表中倒数第k个节点"></a>22_链表中倒数第k个节点</h2><ul>
<li>这个返回的是节点而不是节点的数字，所以就不能在原链表进行修改了<ul>
<li>没想到什么好的方法，用数组保存了下！然后考虑边界，最后返回对应的下标</li>
<li>快慢指针！！！又把这个方法忘了！</li>
<li>最近几题主要讲的是鲁棒性<ul>
<li>输入为空、k大于链表长度、k为0（若是无符号整数，减一就变成了0xFFFFFFFF）</li>
<li>这样得先<code>for</code>循环后<code>while</code>方便点</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//快慢指针</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* getKthFromEnd(ListNode* head, int k) &#123;</span><br><span class="line">        if(!head || k == 0) return nullptr;</span><br><span class="line">        auto pre = head, cur = pre;</span><br><span class="line">        int t = 0;</span><br><span class="line">        while(cur != nullptr)&#123;</span><br><span class="line">            //这里是等于，因为初始值为0</span><br><span class="line">            if(t &gt;= k) pre = pre-&gt;next;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            ++t; </span><br><span class="line">        &#125;</span><br><span class="line">        return pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="23-链表中环的入口节点"><a href="#23-链表中环的入口节点" class="headerlink" title="23_链表中环的入口节点"></a>23_链表中环的入口节点</h2><ul>
<li><p>这题力扣上也没有！！</p>
<ul>
<li>那就总结下书上的思路，之前也做过这道题</li>
<li>在慢指针追上快指针的时候，慢指针要从头开始，之后两指针一次走一步理由如下<ul>
<li>如果环中有n个节点，那么快慢指针都从头开始，然后快指针先走n步，之后两个指针虚度相同地向前移动</li>
<li>这样好理解点</li>
</ul>
</li>
</ul>
</li>
<li><p>代码就不放了！</p>
</li>
</ul>
<h2 id="24-反转链表"><a href="#24-反转链表" class="headerlink" title="24_反转链表"></a>24_反转链表</h2><ul>
<li>在做一题吧<ul>
<li>再试下迭代，可以一次成功</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">        if(!head || !head-&gt;next) return head;</span><br><span class="line"></span><br><span class="line">        ListNode* pre = nullptr;</span><br><span class="line">        while(head != nullptr)&#123;</span><br><span class="line">            //先保存下一个节点</span><br><span class="line">            auto tmp = head-&gt;next;</span><br><span class="line">            head-&gt;next = pre;</span><br><span class="line">            pre = head;</span><br><span class="line">            head = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        return pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>我居然忘了递归也可以！！</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//递归</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">        if(!head || !head-&gt;next) return head;</span><br><span class="line">        //递归就是先假设后面的部分已经反转好，这样有利于理解</span><br><span class="line">        ListNode* nHead = reverseList(head-&gt;next);</span><br><span class="line">        auto tmp = head-&gt;next;</span><br><span class="line">        head-&gt;next = nullptr;</span><br><span class="line">        tmp-&gt;next = head;</span><br><span class="line">        return nHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="25-合并两个排序的链表"><a href="#25-合并两个排序的链表" class="headerlink" title="25_合并两个排序的链表"></a>25_合并两个排序的链表</h2><ul>
<li>21题相同</li>
<li>这应该类似于归并排序<ul>
<li>就看是直接在原链表修改还是生成一个新的链表</li>
<li>直接在原链表修改，好不容易写完了，通过！！<ul>
<li>这里如果不注意，会报错——没判断是不是空指针，就写出其<code>val</code></li>
</ul>
</li>
<li>看看题解和书，能不能优化下</li>
<li>等等，是不是可以用递归啊，试一下，书上用的就是递归！！<ul>
<li>递归是真的厉害！第一次的第二种原来是迭代，无论是循环还是条件判断都比我写的好多了</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//手撕，原链表修改</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;</span><br><span class="line">        //注意这里链表长度可能为空</span><br><span class="line">        if(!l1) return l2;</span><br><span class="line">        if(!l2) return l1;</span><br><span class="line">        //至此两者都不为空，&lt;=</span><br><span class="line">        auto head = l1-&gt;val &lt;= l2-&gt;val ? l1 : l2;</span><br><span class="line">        while(l1 != nullptr || l2 != nullptr)&#123;</span><br><span class="line">            if(l1 != nullptr &amp;&amp; l2 != nullptr)&#123;</span><br><span class="line">                ListNode* pre = nullptr;</span><br><span class="line">                //&lt;=保持一致</span><br><span class="line">                while(l1 != nullptr &amp;&amp; l1-&gt;val &lt;= l2-&gt;val)&#123;</span><br><span class="line">                    pre = l1;</span><br><span class="line">                    l1 = l1-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                //这里出来l1有可能为空或者l1的值大于l2的值</span><br><span class="line">                if(pre != nullptr)&#123;</span><br><span class="line">                    pre-&gt;next = l2;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if(l1 != nullptr)&#123;</span><br><span class="line">                    pre = nullptr;</span><br><span class="line">                    while(l2 != nullptr &amp;&amp; l2-&gt;val &lt; l1-&gt;val)&#123;</span><br><span class="line">                        pre = l2;</span><br><span class="line">                        l2 = l2-&gt;next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //这里出来有可能为空或者l2的值大于等于l1的值，这里要互补</span><br><span class="line">                    if(pre != nullptr) pre-&gt;next = l1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                //这里两个中必有一个为空——可以直接break？</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//递归</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;</span><br><span class="line">        //注意这里链表长度可能为空</span><br><span class="line">        if(!l1) return l2;</span><br><span class="line">        if(!l2) return l1;</span><br><span class="line">        //至此两者都不为空</span><br><span class="line">        ListNode* head = nullptr;</span><br><span class="line">        if(l1-&gt;val &lt; l2-&gt;val)&#123;</span><br><span class="line">            head = l1;</span><br><span class="line">            head-&gt;next = mergeTwoLists(l1-&gt;next, l2);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            head = l2;</span><br><span class="line">            head-&gt;next = mergeTwoLists(l1, l2-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="26-树的子结构"><a href="#26-树的子结构" class="headerlink" title="26_树的子结构"></a>26_树的子结构</h2><ul>
<li>都按前序遍历，化成字符串，最后再看看是不是子字符串，应该没问题，就是最后一个样例没有通过，不知道为啥<ul>
<li>后来试了一次BFS成功了！！最后一个例子也成功了，贴下代码</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//BFS</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isSub(TreeNode* node, TreeNode* B)&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; qa, qb;</span><br><span class="line">        qa.push(node);</span><br><span class="line">        qb.push(B);</span><br><span class="line">        while(!qb.empty() &amp;&amp; !qa.empty())&#123;</span><br><span class="line">            //若qa为空了，qb不为空，那不是子结构</span><br><span class="line">            int n = qb.size();</span><br><span class="line">            int na = qa.size();</span><br><span class="line">            if(n &gt; na) return false;</span><br><span class="line">            while(n &gt; 0)&#123;</span><br><span class="line">                auto b = qb.front();</span><br><span class="line">                qb.pop();</span><br><span class="line">                auto a = qa.front();</span><br><span class="line">                qa.pop();</span><br><span class="line">                if(a-&gt;val != b-&gt;val) return false;</span><br><span class="line">                if(a-&gt;left != nullptr) qa.push(a-&gt;left);</span><br><span class="line">                if(a-&gt;right != nullptr) qa.push(a-&gt;right);</span><br><span class="line">                if(b-&gt;left != nullptr) qb.push(b-&gt;left);</span><br><span class="line">                if(b-&gt;right != nullptr) qb.push(b-&gt;right);</span><br><span class="line">                --n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return qb.empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool isSubStructure(TreeNode* A, TreeNode* B) &#123;</span><br><span class="line">        //先找到相同的根节点，然后再判断是否是子节点</span><br><span class="line">        //用递归还是BFS？用递归感觉有点绕，先用队列吧</span><br><span class="line">        if(!B || !A) return false;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(A);</span><br><span class="line">        bool ans = false;</span><br><span class="line">        while(!q.empty() &amp;&amp; !ans)&#123;</span><br><span class="line">            int n = q.size();</span><br><span class="line">            while(n &gt; 0)&#123;</span><br><span class="line">                auto node = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                if(node-&gt;val == B-&gt;val)&#123;</span><br><span class="line">                    ans = isSub(node, B);</span><br><span class="line">                &#125;</span><br><span class="line">                if(ans) break;</span><br><span class="line">                if(node-&gt;left != nullptr) q.push(node-&gt;left);</span><br><span class="line">                if(node-&gt;right != nullptr) q.push(node-&gt;right);</span><br><span class="line">                --n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>递归有个地方没弄懂，看到大佬的题解懂了<ul>
<li>递归函数是有返回值的（布尔类型）</li>
<li>若是B为空，是返回真还是假，我一直一位得把B都递归到最右边的节点才为真，其实不是，只要为空，就说明之前的已经匹配完成</li>
<li>还是递归更容易看懂</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/Offer/26.png" alt title="recur函数"></p>
<p><img src="/pictrues/Offer/26-1.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//递归</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isSubStructure(TreeNode* A, TreeNode* B) &#123;</span><br><span class="line">        if(!A || !B) return false;</span><br><span class="line">        return (recur(A, B) || isSubStructure(A-&gt;left, B) || isSubStructure(A-&gt;right, B));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool recur(TreeNode* A, TreeNode* B) &#123;</span><br><span class="line">        if(B == nullptr) return true;</span><br><span class="line">        if(A == nullptr || A-&gt;val != B-&gt;val) return false;</span><br><span class="line">        //这里是与运算，因为只要一个错误，就为假</span><br><span class="line">        return recur(A-&gt;left, B-&gt;left) &amp;&amp; recur(A-&gt;right, B-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>书上也是两个递归函数！</li>
</ul>
<h2 id="27-二叉树的镜像"><a href="#27-二叉树的镜像" class="headerlink" title="27_二叉树的镜像"></a>27_二叉树的镜像</h2><ul>
<li>输出镜像<ul>
<li>BFS走起——还是dfs，但是报错了<code>heap-use-after-free on address</code><ul>
<li>这个报错一般是数组指针，<code>delete</code>之后，就不能通过下标来读取了</li>
</ul>
</li>
<li>要先保存！！！！</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* mirrorTree(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return nullptr;</span><br><span class="line">        //似乎不需要创建一个新的二叉树！用递归修改指针试试</span><br><span class="line">        //原来如此！！怪不得会报错！要先保存左子树</span><br><span class="line">        TreeNode* tmp = root-&gt;left;</span><br><span class="line">        root-&gt;left = mirrorTree(root-&gt;right);</span><br><span class="line">        root-&gt;right = mirrorTree(tmp);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="28-对称的二叉树"><a href="#28-对称的二叉树" class="headerlink" title="28_对称的二叉树"></a>28_对称的二叉树</h2><ul>
<li>101题相同<ul>
<li>这次和101都用了递归，既然递归可以，那么BFS应该也可以，不过不太好写，应该把一层的节点的数值都放入字符串了，然后判断回文数？</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//dfs</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isSymmetric(TreeNode* node1, TreeNode* node2)&#123;</span><br><span class="line">        if(!node1 &amp;&amp; !node2)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;else if(!node1 || !node2 || node1-&gt;val != node2-&gt;val)&#123;</span><br><span class="line">            //若一个为空，另一个不为空；或者数值不等</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        //最终结果应该是与</span><br><span class="line">        return isSymmetric(node1-&gt;left, node2-&gt;right) &amp;&amp; isSymmetric(node1-&gt;right, node2-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool isSymmetric(TreeNode* root) &#123;</span><br><span class="line">        //试试递归</span><br><span class="line">        if(!root) return true;</span><br><span class="line"></span><br><span class="line">        //再看左右子树是否是镜像的</span><br><span class="line">        return isSymmetric(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>学习下迭代<ul>
<li>不必判断回文数，而是入队两次？</li>
<li>根节点入队两次！然后每次提取两个节点！<code>node1</code>、<code>node2</code>，若这两个节点值相等，那么就把<code>node1-&gt;left</code>、<code>node2-&gt;right</code>放入队尾，厉害厉害</li>
<li>手撕下<ul>
<li>一直在报错！</li>
<li>思考了半天，终于知道为什么了！！！！因为每次取出两个节点！所以长度<code>n</code>要减去2，而不是减1</li>
</ul>
</li>
<li>题解写的比我好，没有用到队列的长度！我也再优化下</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//bfs，手撕</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isSymmetric(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return true;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        q.push(root);</span><br><span class="line">        </span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            int n = q.size();</span><br><span class="line">            while(n &gt; 0)&#123;</span><br><span class="line">                //每次取出两个节点</span><br><span class="line">                TreeNode* node1 = q.front(); q.pop();</span><br><span class="line"></span><br><span class="line">                //if(q.empty()) return false;  //如果确保下面每次都是两个两个放，那这里可以不要</span><br><span class="line">                TreeNode* node2 = q.front(); q.pop();</span><br><span class="line"></span><br><span class="line">                if(node1-&gt;val != node2-&gt;val)&#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                //这里不用判断两边是否都为空等等，下次迭代自然会不等</span><br><span class="line">                if(node1-&gt;left != nullptr &amp;&amp; node2-&gt;right != nullptr)&#123;</span><br><span class="line">                    q.push(node1-&gt;left);</span><br><span class="line">                    q.push(node2-&gt;right);</span><br><span class="line">                &#125;else if(!node1-&gt;left &amp;&amp; !node2-&gt;right)&#123;</span><br><span class="line">                    ;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if(node1-&gt;right != nullptr &amp;&amp; node2-&gt;left != nullptr)&#123;</span><br><span class="line">                    q.push(node1-&gt;right);</span><br><span class="line">                    q.push(node2-&gt;left);</span><br><span class="line">                &#125;else if(!node1-&gt;right &amp;&amp; !node2-&gt;left)&#123;</span><br><span class="line">                    ;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                n -= 2;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//优化</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isSymmetric(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return true;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        q.push(root);</span><br><span class="line">        </span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            TreeNode* n1 = q.front(); q.pop();</span><br><span class="line">            //这里题解是把空指针也放入了队列，所以下面要判断下</span><br><span class="line">            TreeNode* n2 = q.front(); q.pop();</span><br><span class="line">            //为了简便，这里还加了个两者都为空</span><br><span class="line">            if(!n1 &amp;&amp; !n2) continue;</span><br><span class="line"></span><br><span class="line">            if(!n1 || !n2 || n1-&gt;val != n2-&gt;val)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            q.push(n1-&gt;left);</span><br><span class="line">            q.push(n2-&gt;right);</span><br><span class="line"></span><br><span class="line">            q.push(n1-&gt;right);</span><br><span class="line">            q.push(n2-&gt;left);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>书上也是用的递归，看到前面我还以为是序列化二叉树呢！！！</li>
</ul>
<h2 id="29-顺时针打印矩阵"><a href="#29-顺时针打印矩阵" class="headerlink" title="29_顺时针打印矩阵"></a>29_顺时针打印矩阵</h2><ul>
<li>这次写的比第一次要好很多<ul>
<li>乍看以为是递归，其实两个循环或者一个循环就够了</li>
<li>我是将数字的总个数不等于0为<code>while</code>条件，每次放入一个数，就减一；而题解是对总数字进行<code>for</code>循环，好处是不用再套一个循环！</li>
<li>同样都需要另一个数组来进行标记</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//手撕</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void print(vector&lt;vector&lt;int&gt;&gt;&amp; tmp, vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int&amp; total, int row, int col)&#123;</span><br><span class="line">        //终止条件</span><br><span class="line">        int i = 0, j = 0;</span><br><span class="line">        //方便循环，这里先放(0,0)</span><br><span class="line">        ans.emplace_back(matrix[i][j]);</span><br><span class="line">        //这里不要忘了标记</span><br><span class="line">        tmp[0][0] = 1;</span><br><span class="line">        --total;</span><br><span class="line"></span><br><span class="line">        while(total &gt; 0)&#123;</span><br><span class="line">            //遍历四个方向</span><br><span class="line">            //cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; &quot; j = &quot; &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">            for(auto&amp; dir : direction)&#123;</span><br><span class="line">                //这里是某个方向的第一格，因为新的循环，本身所在的数字已经放过了</span><br><span class="line">                int x = i + dir[0], y = j + dir[1];</span><br><span class="line">                //首先是向右，若没有路，那就向下，依次往后推，这里不仅要小于边界，还要大于等于0</span><br><span class="line">                if(x &lt; 0 || x == row || y &lt; 0 || y == col || tmp[x][y] == 1) continue;</span><br><span class="line"></span><br><span class="line">                while(x &gt;= 0 &amp;&amp; x &lt; row &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; col &amp;&amp; tmp[x][y] != 1)&#123;</span><br><span class="line">                    ans.emplace_back(matrix[x][y]);</span><br><span class="line">                    --total;</span><br><span class="line">                    tmp[x][y] = 1;</span><br><span class="line">                    x += dir[0];</span><br><span class="line">                    y += dir[1];</span><br><span class="line">                &#125;</span><br><span class="line">                //这里x，y不符合条件了，要回退上一个状态</span><br><span class="line">                i = x - dir[0];</span><br><span class="line">                j = y - dir[1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        //右、下、左、上这四个顺序——一直到无路可走，或者要打印的字符都打完了</span><br><span class="line">        if(matrix.empty() || matrix[0].empty()) return vector&lt;int&gt;();</span><br><span class="line"></span><br><span class="line">        int row = matrix.size(), col = matrix[0].size();</span><br><span class="line">        int total = row * col;</span><br><span class="line">        //用来标记已经打印的数字</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; tmp(row, vector&lt;int&gt;(col, 0));</span><br><span class="line">        //怎样用递归写的好看点</span><br><span class="line">        print(tmp, matrix, total, row, col);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; direction = &#123;&#123;0,1&#125;, &#123;1,0&#125;, &#123;0,-1&#125;, &#123;-1,0&#125;&#125;;</span><br><span class="line">    vector&lt;int&gt; ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>看看书上有没有什么好的思路<ul>
<li>书上是用了左上角的坐标，因为是一圈一圈的打印，所以横纵坐标相等，只要满足列数、行数都大于两倍的它，就还有剩余没有打印的数字</li>
<li>之后的函数，是根据起点的坐标，来完成打印一圈的功能</li>
<li>这个方法不太喜欢，还是喜欢四个方向整合在一起比较方便</li>
</ul>
</li>
</ul>
<h2 id="30-包含min函数的栈"><a href="#30-包含min函数的栈" class="headerlink" title="30_包含min函数的栈"></a>30_包含min函数的栈</h2><ul>
<li>155题<ul>
<li>让我想想当时的思路是什么来着——当时用了优先级队列嘛？<ul>
<li>先试试，注意默认是降序的——和一般的队列操作相同，升序队列是<code>priority_queue &lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q;</code></li>
</ul>
</li>
<li>不太好弄，因为栈的<code>push</code>、<code>pop</code>也保留了，因此顺序不应该变，试试<code>multiset</code></li>
<li><code>multiset</code>在删除的时候会将所有相同值都删除，应该只删除一个，加上补丁，居然过了…</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//手撕版本</span><br><span class="line">class MinStack &#123;</span><br><span class="line">public:</span><br><span class="line">    /** initialize your data structure here. */</span><br><span class="line">    MinStack() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    void push(int x) &#123;</span><br><span class="line">        stk.push(x);</span><br><span class="line">        set.insert(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void pop() &#123;</span><br><span class="line">        auto tmp = stk.top();</span><br><span class="line">        stk.pop();</span><br><span class="line">        //看看能不能加个补丁</span><br><span class="line">        auto count = set.count(tmp);</span><br><span class="line">        set.erase(tmp);</span><br><span class="line">        while(count &gt; 1)&#123;</span><br><span class="line">            set.insert(tmp);</span><br><span class="line">            --count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int top() &#123;</span><br><span class="line">        return stk.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int min() &#123;</span><br><span class="line">        return *set.begin();</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    //第二个参数默认是vector...第三个是less</span><br><span class="line">    //priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;</span><br><span class="line">    stack&lt;int&gt; stk;</span><br><span class="line">    multiset&lt;int&gt; set;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>还是题解写的好，每个元素与最小元素一一对应<ul>
<li>手写一遍，加深印象</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//手撕题解</span><br><span class="line">class MinStack &#123;</span><br><span class="line">public:</span><br><span class="line">    MinStack() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    void push(int x) &#123;</span><br><span class="line">        stk.push(x);</span><br><span class="line">        //如果放入的数字比最小值大，那栈顶元素还是最小值，等于也可以，只有当x小于最小值，才放入x</span><br><span class="line">        //这里一开始为空</span><br><span class="line">        if(!min_stk.empty() &amp;&amp; x &gt;= min_stk.top())&#123;</span><br><span class="line">            min_stk.push(min_stk.top());</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            min_stk.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void pop() &#123;</span><br><span class="line">        stk.pop();</span><br><span class="line">        min_stk.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int top() &#123;</span><br><span class="line">        return stk.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int min() &#123;</span><br><span class="line">        return min_stk.top();</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    stack&lt;int&gt; stk;</span><br><span class="line">    stack&lt;int&gt; min_stk;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="31-栈的压入、弹出序列"><a href="#31-栈的压入、弹出序列" class="headerlink" title="31_栈的压入、弹出序列"></a>31_栈的压入、弹出序列</h2><ul>
<li>946题…<ul>
<li>用栈来直接模拟流程，一次通过</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool validateStackSequences(vector&lt;int&gt;&amp; pushed, vector&lt;int&gt;&amp; popped) &#123;</span><br><span class="line">        //试试递归</span><br><span class="line">        //分析下，第一个弹出的数字是4，那么pushed里4前面的数字都要先入栈；那么pushed只剩5了，，，，</span><br><span class="line">        //可以直接用栈来模拟这个流程</span><br><span class="line">        if(pushed.empty() &amp;&amp; popped.empty()) return true;</span><br><span class="line">        if(pushed.size() != popped.size()) return false;</span><br><span class="line">        </span><br><span class="line">        int pos = 0, n = pushed.size();</span><br><span class="line">        stack&lt;int&gt; stk;</span><br><span class="line">        for(auto num : popped)&#123;</span><br><span class="line">            if(stk.empty() || num != stk.top())&#123;</span><br><span class="line">                //将num之前的数字都入栈，再来个指针指向起点，只不过有个条件，必须是后面的数字</span><br><span class="line">                while(pos &lt; n)&#123;</span><br><span class="line">                    if(pushed[pos] == num)&#123;</span><br><span class="line">                        ++pos;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    stk.push(pushed[pos]);</span><br><span class="line">                    ++pos;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                //这里与栈顶元素相等</span><br><span class="line">                stk.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return stk.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>看了题解，emmmm，还可以再优化下代码<ul>
<li>遍历一个<code>pushed</code>，就入栈一个数，再看看是否与<code>popped</code>相等</li>
<li>说是优化，代码简练点，执行用时低了几毫秒</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//优化</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool validateStackSequences(vector&lt;int&gt;&amp; pushed, vector&lt;int&gt;&amp; popped) &#123;</span><br><span class="line">        if(pushed.empty() &amp;&amp; popped.empty()) return true;</span><br><span class="line">        if(pushed.size() != popped.size()) return false;</span><br><span class="line">        </span><br><span class="line">        int pos = 0, n = pushed.size();</span><br><span class="line">        stack&lt;int&gt; stk;</span><br><span class="line">        for(auto num : pushed)&#123;</span><br><span class="line">            stk.push(num);</span><br><span class="line">            while(!stk.empty() &amp;&amp; pos &lt; n &amp;&amp; stk.top() == popped[pos])&#123;</span><br><span class="line">                stk.pop();</span><br><span class="line">                ++pos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return stk.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="32-1-从上到下打印二叉树"><a href="#32-1-从上到下打印二叉树" class="headerlink" title="32-1_从上到下打印二叉树"></a>32-1_从上到下打印二叉树</h2><ul>
<li>层次遍历，但是空节点也要输出<ul>
<li>若只是简单的BFS，那么遇到空节点就自动忽略了…</li>
<li>等等，审题审错了，就是BFS吧？<ul>
<li>可以，一次过  </li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//BFS</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return vector&lt;int&gt;();</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        vector&lt;int&gt; ans;</span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            int n = q.size();</span><br><span class="line">            while(n &gt; 0)&#123;</span><br><span class="line">                auto tmp = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                ans.emplace_back(tmp-&gt;val);</span><br><span class="line">                if(tmp-&gt;left != nullptr) q.push(tmp-&gt;left);</span><br><span class="line">                if(tmp-&gt;right != nullptr) q.push(tmp-&gt;right);</span><br><span class="line">                --n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>其实可以不用<code>n</code>，每次<code>pop()</code>一个节点就行，没有影响</li>
</ul>
<h2 id="32-2-从上到下打印二叉树"><a href="#32-2-从上到下打印二叉树" class="headerlink" title="32-2_从上到下打印二叉树"></a>32-2_从上到下打印二叉树</h2><ul>
<li>102题</li>
<li>这里是一层一层的打印，就需要用到<code>n</code>了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//BFS</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return vector&lt;vector&lt;int&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line"></span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            vector&lt;int&gt; tmp;</span><br><span class="line">            int n = q.size();</span><br><span class="line">            while(n &gt; 0)&#123;</span><br><span class="line">                auto node = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                tmp.emplace_back(node-&gt;val);</span><br><span class="line">                if(node-&gt;left != nullptr) q.push(node-&gt;left);</span><br><span class="line">                if(node-&gt;right != nullptr) q.push(node-&gt;right);</span><br><span class="line">                --n;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.emplace_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="32-3-从上到下打印二叉树"><a href="#32-3-从上到下打印二叉树" class="headerlink" title="32-3_从上到下打印二叉树"></a>32-3_从上到下打印二叉树</h2><ul>
<li>这题应该做过，但是下面提示没有显示<ul>
<li>应该加一个变量，用来判断奇偶层</li>
<li>这里出错了！</li>
<li>判断奇偶层没有用，因为下一层的起始节点，是上一层队列里的最后一个节点，这时才应该考虑先放左还是右</li>
<li>既然要考虑头尾，应该使用双向适配器<ul>
<li>也可以简单的将某一层的数组反转，再添加到结果的二维数组里</li>
</ul>
</li>
<li>每一层都是从最后开始的，可以不用双向链表，用栈，哈哈哈，说笑了说笑了！</li>
<li>还是得翻转，因为放置的节点，与数组的元素是交替相反的</li>
<li>总算过了</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//BFS+翻转数组</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return vector&lt;vector&lt;int&gt;&gt;();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">        int lines = 0;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line"></span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            vector&lt;int&gt; tmp;</span><br><span class="line">            int n = q.size();</span><br><span class="line">            while(n &gt; 0)&#123;</span><br><span class="line">                auto node = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                tmp.emplace_back(node-&gt;val);</span><br><span class="line">                if(node-&gt;left != nullptr) q.push(node-&gt;left);</span><br><span class="line">                if(node-&gt;right != nullptr) q.push(node-&gt;right);</span><br><span class="line">                --n;</span><br><span class="line">            &#125;</span><br><span class="line">            ++lines;</span><br><span class="line">            if(lines % 2 == 0) reverse(tmp.begin(), tmp.end());</span><br><span class="line">            ans.emplace_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>书上用的是两个栈！先进后出，然后分先左后右还是先右后左入栈</li>
<li>评论里用的是Java，返回类型是一个双向链表，这样就要么放到最后，要么放到前面，不用翻转那么麻烦</li>
<li>手撕下双栈！<ul>
<li>咳咳，明天吧！今天就写好</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//双栈</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return vector&lt;vector&lt;int&gt;&gt;();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk1, stk2;</span><br><span class="line">        stk1.push(root);</span><br><span class="line">        while(!stk1.empty() || !stk2.empty())&#123;</span><br><span class="line">            //两个栈有一个不为空，需要根据层数来确定先放左子树还是右子树</span><br><span class="line">            vector&lt;int&gt; tmp;</span><br><span class="line">            if(!stk1.empty())&#123;</span><br><span class="line">                while(!stk1.empty())&#123;</span><br><span class="line">                    auto node = stk1.top();</span><br><span class="line">                    stk1.pop();</span><br><span class="line">                    tmp.emplace_back(node-&gt;val);</span><br><span class="line">                    //好像不需要记录层数，是不是stk1的节点都是奇数层的？</span><br><span class="line">                    //先放左节点</span><br><span class="line">                    if(node-&gt;left != nullptr) stk2.push(node-&gt;left);</span><br><span class="line">                    if(node-&gt;right != nullptr) stk2.push(node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                while(!stk2.empty())&#123;</span><br><span class="line">                    auto node = stk2.top();</span><br><span class="line">                    stk2.pop();</span><br><span class="line">                    tmp.emplace_back(node-&gt;val);</span><br><span class="line">                    //好像不需要记录层数，是不是stk1的节点都是奇数层的？</span><br><span class="line">                    //先放右节点</span><br><span class="line">                    if(node-&gt;right != nullptr) stk1.push(node-&gt;right);</span><br><span class="line">                    if(node-&gt;left != nullptr) stk1.push(node-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.emplace_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="33-二叉搜索树的后序遍历序列"><a href="#33-二叉搜索树的后序遍历序列" class="headerlink" title="33_二叉搜索树的后序遍历序列"></a>33_二叉搜索树的后序遍历序列</h2><ul>
<li><p>那这题也写下吧</p>
<ul>
<li>复习下，递归和迭代！！</li>
<li>又没有仔细审题…这题似乎是反着来的</li>
<li>二叉搜索树的性质<ul>
<li>左子节点小于根节点小于右子节点</li>
<li>放在数组里的话，若没有空节点，那么刚开始的三个数字，第一个是左节点最小，第二个是右节点最大，第三个是根节点大小在中间，之后这三个为一组，取最大值，与后面的两个数字又组成一个完整的二叉树</li>
<li>问题是，考虑了空节点，那么可能性就比较多</li>
<li>就拿三个完整的节点（最小二叉树结构）来说<ul>
<li>第一种，三个节点都在</li>
<li>第二种，有一个空节点，这里又细分为三种情况</li>
<li>第三种，有两个空节点，这里也细分为三种情况</li>
<li>第四种，都是空节点</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>这题比较麻烦，明天再做</p>
<ul>
<li>既然这么多种情况，那就用递归，递个遍！<ul>
<li>递归不了，还得用分治，因为后序遍历，最后一个节点一定是根节点，这也解释了为什么，只有两个数字时，必然正确，因为前一个数字可大可小，可左可右；</li>
</ul>
</li>
<li>还得用分治！！前面某一段连续的数字必然是小于最后一个数，剩下的必然大于最后一个数<ul>
<li>如果，满足上述条件，那就分成两段，继续递归；若不满足，就返回<code>false</code>，而且只要出现<code>false</code>，那么结果就是<code>false</code></li>
<li>这么一想，思路就打开了！</li>
<li>就是判断条件的时候，都要遍历一次嘛？</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>用分治出了点问题<ul>
<li><code>upper_bound</code>的问题，明明6比5大，为什么还是显示在最后呢？</li>
<li><code>auto pos = upper_bound(postorder.begin(), postorder.end() - 1, root);</code>报错（堆溢出），我就纳闷了，不减1不报错，减2也不报错！！</li>
<li>噢，前提是要排好序！！哈哈哈哈哈哈哈，用的二分法，循环判断终于搞定了！！</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//分治</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool verifyPostorder(vector&lt;int&gt;&amp; postorder) &#123;</span><br><span class="line">        //发现分治，可以不用重载</span><br><span class="line">        int n = postorder.size();</span><br><span class="line">        //假设输入的数组的任意两个数字都互不相同，那么小于3个数，应该都是对的</span><br><span class="line">        if(n &lt; 3) return true;</span><br><span class="line">        </span><br><span class="line">        int root = postorder.back();</span><br><span class="line">        auto pos = postorder.begin();</span><br><span class="line">        for(; pos != postorder.end(); ++pos)&#123;</span><br><span class="line">            if(*pos &gt; root) break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //若pos在end()，则说明前面的数字都在左子树</span><br><span class="line">        if(pos == postorder.end())&#123;</span><br><span class="line">            vector&lt;int&gt; tmp(postorder.begin(), postorder.end() - 1);</span><br><span class="line">            return verifyPostorder(tmp);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            //这里判断pos后面的数是不是都大于root</span><br><span class="line">            //注意，这里起始点pos可能在begin()</span><br><span class="line">            for(auto it = pos + 1; it != postorder.end() - 1; ++it)&#123;</span><br><span class="line">                if(*it &lt; root) return false;</span><br><span class="line">            &#125;</span><br><span class="line">            //这里再判断是否在begin()处</span><br><span class="line">            if(pos == postorder.begin())&#123;</span><br><span class="line">                //只有右子树</span><br><span class="line">                vector&lt;int&gt; tmp(postorder.begin(), postorder.end() - 1);</span><br><span class="line">                return verifyPostorder(tmp);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                vector&lt;int&gt; tmp1(pos, postorder.end() - 1);</span><br><span class="line">                vector&lt;int&gt; tmp2(postorder.begin(), pos);</span><br><span class="line">                return verifyPostorder(tmp1) &amp;&amp; verifyPostorder(tmp2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>知道用分治，可为什么大佬写的非常简洁！！<ul>
<li>再优化优化，首先不用重新生成数组，而是添加标记</li>
</ul>
</li>
</ul>
<h2 id="34-二叉树中和为某一值的路径"><a href="#34-二叉树中和为某一值的路径" class="headerlink" title="34_二叉树中和为某一值的路径"></a>34_二叉树中和为某一值的路径</h2><ul>
<li>113<ul>
<li>记得当时做这题比较难，用了递归，没怎么理解透</li>
<li>哦哦，好像不是这题，应该任意两个节点之间的路径和，这题用回溯加剪枝应该很容易！手撕下</li>
<li>这次的出口条件跟以往不太一样，或者说，有多种条件，每次条件都对应的下面的不同判断语句</li>
<li>还是有点小问题<ul>
<li>还是审题不清，从根节点必须到叶节点才行，而不是到中间就行！唉，33、34这两题跟我过不去</li>
<li>出口那儿，再加上判断叶节点的条件，还好</li>
<li>又报错了，因为还有负数？不能简单的比较大小了，得全部递归到底了，不能剪枝，那这样，待会用下BFS试试</li>
<li>力扣真垃圾，测试个代码测半天——又又报错了</li>
</ul>
</li>
<li>知道问题出在哪儿了<ul>
<li><code>target == root-&gt;val</code>是有可能的，但不是叶节点，所以去掉<code>target != root-&gt;val</code>判断条件</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void dfs(TreeNode* root, int target, vector&lt;int&gt;&amp; tmp)&#123;</span><br><span class="line">        //这个递归，是要递归所有可能性才结束，下面递归条件决定了，这里不会出现空节点</span><br><span class="line">        if(target == root-&gt;val &amp;&amp; !root-&gt;left &amp;&amp; !root-&gt;right)&#123;</span><br><span class="line">            //这里弹入弹出下，方便回溯</span><br><span class="line">            tmp.emplace_back(root-&gt;val);</span><br><span class="line">            ans.emplace_back(tmp);</span><br><span class="line">            tmp.pop_back();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //画画图就明白了，这里target == root-&gt;val是有可能的，所以去掉target != root-&gt;val</span><br><span class="line">        tmp.emplace_back(root-&gt;val);</span><br><span class="line">        //这里回溯的时候会有个问题，若左节点为空，那就不应该弹出，直接再递归右节点，那就再加个条件</span><br><span class="line">        if(root-&gt;left != nullptr) dfs(root-&gt;left, target - root-&gt;val, tmp);</span><br><span class="line">        if(root-&gt;right != nullptr) dfs(root-&gt;right, target - root-&gt;val, tmp);</span><br><span class="line">        </span><br><span class="line">        //若两个子树都为空，那显然root-&gt;val不符合</span><br><span class="line">        tmp.pop_back();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int target) &#123;</span><br><span class="line">        //这个是打印出所有路径</span><br><span class="line">        if(!root) return vector&lt;vector&lt;int&gt;&gt;();</span><br><span class="line">        vector&lt;int&gt; tmp;</span><br><span class="line">        dfs(root, target, tmp);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>题解优化的比较好<ul>
<li>把节点为空和满足条件的路径分开来了</li>
<li>这样做的好处就是<code>tmp</code>只需弹入弹出一次</li>
<li>用BFS的话，不是每一层都记录下所有的路径，而是用哈希表记录对应的父节点，这样到叶节点是若满足目标值，就向前迭代</li>
</ul>
</li>
</ul>
<h2 id="35-复杂链表的复制"><a href="#35-复杂链表的复制" class="headerlink" title="35_复杂链表的复制"></a>35_复杂链表的复制</h2><ul>
<li><p>138</p>
<ul>
<li>应该算是深度拷贝，要创建新的节点</li>
<li>这应该算作图了，不过当时拷贝的时候不尽人意，总会报错，这次再来试试</li>
<li>有重复的数字，不好区分重复的节点是哪一个…</li>
<li>这题不会</li>
</ul>
</li>
<li><p>看了题解之后</p>
<ul>
<li>原来是将 原节点 与 新节点 一一对应啊；这样在 <code>next</code> 、<code>random</code> 变化之后，也可以找到对应的节点</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    Node* copyRandomList(Node* head) &#123;</span><br><span class="line">        if(head == nullptr) return nullptr;</span><br><span class="line">        Node* cur = head;</span><br><span class="line">        unordered_map&lt;Node*, Node*&gt; map;</span><br><span class="line">        // 3. 复制各节点，并建立 “原节点 -&gt; 新节点” 的 Map 映射</span><br><span class="line">        while(cur != nullptr) &#123;</span><br><span class="line">            map[cur] = new Node(cur-&gt;val);</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head;</span><br><span class="line">        // 4. 构建新链表的 next 和 random 指向</span><br><span class="line">        while(cur != nullptr) &#123;</span><br><span class="line">            map[cur]-&gt;next = map[cur-&gt;next];</span><br><span class="line">            map[cur]-&gt;random = map[cur-&gt;random];</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        // 5. 返回新链表的头节点</span><br><span class="line">        return map[head];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>还有一种方法居然一点印象都没有了<ul>
<li>我感觉看了大佬的题解之后，就不需要看书了</li>
<li>直接在原链表上生成新的节点，之后再拆分，拆分的时候只需要拆分 <code>next</code> 指针就行，别忘了前节点也要拆分</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/Offer/35.png" alt title="拆分"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    Node* copyRandomList(Node* head) &#123;</span><br><span class="line">        if(head == nullptr) return nullptr;</span><br><span class="line">        Node* cur = head;</span><br><span class="line">        // 1. 复制各节点，并构建拼接链表</span><br><span class="line">        while(cur != nullptr) &#123;</span><br><span class="line">            Node* tmp = new Node(cur-&gt;val);</span><br><span class="line">            tmp-&gt;next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = tmp;</span><br><span class="line">            cur = tmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        // 2. 构建各新节点的 random 指向</span><br><span class="line">        cur = head;</span><br><span class="line">        while(cur != nullptr) &#123;</span><br><span class="line">            if(cur-&gt;random != nullptr)</span><br><span class="line">                cur-&gt;next-&gt;random = cur-&gt;random-&gt;next;</span><br><span class="line">            cur = cur-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        // 3. 拆分两链表</span><br><span class="line">        cur = head-&gt;next;</span><br><span class="line">        Node* pre = head, *res = head-&gt;next;</span><br><span class="line">        while(cur-&gt;next != nullptr) &#123;</span><br><span class="line">            pre-&gt;next = pre-&gt;next-&gt;next;</span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre-&gt;next = nullptr; // 单独处理原链表尾节点</span><br><span class="line">        return res;      // 返回新链表头节点</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="36-二叉搜索树与双向链表"><a href="#36-二叉搜索树与双向链表" class="headerlink" title="36_二叉搜索树与双向链表"></a>36_二叉搜索树与双向链表</h2><ul>
<li>426还没有做到<ul>
<li>用了递归，一次过</li>
<li>有些地方需要注意，因为是环形双向链表，所以在递归返回的时候，也是一个环形双向链表</li>
<li>不能只是简单的改变<code>root</code>的左右指针这么简单，还要改变别的，并且还要考虑空指针的情况</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    Node* treeToDoublyList(Node* root) &#123;</span><br><span class="line">        //每个节点都有两个指针，正好一前一后，left就当做前，right就当作后</span><br><span class="line">        //用递归比较方便，问题就是头尾不好确定，应该分别是最小、最大的数</span><br><span class="line">        if(!root) return nullptr;</span><br><span class="line"></span><br><span class="line">        //不太对，这里返回的是头节点，还需要再改改！！，应该很简单，明天画画图！把头转为尾即可！！</span><br><span class="line">        auto l = treeToDoublyList(root-&gt;left);</span><br><span class="line">        auto r = treeToDoublyList(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        //更改方向，注意这里是双向的——这里l就是头节点</span><br><span class="line">        if(l != nullptr &amp;&amp; r != nullptr)&#123;</span><br><span class="line">            //先连接root</span><br><span class="line">            l-&gt;left-&gt;right = root;</span><br><span class="line">            root-&gt;left = l-&gt;left;</span><br><span class="line">            root-&gt;right = r;</span><br><span class="line">            auto tail = r-&gt;left;</span><br><span class="line">            r-&gt;left = root;</span><br><span class="line">            //最后连接首尾</span><br><span class="line">            l-&gt;left = tail;</span><br><span class="line">            tail-&gt;right = l;</span><br><span class="line">            return l;</span><br><span class="line">        &#125;else if(l != nullptr)&#123;</span><br><span class="line">            //这里右边为空——先连接root</span><br><span class="line">            l-&gt;left-&gt;right = root;</span><br><span class="line">            root-&gt;left = l-&gt;left;</span><br><span class="line">            //连首尾</span><br><span class="line">            l-&gt;left = root;</span><br><span class="line">            root-&gt;right = l;</span><br><span class="line">            return l;</span><br><span class="line">        &#125;else if(r != nullptr)&#123;</span><br><span class="line">            //这里左边为空——先连接root，root为头节点</span><br><span class="line">            auto tail = r-&gt;left;</span><br><span class="line">            root-&gt;right = r;</span><br><span class="line">            r-&gt;left = root;</span><br><span class="line">            //连首尾</span><br><span class="line">            tail-&gt;right = root;</span><br><span class="line">            root-&gt;left = tail;</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">        //若两个都为空</span><br><span class="line">        root-&gt;left = root;</span><br><span class="line">        root-&gt;right = root;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>我写的还是有点繁琐了<ul>
<li>大佬的题解是根据中序遍历，然后记录前驱节点（相当于尾节点），头节点</li>
<li>中序遍历一次，之后就可以直接加上头尾节点的方向就行！</li>
<li>太方便了，不需要判断那么多<code>if else</code>条件，代码也非常简洁</li>
<li>但是自己写不出来，在递归的时候如何保存上一个节点呢</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//手撕大佬题解——参考</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void dfs(Node* node)&#123;</span><br><span class="line">        //套用中序遍历的模板，左，根，右</span><br><span class="line">        if(!node) return;</span><br><span class="line">        dfs(node-&gt;left);</span><br><span class="line">        //这里需要pre，这里一直遍历到最左边</span><br><span class="line">        if(pre != nullptr)</span><br><span class="line">            pre-&gt;right = node; //右子树不影响</span><br><span class="line">        else</span><br><span class="line">            head = node;</span><br><span class="line">        </span><br><span class="line">        node-&gt;left = pre; //这里右子树也不影响，因为递归右节点的时候，会一直递归到左节点</span><br><span class="line">        pre = node;</span><br><span class="line">        dfs(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node* treeToDoublyList(Node* root) &#123;</span><br><span class="line">        if(!root) return nullptr;</span><br><span class="line">        dfs(root);</span><br><span class="line">        head-&gt;left = pre;</span><br><span class="line">        pre-&gt;right = head;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    Node* pre;</span><br><span class="line">    Node* head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>这题需要好好琢磨琢磨</li>
</ul>
<h2 id="37-序列化二叉树"><a href="#37-序列化二叉树" class="headerlink" title="37_序列化二叉树"></a>37_序列化二叉树</h2><ul>
<li><p>297题一样，但还没做到</p>
<ul>
<li>审下题，序列化不限制逻辑，前序、中序、后序遍历都可以，关键是只有一个序列，怎么恢复二叉树</li>
<li>之前做的一题是一个前序一个中序来恢复二叉树，这里运用下？</li>
<li>所以格式到底是什么？这题怎么恢复呢</li>
<li>看了书——之前的方法，有两个缺点：数值不能重复、得全部读取数据才能进行反序列化</li>
<li>格式原来就是遇到空指针时，字符串添加特殊字符，比如<code>$</code>，力扣上的一些参数例子就是，层序遍历，空指针为<code>NULL</code>；书上是深度优先，待会儿这两个方法都试下！</li>
</ul>
</li>
<li><p>有个注意点</p>
<ul>
<li>书上是输出流，是引用，自己写参数的时候，也要写成引用的，因为回溯后，字符还是要向前推的</li>
<li>但是我写完运行出错，不知道错哪儿<ul>
<li>错误地方在于，并没有全部序列化或者反序列化，只是一部分？</li>
<li>输出的字符串发现有的乱码了，我知道了，有的数字是两位数，转成字符串就不能直接<code>+&#39;0&#39;</code>了</li>
<li>那么反序列化，也就不能一个个字符来了</li>
<li>嗷，数字也要隔开！！不然乱套了</li>
<li>还是没成功！——递归出口也要<code>++i;</code>，，，，，emmmmmmmmm</li>
<li>居然还有负数？？那<code>stoi</code>就没用了，有用是有用，就是判断负号比较烦？</li>
<li>啊，成功了</li>
</ul>
</li>
</ul>
</li>
<li><p>题解是将字符串转为双向链表<code>list&lt;string&gt; dataArray;</code>，之后递归的时候一直删第一个，这样省去了不少麻烦！</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//手撕版本，双5%，哈哈哈哈</span><br><span class="line">class Codec &#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    // Encodes a tree to a single string.</span><br><span class="line">    string serialize(TreeNode* root) &#123;</span><br><span class="line">        //这里居然是由返回值的</span><br><span class="line">        if(!root)&#123;</span><br><span class="line">            //这里不加逗号，会出现nn连在一起</span><br><span class="line">            return &quot;n,&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        string s;</span><br><span class="line">        s += to_string(root-&gt;val);</span><br><span class="line">        s.push_back(&apos;,&apos;);</span><br><span class="line">        s += serialize(root-&gt;left);</span><br><span class="line">        s += serialize(root-&gt;right);</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Decodes your encoded data to tree.</span><br><span class="line">    TreeNode* deserialize(string data) &#123;</span><br><span class="line">        //因为参数i是引用，所以得有变量</span><br><span class="line">        int n = data.size();</span><br><span class="line">        int i = 0;</span><br><span class="line">        return deserialize(data, i, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode* deserialize(string data, int&amp; i, int n) &#123;</span><br><span class="line">        //这里再加一个补丁</span><br><span class="line">        if(data[i] == &apos;,&apos;) ++i;</span><br><span class="line"></span><br><span class="line">        //这里的i应该是引用，因为回溯后，i是往前进一位的</span><br><span class="line">        if(i == n || data[i] == &apos;n&apos;)&#123;</span><br><span class="line">            //想起来了，这里也要++i，！！！</span><br><span class="line">            ++i;</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //加上负号补丁</span><br><span class="line">        int sign = 1;</span><br><span class="line">        if(data[i] == &apos;-&apos;)&#123;</span><br><span class="line">            ++i;</span><br><span class="line">            sign = -1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //这里提取数字</span><br><span class="line">        int j = i;</span><br><span class="line">        while(isdigit(data[i]))&#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //这里的i应该指向&apos;,&apos;，并不是负号</span><br><span class="line">        int num = stoi(data.substr(j, i - j));</span><br><span class="line">        TreeNode* head = new TreeNode(num * sign);</span><br><span class="line">        head-&gt;left = deserialize(data, i, n);</span><br><span class="line">        head-&gt;right = deserialize(data, i, n);</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//题解</span><br><span class="line">class Codec &#123;</span><br><span class="line">public:</span><br><span class="line">    void rserialize(TreeNode* root, string&amp; str) &#123;</span><br><span class="line">        if (root == nullptr) &#123;</span><br><span class="line">            str += &quot;None,&quot;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            str += to_string(root-&gt;val) + &quot;,&quot;;</span><br><span class="line">            rserialize(root-&gt;left, str);</span><br><span class="line">            rserialize(root-&gt;right, str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string serialize(TreeNode* root) &#123;</span><br><span class="line">        string ret;</span><br><span class="line">        rserialize(root, ret);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode* rdeserialize(list&lt;string&gt;&amp; dataArray) &#123;</span><br><span class="line">        if (dataArray.front() == &quot;None&quot;) &#123;</span><br><span class="line">            dataArray.erase(dataArray.begin());</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode* root = new TreeNode(stoi(dataArray.front()));</span><br><span class="line">        dataArray.erase(dataArray.begin());</span><br><span class="line">        root-&gt;left = rdeserialize(dataArray);</span><br><span class="line">        root-&gt;right = rdeserialize(dataArray);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode* deserialize(string data) &#123;</span><br><span class="line">        list&lt;string&gt; dataArray;</span><br><span class="line">        string str;</span><br><span class="line">        for (auto&amp; ch : data) &#123;</span><br><span class="line">            if (ch == &apos;,&apos;) &#123;</span><br><span class="line">                dataArray.push_back(str);</span><br><span class="line">                str.clear();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                str.push_back(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!str.empty()) &#123;</span><br><span class="line">            dataArray.push_back(str);</span><br><span class="line">            str.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        return rdeserialize(dataArray);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="38-字符串的排列"><a href="#38-字符串的排列" class="headerlink" title="38_字符串的排列"></a>38_字符串的排列</h2><ul>
<li>这题得好好做下，之前看的一本书（不过那是元素不重复的排列），用了<code>swap</code>方法，比重新生成字符串或者标记好多了<ul>
<li>如果是交换的话，该如何去重呢</li>
</ul>
</li>
<li>每日一题做的时候，发现这上面已经有代码，可能之前做过一次——但是没有提交记录，我写的是用了<code>erase</code>方法，用了哪个就删除哪个；终止条件是临时字符串的长度是否等于源字符串的长度!——但是没有去重，得用哈希记录下已经出现（用过）的字符</li>
<li>再看看剑指Offer书<ul>
<li>也是交换；把一个一个字符串分成两个部分、第一部分就是第一个字符，第二部分就是剩下的字符串，然后一一交换！嗷，如果遇见一样的就不用交换？</li>
<li>但是去重后交换报错了，不知道错哪儿；例子只通过了一半</li>
<li>因为还是需要哈希去重！！另一种去重方法就是排序去重，遇到和之前一样的，就跳过！</li>
</ul>
</li>
<li>题解的31下一个排列，用了字典序（当然，也是先排序），之前做过的都忘光光了0.0</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//之前的老版本</span><br><span class="line">/*class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void dfs(vector&lt;string&gt; &amp;res, string &amp;tmp, string s, int n)&#123;</span><br><span class="line">        if(tmp.size() == n)&#123;</span><br><span class="line">            res.emplace_back(tmp);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        unordered_set&lt;char&gt; set;</span><br><span class="line">        //这里是从0开始，并且每次递归字符串s的长度会逐渐减小</span><br><span class="line">        for(int i = 0; i &lt; s.size(); ++i)&#123;</span><br><span class="line">            //这里去重，不能全部去除，只要遇到一样的，就不能重复放在一个位置</span><br><span class="line">            //这里就相当于第一个位置</span><br><span class="line">            if(set.find(s[i]) != set.end())</span><br><span class="line">                continue;</span><br><span class="line">            set.insert(s[i]);</span><br><span class="line"></span><br><span class="line">            tmp.push_back(s[i]);</span><br><span class="line">            string s1 = s;</span><br><span class="line">            dfs(res, tmp, s1.erase(i, 1), n);</span><br><span class="line">            tmp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;string&gt; permutation(string s) &#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        string tmp;</span><br><span class="line">        int n = s.size();</span><br><span class="line">        dfs(res, tmp, s, n);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;*/</span><br><span class="line"></span><br><span class="line">//交换去重版本</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void dfs(string s, int pos, int n)&#123;</span><br><span class="line">        if(pos == n)&#123;</span><br><span class="line">            ans.emplace_back(s);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        unordered_set&lt;char&gt; set;</span><br><span class="line">        for(int i = pos; i &lt; n; ++i)&#123;</span><br><span class="line">            //这里还要考虑s[i]有没有出现重复的！！还是得用哈希表</span><br><span class="line">            if(set.find(s[i]) != set.end())</span><br><span class="line">                continue;</span><br><span class="line">            set.insert(s[i]);</span><br><span class="line">            swap(s[pos], s[i]);</span><br><span class="line">            dfs(s, pos + 1, n);</span><br><span class="line">            swap(s[pos], s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;string&gt; permutation(string s) &#123;</span><br><span class="line">        if(s.empty())</span><br><span class="line">            return vector&lt;string&gt;();</span><br><span class="line">        int n = s.size();</span><br><span class="line">        dfs(s, 0, n);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>这里再啰嗦下，下次就不容易忘了<ul>
<li>交换去重和回溯思路是完全一样的，都是先确定第一位，依次往下</li>
<li>若是第一位或者某一位，出现了重复，那就要跳过——因为之前（后面几位）已经交换好了——这样理解：第一位确定好之后，再次回溯到第一位时，说明后面所有的字符都已经排列好了</li>
<li><code>i = pos</code> 循环是没有问题的！不是负负得正，而是就应该这样！</li>
</ul>
</li>
</ul>
<h2 id="39-数组中出现次数超过一半的数字"><a href="#39-数组中出现次数超过一半的数字" class="headerlink" title="39_数组中出现次数超过一半的数字"></a>39_数组中出现次数超过一半的数字</h2><ul>
<li>169<ul>
<li>用了投票算法，一次过</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int majorityElement(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        // 这里题目是说必定存在一个数字次数超过一半？</span><br><span class="line">        if(nums.size() == 1) return nums[0];</span><br><span class="line">        // 用下投票算法</span><br><span class="line">        int candidate, count = 0;</span><br><span class="line">        for(auto num : nums)&#123;</span><br><span class="line">            if(count == 0)&#123;</span><br><span class="line">                // 这里更新候选人</span><br><span class="line">                candidate = num;</span><br><span class="line">            &#125;</span><br><span class="line">            // 这里不用 if else；因为还要更新 count</span><br><span class="line">            if(candidate == num)&#123;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                --count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return candidate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>题解还用了其他方法<ul>
<li>哈希表、排序、随机化、分治</li>
</ul>
</li>
</ul>
<h2 id="40-最小的k个数"><a href="#40-最小的k个数" class="headerlink" title="40_最小的k个数"></a>40_最小的k个数</h2><ul>
<li>难道是先排序嘛<ul>
<li>还有要注意 k 的范围</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// sort 排序</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; getLeastNumbers(vector&lt;int&gt;&amp; arr, int k) &#123;</span><br><span class="line">        // k 是个数，0 应该返回空</span><br><span class="line">        if(arr.empty() || k &lt; 1 || k &gt; arr.size()) return vector&lt;int&gt;();</span><br><span class="line">        sort(arr.begin(), arr.end());</span><br><span class="line">        return vector&lt;int&gt;(arr.begin(), arr.begin() + k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>学习下大根堆<ul>
<li>面试容易问到，在处理大数据的时候，内存不够用，用大根堆就比较好</li>
<li><code>priority_queue&lt;int&gt; Q;</code> 为大根堆 —— 第一个元素总是最大的</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 大根堆</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; getLeastNumbers(vector&lt;int&gt;&amp; arr, int k) &#123;</span><br><span class="line">        vector&lt;int&gt; vec(k, 0);</span><br><span class="line">        if (k == 0) &#123; // 排除 0 的情况</span><br><span class="line">            return vec;</span><br><span class="line">        &#125;</span><br><span class="line">        priority_queue&lt;int&gt; Q;</span><br><span class="line">        for (int i = 0; i &lt; k; ++i) &#123;</span><br><span class="line">            Q.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = k; i &lt; (int)arr.size(); ++i) &#123;</span><br><span class="line">            if (Q.top() &gt; arr[i]) &#123;</span><br><span class="line">                Q.pop();</span><br><span class="line">                Q.push(arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; k; ++i) &#123;</span><br><span class="line">            vec[i] = Q.top();</span><br><span class="line">            Q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        return vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>再复习下快排算法，之前 “剑指Offer” 有一题练习过<ul>
<li>只快排数组前 k 个数……</li>
<li>不是快排，而是快速选择算法？</li>
</ul>
</li>
</ul>
<h2 id="41-数据流中的中位数"><a href="#41-数据流中的中位数" class="headerlink" title="41_数据流中的中位数"></a>41_数据流中的中位数</h2><ul>
<li>295<ul>
<li>记得有一题是数字递增的，忘了是哪一题了；</li>
<li>这题当时做的的心累，没有想到大根堆、小根堆，这次来手撕下！！</li>
<li>平衡两个堆，注意一些坑！优先级队列的定义 <code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt;</code> 有三个参数！</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 手撕，一次过</span><br><span class="line">class MedianFinder &#123;</span><br><span class="line">public:</span><br><span class="line">    MedianFinder() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    void addNum(int num) &#123;</span><br><span class="line">        // 这里要先确保 大堆 的所有数字都比 小堆 的大</span><br><span class="line">        mi.push(num);</span><br><span class="line">        ma.push(mi.top());</span><br><span class="line">        mi.pop();</span><br><span class="line">        // 这里再平衡，要么相等、要么小于</span><br><span class="line">        while(ma.size() &gt; mi.size())&#123;</span><br><span class="line">            mi.push(ma.top());</span><br><span class="line">            ma.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    double findMedian() &#123;</span><br><span class="line">        if(ma.size() == mi.size())&#123;</span><br><span class="line">            return (double)(ma.top() + mi.top()) / 2;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return (double)(mi.top());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    // ma 是越来越大，头部是最小值</span><br><span class="line">    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt;  ma;</span><br><span class="line">    // mi 是越来越小，头部是最大值</span><br><span class="line">    priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt;  mi;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="42-连续子数组的最大和"><a href="#42-连续子数组的最大和" class="headerlink" title="42_连续子数组的最大和"></a>42_连续子数组的最大和</h2><ul>
<li>53没印象了<ul>
<li>不知道是不是用的动态规划，先手撕下</li>
<li>好像应该用前缀和+哈希表！！！动规和双循环都会超时？</li>
<li>有点乱，状态转移只需要考虑<code>dp[i - 1]</code>，因为子数组是连续的；那之前需要遍历前面最大值的是哪题来着？？？</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//手撕动规</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        //先把每日一题敲一遍 好像是用的动规</span><br><span class="line">        if(nums.empty()) return 0;</span><br><span class="line"></span><br><span class="line">        //dp[i]是以i为结尾的子数组的最大值</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        vector&lt;int&gt; dp(n, 0);</span><br><span class="line">        //边界</span><br><span class="line">        dp[0] = nums[0];</span><br><span class="line"></span><br><span class="line">        for(int i = 1; i &lt; n; ++i)&#123;</span><br><span class="line">            //以 i 为结尾，这里还不能初始化为0呢，乱了乱了，因为是连续的所以只需考虑dp[i - 1]？</span><br><span class="line">            </span><br><span class="line">            //这里不一定得加上前面的，而是取最大值</span><br><span class="line">            dp[i] = max(dp[i - 1] + nums[i], nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return *max_element(dp.begin(), dp.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>题解写的真简洁<ul>
<li>这里不放了，类似于滚动数组</li>
<li>但是得学下分治！</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// TODO</span><br></pre></td></tr></table></figure>

<h2 id="43-1～n-整数中-1-出现的次数"><a href="#43-1～n-整数中-1-出现的次数" class="headerlink" title="43_1～n 整数中 1 出现的次数"></a>43_1～n 整数中 1 出现的次数</h2><ul>
<li>233<ul>
<li>有点棘手</li>
<li>一时忘了当时是怎么磨出来的，题解又是怎么的简洁！</li>
<li>直接看题解还有大佬的思路<ul>
<li>每一位上 1 出现的次数相加，总结果就是 1 的总个数</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/Offer/43.png" alt></p>
<ul>
<li><p>位因子是 10 的幂</p>
<ul>
<li>难点在于需要考虑不能大于原来的数字，比如 1014 这个数字；要分为两部分，一是 0010 ~ 0919，二是 1010 ~ 1014</li>
<li>第一部分可以肆无忌惮的相乘，因为没有范围限制；但是后面就有了</li>
<li>有个变量整数溢出了，<code>int</code> 得改为 <code>long long</code> 类型<ul>
<li><code>long long num = 1</code></li>
</ul>
</li>
<li><code>TODO</code> 明天再来记录！</li>
</ul>
</li>
<li><p>过了不知多久，在每日一题看到了</p>
<ul>
<li>那么是时候来填坑了！</li>
</ul>
</li>
</ul>
<h2 id="44-数字序列中某一位的数字"><a href="#44-数字序列中某一位的数字" class="headerlink" title="44_数字序列中某一位的数字"></a>44_数字序列中某一位的数字</h2><ul>
<li>400 还没有做到<ul>
<li>结果是唯一确定的，要是按照某个公式直接输出就好了</li>
<li></li>
</ul>
</li>
</ul>
<h2 id="45-把数组排成最小的数"><a href="#45-把数组排成最小的数" class="headerlink" title="45_把数组排成最小的数"></a>45_把数组排成最小的数</h2><ul>
<li>写谓词写到一半才发现，比较数字的时候，3 比 30、31、32 都大，3 就相当于 33<ul>
<li>有点像按照个位数排序的那个排序算法</li>
<li>这题之前有点印象，因为当时好像就是把 3 当成 33 来着</li>
<li>唉，积压的题目越来越多！</li>
</ul>
</li>
</ul>
<h2 id="46-把数字翻译成字符串"><a href="#46-把数字翻译成字符串" class="headerlink" title="46_把数字翻译成字符串"></a>46_把数字翻译成字符串</h2><ul>
<li>这个题目有印象<ul>
<li>要考虑多种情况，比如数字前面有个 0，或者前后两个数字合在一起超过了表示范围</li>
<li>感觉这题适合用动规</li>
<li>提示给出了 <code>num</code> 的范围，状态转移的时候要注意点，这题跟之前一题不太一样，任何个位数都可以翻译，也就是说，答案至少为 1</li>
<li>状态转移方程终于给我试出来了，只有两种情况，既考虑前一位数字也考虑本身（这个就是类似于斐波那契数列，或者青蛙跳台阶），第二种情况只能考虑本身</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int translateNum(int num) &#123;</span><br><span class="line">        // 似乎可以大致分为两种，考虑前一个数字，不考虑前一个数字</span><br><span class="line">        // 先转为字符串</span><br><span class="line">        string s(to_string(num));</span><br><span class="line">        int n = s.size();</span><br><span class="line">        vector&lt;int&gt; dp(n + 1, 0);</span><br><span class="line">        // 第一个数字 0 ~ 9 都可以翻译</span><br><span class="line">        dp[0] = 1;</span><br><span class="line">        dp[1] = 1;</span><br><span class="line">        for(int i = 1; i &lt; n; ++i)&#123;</span><br><span class="line">            // 考虑前一个数字在不在范围内，这个是考虑两个数连在一起的情况，应该是相加才对</span><br><span class="line">            if(s[i - 1] == &apos;1&apos; || (s[i - 1] == &apos;2&apos; &amp;&amp; s[i] &lt; &apos;6&apos;))&#123;</span><br><span class="line">                // 这样写看看</span><br><span class="line">                dp[i + 1] = dp[i - 1] + dp[i];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                // 不考虑前一个数字，都可以翻译</span><br><span class="line">                dp[i + 1] = dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>试下滚动数组</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int translateNum(int num) &#123;</span><br><span class="line">        string s(to_string(num));</span><br><span class="line">        int n = s.size();</span><br><span class="line">        // 这里 p 也要初始化下</span><br><span class="line">        int p2 = 1, p1 = 1, p = 1;</span><br><span class="line"></span><br><span class="line">        for(int i = 1; i &lt; n; ++i)&#123;</span><br><span class="line">            if(s[i - 1] == &apos;1&apos; || (s[i - 1] == &apos;2&apos; &amp;&amp; s[i] &lt; &apos;6&apos;))&#123;</span><br><span class="line">                p = p2 + p1;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                p = p1;</span><br><span class="line">            &#125;</span><br><span class="line">            p2 = p1;</span><br><span class="line">            p1 = p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="47-礼物的最大价值"><a href="#47-礼物的最大价值" class="headerlink" title="47_礼物的最大价值"></a>47_礼物的最大价值</h2><ul>
<li>这题有印象<ul>
<li>这题之前应该是第一次摸索出的动规，这里再加深下印象，可以，一次过</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxValue(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        // 提示里显示不为空</span><br><span class="line">        int row = grid.size(), col = grid[0].size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(row, vector&lt;int&gt;(col, 0));</span><br><span class="line">        // 边界</span><br><span class="line">        dp[0][0] = grid[0][0];</span><br><span class="line">        for(int i = 1; i &lt; row; ++i)&#123;</span><br><span class="line">            dp[i][0] = dp[i - 1][0] + grid[i][0];</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j = 1; j &lt; col; ++j)&#123;</span><br><span class="line">            dp[0][j] = dp[0][j - 1] + grid[0][j];</span><br><span class="line">        &#125;</span><br><span class="line">        // 遍历</span><br><span class="line">        for(int i = 1; i &lt; row; ++i)&#123;</span><br><span class="line">            for(int j = 1; j &lt; col; ++j)&#123;</span><br><span class="line">                // 状态转移</span><br><span class="line">                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[row - 1][col - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>大佬题解是直接在原数组修改的<ul>
<li>还有大佬是直接多开一行一列，这样初始化边界就可以不用那两个一次循环了</li>
</ul>
</li>
</ul>
<h2 id="48-最长不含重复字符的子字符串"><a href="#48-最长不含重复字符的子字符串" class="headerlink" title="48_最长不含重复字符的子字符串"></a>48_最长不含重复字符的子字符串</h2><ul>
<li>3</li>
<li>再来复习下动态规划，说错了，应该是滑动窗口<ul>
<li>判断窗口里有没有重复的，最简单的应该是用哈希表</li>
<li>这次我想试试 数组 长度为 26，但是有个问题，题目中没有确保都是小写字母</li>
<li>用哈希后，栈溢出了……还有删除的时候有个坑，不是遇到重复的就删，而是一直删除前面的……</li>
<li>又溢出了，怎么回事</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLongestSubstring(string s) &#123;</span><br><span class="line">        // 就用哈希表</span><br><span class="line">        if(s.empty()) return 0;</span><br><span class="line">        int ans = 1;</span><br><span class="line">        int l = 0, r = 0;</span><br><span class="line">        // 哈希，用 set 不用 map 是因为遇到重复的就要缩短窗口来去除重复</span><br><span class="line">        unordered_set&lt;int&gt; set;</span><br><span class="line">        while(r &lt; s.size())&#123;</span><br><span class="line">            //cout &lt;&lt; &quot;r = &quot; &lt;&lt; r &lt;&lt; endl;</span><br><span class="line">            // 先拉长窗口，哦哦，这里应该写 ==</span><br><span class="line">            if(set.find(s[r]) == set.end())&#123;</span><br><span class="line">                set.insert(s[r]);</span><br><span class="line">                // 这里可能会直接结束了，外面还要再判断一次</span><br><span class="line">                ++r;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                // 先更新结果</span><br><span class="line">                ans = max(ans, r - l);</span><br><span class="line">                // 缩短窗口，这里还不能删呢，不对还是得删，不然没法进入第一个条件</span><br><span class="line">                set.erase(s[r]);</span><br><span class="line">                while(s[l] != s[r])&#123;</span><br><span class="line">                    set.erase(s[l]);</span><br><span class="line">                    ++l;</span><br><span class="line">                &#125;</span><br><span class="line">                ++l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 这里也可以直接初始化成字符串的长度</span><br><span class="line">        ans = max(ans, r - l);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>也可以用动态规划……<ul>
<li>也要用哈希来辅助 —— 主要来记录对应元素的下标</li>
<li>下标有什么用呢，在状态转移的时候会分类讨论，先手撕下，加深理解</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 动规</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLongestSubstring(string s) &#123;</span><br><span class="line">        if(s.empty()) return 0;</span><br><span class="line">        int n = s.size();</span><br><span class="line">        vector&lt;int&gt; dp(n, 0);</span><br><span class="line">        unordered_map&lt;char, int&gt; map;</span><br><span class="line">        int ans = 1;</span><br><span class="line">        // 边界初始化</span><br><span class="line">        dp[0] = 1;</span><br><span class="line">        map[s[0]] = 0;</span><br><span class="line">        for(int i = 1; i &lt; n; ++i)&#123;</span><br><span class="line">            if(map.find(s[i]) == map.end())&#123;</span><br><span class="line">                dp[i] = dp[i - 1] + 1;</span><br><span class="line">                // 这里的哈希类似于滚动数组</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                // 这里得分两种</span><br><span class="line">                int j = map[s[i]];</span><br><span class="line">                if(dp[i - 1] &lt; i - j)</span><br><span class="line">                    dp[i] = dp[i - 1] + 1;</span><br><span class="line">                else</span><br><span class="line">                    dp[i] = i - j;</span><br><span class="line">            &#125;</span><br><span class="line">            map[s[i]] = i;</span><br><span class="line">            ans = max(ans, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>我觉得我写的好啰嗦</li>
</ul>
<h2 id="49-丑数"><a href="#49-丑数" class="headerlink" title="49_丑数"></a>49_丑数</h2><ul>
<li>264<ul>
<li>老朋友了，但我忘了……</li>
<li>再学习下</li>
<li>最小堆永远的神！<code>priority_queue&lt;long, vector&lt;long&gt;, greater&lt;long&gt;&gt;</code></li>
<li>三个指针也牛皮</li>
</ul>
</li>
</ul>
<h2 id="50-第一个只出现一次的字符"><a href="#50-第一个只出现一次的字符" class="headerlink" title="50_第一个只出现一次的字符"></a>50_第一个只出现一次的字符</h2><ul>
<li>一种方法是遍历两次字符串，可以用哈希，也可以用数组</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    char firstUniqChar(string s) &#123;</span><br><span class="line">        // 简单吗，只包含小写字母，那就用计数排序</span><br><span class="line">        if(s.empty()) return &apos; &apos;;</span><br><span class="line">        vector&lt;int&gt; dp(26, 0);</span><br><span class="line">        for(auto ch : s)&#123;</span><br><span class="line">            dp[ch - &apos;a&apos;]++;</span><br><span class="line">        &#125;</span><br><span class="line">        // 遍历数组不对，会破坏原来的顺序，还是得遍历一遍字符串</span><br><span class="line">        for(auto ch : s)&#123;</span><br><span class="line">            if(dp[ch - &apos;a&apos;] == 1) return ch;</span><br><span class="line">        &#125;</span><br><span class="line">        return &apos; &apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>另一种改进的方法是，第一次遍历字符串，第二次遍历哈希表，若值为 下标 则不重复，若为 -1 则重复<ul>
<li>可是怎么确定这是第一个，哈希表不是无序的吗</li>
<li>又加了个变量 <code>first</code>，也就是说，要对哈希表完整遍历一次才能找出最小值</li>
<li>感觉比数组慢……</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    char firstUniqChar(string s) &#123;</span><br><span class="line">        unordered_map&lt;char, int&gt; position;</span><br><span class="line">        int n = s.size();</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            if (position.count(s[i])) &#123;</span><br><span class="line">                position[s[i]] = -1;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                position[s[i]] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int first = n;</span><br><span class="line">        for (auto [_, pos]: position) &#123;</span><br><span class="line">            if (pos != -1 &amp;&amp; pos &lt; first) &#123;</span><br><span class="line">                first = pos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return first == n ? &apos; &apos; : s[first];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="51-数组中的逆序对"><a href="#51-数组中的逆序对" class="headerlink" title="51_数组中的逆序对"></a>51_数组中的逆序对</h2><ul>
<li>归并排序<ul>
<li>与求逆序对的关系，在合并的过程中，最小的那个数（新的数组开头）对逆序对没有贡献</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/Offer/51.png" alt></p>
<h2 id="52-两个链表的第一个公共节点"><a href="#52-两个链表的第一个公共节点" class="headerlink" title="52_两个链表的第一个公共节点"></a>52_两个链表的第一个公共节点</h2><ul>
<li>160<ul>
<li>再来手撕下</li>
<li>这里有个问题，数字是可以重复的，那仅仅判断数字重复就断定交点是不是草率了，待会看看之前的解法</li>
<li><code>==</code> 存在漏洞，用了判断地址是否相同</li>
<li>之前是用的 <code>while (carry1 != carry2)</code> 这个条件，哈希表也可以存储节点</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;</span><br><span class="line">        // 交点可能有，也可能没有</span><br><span class="line">        if(!headA || !headB) return nullptr;</span><br><span class="line">        ListNode* carryA = headA;</span><br><span class="line">        ListNode* carryB = headB;</span><br><span class="line"></span><br><span class="line">        // 这里应该用或运算，只要两个节点都不为空即可</span><br><span class="line">        while(carryA != nullptr || carryB != nullptr)&#123;</span><br><span class="line">            // 这里判断相等 == 应该没有重载，但是数字也有可能是重复的</span><br><span class="line">            // 要写在后面，防止节点为空，不对，还是要加上不为空的条件，还得写在前面，第一个就是交点呢</span><br><span class="line">            if(carryA == carryB) break;</span><br><span class="line"></span><br><span class="line">            // 这里换个写法，如果都为空，是进不来的</span><br><span class="line">            if(!carryA) carryA = headB;</span><br><span class="line">            else carryA = carryA-&gt;next;</span><br><span class="line"></span><br><span class="line">            if(!carryB) carryB = headA;</span><br><span class="line">            else carryB = carryB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return carryA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="53-1-在排序数组中查找数字"><a href="#53-1-在排序数组中查找数字" class="headerlink" title="53-1_在排序数组中查找数字"></a>53-1_在排序数组中查找数字</h2><ul>
<li>34题一样，好像当时是找到一个，然后向左向右分别遍历的<ul>
<li>这个时候就体现出<code>upper_bound</code>、<code>lower_bound</code>的好处了</li>
<li>这两个函数也可以满足没有目标值的情况，一次通过！！</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int search(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        //运用两次二分，查找左右边界？</span><br><span class="line">        //第一个大于</span><br><span class="line">        auto r = upper_bound(nums.begin(), nums.end(), target);</span><br><span class="line">        //第一个不小于</span><br><span class="line">        auto l = lower_bound(nums.begin(), nums.end(), target);</span><br><span class="line"></span><br><span class="line">        return r - l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>这题的考点就是二分了<ul>
<li>题解是把左边界和右边界二分合在一起，再琢磨琢磨<ul>
<li>这里是精髓<code>if (nums[mid] &gt; target || (lower &amp;&amp; nums[mid] &gt;= target))</code></li>
<li>但是题解返回的是<code>ans</code>而不是<code>l</code>，我再改改</li>
<li>还是写成<code>l &lt; r</code>吧，左开右闭</li>
<li>二分法还是一生之敌啊</li>
<li>寻找左边界是指左边比<code>target</code>小的数有几个，也就是说，若<code>target</code>不在数组中，且存在小的数，<code>l</code>也是有解的</li>
<li>那么寻找右边界是指左边比<code>target</code>小于等于的数有几个，若最后答案减一，那就是下标，不减一就是个数，，，，说的我自己都有点乱！！</li>
</ul>
</li>
<li>也有大佬把<code>upper_bound</code>、<code>lower_bound</code>的模板写了一遍！</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//手撕题解</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int binarySearch(vector&lt;int&gt;&amp; nums, int target, bool lower, int n)&#123;</span><br><span class="line">        int l = 0, r = n;</span><br><span class="line">        while(l &lt; r)&#123;</span><br><span class="line">            int mid = (r - l) / 2 + l;</span><br><span class="line">            if(lower)&#123;</span><br><span class="line">                //左边界</span><br><span class="line">                if(nums[mid] &gt;= target)&#123;</span><br><span class="line">                    r = mid;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    l = mid + 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                //右边界，因为是有边界，最后是要返回l - 1的</span><br><span class="line">                if(nums[mid] &lt;= target)&#123;</span><br><span class="line">                    l = mid + 1;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    r = mid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int search(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        if(nums.empty() || target &lt; nums[0] || target &gt; nums.back()) return 0;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        //前提是这个数字在数组中</span><br><span class="line">        int l = binarySearch(nums, target, true, n);</span><br><span class="line">        //cout &lt;&lt; &quot;l = &quot; &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">        int r = binarySearch(nums, target, false, n);</span><br><span class="line">        //cout &lt;&lt; &quot;r = &quot; &lt;&lt; r &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        return r - l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>为什么不直接抄题解<ul>
<li>因为题解最后返回的不是<code>l</code>而是<code>ans</code>，与我之前的一贯思路不匹配，容易乱！</li>
<li>经过这次的洗礼，印象又加深了<ul>
<li>如<code>target</code>不在数组中，那么左边界——返回的是小于<code>target</code>的个数；右边界——也不能算作个数，而是第一个大于<code>target</code>数字的下标，有可能在<code>end()</code>处</li>
<li>那么左边界、右边界相等时（两者之差为0），说明<code>target</code>不在数组中！！！</li>
</ul>
</li>
<li>先告一段落！！</li>
</ul>
</li>
</ul>
<h2 id="53-2-0～n-1-中缺失的数字"><a href="#53-2-0～n-1-中缺失的数字" class="headerlink" title="53_2_0～n-1 中缺失的数字"></a>53_2_0～n-1 中缺失的数字</h2><ul>
<li>除了数学求和，看看还有没有其他方法<ul>
<li>雾草，怪不得都是 53 题，也是可以用二分的！</li>
<li>因为原数组排好序了，而且第一个数字又是从 0 开始，所以跟下标是一一对应的，若缺少一个数字，那么后面的数字跟下标就不对应了</li>
<li>技能点<ul>
<li>排序数组中的搜索问题，首先想到 二分法 解决</li>
<li>这题再手撕下</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 数学求和</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int missingNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        // 之前应该用了数学求和的方法</span><br><span class="line">        // 从 0 开始，一共有 n 个数字（少一个），整数边界要注意</span><br><span class="line">        int sum = accumulate(nums.begin(), nums.end(), 0);</span><br><span class="line">        // 这里的 n 是少一个的，要注意</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        // 注意这里，不能先除</span><br><span class="line">        int allSum = n * (n + 1) / 2;</span><br><span class="line">        return allSum - sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 二分法</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int missingNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        // 找边界，还是用开区间吧</span><br><span class="line">        int l = 0, r = nums.size();</span><br><span class="line">        while(l &lt; r)&#123;</span><br><span class="line">            int mid = (r - l) / 2 + l;</span><br><span class="line">            // 左边界</span><br><span class="line">            if(nums[mid] == mid)&#123;</span><br><span class="line">                // 这里 +1 是因为 l = mid 不是最后要的结果</span><br><span class="line">                l = mid + 1;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="54-二叉搜索树的第-k-大节点"><a href="#54-二叉搜索树的第-k-大节点" class="headerlink" title="54_二叉搜索树的第 k 大节点"></a>54_二叉搜索树的第 k 大节点</h2><ul>
<li>这题用的递归<ul>
<li>算是巩固下，加深理解</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int ans, pos = 0;</span><br><span class="line">    // 第 k 大的节点，不能中序遍历，而是自定义的遍历，先右、根、再左</span><br><span class="line">    // 还是得自定义一个函数</span><br><span class="line">    void kth(TreeNode* root, int k)&#123;</span><br><span class="line">        if(pos == k || !root)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 先到最右边</span><br><span class="line">        kthLargest(root-&gt;right, k);</span><br><span class="line">        // 这里返回后，pos 已经等于 k 了，但是没有判断，再加一个判断；那开头是不是就不用加了呢</span><br><span class="line">        if(pos == k) return;</span><br><span class="line"></span><br><span class="line">        // 更新 pos、ans</span><br><span class="line">        pos++;</span><br><span class="line">        ans = root-&gt;val;</span><br><span class="line">        kthLargest(root-&gt;left, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int kthLargest(TreeNode* root, int k) &#123;</span><br><span class="line">        // if(k &lt; 1) return -1;</span><br><span class="line">        kth(root, k);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="55-1-二叉树的深度"><a href="#55-1-二叉树的深度" class="headerlink" title="55-1_二叉树的深度"></a>55-1_二叉树的深度</h2><ul>
<li>104<ul>
<li>之前应该都用的 BFS 不知道 DFS 行不行的通</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxDepth(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return 0;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        q.push(root);</span><br><span class="line"></span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            int n = q.size();</span><br><span class="line">            while(n &gt; 0)&#123;</span><br><span class="line">                auto node = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                if(node-&gt;left != nullptr) q.push(node-&gt;left);</span><br><span class="line">                if(node-&gt;right != nullptr) q.push(node-&gt;right);</span><br><span class="line">                --n;</span><br><span class="line">            &#125;</span><br><span class="line">            ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>DFS 原来更简单</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// DFS</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxDepth(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return 0;</span><br><span class="line">        int l = maxDepth(root-&gt;left);</span><br><span class="line">        int r = maxDepth(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        return max(l + 1, r + 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="55-2-平衡二叉树"><a href="#55-2-平衡二叉树" class="headerlink" title="55-2_平衡二叉树"></a>55-2_平衡二叉树</h2><ul>
<li>110<ul>
<li>这题应该用递归好一点！</li>
<li>应该再加一个 深度 参数，报错了……</li>
<li>递归求出来的是 最大长度 而题目要求必须是每个节点都要平衡！要不再加一行递归，那这两个函数都递归岂不是重复了好多……<ul>
<li>先看看能不能过吧</li>
<li>雾草，还真可以</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/Offer/55-2.png" alt title="提交记录"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    // 写个求深度的函数，然后主函数调用</span><br><span class="line">    int maxDepth(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return 0;</span><br><span class="line">        int l = maxDepth(root-&gt;left);</span><br><span class="line">        int r = maxDepth(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        return max(l + 1, r + 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool isBalanced(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return true;</span><br><span class="line">        int l = maxDepth(root-&gt;left);</span><br><span class="line">        int r = maxDepth(root-&gt;right);</span><br><span class="line">        bool flag = abs(l - r) &lt; 2 ? true : false;</span><br><span class="line">        // 这里除了根节点平衡，其余节点也要平衡！</span><br><span class="line">        return flag &amp;&amp; isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>大佬题解也是这个思路<ul>
<li>比我写的还要简洁</li>
</ul>
</li>
</ul>
<h2 id="56-1-数组中数字出现的次数"><a href="#56-1-数组中数字出现的次数" class="headerlink" title="56-1_数组中数字出现的次数"></a>56-1_数组中数字出现的次数</h2><ul>
<li><p>其余数字出现两次，有且仅有两个数字出现一次</p>
</li>
<li><p>时空复杂度……想不出来</p>
<ul>
<li>想排个序，但好像没有符合要求的</li>
<li>看了题解：两个只出现一次的数字在不同的组中；相同的数字会被分到相同的组中。</li>
<li>之后跟二进制前缀和有点像，按照 1 和 0 来进行区分<ul>
<li>是随便选一个位为 1，来进行划分</li>
</ul>
</li>
</ul>
</li>
<li><p>算法</p>
</li>
</ul>
<p><img src="/pictrues/Offer/56-1.png" alt title="算法"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; singleNumbers(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int ret = 0;</span><br><span class="line">        for (int n : nums)</span><br><span class="line">            ret ^= n;</span><br><span class="line">        int div = 1;</span><br><span class="line">        while ((div &amp; ret) == 0)</span><br><span class="line">            div &lt;&lt;= 1;</span><br><span class="line">        // 说是分组其实是分别与两个数进行异或</span><br><span class="line">        int a = 0, b = 0;</span><br><span class="line">        for (int n : nums)</span><br><span class="line">            if (div &amp; n)</span><br><span class="line">                a ^= n;</span><br><span class="line">            else</span><br><span class="line">                b ^= n;</span><br><span class="line">        return vector&lt;int&gt;&#123;a, b&#125;; // 初始化</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="56-2-数组中数字出现的次数"><a href="#56-2-数组中数字出现的次数" class="headerlink" title="56-2_数组中数字出现的次数"></a>56-2_数组中数字出现的次数</h2><ul>
<li><p>其余数字出现三次，有且仅有一个数字出现一次</p>
<ul>
<li>上一题可以分组，那么这一题呢</li>
<li>看了大佬的题解，不是想着如何去异或，而是从各个二进制位入手，出现三次的数字，其各个二进制位的出现次数都是 3 的倍数</li>
<li>主要是如何统计二进制 1 的总个数，咳咳，在这儿之前还是得先异或，不对，不知道咋算</li>
<li>有限状态自动机……数字逻辑、真值表，都忘得差不多了<ul>
<li>好难理解…</li>
</ul>
</li>
</ul>
</li>
<li><p>时隔几日，再看一遍</p>
<ul>
<li>只看状态转移表还是很容易理解的，当状态为 10 时，也就是余数是 2，无论再来一个二进制位 0 或 1 下一个状态不是 10（余数 2） 就是 00（余数 0），也就是 one = 0；</li>
<li>上面是计算 one 的，计算 two 的公式就有点难以理解……</li>
<li>两个公式都是一个二进制位 n 来计算的，可以推广到 int 32 位，来并行计算！所以最后的代码很简洁，主要就是公式，而且是计算 two 的公式</li>
</ul>
</li>
<li><p>就是这里看不懂</p>
<ul>
<li>n 为 0 的时候，状态不是不变么，这里应该是 n 为 1 的时候</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/Offer/56-2.png" alt title="？？？"></p>
<ul>
<li>因为只有一个 出现一次的 数字，所以最后结果（状态）不是 00 就是 01，不会出现余数为 2 的情况</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int ones = 0, twos = 0;</span><br><span class="line">        for(auto n : nums)&#123;</span><br><span class="line">            ones = ones ^ n &amp; ~ twos;</span><br><span class="line">            twos = twos ^ n &amp; ~ ones;</span><br><span class="line">        &#125;</span><br><span class="line">        return ones;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="57-1-和为-s-的两个数字"><a href="#57-1-和为-s-的两个数字" class="headerlink" title="57-1_和为 s 的两个数字"></a>57-1_和为 s 的两个数字</h2><ul>
<li>这题倒是做出来了<ul>
<li>遍历第一个数字，之后用二分查找另一个，遍历的时候可以缩小范围</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        // 递增、二分</span><br><span class="line">        vector&lt;int&gt; ans;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        for(int i = 0; (nums[i] &lt; (target &gt;&gt; 1) + 1) &amp;&amp; i &lt; n; ++i)&#123;</span><br><span class="line">            int tmp = target - nums[i];</span><br><span class="line">            // 用二分找 tmp</span><br><span class="line">            int l = i + 1, r = n - 1;</span><br><span class="line">            int pos = -1;</span><br><span class="line">            while(l &lt;= r)&#123;</span><br><span class="line">                int mid = (r - l) / 2 + l;</span><br><span class="line">                if(nums[mid] == tmp)&#123;</span><br><span class="line">                    pos = mid;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;else if(nums[mid] &lt; tmp)&#123;</span><br><span class="line">                    l = mid + 1;</span><br><span class="line">                &#125;else if(nums[mid] &gt; tmp)&#123;</span><br><span class="line">                    r = mid - 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(pos != -1)&#123;</span><br><span class="line">                ans.push_back(nums[i]);</span><br><span class="line">                ans.push_back(tmp);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="57-2-和为-s-的连续正数序列"><a href="#57-2-和为-s-的连续正数序列" class="headerlink" title="57-2_和为 s 的连续正数序列"></a>57-2_和为 s 的连续正数序列</h2><ul>
<li>这题为什么标记为简单？<ul>
<li>简单吗？</li>
<li>既然是连续的数字，那就标记左右两端的数字，之后计算总和，好像和上题差不多……</li>
<li>有个注意点，子序列必须至少为两个数！</li>
<li>有点绕，确定一个数字后，要根据目标值计算出另一个，这样用二分才比较好找，但是要判断存不存在</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; findContinuousSequence(int target) &#123;</span><br><span class="line">        if(target &lt; 3) return vector&lt;vector&lt;int&gt;&gt;();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">        for(int i = 1; i &lt; (target + 1) / 2; ++i)&#123;</span><br><span class="line">            // 还是个二元方程</span><br><span class="line">            // (i + n) * (n - i + 1) / 2 == target;</span><br><span class="line">            // 找 n </span><br><span class="line">            int l = i + 1, r = (target + 1) / 2;</span><br><span class="line">            bool flag = false;</span><br><span class="line">            // 这里二分，因为要至少两个数，所以不能等于，</span><br><span class="line">            while(l &lt;= r)&#123;</span><br><span class="line">                int mid = (r - l) / 2 + l;</span><br><span class="line">                int tmp = (i + mid) * (mid - i + 1);</span><br><span class="line">                if(tmp == target * 2)&#123;</span><br><span class="line">                    flag = true;</span><br><span class="line">                    l = mid;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;else if(tmp &lt; target * 2)&#123;</span><br><span class="line">                    l = mid + 1;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    r = mid - 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(flag)&#123;</span><br><span class="line">                vector&lt;int&gt; m;</span><br><span class="line">                for(int j = i; j &lt;= l; ++j)&#123;</span><br><span class="line">                    m.emplace_back(j);</span><br><span class="line">                &#125;ans.emplace_back(m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>但是上面的代码不够优化，看看题解<ul>
<li>若区间 [l, r] 的和等于 target 那么 [l + 1, r] 的区间和必然小于 target，二分要从 r + 1 开始！</li>
</ul>
</li>
</ul>
<h2 id="58-1-翻转单词顺序"><a href="#58-1-翻转单词顺序" class="headerlink" title="58-1_翻转单词顺序"></a>58-1_翻转单词顺序</h2><ul>
<li>151<ul>
<li>这次用栈试试，可以一次过</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string reverseWords(string s) &#123;</span><br><span class="line">        // 以空格为单位，很容易想到用栈！之后多个空格要变为一个空格</span><br><span class="line">        if(s.empty()) return s;</span><br><span class="line">        stack&lt;string&gt; stk;</span><br><span class="line">        int pos = 0, n = s.size();</span><br><span class="line">        while(pos &lt; n)&#123;</span><br><span class="line">            // 为空格直接跳过</span><br><span class="line">            if(s[pos] != &apos; &apos;)&#123;</span><br><span class="line">                int tmp = pos + 1;</span><br><span class="line">                while(tmp &lt; n &amp;&amp; s[tmp] != &apos; &apos;)&#123;</span><br><span class="line">                    ++tmp;</span><br><span class="line">                &#125;</span><br><span class="line">                // 这里要么在边界，要么为空格，但是长度总是 tmp - pos</span><br><span class="line">                if(!stk.empty()) stk.push(&quot; &quot;);</span><br><span class="line">                stk.push(s.substr(pos, tmp - pos));</span><br><span class="line">                // 更新下标</span><br><span class="line">                pos = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            ++pos;</span><br><span class="line">        &#125;</span><br><span class="line">        // 恢复字符串</span><br><span class="line">        string ans;</span><br><span class="line">        while(!stk.empty())&#123;</span><br><span class="line">            ans += stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>题解思路差不多，也可以直接从后往前遍历，也就是双指针，这样好像更快一点！</li>
</ul>
<h2 id="58-2-左旋转字符串"><a href="#58-2-左旋转字符串" class="headerlink" title="58-2_左旋转字符串"></a>58-2_左旋转字符串</h2><ul>
<li>这题用 <code>substr()</code> 函数是不是不太好<ul>
<li>如果面试不给用，那就用交换，对，不过得交换三次！</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string reverseLeftWords(string s, int n) &#123;</span><br><span class="line">        // 前面若干个字符</span><br><span class="line">        if(s.empty() || n &lt; 1 || n &gt;= s.size()) return s;</span><br><span class="line">        // 注意 n 是个数，而不是下标，只不过这里可以当成下标</span><br><span class="line">        string cur(s.substr(0, n));</span><br><span class="line">        string pre(s.substr(n));</span><br><span class="line">        return pre + cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="59-1-滑动窗口的最大值"><a href="#59-1-滑动窗口的最大值" class="headerlink" title="59-1_滑动窗口的最大值"></a>59-1_滑动窗口的最大值</h2><ul>
<li>239<ul>
<li>当时这题没有做出来，这次估计也比较悬</li>
<li>用优先级队列看看</li>
<li>踩了几个坑，一个是边界一个是顺序，好歹可以过</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        // 边界问题</span><br><span class="line">        if(nums.empty()) return vector&lt;int&gt;();</span><br><span class="line">        // k 是滑动窗口的长度</span><br><span class="line">        unordered_map&lt;int, int&gt; map;</span><br><span class="line">        priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; q;</span><br><span class="line">        // 初始化</span><br><span class="line">        for(int i = 0; i &lt; k; ++i)&#123;</span><br><span class="line">            q.push(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; ans&#123;q.top()&#125;;</span><br><span class="line">        int l = 0, r = k;</span><br><span class="line">        // 报错了，这里顺序有点问题</span><br><span class="line">        while(r &lt; nums.size())&#123;</span><br><span class="line">            q.push(nums[r]);</span><br><span class="line">            map[nums[l]]++;</span><br><span class="line">            ++l;</span><br><span class="line">            // 更新答案吧</span><br><span class="line">            while(map.find(q.top()) != map.end())&#123;</span><br><span class="line">                if(map[q.top()] == 1)&#123;</span><br><span class="line">                    map.erase(q.top());</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    map[q.top()]--;</span><br><span class="line">                &#125;</span><br><span class="line">                q.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(q.top());</span><br><span class="line">            // 更新</span><br><span class="line">            ++r;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>题解写的更好，学习下<ul>
<li>优先级队列通过下标来确定在不在滑动窗口内！</li>
<li>定义可以直接这样写 <code>priority_queue&lt;pair&lt;int, int&gt;&gt; q;</code></li>
</ul>
</li>
</ul>
<h2 id="59-2-队列的最大值"><a href="#59-2-队列的最大值" class="headerlink" title="59-2_队列的最大值"></a>59-2_队列的最大值</h2><ul>
<li>这题有点眼熟！<ul>
<li>之前好像是有一题是栈的最大值？这题应该也是双队列，然后另一个队列就是存放对应的最大值</li>
<li>不太对，这是队列，队列弹出一个，后面的最大值可能都会跟着变</li>
<li>试试用优先级队列，因为有重复数字，所以应该用 <code>unordered_map</code> 而不是 <code>unordered_set</code></li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MaxQueue &#123;</span><br><span class="line">public:</span><br><span class="line">    MaxQueue() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    int max_value() &#123;</span><br><span class="line">        // 如果是已经删除的</span><br><span class="line">        while(!m.empty() &amp;&amp; map.find(m.top()) != map.end())&#123;</span><br><span class="line">            if(map[m.top()] == 1)&#123;</span><br><span class="line">                map.erase(m.top());</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                map[m.top()]--;</span><br><span class="line">            &#125;</span><br><span class="line">            m.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        if(m.empty()) return -1;</span><br><span class="line">        return m.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void push_back(int value) &#123;</span><br><span class="line">        q.push(value);</span><br><span class="line">        m.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int pop_front() &#123;</span><br><span class="line">        if(q.empty()) return -1;</span><br><span class="line">        auto tmp = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        map[tmp]++;</span><br><span class="line">        return tmp;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    queue&lt;int&gt; q;</span><br><span class="line">    priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; m;</span><br><span class="line">    // 这里数字会重复，应该用 map 好点</span><br><span class="line">    unordered_map&lt;int, int&gt; map;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="60-n-个骰子的点数"><a href="#60-n-个骰子的点数" class="headerlink" title="60_ n 个骰子的点数"></a>60_ n 个骰子的点数</h2><ul>
<li><p>每天刷题的时间感觉花的太多了，每晚十点开始刷是最好的，控制下时间，面试不过两小时四五道题</p>
<ul>
<li>若想多看看题解，那就提前半小时！</li>
<li>这题和的范围 1 * n ~ 6 * n（个数为 5 * n + 1 而不是 6 * n）</li>
<li>每个骰子都是独立同分布的并且是等概分布，关键在于 n 个</li>
</ul>
</li>
<li><p>看了评论，雾草这题面试会问到！</p>
<ul>
<li>看了答案才会！之后还得二刷，这里就不记录了</li>
</ul>
</li>
</ul>
<h2 id="61-扑克牌中的顺子"><a href="#61-扑克牌中的顺子" class="headerlink" title="61_扑克牌中的顺子"></a>61_扑克牌中的顺子</h2><ul>
<li>上一题暂时没做出来，先做这一题<ul>
<li>用了优先级队列，然后计算出需要几个 0 以及一共有几个 0</li>
<li>最后比较是否供大于需</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isStraight(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        // 这样吧，放入优先级队列，然后看差距，判断需要几个 0</span><br><span class="line">        priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; q;</span><br><span class="line">        for(auto num : nums)&#123;</span><br><span class="line">            q.push(num);</span><br><span class="line">        &#125;</span><br><span class="line">        // 初始化</span><br><span class="line">        int zeros = 0, pre = q.top(), need = 0;</span><br><span class="line">        q.pop();</span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            auto tmp = q.top();</span><br><span class="line">            q.pop();</span><br><span class="line">            if(tmp == 0)&#123;</span><br><span class="line">                zeros++;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if(tmp == pre)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                // 这里别忘了减一，因为不包括两边</span><br><span class="line">                if(pre - tmp != 1) need += (pre - tmp - 1);</span><br><span class="line">                // 这里别忘了更新 pre</span><br><span class="line">                pre = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // cout &lt;&lt; &quot;need = &quot; &lt;&lt; need &lt;&lt; &quot; zeros = &quot; &lt;&lt; zeros &lt;&lt; endl;</span><br><span class="line">        return need &lt;= zeros;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>看了题解，我觉得我想的有些复杂<ul>
<li>只需判断除 0 之外的最大值与最小值之间距离是不是小于 5 就行，当然遍历的时候还要判断是否重复</li>
</ul>
</li>
</ul>
<h2 id="62-圆圈中最后剩下的数字"><a href="#62-圆圈中最后剩下的数字" class="headerlink" title="62_圆圈中最后剩下的数字"></a>62_圆圈中最后剩下的数字</h2><ul>
<li>感觉我找不到规律……<ul>
<li>这真的是简单题嘛？</li>
</ul>
</li>
</ul>
<h2 id="63-股票的最大利润"><a href="#63-股票的最大利润" class="headerlink" title="63_股票的最大利润"></a>63_股票的最大利润</h2><ul>
<li>121<ul>
<li>这题堪称经典，这里只买卖一次，记得当时用的贪心或者动规</li>
<li>这题做完得复习下，买卖两次和三次的！</li>
<li>注意点，一天之内可以同时买卖</li>
<li>还有点进步，用了依次遍历 + 两个指标做出来了，第一次用的双重循环……</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        // 第一次买了还没卖、卖了，这里都初始化为 0 吧，不加负号了，有点绕</span><br><span class="line">        // buy 不能初始化为 0</span><br><span class="line">        int buy = INT32_MAX;</span><br><span class="line">        int sell = 0;</span><br><span class="line">        for(auto p : prices)&#123;</span><br><span class="line">            // 分别更新这两个指标</span><br><span class="line">            buy = min(buy, p);</span><br><span class="line">            sell = max(p - buy, sell);</span><br><span class="line">        &#125;</span><br><span class="line">        return sell;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="64-求-1-2-…-n"><a href="#64-求-1-2-…-n" class="headerlink" title="64_求 1 + 2 + … + n"></a>64_求 1 + 2 + … + n</h2><ul>
<li>还剩三题，连续好几天没看了</li>
<li>这题我？<ul>
<li>难道要用位运算吗</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int sumNums(int n) &#123;</span><br><span class="line">        // 这里递归很厉害，短路性质</span><br><span class="line">        n &amp;&amp; (n += sumNums(n-1));</span><br><span class="line">        return n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>方法二看不懂0.0</li>
</ul>
<h2 id="65-不用加减乘除做加法"><a href="#65-不用加减乘除做加法" class="headerlink" title="65_不用加减乘除做加法"></a>65_不用加减乘除做加法</h2><ul>
<li>这个学微机原理的时候，通过位运算来实现加法器，这题的思路应该就是这个了<ul>
<li>应该是取反码、补码进行位运算，然后再取补码的补码</li>
<li>补码是取反后加一</li>
<li>这里 C++ 负数不能左移应该是 LeetCode 环境的问题</li>
<li>关键点：如何取进位、若没有进位，直接异或、最后是循环进行</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    // 大佬的注释</span><br><span class="line">    int add(int a, int b) &#123;</span><br><span class="line">        // 因为不允许用 + 号，所以求出异或部分和进位部分依然不能用 + 号，所以只能循环到没有进位为止        </span><br><span class="line">        while(b != 0)&#123;</span><br><span class="line">            // 保存进位值，下次循环用</span><br><span class="line">            int c = (unsigned int)(a &amp; b) &lt;&lt; 1; // C++ 中负数不支持左移位，因为结果是不定的</span><br><span class="line">            // 保存不进位值，下次循环用，</span><br><span class="line">            a ^= b;</span><br><span class="line">            // 如果还有进位，再循环，如果没有，则直接输出没有进位部分即可。</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="66-构建乘积数组"><a href="#66-构建乘积数组" class="headerlink" title="66_构建乘积数组"></a>66_构建乘积数组</h2><ul>
<li>还可以，就是生成乘积前缀数组的时候要注意下标</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; constructArr(vector&lt;int&gt;&amp; a) &#123;</span><br><span class="line">        // 应该用乘积前缀，并且要有两个，一个从前往后，一个从后往前</span><br><span class="line">        int n = a.size();</span><br><span class="line">        vector&lt;int&gt; pre(n, 1);</span><br><span class="line">        vector&lt;int&gt; cur(n, 1);</span><br><span class="line"></span><br><span class="line">        for(int i = 1; i &lt; n; ++i)&#123;</span><br><span class="line">            pre[i] = pre[i - 1] * a[i - 1];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /*cout &lt;&lt; &quot;pre = &quot;;</span><br><span class="line">        copy(pre.begin(), pre.end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot;));</span><br><span class="line">        cout &lt;&lt; endl;*/</span><br><span class="line"></span><br><span class="line">        for(int i = n - 2; i &gt;= 0; --i)&#123;</span><br><span class="line">            cur[i] = cur[i + 1] * a[i + 1];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /*cout &lt;&lt; &quot;cur = &quot;;</span><br><span class="line">        copy(cur.begin(), cur.end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot;));</span><br><span class="line">        cout &lt;&lt; endl;*/</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt; b(n);</span><br><span class="line"></span><br><span class="line">        for(int i = 0; i &lt; n; ++i)&#123;</span><br><span class="line">            b[i] = pre[i] * cur[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>大佬写的很厉害<ul>
<li>分为上三角和下三角！</li>
</ul>
</li>
</ul>
<h2 id="67-把字符串转换成整数"><a href="#67-把字符串转换成整数" class="headerlink" title="67_把字符串转换成整数"></a>67_把字符串转换成整数</h2><ul>
<li>8<ul>
<li>怪不得似曾相识，这得考虑整数边界</li>
<li>这次处理的还行</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int strToInt(string&amp; str, int pos, int n, int sign) &#123;</span><br><span class="line">        long long ans = 0;</span><br><span class="line">        while(pos &lt; n &amp;&amp; isdigit(str[pos]))&#123;</span><br><span class="line">            ans = 10 * ans + (str[pos] - &apos;0&apos;);</span><br><span class="line">            if(ans * sign &gt;= INT32_MAX) return INT32_MAX;</span><br><span class="line">            if(ans * sign &lt;= INT32_MIN) return INT32_MIN;</span><br><span class="line">            ++pos;</span><br><span class="line">        &#125;</span><br><span class="line">        return static_cast&lt;int&gt;(sign * ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int strToInt(string str) &#123;</span><br><span class="line">        if(str.empty()) return 0;</span><br><span class="line">        int n = str.size();</span><br><span class="line">        int pos = 0;</span><br><span class="line">        while(pos &lt; n &amp;&amp; str[pos] == &apos; &apos;)&#123;</span><br><span class="line">            ++pos;</span><br><span class="line">        &#125;</span><br><span class="line">        if(pos == n) return 0;</span><br><span class="line"></span><br><span class="line">        // 这里开始提取有效数字</span><br><span class="line">        int sign = 1;</span><br><span class="line">        if(str[pos] == &apos;-&apos; || str[pos] == &apos;+&apos;)&#123;</span><br><span class="line">            sign = str[pos] == &apos;-&apos; ? -1 : 1;</span><br><span class="line">            return strToInt(str, pos + 1, n, sign);</span><br><span class="line">        &#125;else if(isdigit(str[pos]))&#123;</span><br><span class="line">            return strToInt(str, pos, n, sign);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>emmmmm，还可以再优化下！<ul>
<li>判断边界时，bndry = 2147483647 / 10 = 214748364</li>
<li>这里有个关键点，判断边界条件 <code>if(res &gt; bndry || res == bndry &amp;&amp; str[j] &gt; &#39;7&#39;)</code></li>
<li>直接根据符号位返回最大值还是最小值，这个 <code>&#39;7&#39;</code> 就很有灵性！</li>
</ul>
</li>
</ul>
<h2 id="68-1-二叉搜索树的最近公共祖先"><a href="#68-1-二叉搜索树的最近公共祖先" class="headerlink" title="68-1_二叉搜索树的最近公共祖先"></a>68-1_二叉搜索树的最近公共祖先</h2><ul>
<li>235<ul>
<li>愣是没看出来这题与下题的区别在哪儿，即使之前做过！</li>
<li>嗷嗷嗷，这是二叉搜索树！下一题是普通的二叉树</li>
<li>根据二叉搜索树的特性即可，递归很容易</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* ans;</span><br><span class="line"></span><br><span class="line">    void dfs(TreeNode* node, int p, int q)&#123;</span><br><span class="line">        // 这里应该不会遇见空节点，因为遇到 p 或者 q 就返回了</span><br><span class="line">        if(ans != nullptr) return;</span><br><span class="line">        if(node-&gt;val &gt;= p &amp;&amp; node-&gt;val &lt;= q)&#123;</span><br><span class="line">            ans = node;</span><br><span class="line">            return;</span><br><span class="line">        &#125;else if(node-&gt;val &gt; q)&#123;</span><br><span class="line">            dfs(node-&gt;left, p, q);</span><br><span class="line">        &#125;else if(node-&gt;val &lt; p)&#123;</span><br><span class="line">            dfs(node-&gt;right, p, q);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        // 这里要排下序</span><br><span class="line">        int a = p-&gt;val, b = q-&gt;val;</span><br><span class="line">        if(a &gt; b)&#123;</span><br><span class="line">            swap(a, b);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root, a, b);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>题解没有用递归也可以……<ul>
<li>二分查找！</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        // 这里没有比较大小，注意，这是一个技巧</span><br><span class="line">        TreeNode* ancestor = root;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            // 这里条件没有判断大小在两者之间</span><br><span class="line">            if (p-&gt;val &lt; ancestor-&gt;val &amp;&amp; q-&gt;val &lt; ancestor-&gt;val) &#123;</span><br><span class="line">                ancestor = ancestor-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (p-&gt;val &gt; ancestor-&gt;val &amp;&amp; q-&gt;val &gt; ancestor-&gt;val) &#123;</span><br><span class="line">                ancestor = ancestor-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ancestor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="68-2-二叉树的最近公共祖先"><a href="#68-2-二叉树的最近公共祖先" class="headerlink" title="68-2_二叉树的最近公共祖先"></a>68-2_二叉树的最近公共祖先</h2><ul>
<li>236<ul>
<li>这是普通的二叉树</li>
<li>似乎没有什么好的方法，分别记录到达这两个节点的路径，然后再找</li>
<li>这题存储父节点不能用 <code>vector</code>，因为谈出来的时候比较麻烦！</li>
<li>我去，我第一次是怎么做出来的？<ul>
<li>刷了这么多题，能力怎么下降了！</li>
<li>数组是全局变量，开头放入，最后弹出，不管左右子树中间！</li>
<li>改了一下，发现还是有问题！难受</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><ul>
<li>vector创建一个数组，要用<font color="#FF0000">大括号</font></li>
</ul>
<p><code>vector&lt;int&gt; nums = {2, 7, 11, 15};</code></p>
<h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1_两数之和"></a>1_两数之和</h2><ul>
<li>给定 nums = [2, 7, 11, 15], target = 9</li>
<li>返回 [0, 1]</li>
</ul>
<blockquote>
<p>C/C++</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int i,j;</span><br><span class="line">        for(i=0; i&lt;nums.size()-1; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(j=i+1;j&lt;nums.size();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(nums[i]+nums[j]==target)</span><br><span class="line">                &#123;</span><br><span class="line">                    return &#123;i,j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return &#123;&#125;;		//若没有答案返回空</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Solution s;</span><br><span class="line">    vector&lt;int&gt; nums = &#123;2, 7, 11, 15&#125;;</span><br><span class="line">    int target = 9;</span><br><span class="line">    std::cout &lt;&lt; s.twoSum(nums, target)[0] &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; s.twoSum(nums, target)[1] &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-正序数组中位数"><a href="#4-正序数组中位数" class="headerlink" title="4_正序数组中位数"></a>4_正序数组中位数</h2><ul>
<li>两个正序数组，找出中位数</li>
</ul>
<h3 id="归并法"><a href="#归并法" class="headerlink" title="归并法"></a>归并法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using  namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</span><br><span class="line">        // 归并</span><br><span class="line">        vector&lt;int&gt; num;</span><br><span class="line">        int i, j;</span><br><span class="line">        for(i = 0, j = 0; i &lt; nums1.size() &amp;&amp; j &lt; nums2.size();)&#123;</span><br><span class="line">            if(nums1[i] &gt; nums2[j])&#123;</span><br><span class="line">                num.push_back(nums2[j]);</span><br><span class="line">                j++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                num.push_back(nums1[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while (i &lt; nums1.size())&#123;</span><br><span class="line">            num.push_back(nums1[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        while (j &lt; nums2.size())&#123;</span><br><span class="line">            num.push_back(nums2[j]);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        int len = num.size();</span><br><span class="line">        if(len % 2 == 1)&#123;return num[len / 2];&#125; else &#123;</span><br><span class="line">            double m = num[len / 2 - 1] + num[len / 2];</span><br><span class="line">            return m / 2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; nums1 = &#123;3, 4&#125;;</span><br><span class="line">    vector&lt;int&gt; nums2 = &#123;1, 2&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    double l = solution.findMedianSortedArrays(nums1, nums2);</span><br><span class="line">    cout &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-盛最多水的容器"><a href="#10-盛最多水的容器" class="headerlink" title="10_盛最多水的容器"></a>10_盛最多水的容器</h2><ul>
<li>如图，两个指针，分别从左右两边向里遍历，哪个高度小，对应的指针移位一次</li>
</ul>
<p><img src="/pictrues/11.png" alt="题目描述" title="题目描述"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxArea(vector&lt;int&gt;&amp; height) &#123;</span><br><span class="line">        int area = 0, l = 0, r = (int)(height.size() - 1);  // 初始化双指针</span><br><span class="line">        while (l &lt; r)&#123;</span><br><span class="line">            int h = min(height[l], height[r]);</span><br><span class="line">            area = max(area, h * (r - l));	// 注意r和l的大小</span><br><span class="line">            if(height[l] &lt; height[r])&#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125; else r--;</span><br><span class="line">        &#125;</span><br><span class="line">        return area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; height = &#123;1, 8, 6, 2, 5, 4, 8, 3, 7&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    std::cout &lt;&lt; solution.maxArea(height) &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15_三数之和"></a>15_三数之和</h2><ul>
<li>先排序，再用三重循环或者双指针，需注意前两个元素不可重复</li>
<li>注意<code>continue</code>用法以及声明一个<font color="#FF0000">二维数组</font></li>
<li>输入<code>nums = [-1, 0, 1, 2, -1, -4]</code></li>
<li>输出<code>[[-1, 0, 1],[-1, -1, 2]]</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;    // sort()函数</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; vec;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        for(int i = 0; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            if(i &gt; 0 &amp;&amp; nums[i] == nums[i - 1])&#123;continue;&#125;  // 如果为真，则进入下一个循环</span><br><span class="line">            int k = (int)(nums.size()) - 1; // 每一次循环，都初始化k，只要前两个元素不出现重复，第三个元素就不会重复</span><br><span class="line">            for(int j = i + 1; j &lt; nums.size(); j++)&#123;</span><br><span class="line">                if(j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1])&#123;continue;&#125;</span><br><span class="line">                while (k &gt; j &amp;&amp; nums[i] + nums[j] + nums[k] &gt; 0)&#123;</span><br><span class="line">                    k--;</span><br><span class="line">                &#125;</span><br><span class="line">                if(k == j)&#123;break;&#125;</span><br><span class="line">                if(nums[i] + nums[j] + nums[k] == 0)&#123;</span><br><span class="line">                    vec.push_back(&#123;nums[i], nums[j], nums[k]&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; nums = &#123;-1, 0, 1, 2, -1, -4&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; vec = solution.threeSum(nums);</span><br><span class="line">    for(auto &amp; i : vec)&#123;</span><br><span class="line">        for(int j : i)&#123;</span><br><span class="line">            cout &lt;&lt; j;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16_最接近的三数之和"></a>16_最接近的三数之和</h2><ul>
<li>找出三个数使其和与target值最接近</li>
<li>一般推荐排序+双指针</li>
</ul>
<h3 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int sum = nums[1] + nums[2] + nums[3], sub = abs(nums[1] + nums[2] + nums[3] - target);</span><br><span class="line">        for(int i = 0; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            for(int j = i + 1; j &lt; nums.size(); j++)&#123;</span><br><span class="line">                for(int k = j + 1; k &lt; nums.size(); k++)&#123;</span><br><span class="line">                    if(abs(nums[i] + nums[j] + nums[k] - target) &lt; sub)&#123;</span><br><span class="line">                        sum = nums[i] + nums[j] + nums[k];</span><br><span class="line">                        sub = abs(nums[i] + nums[j] + nums[k] - target);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; s = &#123;-1, 2, 1, 4&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    std::cout &lt;&lt; solution.threeSumClosest(s, 0) &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        int sum = 1e7;</span><br><span class="line">        int len = nums.size();</span><br><span class="line">        for(int i = 0; i &lt; len; i++)&#123;</span><br><span class="line">            if(i &gt; 0 &amp;&amp; nums[i] == nums[i - 1])&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            int j = i + 1, k = len - 1;</span><br><span class="line">            while (j &lt; k)&#123;</span><br><span class="line">                if(nums[i] + nums[j] + nums[k] == target)&#123;</span><br><span class="line">                    return target;</span><br><span class="line">                &#125;</span><br><span class="line">                if(abs(sum - target) &gt; abs(nums[i] + nums[j] + nums[k] - target))&#123;</span><br><span class="line">                    sum = nums[i] + nums[j] + nums[k];</span><br><span class="line">                &#125;</span><br><span class="line">                if(nums[i] + nums[j] + nums[k] &gt; target)&#123;</span><br><span class="line">                    int k0 = k - 1;</span><br><span class="line">                    while (j &lt; k0 &amp;&amp; nums[k0] == nums[k0 + 1])&#123;</span><br><span class="line">                        k0--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    k = k0;</span><br><span class="line">                &#125; else&#123;</span><br><span class="line">                    int j0 = j + 1;</span><br><span class="line">                    while (j0 &lt; k &amp;&amp; nums[j0] == nums[j0 - 1])&#123;</span><br><span class="line">                        j0++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    j = j0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; s = &#123;-1, 2, 1, 4&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    std::cout &lt;&lt; solution.threeSumClosest(s, 0) &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17_电话号码的字母组合"></a>17_电话号码的字母组合</h2><ul>
<li>先把第一个数字对应的几个字母分开放入输出字符串数组<code>res</code>中</li>
<li>之后每遍历一个数字，<code>res</code>对应的元素与数字对应的字母分别相加，存放在<code>tmp</code>中，</li>
<li>最后更新<code>res</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution1 &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; letterCombinations(string digits) &#123;</span><br><span class="line">        if(digits.empty())&#123;return &#123;&#125;;&#125;</span><br><span class="line">        vector&lt;string&gt; s = &#123;&quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;&#125;;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        int k = 0, pos = (digits[0] - &apos;0&apos;) - 2;</span><br><span class="line">        while (k &lt; s[pos].size())&#123;</span><br><span class="line">            char ch = s[pos][k];</span><br><span class="line">            string l;     // string是指针类型</span><br><span class="line">            l.append(1, ch);</span><br><span class="line">            res.push_back(l);</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        int len = 1;</span><br><span class="line">        while (len &lt; digits.size())&#123;</span><br><span class="line">            vector&lt;string&gt; tmp;</span><br><span class="line">            for(int i = 0; i &lt; res.size(); i++)&#123;</span><br><span class="line">                int d = digits[len] - &apos;0&apos;;</span><br><span class="line">                d -= 2;</span><br><span class="line">                for(int j = 0; j &lt; s[d].size(); j++)&#123;</span><br><span class="line">                    string l1;</span><br><span class="line">                    l1.append(res[i] + s[d][j]);</span><br><span class="line">                    tmp.push_back(l1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res = tmp;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    string digit = &quot;26&quot;;</span><br><span class="line">    Solution1 solution;</span><br><span class="line">    vector&lt;string&gt; res = solution.letterCombinations(digit);</span><br><span class="line">    for(auto &amp; re : res)&#123;</span><br><span class="line">        for(char j : re)&#123;</span><br><span class="line">            cout &lt;&lt; j;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18_四数之和"></a>18_四数之和</h2><ul>
<li>三数之和前两个数字确定后，第三个数是唯一确定的</li>
<li>四数之和前两个数字确定后，后两个数字不唯一，满足条件后，要继续遍历(注意重复)</li>
<li>第一位数字确定后，第二位数字都是从<code>i+1</code>开始，<code>nums[j]</code>一确定，后面就已罗列出所有不重复的可能性，因此第二重循环再次确定<code>nums[j]</code>时，要与之前的不一样</li>
<li><code>nums[i]</code>同理</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        for(int i = 0; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            if(i &gt; 0 &amp;&amp; nums[i] == nums[i - 1])&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int j = i +1; j &lt; nums.size(); j++)&#123;</span><br><span class="line">                if(j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1])&#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                int k = j + 1, l = nums.size();</span><br><span class="line">                l--;</span><br><span class="line">                while (k &lt; l)&#123;</span><br><span class="line">                    int sum = nums[i] + nums[j] + nums[k] + nums[l];</span><br><span class="line">                    if(sum == target)&#123;</span><br><span class="line">                        res.push_back(&#123;nums[i], nums[j], nums[k], nums[l]&#125;);</span><br><span class="line">                        int k0 = k + 1;</span><br><span class="line">                        while (k0 &lt; l &amp;&amp; nums[k0] == nums[k])&#123;</span><br><span class="line">                            k0++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        k = k0;</span><br><span class="line">                    &#125; else if(sum &gt; target)&#123;</span><br><span class="line">                        int l0 = l - 1;</span><br><span class="line">                        while (l0 &gt; k &amp;&amp; nums[l0] == nums[l])&#123;</span><br><span class="line">                            l0--;</span><br><span class="line">                        &#125;</span><br><span class="line">                        l = l0;</span><br><span class="line">                    &#125; else&#123;</span><br><span class="line">                        int k0 = k + 1;</span><br><span class="line">                        while (k0 &lt; l &amp;&amp; nums[k0] == nums[k])&#123;</span><br><span class="line">                            k0++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        k = k0;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; nums = &#123;-3, -2, -1, 0, 0, 1, 2, 3&#125;;</span><br><span class="line">    int target = 0;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; res = solution.fourSum(nums, target);</span><br><span class="line">    for(const auto&amp; re : res)&#123;</span><br><span class="line">        for(auto num : re)&#123;</span><br><span class="line">            cout &lt;&lt; num;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; &quot;,&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22_括号生成"></a>22_括号生成</h2><ul>
<li>先用递归生成所有可能性的括号，再判断其是否有效</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool valid(string &amp;cur)&#123;</span><br><span class="line">        unordered_map&lt;char, char&gt; map&#123;</span><br><span class="line">                &#123;&apos;)&apos;, &apos;(&apos;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        stack&lt;char&gt; stc;</span><br><span class="line">        for(char ch : cur)&#123;</span><br><span class="line">            if(map.count(ch))&#123;</span><br><span class="line">                if(stc.empty())&#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">                stc.pop();</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                stc.push(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stc.empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void generateALL(int n, string &amp;cur, vector&lt;string&gt; &amp;res)&#123;</span><br><span class="line">        if(cur.size() == n)&#123;</span><br><span class="line">            if(valid(cur))&#123;</span><br><span class="line">                res.push_back(cur);</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        cur += &apos;(&apos;;</span><br><span class="line">        generateALL(n, cur, res);</span><br><span class="line">        cur.pop_back();</span><br><span class="line">        cur += &apos;)&apos;;</span><br><span class="line">        generateALL(n, cur, res);</span><br><span class="line">        cur.pop_back();     // 返回上一次递归，删除一个保持长度不变</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;string&gt; generateParenthesis(int n)&#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        string cur;</span><br><span class="line">        n *= 2;     //  肯定为偶数</span><br><span class="line">        generateALL(n, cur, res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;string&gt; s = solution.generateParenthesis(2);</span><br><span class="line">    for(string l : s)&#123;</span><br><span class="line">        for(char ch : l)&#123;</span><br><span class="line">            cout &lt;&lt; ch;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; &quot;   &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="26-删除排序数组中的重复项"><a href="#26-删除排序数组中的重复项" class="headerlink" title="26_删除排序数组中的重复项"></a>26_删除排序数组中的重复项</h2><ul>
<li>被我搞复杂了，用双指针已经有<code>len=1</code>却又在循环里定义了个<code>j=i+1</code>，直接在开头定义<code>i=0</code>即可，返回<code>i+1</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if(nums.empty())&#123;return 0;&#125;</span><br><span class="line">        int i = 0;</span><br><span class="line">        for(int j = 0; j &lt; nums.size(); j++)&#123;</span><br><span class="line">            if(nums[j] != nums[i])&#123;</span><br><span class="line">                nums[i + 1] = nums[j];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return i + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; nums = &#123;0, 0, 1, 1, 1, 2, 2, 3, 3, 4&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    int len = solution.removeDuplicates(nums);</span><br><span class="line">    for(int i = 0; i &lt; len; i++)&#123;</span><br><span class="line">        std::cout &lt;&lt; nums[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27_移除元素"></a>27_移除元素</h2><ul>
<li>又又又被我搞复杂了，没错在下算出了要移除元素的个数，然后剩下的元素整体搬到移除元素的起点@#￥%……&amp;*</li>
<li>双指针真的好简单啊，连排序都用不到</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;</span><br><span class="line">        int i = 0;</span><br><span class="line">        for (int j = 0; j &lt; nums.size(); j++) &#123;</span><br><span class="line">            if (nums[j] != val) &#123;</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;int&gt; nums = &#123;0, 1, 2, 2, 3, 0, 4, 2&#125;;</span><br><span class="line">    int val = 2;</span><br><span class="line">    int len = solution.removeElement(nums, val);</span><br><span class="line">    for(int i = 0; i &lt; len; i++)&#123;</span><br><span class="line">        std::cout &lt;&lt; nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31_下一个排列"></a>31_下一个排列</h2><ul>
<li>对字典序列不了解，我是直接看算法的，首先考虑特殊情况，<code>nums</code>为空或者只有一个数字，直接<code>return</code>，(等等，这步可以跳过)</li>
<li>从右往左找两次，一次小的一次大的，交换再排序，用<code>swap</code></li>
<li>翻转次序直接调用函数<code>reverse</code>，<code>#include &lt;algorithm&gt;</code>，淦！</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">        void nextPermutation(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">            int i = nums.size() - 2;</span><br><span class="line">            while (i &gt;= 0 &amp;&amp; nums[i] &gt;= nums[i + 1]) &#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            if (i &gt;= 0) &#123;</span><br><span class="line">                int j = nums.size() - 1;</span><br><span class="line">                while (j &gt;= 0 &amp;&amp; nums[i] &gt;= nums[j]) &#123;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">                swap(nums[i], nums[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            reverse(nums.begin() + i + 1, nums.end());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; nums = &#123;1, 5, 1&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    solution.nextPermutation(nums);</span><br><span class="line">    for(int n : nums)&#123;</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33_搜索旋转排序数组"></a>33_搜索旋转排序数组</h2><ul>
<li>看题解是有时间复杂度要求的，愣了一下，也是，不然一次遍历就可以解决为什么会标中等难度呢</li>
<li>每次从中间查找，左右两段必有一个完全升序，这里分两种情况</li>
<li>左边完全升序：判断<code>target</code>在不在，在更新<code>r</code>，不在更新<code>l</code></li>
<li>右边完全升序：判断<code>target</code>在不在，在更新<code>l</code>，不在更新<code>r</code></li>
</ul>
<h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int search(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        int l = 0, r = n - 1;</span><br><span class="line">        while (l &lt;= r)&#123;</span><br><span class="line">            int mid = (r + l) / 2;</span><br><span class="line">            if(nums[mid] == target)&#123;return mid;&#125;</span><br><span class="line">            if(nums[l] &lt;= nums[mid])&#123;</span><br><span class="line">                if(target &gt;= nums[l] &amp;&amp; target &lt; nums[mid])&#123;</span><br><span class="line">                    r = mid - 1;</span><br><span class="line">                &#125; else&#123;</span><br><span class="line">                    l = mid + 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                if(target &gt; nums[mid] &amp;&amp; target &lt;= nums[r])&#123;</span><br><span class="line">                    l = mid + 1;</span><br><span class="line">                &#125; else&#123;</span><br><span class="line">                    r = mid - 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; nums = &#123;6, 4, 5&#125;;</span><br><span class="line">    int target = 5;</span><br><span class="line">    Solution solution;</span><br><span class="line">    std::cout &lt;&lt; solution.search(nums, target) &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34_在排序数组中查找元素的第一个和最后一个位置"></a>34_在排序数组中查找元素的第一个和最后一个位置</h2><ul>
<li><font color="#FF0000">排序有关，首推二分</font></li>
<li>我是先用二分法找到<code>target</code>，如果没有，直接返回<code>{-1,-1}</code>，找到之后在遍历左右两边等于<code>target</code>的个数，后来想了想，万一整个数组都是<code>target</code>，不就是遍历吗</li>
<li>看了题解才知道，要用二分法找两次，一次是第一个<font color="#FF0000">大于等于</font><code>target</code>的下标，另一次是第一个<font color="#FF0000">大于</font><code>target</code>的下标</li>
<li>找的时候要仔细思考其内在逻辑，判断条件是大于还是大于等于，诸如此类</li>
</ul>
<h3 id="二分法-1"><a href="#二分法-1" class="headerlink" title="二分法"></a>二分法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int search(vector&lt;int&gt;&amp; nums, int target, bool f)&#123;</span><br><span class="line">        int len = nums.size(), ans = len;   // 如果目标在最后，ans初始化为len，不能减一，要始终大于target</span><br><span class="line">        int l = 0, r = len - 1;</span><br><span class="line">        while (l &lt;= r)&#123;</span><br><span class="line">            int mid = (l + r) / 2;</span><br><span class="line">            if(nums[mid] &lt; target || (nums[mid] &lt;= target &amp;&amp; f))&#123;</span><br><span class="line">                l = mid + 1;</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                r = mid - 1;</span><br><span class="line">                ans = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int a = search(nums, target, false);</span><br><span class="line">        int b = search(nums, target, true) - 1;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">        if(a &lt;= b &amp;&amp; b &lt; nums.size() &amp;&amp; nums[b] == target &amp;&amp; nums[a] == target)&#123;</span><br><span class="line">            return &#123;a, b&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        return &#123;-1, -1&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; nums = &#123;8&#125;;</span><br><span class="line">    int target = 8;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;int&gt; pos = solution.searchRange(nums, target);</span><br><span class="line">    for(int n : pos)&#123;</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35_搜索插入位置"></a>35_搜索插入位置</h2><ul>
<li>根据前一题的思路，我采用找出第一个比<code>target</code>大的值，当然如果有等于，则直接返回下标</li>
<li>插入时，这个第一个比<code>target</code>大的值的下标就是返回的值</li>
</ul>
<h3 id="二分法-2"><a href="#二分法-2" class="headerlink" title="二分法"></a>二分法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        if(nums.empty())&#123;return 0;&#125;</span><br><span class="line">        int len = nums.size(), ans = len;</span><br><span class="line">        int l = 0, r = len - 1;</span><br><span class="line">        while (l &lt;= r)&#123;</span><br><span class="line">            int mid = (l + r) / 2;</span><br><span class="line">            if(nums[mid] == target)&#123;return mid;&#125;</span><br><span class="line">            if(nums[mid] &lt; target)&#123;</span><br><span class="line">                l = mid + 1;</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                r = mid - 1;</span><br><span class="line">                ans = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; nums = &#123;10&#125;;</span><br><span class="line">    int target = 2;</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.searchInsert(nums, target) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="36-有效的数独"><a href="#36-有效的数独" class="headerlink" title="36_有效的数独"></a>36_有效的数独</h2><ul>
<li>一开始用的三次遍历，三个条件各一次，看了题解一次遍历即可</li>
<li>如果用哈希表，那么每一行每一列每一个子数独都要用到哈希表，一共27个</li>
<li>看来别人的答案，可以用三个二维数组，同样判断个数是否大于1</li>
<li>对应的位置不会变，例如相同的<font color="#FF0000">行数</font>，列不同，<font color="#FF0000">字符</font>一样，那么对于维护行的二维数组定位一样</li>
<li><code>(r / 3) * 3</code>注意一下与<code>r</code>不一样，前者是3的倍数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;</span><br><span class="line">        vector&lt;unordered_map&lt;char, int&gt;&gt; row(9);</span><br><span class="line">        vector&lt;unordered_map&lt;char, int&gt;&gt; column(9);</span><br><span class="line">        vector&lt;unordered_map&lt;char, int&gt;&gt; box(9);</span><br><span class="line">        for(int r = 0; r &lt; 9; r++)&#123;</span><br><span class="line">            for(int c = 0; c &lt; 9; c++)&#123;</span><br><span class="line">                if(isdigit(board[r][c]))&#123;</span><br><span class="line">                    row[r][board[r][c]]++;</span><br><span class="line">                    column[c][board[r][c]]++;</span><br><span class="line">                    int n = (r / 3) * 3 + c / 3;</span><br><span class="line">                    box[n][board[r][c]]++;</span><br><span class="line">                    if(row[r][board[r][c]] &gt; 1 || column[c][board[r][c]] &gt; 1 || box[n][board[r][c]] &gt; 1)&#123;</span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int r = 9, c = 9;   // 行数 列数</span><br><span class="line">    vector&lt;vector&lt;char&gt;&gt; board(r, vector&lt;char&gt;(c, &apos;.&apos;));    //初始化二维数组</span><br><span class="line">    board[0][2] = &apos;4&apos;; board[0][6] = &apos;6&apos;; board[0][7] = &apos;3&apos;;</span><br><span class="line">    board[2][0] = &apos;5&apos;; board[2][7] = &apos;9&apos;; //board[1][4] = &apos;9&apos;; board[1][5] = &apos;5&apos;;</span><br><span class="line">    board[3][3] = &apos;5&apos;; board[3][4] = &apos;6&apos;; //board[2][7] = &apos;6&apos;;</span><br><span class="line">    board[4][0] = &apos;9&apos;; board[4][2] = &apos;3&apos;; board[4][8] = &apos;1&apos;;</span><br><span class="line">    board[5][3] = &apos;6&apos;;</span><br><span class="line">    board[6][3] = &apos;8&apos;;</span><br><span class="line">    for(auto ch_r : board)&#123;</span><br><span class="line">        for(char ch_c : ch_r)&#123;</span><br><span class="line">            cout &lt;&lt; ch_c &lt;&lt; &quot;  &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.isValidSudoku(board) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="37-解数独"><a href="#37-解数独" class="headerlink" title="37_解数独"></a>37_解数独</h2><ul>
<li>首先我想到的是遍历，遍历的同时判断是否有效，有效就下一个，无效就填入下一个数字，所有数字都不对，那就emmmmmmmmm</li>
<li>想法是美好的，写起来很困难，其一：对数独进行一次遍历，要先判断是否为空，这样才能写入数字，写入数字也要从1-9开始循环</li>
<li>开头有了两个<code>for</code>循环，对于1-9用的<code>while</code>，再调用判断是否有效函数，后来发现这个过程是<font color="#FF0000">不可逆</font>的，如果这个格子里1-9数字都不对，那怎么修改上一个空格的数字呢</li>
<li>用<code>if</code>？记录空格子的位置？要想<font color="#FF0000">回溯</font>，还得用递归</li>
<li>记录空格子的位置，方便直接操作，递归函数用的<code>bool</code>，每次递归都从数字1-9遍历，首先第一个空格子，先判断是否有效，有效，写入数字1，&lt;font color=#</li>
<li>6600&gt;递归下一个格子，如果下一个格子一直有效，那么会递归到最后一个格子，也就是出口；如果下一个格子无效，那么<font color="#FF0000">擦除</font>数字1即可，之后会从数字2开始</li>
<li>理解进一步加深，别看我还在第一个格子数字1，其实后面所有情况我都已经遍历完了；复杂度确实比较高，可以再优化下：比如将判断有效函数与递归结合起来，用<font color="#00FF00">三个</font>二维数组，默认值都是0，在记录空格子的位置时，同时将<font color="#FF0000">各行各列各个九宫格</font>出现的数字记录，即二维数组取值1，表示出现过，之后就看这个数有没有出现就行，记得回溯上一个递归时，别忘了<font color="#0000FF">“擦除”</font></li>
<li>为什么要优化呢，因为我超出时间限制了</li>
</ul>
<h3 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h3><ul>
<li>二维数组赋值的时候要一次性赋值，如果是一个一个赋值会失败，这是坑吗？</li>
<li>我在下面注释了，我仔细观察了，在第二行第九列遍历数字的时候，应该在8停下，进入下一个递归，(当然前面都是对的)，但是判断的时候，却是显示第九列已经有了8，，，，希望哪位有缘人能解惑</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;pair&lt;int, int&gt;&gt; pos;</span><br><span class="line">    bool row[9][9];</span><br><span class="line">    bool column[9][9];</span><br><span class="line">    bool box[9][9];</span><br><span class="line">public:</span><br><span class="line">    bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int index) &#123;</span><br><span class="line">        if(index == pos.size())&#123;return true;&#125;   //递归出口</span><br><span class="line">        int r_in = pos[index].first, c_in = pos[index].second;  //当前位置</span><br><span class="line">        for(int number = 1; number &lt; 10; number++)&#123;</span><br><span class="line">            if(!row[r_in][number - 1] &amp;&amp; !column[c_in][number - 1] &amp;&amp; !box[r_in / 3 * 3 + c_in / 3][number - 1])&#123;</span><br><span class="line">                board[r_in][c_in] = number + &apos;0&apos;;</span><br><span class="line">                row[r_in][number - 1] = true;</span><br><span class="line">                column[c_in][number - 1] = true;</span><br><span class="line">                box[r_in / 3 * 3 + c_in / 3][number - 1] = true;</span><br><span class="line">                if(dfs(board, index + 1))&#123;return true;&#125;</span><br><span class="line">                row[r_in][number - 1] = false;</span><br><span class="line">                column[c_in][number - 1] = false;</span><br><span class="line">                box[r_in / 3 * 3 + c_in / 3][number - 1] = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;</span><br><span class="line">        for(int r = 0; r &lt; 9; r++) &#123;</span><br><span class="line">            for (int c = 0; c &lt; 9; c++) &#123;</span><br><span class="line">                if(!isdigit(board[r][c]))&#123;</span><br><span class="line">                    pos.emplace_back(r, c);</span><br><span class="line">                &#125; else&#123;</span><br><span class="line">                    unordered_map&lt;char, int&gt; m1;</span><br><span class="line">                    row[r][board[r][c] - &apos;0&apos; - 1] = true;</span><br><span class="line">                    column[c][board[r][c] - &apos;0&apos; - 1] = true;</span><br><span class="line">                    box[r / 3 * 3 + c / 3][board[r][c] - &apos;0&apos; - 1] = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(board, 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;vector&lt;char&gt;&gt; board(9, vector&lt;char&gt;(9, &apos;.&apos;));    //初始化二维数组</span><br><span class="line">    board = &#123;&#123;&apos;5&apos;,&apos;3&apos;,&apos;.&apos;,&apos;.&apos;,&apos;7&apos;,&apos;.&apos;,&apos;.&apos;,&apos;.&apos;,&apos;.&apos;&#125;,</span><br><span class="line">             &#123;&apos;6&apos;,&apos;.&apos;,&apos;.&apos;,&apos;1&apos;,&apos;9&apos;,&apos;5&apos;,&apos;.&apos;,&apos;.&apos;,&apos;.&apos;&#125;,</span><br><span class="line">             &#123;&apos;.&apos;,&apos;9&apos;,&apos;8&apos;,&apos;.&apos;,&apos;.&apos;,&apos;.&apos;,&apos;.&apos;,&apos;6&apos;,&apos;.&apos;&#125;,</span><br><span class="line">             &#123;&apos;8&apos;,&apos;.&apos;,&apos;.&apos;,&apos;.&apos;,&apos;6&apos;,&apos;.&apos;,&apos;.&apos;,&apos;.&apos;,&apos;3&apos;&#125;,</span><br><span class="line">             &#123;&apos;4&apos;,&apos;.&apos;,&apos;.&apos;,&apos;8&apos;,&apos;.&apos;,&apos;3&apos;,&apos;.&apos;,&apos;.&apos;,&apos;1&apos;&#125;,</span><br><span class="line">             &#123;&apos;7&apos;,&apos;.&apos;,&apos;.&apos;,&apos;.&apos;,&apos;2&apos;,&apos;.&apos;,&apos;.&apos;,&apos;.&apos;,&apos;6&apos;&#125;,</span><br><span class="line">             &#123;&apos;.&apos;,&apos;6&apos;,&apos;.&apos;,&apos;.&apos;,&apos;.&apos;,&apos;.&apos;,&apos;2&apos;,&apos;8&apos;,&apos;.&apos;&#125;,</span><br><span class="line">             &#123;&apos;.&apos;,&apos;.&apos;,&apos;.&apos;,&apos;4&apos;,&apos;1&apos;,&apos;9&apos;,&apos;.&apos;,&apos;.&apos;,&apos;5&apos;&#125;,</span><br><span class="line">             &#123;&apos;.&apos;,&apos;.&apos;,&apos;.&apos;,&apos;.&apos;,&apos;8&apos;,&apos;.&apos;,&apos;.&apos;,&apos;7&apos;,&apos;9&apos;&#125;&#125;;</span><br><span class="line"></span><br><span class="line">	// 有缘人可以试下</span><br><span class="line">//    board[1][0] = &apos;6&apos;; board[1][3] = &apos;1&apos;; board[1][4] = &apos;9&apos;; board[1][5] = &apos;5&apos;;</span><br><span class="line">//    board[2][1] = &apos;9&apos;; board[2][2] = &apos;8&apos;; board[2][7] = &apos;6&apos;;</span><br><span class="line">//    board[3][1] = &apos;8&apos;; board[3][4] = &apos;6&apos;; board[3][8] = &apos;3&apos;;</span><br><span class="line">//    board[4][0] = &apos;4&apos;; board[4][3] = &apos;8&apos;; board[4][5] = &apos;3&apos;; board[4][8] = &apos;1&apos;;</span><br><span class="line">//    board[5][0] = &apos;7&apos;; board[5][4] = &apos;2&apos;; board[5][8] = &apos;6&apos;;</span><br><span class="line">//    board[6][1] = &apos;6&apos;; board[6][6] = &apos;2&apos;; board[6][7] = &apos;8&apos;;</span><br><span class="line">//    board[7][3] = &apos;4&apos;; board[7][4] = &apos;1&apos;; board[7][5] = &apos;9&apos;; board[7][8] = &apos;5&apos;;</span><br><span class="line">//    board[8][4] = &apos;8&apos;; board[8][7] = &apos;7&apos;; board[8][8] = &apos;9&apos;;</span><br><span class="line"></span><br><span class="line">    for(int r = 0; r &lt; 9; r++) &#123;</span><br><span class="line">        for (int c = 0; c &lt; 9; c++) &#123;</span><br><span class="line">            cout &lt;&lt; board[r][c] &lt;&lt; &quot;  &quot;;</span><br><span class="line">            if(c == 2 || c == 5)&#123;</span><br><span class="line">                cout &lt;&lt; &quot;  &quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        if(r == 2 || r == 5)&#123;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    Solution solution;</span><br><span class="line">    solution.solveSudoku(board);</span><br><span class="line">    for(int r = 0; r &lt; 9; r++) &#123;</span><br><span class="line">        for (int c = 0; c &lt; 9; c++) &#123;</span><br><span class="line">            cout &lt;&lt; board[r][c] &lt;&lt; &quot;  &quot;;</span><br><span class="line">            if(c == 2 || c == 5)&#123;</span><br><span class="line">                cout &lt;&lt; &quot;  &quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        if(r == 2 || r == 5)&#123;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39_组合总和"></a>39_组合总和</h2><ul>
<li>回溯永远的神！当时就如何把潜在的值放入数组，并且之后还可以删除百思不得其解，看了题解，有种了然的感觉</li>
</ul>
<h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void dfs(vector&lt;int&gt;&amp; candidates, int target, vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; tmp, int i)&#123;</span><br><span class="line">        if(i == candidates.size())&#123;return;&#125;</span><br><span class="line">        if(target == 0)&#123;</span><br><span class="line">            res.emplace_back(tmp);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(candidates, target, res, tmp, i + 1);</span><br><span class="line">        if(target - candidates[i] &gt;= 0)&#123;</span><br><span class="line">            tmp.push_back(candidates[i]);</span><br><span class="line">            dfs(candidates, target - candidates[i], res, tmp, i);</span><br><span class="line">            tmp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target)&#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;    //存放结果</span><br><span class="line">        vector&lt;int&gt; tmp;    //每一节树枝暂时存放的结果</span><br><span class="line">        int i = 0;  //数组起始位置</span><br><span class="line">        dfs(candidates, target, res, tmp, i);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; candidates = &#123;2, 3, 6, 7&#125;;</span><br><span class="line">    int target = 7;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; res = solution.combinationSum(candidates, target);</span><br><span class="line">    for(const auto&amp; i : res)&#123;</span><br><span class="line">        for(auto j : i)&#123;</span><br><span class="line">            cout &lt;&lt; j;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="40-组合总和"><a href="#40-组合总和" class="headerlink" title="40_组合总和 ||"></a>40_组合总和 ||</h2><ul>
<li>这题深陷上一题的框架里，递归或者回溯，先捋一捋感觉就是本来会递归的，加上回溯之后，就不会了</li>
<li>有几点要注意下，在递归传递参数的时候，比如记录结果的数组，如果参数比较多，可以在类里单独声明属性，这样就可以不用&amp;带了</li>
<li>回溯的时候，一般都是先放入，回溯后，还要再拿出来</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">    vector&lt;int&gt; tmp;</span><br><span class="line">public:</span><br><span class="line">    void dfs(vector&lt;int&gt;&amp; candidates, int target, int i)&#123;</span><br><span class="line">        if(target == 0)&#123;</span><br><span class="line">            res.emplace_back(tmp);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int j = i; j &lt; candidates.size(); j++)&#123;</span><br><span class="line">            if(j &gt; i &amp;&amp; candidates[j] == candidates[j - 1])&#123;continue;&#125;</span><br><span class="line">            if(target - candidates[j] &gt;= 0)&#123;</span><br><span class="line">                tmp.push_back(candidates[j]);</span><br><span class="line">                dfs(candidates, target - candidates[j], j + 1);</span><br><span class="line">                tmp.pop_back();     //回溯后删除</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123;</span><br><span class="line">        sort(candidates.begin(), candidates.end());     //先排序</span><br><span class="line">        dfs(candidates, target, 0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; candidates = &#123;2, 2, 2, 2, 2&#125;;</span><br><span class="line">    int target = 8;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; res = solution.combinationSum2(candidates, target);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    for(auto re : res)&#123;</span><br><span class="line">        for(int r : re)&#123;</span><br><span class="line">            cout &lt;&lt; r;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="41-缺失的第一个正数"><a href="#41-缺失的第一个正数" class="headerlink" title="41_缺失的第一个正数"></a>41_缺失的第一个正数</h2><ul>
<li>第一个循环对数组<code>nums</code>的负数取正，第二个循环判断是否小于<code>n</code>，判断的时候怎么还有负数？我？？？？？？</li>
<li>咳咳，是我太菜了，第二个循环是加负号，并不是原地加，而是<code>nums[nums[j] - 1]</code>这个数，还没有遍历到他，他就变成负数了</li>
<li>第二个循环就不要更改数组了，用<font color="#FF0000">中间值</font>代替</li>
<li>这个方法，我想不到</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int firstMissingPositive(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if(nums.empty())&#123;return 1;&#125;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        for(int&amp; i : nums)&#123;</span><br><span class="line">            if(i &lt;= 0)&#123;</span><br><span class="line">                i = n + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j = 0; j &lt; n; j++)&#123;</span><br><span class="line">            int tmp = abs(nums[j]);</span><br><span class="line">            if(tmp &lt;= n)&#123;</span><br><span class="line">                nums[tmp - 1] = -1 * abs(nums[tmp - 1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int k = 0; k &lt; n; k++)&#123;</span><br><span class="line">            if(nums[k] &gt; 0)&#123;</span><br><span class="line">                return k + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return n + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; nums = &#123;2, 1&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    std::cout &lt;&lt; solution.firstMissingPositive(nums) &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42_接雨水"></a>42_接雨水</h2><ul>
<li>一开始的思路是想到俄罗斯方块消行（对数组两端裁剪，等于0的去掉，再遍历，如果为零，则<code>ans++</code>，否则减1，最后递归，直到数组的长度小于3），每次都一层或者层的消，最后超出时间限制</li>
<li>看了题解有关栈的方法，大体上是分成多个小段，对每个小段计算水的体积，计算体积是一层一层来计算，高度*长度，即始终确保是个矩形</li>
</ul>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int trap(vector&lt;int&gt;&amp; height) &#123;</span><br><span class="line">        int len = height.size(), ans = 0;</span><br><span class="line">        stack&lt;int&gt; stk;</span><br><span class="line">        for(int i = 0; i &lt; len; i++)&#123;</span><br><span class="line">            while (!stk.empty() &amp;&amp; height[i] &gt; height[stk.top()])&#123;</span><br><span class="line">                int t = stk.top();</span><br><span class="line">                stk.pop();</span><br><span class="line">                if(stk.empty())&#123;break;&#125;</span><br><span class="line">                int h = min(height[stk.top()] - height[t], height[i] - height[t]);</span><br><span class="line">                ans = h * (i - stk.top() - 1) + ans;</span><br><span class="line">            &#125;</span><br><span class="line">            stk.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; height = &#123;0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    std::cout &lt;&lt; solution.trap(height) &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="45-跳跃游戏"><a href="#45-跳跃游戏" class="headerlink" title="45_跳跃游戏 ||"></a>45_跳跃游戏 ||</h2><ul>
<li>之前罗马数字用了贪心算法，当时没怎么在意，这题也可用，虽然会超出时间限制：当跳到数组的最后时，从后往前推，哪个位置可以跳到，选距离最大的那个位置，并更新<code>pos</code></li>
<li>第二个方法是正向查找，每次找到可到达的最远位置，还是太菜了…</li>
</ul>
<h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><ul>
<li>反向</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int jump(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if(nums.size() &lt;= 1)&#123;return 0;&#125;</span><br><span class="line">        int pos = (int)(nums.size() - 1), ans = 0;</span><br><span class="line">        while (pos &gt; 0)&#123;</span><br><span class="line">            for(int i = 0; i &lt; pos; i++)&#123;</span><br><span class="line">                if(i + nums[i] &gt;= pos)&#123;</span><br><span class="line">                    pos = i;</span><br><span class="line">                    ans++;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; nums = &#123;2, 3, 1, 1, 4&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.jump(nums) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>正向</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int jump(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int maxPos = 0, n = nums.size(), end = 0, step = 0;</span><br><span class="line">        for (int i = 0; i &lt; n - 1; ++i) &#123;</span><br><span class="line">            if (maxPos &gt;= i) &#123;</span><br><span class="line">                maxPos = max(maxPos, i + nums[i]);</span><br><span class="line">                if (i == end) &#123;</span><br><span class="line">                    end = maxPos;</span><br><span class="line">                    ++step;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return step;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46_全排列"></a>46_全排列</h2><ul>
<li>这题咋一看跟之前的回溯(剪树枝)有点像，后来发现不对，最开始的树根会变，仔细思考了下，有点类似数独那题，要用递归</li>
<li>像平时思考一样，第一个位置可以放1，2，3三个数，那么第二个位置就只能放两个数了，以此往后，到最后一个数时进行回溯，同时<code>tmp</code>数组要删除一个数</li>
<li>一次通过</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void dfs(vector&lt;int&gt; nums, vector&lt;int&gt;&amp; tmp, vector&lt;vector&lt;int&gt;&gt;&amp; res, int n)&#123;</span><br><span class="line">        if(tmp.size() == n)&#123;</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            vector&lt;int&gt; nums_tmp = nums;</span><br><span class="line">            tmp.push_back(nums[i]);</span><br><span class="line">            nums_tmp.erase(nums_tmp.begin() + i);</span><br><span class="line">            dfs(nums_tmp, tmp, res, n);</span><br><span class="line">            tmp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        vector&lt;int&gt; tmp;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        dfs(nums, tmp, res, n);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; nums = &#123;1, 2, 3&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; res = solution.permute(nums);</span><br><span class="line">    for(const auto&amp; i : res)&#123;</span><br><span class="line">        for(auto j : i)&#123;</span><br><span class="line">            cout &lt;&lt; j;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="47-全排列"><a href="#47-全排列" class="headerlink" title="47_全排列 ||"></a>47_全排列 ||</h2><ul>
<li>跟上题一样，只需添加几行代码就行；在进行去重复时，要先梳理下原数组，同样的挨在一起</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void dfs(vector&lt;int&gt; nums, vector&lt;int&gt;&amp; tmp, vector&lt;vector&lt;int&gt;&gt;&amp; res, int n)&#123;</span><br><span class="line">        if(tmp.size() == n)&#123;</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            if(i &gt;= 1 &amp;&amp; nums[i] == nums[i - 1])&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            vector&lt;int&gt; nums_tmp = nums;</span><br><span class="line">            tmp.push_back(nums[i]);</span><br><span class="line">            nums_tmp.erase(nums_tmp.begin() + i);</span><br><span class="line">            dfs(nums_tmp, tmp, res, n);</span><br><span class="line">            tmp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        vector&lt;int&gt; tmp;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        dfs(nums, tmp, res, n);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; nums = &#123;1, 2, 1&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; res = solution.permuteUnique(nums);</span><br><span class="line">    for(const auto&amp; i : res)&#123;</span><br><span class="line">        for(auto j : i)&#123;</span><br><span class="line">            cout &lt;&lt; j;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48_旋转图像"></a>48_旋转图像</h2><ul>
<li>一步到位不了，那就分两步；第一步：转置，声明一个中间值<code>tmp</code>；第二步：以中间列为轴心，翻转180度</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        int tmp = 0, n = matrix.size();</span><br><span class="line">        for(int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">            for(int j = i + 1; j &lt; n; j++)&#123;</span><br><span class="line">                tmp = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[j][i];</span><br><span class="line">                matrix[j][i] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">            for(int j = 0; j &lt; n - j - 1; j++)&#123;</span><br><span class="line">                tmp = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[i][n - j - 1];</span><br><span class="line">                matrix[i][n - j - 1] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; matrix = &#123;&#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;, &#123;7, 8, 9&#125;&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    solution.rotate(matrix);</span><br><span class="line">    for(auto i : matrix)&#123;</span><br><span class="line">        for(auto j : i)&#123;</span><br><span class="line">            cout &lt;&lt; j;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="51-N皇后"><a href="#51-N皇后" class="headerlink" title="51_N皇后"></a>51_N皇后</h2><ul>
<li>这题类似于解数独，每次放置<code>Q</code>之前都要判断那三个规则；数独那题是先放数字，再判断规则；</li>
<li>重点就是标记，不能只用0或1来标记，去标记的时候会覆盖之前的（这个格子不能放，去完标记操作后，变成可以放），在递归时就会产生错误；标记的时候，用一个二维数组来维护行、列、斜线（正对角线、次对角线）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">    vector&lt;string&gt; tmp;</span><br><span class="line">public:</span><br><span class="line">    void mark(vector&lt;vector&lt;int&gt;&gt;&amp; oblique, int i, int j, int n, int m, bool flag)&#123;</span><br><span class="line">        int a = 0, b = m;</span><br><span class="line">        if(!flag)&#123;a = m; b = 0;&#125;</span><br><span class="line"></span><br><span class="line">        int i_tmp = i, j_tmp = j;  // 斜线有两条，分开来写，如果写在一起，有一个到边界另一个就停止了</span><br><span class="line">        while (i_tmp &lt; n &amp;&amp; j_tmp &lt; n)&#123;</span><br><span class="line">            if(oblique[i_tmp][j_tmp] == a)&#123;</span><br><span class="line">                oblique[i_tmp][j_tmp] = b;  // 每次标记都要不一样，否则消除标记时会覆盖原来的</span><br><span class="line">            &#125;</span><br><span class="line">            i_tmp++; j_tmp++;</span><br><span class="line">        &#125;</span><br><span class="line">        i_tmp = i, j_tmp = j;</span><br><span class="line">        while (i_tmp &lt; n &amp;&amp; j_tmp &gt;= 0)&#123;</span><br><span class="line">            if(oblique[i_tmp][j_tmp] == a)&#123;</span><br><span class="line">                oblique[i_tmp][j_tmp] = b;  // 每次标记都要不一样，否则消除标记时会覆盖原来的</span><br><span class="line">            &#125;</span><br><span class="line">            i_tmp++; j_tmp--;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i_0 = 0; i_0 &lt; n; i_0++)&#123;</span><br><span class="line">            if(oblique[i_0][j] == a)&#123;</span><br><span class="line">                oblique[i_0][j] = b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j_0 = 0; j_0 &lt; n; j_0++)&#123;</span><br><span class="line">            if(oblique[i][j_0] == a)&#123;</span><br><span class="line">                oblique[i][j_0] = b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void dfs(int n, vector&lt;int&gt;&amp; row, vector&lt;vector&lt;int&gt;&gt;&amp; oblique, int Q_number)&#123;</span><br><span class="line">        if(Q_number == n)&#123;</span><br><span class="line">            res.emplace_back(tmp);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i = Q_number ; i &lt; n; i++)&#123;</span><br><span class="line">            for(int j = 0; j &lt; n; j++)&#123;</span><br><span class="line">                if(oblique[i][j] == 0)&#123;</span><br><span class="line">                    tmp[i][j] = &apos;Q&apos;;   // 放置Q后，要将其余对应的位置做标记，方便之后判断</span><br><span class="line">                    Q_number++;</span><br><span class="line">                    row[i] = 1;</span><br><span class="line">                    mark(oblique, i, j, n, i + 1, true);</span><br><span class="line"></span><br><span class="line">                    dfs(n, row, oblique, Q_number);</span><br><span class="line"></span><br><span class="line">                    tmp[i][j] = &apos;.&apos;;    // 回溯后，抹去Q</span><br><span class="line">                    Q_number--;</span><br><span class="line">                    row[i] = 0;</span><br><span class="line">                    mark(oblique, i, j, n, i + 1, false);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(row[i] == 0)&#123;return;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123;</span><br><span class="line">        vector&lt;int&gt; row(n);</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; oblique(n, vector&lt;int&gt;(n));</span><br><span class="line">        int Q_number = 0;</span><br><span class="line">        for(int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">            tmp.emplace_back(&quot;&quot;);</span><br><span class="line">            for(int j = 0; j &lt; n; j++)&#123;</span><br><span class="line">                tmp[i].push_back(&apos;.&apos;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   // 初始化tmp</span><br><span class="line">        dfs(n, row, oblique, Q_number);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; res = solution.solveNQueens(6);</span><br><span class="line">    for(const auto&amp; re :res)&#123;</span><br><span class="line">        for(const auto&amp; r : re)&#123;</span><br><span class="line">            for(auto s : r)&#123;</span><br><span class="line">                cout &lt;&lt; s &lt;&lt; &quot; &quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; &quot;----------&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="52-N皇后"><a href="#52-N皇后" class="headerlink" title="52_N皇后 ||"></a>52_N皇后 ||</h2><ul>
<li>只要将上题输出改成个数就行（代码就不粘了）</li>
</ul>
<h2 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53_最大子序和"></a>53_最大子序和</h2><ul>
<li>用双指针法失败了，在判断两边指针谁先移动感觉没有规律，如果两边对应的数字一样大，那不得分情况；最后手撸了一遍三重循环(笑)</li>
<li>动态规划转移方程，算<code>f(i)</code>(每一个连续子段都有个末尾，根据末尾出现的位置，可以将数组从头到尾遍历一遍)，注意循环到最后的结果是最后一个<code>f(i)</code>，还要比较大小（怪不得这题算简单题）</li>
</ul>
<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int ans = INT32_MIN, tmp = 0;</span><br><span class="line">        for(int num : nums)&#123;</span><br><span class="line">            if(num &gt;= tmp + num)&#123;</span><br><span class="line">                tmp = num;</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                tmp += num;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = max(ans, tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; nums = &#123;-2,1,-3,4,-1,2,1,-5&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    int ans = solution.maxSubArray(nums);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54_螺旋矩阵"></a>54_螺旋矩阵</h2><ul>
<li>有点像贪吃蛇；我用了四个方向函数，向右函数末尾会调用向下函数，向下函数会调用向左函数······每次调用函数都会判断是否满足条件，我觉得我写的比较繁琐，提交记录却出人意料的好</li>
<li>看下题解优化下</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void right(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, vector&lt;vector&lt;int&gt;&gt;&amp; tmp, vector&lt;int&gt;&amp; res, int&amp; i, int&amp; j, bool&amp; flag, int m, int n)&#123;</span><br><span class="line">        if(!flag)&#123;return;&#125;</span><br><span class="line">        while (j &lt; n &amp;&amp; tmp[i][j] != 0)&#123;</span><br><span class="line">            res.push_back(matrix[i][j]);</span><br><span class="line">            tmp[i][j] = 0;</span><br><span class="line">            cout &lt;&lt; &quot;(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot;&lt;&lt; j &lt;&lt; &quot;)&quot;;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        j--;</span><br><span class="line">        i++;</span><br><span class="line">        if(i &gt;= m || (tmp[i][j] == 0 &amp;&amp; i &lt; m))&#123;</span><br><span class="line">            flag = false;</span><br><span class="line">        &#125;</span><br><span class="line">        down(matrix, tmp, res, i, j, flag, m, n);</span><br><span class="line">    &#125;</span><br><span class="line">    void down(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, vector&lt;vector&lt;int&gt;&gt;&amp; tmp, vector&lt;int&gt;&amp; res, int&amp; i, int&amp; j, bool&amp; flag, int m, int n)&#123;</span><br><span class="line">        if(!flag)&#123;return;&#125;</span><br><span class="line">        while (i &lt; m &amp;&amp; tmp[i][j] != 0)&#123;</span><br><span class="line">            res.push_back(matrix[i][j]);</span><br><span class="line">            tmp[i][j] = 0;</span><br><span class="line">            cout &lt;&lt; &quot;(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot;&lt;&lt; j &lt;&lt; &quot;)&quot;;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        i--;</span><br><span class="line">        j--;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        if(j &lt; 0 || (tmp[i][j] == 0 &amp;&amp; j &gt;= 0))&#123;</span><br><span class="line">            flag = false;</span><br><span class="line">        &#125;</span><br><span class="line">        left(matrix, tmp, res, i, j, flag, m, n);</span><br><span class="line">    &#125;</span><br><span class="line">    void left(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, vector&lt;vector&lt;int&gt;&gt;&amp; tmp, vector&lt;int&gt;&amp; res, int&amp; i, int&amp; j, bool&amp; flag, int m, int n)&#123;</span><br><span class="line">        if(!flag)&#123;return;&#125;</span><br><span class="line">        while (j &gt;= 0 &amp;&amp; tmp[i][j] != 0)&#123;</span><br><span class="line">            res.push_back(matrix[i][j]);</span><br><span class="line">            tmp[i][j] = 0;</span><br><span class="line">            cout &lt;&lt; &quot;(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot;&lt;&lt; j &lt;&lt; &quot;)&quot;;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        j++;</span><br><span class="line">        i--;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        if(i &lt; 0 || (tmp[i][j] == 0 &amp;&amp; i &gt;= 0))&#123;</span><br><span class="line">            flag = false;</span><br><span class="line">        &#125;</span><br><span class="line">        up(matrix, tmp, res, i, j, flag, m, n);</span><br><span class="line">    &#125;</span><br><span class="line">    void up(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, vector&lt;vector&lt;int&gt;&gt;&amp; tmp, vector&lt;int&gt;&amp; res, int&amp; i, int&amp; j, bool&amp; flag, int m, int n)&#123;</span><br><span class="line">        if(!flag)&#123;return;&#125;</span><br><span class="line">        while (i &gt;= 0 &amp;&amp; tmp[i][j] != 0)&#123;</span><br><span class="line">            res.push_back(matrix[i][j]);</span><br><span class="line">            tmp[i][j] = 0;</span><br><span class="line">            cout &lt;&lt; &quot;(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot;&lt;&lt; j &lt;&lt; &quot;)&quot;;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        j++;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        if(j &gt;= n || (tmp[i][j] == 0 &amp;&amp; j &lt; n))&#123;</span><br><span class="line">            flag = false;</span><br><span class="line">        &#125;</span><br><span class="line">        right(matrix, tmp, res, i, j, flag, m, n);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        int m = matrix.size(), n = matrix[0].size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; tmp(m, vector&lt;int&gt;(n, 1));</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        int i = 0, j = 0;</span><br><span class="line">        bool flag = true;</span><br><span class="line"></span><br><span class="line">        right(matrix,tmp, res, i, j, flag, m, n);</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; matrix = &#123;&#123;1,2,3&#125;, &#123;4,5,6&#125;, &#123;7,8,9&#125;&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;int&gt; res = solution.spiralOrder(matrix);</span><br><span class="line">    for(auto re : res)&#123;</span><br><span class="line">        cout &lt;&lt; re &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55_跳跃游戏"></a>55_跳跃游戏</h2><ul>
<li>这题用了跳跃游戏||的反向贪心算法，通过是通过了，就是运行时间有点久，一千多ms</li>
<li>还是参考下题解吧：维护可以到达的最远距离</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    // 反向贪心算法</span><br><span class="line">    bool canJump1(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int l = nums.size();</span><br><span class="line">        l--;</span><br><span class="line">        while (l &gt; 0)&#123;</span><br><span class="line">            cout &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">            for(int j = 0; j &lt; l; j++)&#123;</span><br><span class="line">                if(nums[j] + j &gt;= l)&#123;</span><br><span class="line">                    l = j;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                if(j == l - 1)&#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    //维护最大距离</span><br><span class="line">    bool canJump(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int distance = 0;</span><br><span class="line">        for(int i = 0; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            if(i &lt;= distance)&#123;</span><br><span class="line">                distance = max(i + nums[i], distance);</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; nums = &#123;2,3,1,1,4&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.canJump(nums) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56_合并区间"></a>56_合并区间</h2><ul>
<li>不小心看到了提示（链表），看到提示反而不会了0.0</li>
<li>还是看了别人的博客视频，对这个二维数组进行排序，用<code>sort()</code>时要注意参数，直接写<code>sort(intervals.begin(), intervals.end(), cmp);</code>会在<code>cmp</code>报错</li>
<li>对于像<code>bool cmp(const Interval &amp;a,const Interval &amp;b)</code>这样的成员函数，它是属于类的，所以调用它必须需要对象才可以，<code>bool cmp( Solution* this, const Interval &amp;a,const Interval &amp;b );</code>它有一个<code>implicit parameter</code>(隐含参数)，这才导致它无法被<code>sort()</code>这样的函数调用，主要是参数不匹配，改成静态即可</li>
<li>用下面这个方法，提交记录指标比较低；看了下答案，原来可以直接省去<code>cmp</code>参数0.0</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    static bool cmp(vector&lt;int&gt; a, vector&lt;int&gt; b) &#123;</span><br><span class="line">        return a[0] &lt; b[0]; // 小于号是从小到大排列</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        sort(intervals.begin(), intervals.end(), cmp);</span><br><span class="line">        for(auto i : intervals)&#123;</span><br><span class="line">            if(res.empty() || i[0] &gt; res[res.size() - 1][1])&#123;</span><br><span class="line">                res.push_back(i);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                res[res.size() - 1][1] = max(res[res.size() - 1][1], i[1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; intervals = &#123;&#123;1,3&#125;,&#123;2,6&#125;,&#123;8,10&#125;,&#123;15,18&#125;&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; res = solution.merge(intervals);</span><br><span class="line">    for(const auto&amp; re : res)&#123;</span><br><span class="line">        for(auto r : re)&#123;</span><br><span class="line">            cout &lt;&lt; r &lt;&lt; &quot; &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; &quot;, &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="57-插入区间"><a href="#57-插入区间" class="headerlink" title="57_插入区间"></a>57_插入区间</h2><ul>
<li>本质上和上一题还是一样的，先把新区间放在最后再排序，然后合并；康康题解的思路，再手撕一遍；</li>
<li>自己手动写的时候，步骤比较繁琐，而且还没实现出来0.0，都是找有重叠的区间，一上来就默认有重叠了，记录了重叠区间的位置，合并之前还要删除重叠的区间，最后插入…</li>
<li>还是一次遍历总区间，将合适的放入<code>res</code>里，最后再康没有重叠就直接插入新区间（不用再找第几个位置插入了）；遇到一个坑，clion里代码是可以得出正确答案的，leetcode就不行。。。<code>bool flag = false;</code>这里要写完整</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; insert1(vector&lt;vector&lt;int&gt;&gt;&amp; intervals, vector&lt;int&gt;&amp; newInterval) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; tmp = intervals;</span><br><span class="line">        tmp.push_back(newInterval);</span><br><span class="line">        sort(tmp.begin(), tmp.end());</span><br><span class="line">        for(auto i : tmp)&#123;</span><br><span class="line">            if(res.empty() || i[0] &gt; res[res.size() - 1][1])&#123;</span><br><span class="line">                res.push_back(i);</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                res[res.size() - 1][1] = max(i[1], res[res.size() - 1][1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; insert(vector&lt;vector&lt;int&gt;&gt;&amp; intervals, vector&lt;int&gt;&amp; newInterval) &#123;</span><br><span class="line">        if(intervals.empty())&#123;return &#123;newInterval&#125;;&#125;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        int l = newInterval[0], r = newInterval[1];</span><br><span class="line">        bool flag = false;</span><br><span class="line">        for(auto i : intervals)&#123;</span><br><span class="line">            if(i[0] &gt; r)&#123;</span><br><span class="line">                if(!flag)&#123;res.push_back(&#123;l, r&#125;); flag = true;&#125;</span><br><span class="line">                res.push_back(i);</span><br><span class="line">            &#125; else if(i[1] &lt; l)&#123;</span><br><span class="line">                res.push_back(i);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                l = min(l, i[0]);</span><br><span class="line">                r = max(r, i[1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!flag)&#123;res.push_back(&#123;l, r&#125;);&#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; intervals = &#123;&#123;1,3&#125;,&#123;6,9&#125;&#125;;</span><br><span class="line">    vector&lt;int&gt; newInterval = &#123;3,5&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; res = solution.insert(intervals, newInterval);</span><br><span class="line">    for(auto re : res)&#123;</span><br><span class="line">        cout &lt;&lt; re[0] &lt;&lt; &quot; &quot; &lt;&lt; re[1] &lt;&lt; &quot;, &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="59-螺旋矩阵"><a href="#59-螺旋矩阵" class="headerlink" title="59_螺旋矩阵 ||"></a>59_螺旋矩阵 ||</h2><ul>
<li>这题感觉比|简单点</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void right(vector&lt;vector&lt;int&gt;&gt;&amp; res, int i, int j, int&amp; number, int n)&#123;</span><br><span class="line">        if(number &gt; n * n)&#123;return;&#125;</span><br><span class="line">        while (j &lt; n &amp;&amp; res[i][j] == 0)&#123;</span><br><span class="line">            res[i][j] = number;</span><br><span class="line">            number++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        j--;</span><br><span class="line">        down(res, i + 1, j, number, n);</span><br><span class="line">    &#125;</span><br><span class="line">    void down(vector&lt;vector&lt;int&gt;&gt;&amp; res, int i, int j, int&amp; number, int n)&#123;</span><br><span class="line">        if(number &gt; n * n)&#123;return;&#125;</span><br><span class="line">        while (i &lt; n &amp;&amp; res[i][j] == 0)&#123;</span><br><span class="line">            res[i][j] = number;</span><br><span class="line">            number++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        i--;</span><br><span class="line">        left(res, i, j - 1, number, n);</span><br><span class="line">    &#125;</span><br><span class="line">    void left(vector&lt;vector&lt;int&gt;&gt;&amp; res, int i, int j, int&amp; number, int n)&#123;</span><br><span class="line">        if(number &gt; n * n)&#123;return;&#125;</span><br><span class="line">        while (j &gt;= 0 &amp;&amp; res[i][j] == 0)&#123;</span><br><span class="line">            res[i][j] = number;</span><br><span class="line">            number++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        j++;</span><br><span class="line">        up(res, i - 1, j, number, n);</span><br><span class="line">    &#125;</span><br><span class="line">    void up(vector&lt;vector&lt;int&gt;&gt;&amp; res, int i, int j, int&amp; number, int n)&#123;</span><br><span class="line">        if(number &gt; n * n)&#123;return;&#125;</span><br><span class="line">        while (i &gt;= 0 &amp;&amp; res[i][j] == 0)&#123;</span><br><span class="line">            res[i][j] = number;</span><br><span class="line">            number++;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        right(res, i, j + 1, number, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res(n, vector&lt;int&gt;(n, 0));</span><br><span class="line">        int number = 1;</span><br><span class="line">        right(res, 0, 0,number, n);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; matrix = &#123;&#123;1,2,3&#125;, &#123;4,5,6&#125;, &#123;7,8,9&#125;&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; res = solution.generateMatrix(2);</span><br><span class="line">    for(const auto&amp; re : res)&#123;</span><br><span class="line">        for(auto r : re)&#123;</span><br><span class="line">            cout &lt;&lt; r &lt;&lt; &quot; &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="63-不同路径"><a href="#63-不同路径" class="headerlink" title="63_不同路径 ||"></a>63_不同路径 ||</h2><ul>
<li>组合数学用不了了，试着用递归，不出所料超出时间限制</li>
<li>每次都要判断两个方向，每次选择一个方向，另一个方向就会暂停，一直到最后的格子，才会返回上一层，没错这就是递归；那怎样才能让两个方向同时进行呢，这样一到最后的格子，答案也随之出来，有点像遍历；</li>
<li>回想以前的题，接触过几次动态规划，说实话动态规划有点像马尔科夫链——当前状态取决于上一个状态，仔细思考后发现：最后一个格子的所有路径=左边的格子+上边的格子，以此往前推可以得出，任意一个格子的路径数=与之相邻左边的格子+上边的格子；如果格子在边界，那么默认左边或者上边为0。</li>
<li>主要是如何标记这个二维数组：万事开头难，开头不能有障碍物（初始为0），再标记为1；之后遍历，跳过开头，如果遇到障碍物，先标记为0，再<code>continue;</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123;</span><br><span class="line">        if(obstacleGrid[0][0] == 1)&#123;return 0;&#125;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; tmp = obstacleGrid;</span><br><span class="line">        tmp[0][0] = 1;</span><br><span class="line">        int m = obstacleGrid.size(), n = obstacleGrid[0].size();</span><br><span class="line">        for(int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">            for(int j = 0; j &lt; n; j++)&#123;</span><br><span class="line">                if(i == 0 &amp;&amp; j == 0)&#123; continue;&#125;    //开头直接跳过</span><br><span class="line">                if(tmp[i][j] == 1)&#123;tmp[i][j] = 0;continue;&#125;</span><br><span class="line">                int up = i == 0 ? 0 : tmp[i - 1][j], left = j == 0 ? 0 : tmp[i][j - 1];</span><br><span class="line">                tmp[i][j] = up + left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return tmp[m - 1][n - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; obstacleGrid = &#123;&#123;0,0,0,0&#125;&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.uniquePathsWithObstacles(obstacleGrid) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64_最小路径和"></a>64_最小路径和</h2><ul>
<li>这个和上题一个思路，麻烦就在于边界，之后就判断上边和左边哪个值更小</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        int m = grid.size(), n = grid[0].size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; tmp = grid;</span><br><span class="line">        for(int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">            for(int j = 0; j &lt; n; j++)&#123;</span><br><span class="line">                if(i == 0)&#123;</span><br><span class="line">                    tmp[i][j] += j == 0 ? 0 : tmp[i][j - 1];</span><br><span class="line">                &#125; else if(j == 0)&#123;</span><br><span class="line">                    tmp[i][j] += tmp[i - 1][j];</span><br><span class="line">                &#125; else&#123;</span><br><span class="line">                    tmp[i][j] += min(tmp[i - 1][j], tmp[i][j - 1]);</span><br><span class="line">                &#125;</span><br><span class="line">                cout &lt;&lt; tmp[i][j] &lt;&lt; &quot; &quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        return tmp[m - 1][n - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; grid = &#123;&#123;0,2,2&#125;,</span><br><span class="line">                                &#123;0,3,6&#125;,</span><br><span class="line">                                &#123;6,9,0&#125;&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.minPathSum(grid) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="66-加一"><a href="#66-加一" class="headerlink" title="66_加一"></a>66_加一</h2><ul>
<li>这题类似43_字符串相乘，主要考虑进位（初始值为1）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        int carry = 1, l = digits.size();</span><br><span class="line">        for(int i = l - 1; i &gt;= 0; i--)&#123;</span><br><span class="line">            int ans = digits[i] + carry;</span><br><span class="line">            res.insert(res.begin(), ans % 10);</span><br><span class="line">            carry = ans / 10;</span><br><span class="line">        &#125;</span><br><span class="line">        if(carry != 0)&#123;res.insert(res.begin(), carry);&#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; digits = &#123;9, 8, 9&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;int&gt; res = solution.plusOne(digits);</span><br><span class="line">    for(auto re : res)&#123;</span><br><span class="line">        cout &lt;&lt; re;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="68-文本左右对齐"><a href="#68-文本左右对齐" class="headerlink" title="68_文本左右对齐"></a>68_文本左右对齐</h2><ul>
<li>因为每一行要尽可能多的放入单词，单词之间至少一个空格，我的思路和题解其实是一样的：先把单词放好，再将空格平均分配（商和余数）</li>
<li>例如标记出了空格的所有位置，那么插入几个空格，后面的位置全部都要更新；吐槽下，最后一行我以为也要对齐的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void insert_space(string&amp; tmp, int maxWidth, bool flag)&#123;</span><br><span class="line">        if(tmp.size() &gt;= maxWidth)&#123;return;&#125;</span><br><span class="line">        int n = maxWidth - (int)tmp.size(); //末尾空格数</span><br><span class="line">        cout &lt;&lt; &quot;tmp.size() = &quot; &lt;&lt; tmp.size() &lt;&lt; &quot; n = &quot; &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">        vector&lt;int&gt; pos;</span><br><span class="line">        for(int i = 0; i &lt; tmp.size() - 1; i++)&#123;</span><br><span class="line">            if(tmp[i] == &apos; &apos; &amp;&amp; tmp[i + 1] != &apos; &apos;)&#123;</span><br><span class="line">                pos.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(pos.empty() || flag)&#123;</span><br><span class="line">            while (n &gt; 0)&#123;</span><br><span class="line">                tmp.push_back(&apos; &apos;);</span><br><span class="line">                n--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">            int n_pos = pos.size(); //间隔数</span><br><span class="line">            int remainder = n % n_pos; //余数</span><br><span class="line">            for(int j = 0; j &lt; n_pos; j++)&#123;</span><br><span class="line">                int quotient = n / n_pos;   //商</span><br><span class="line">                if(remainder &gt; 0)&#123;</span><br><span class="line">                    tmp.insert(pos[j], quotient + 1, &apos; &apos;);</span><br><span class="line">                    int k = j + 1;</span><br><span class="line">                    while (k &lt; n_pos)&#123;</span><br><span class="line">                        pos[k] += quotient + 1;</span><br><span class="line">                        k++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    remainder--;</span><br><span class="line">                &#125; else&#123;</span><br><span class="line">                    tmp.insert(pos[j], quotient, &apos; &apos;);</span><br><span class="line">                    int k = j + 1;</span><br><span class="line">                    while (k &lt; n_pos)&#123;</span><br><span class="line">                        pos[k] += quotient;</span><br><span class="line">                        k++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;string&gt; fullJustify(vector&lt;string&gt;&amp; words, int maxWidth) &#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        string tmp;</span><br><span class="line">        for(int i = 0; i &lt; words.size(); i++)&#123;</span><br><span class="line">            if(tmp.size() + words[i].size() + 1 &lt;= maxWidth &amp;&amp; !tmp.empty())&#123;</span><br><span class="line">                tmp.push_back(&apos; &apos;);</span><br><span class="line">            &#125; else if(tmp.size() + words[i].size() + 1 &gt; maxWidth &amp;&amp; !tmp.empty())&#123;</span><br><span class="line">                insert_space(tmp, maxWidth, false);</span><br><span class="line">                res.push_back(tmp);</span><br><span class="line">                tmp.clear();</span><br><span class="line">            &#125;</span><br><span class="line">            tmp.append(words[i]);</span><br><span class="line">            if(i + 1 == words.size())&#123;</span><br><span class="line">                insert_space(tmp, maxWidth, true);</span><br><span class="line">                res.push_back(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;string&gt; words = &#123;&quot;Science&quot;,&quot;is&quot;,&quot;what&quot;,&quot;we&quot;,&quot;understand&quot;,&quot;well&quot;,&quot;enough&quot;,&quot;to&quot;,&quot;explain&quot;,&quot;to&quot;,&quot;a&quot;,&quot;computer.&quot;,&quot;Art&quot;,&quot;is&quot;,&quot;everything&quot;,&quot;else&quot;,&quot;we&quot;,&quot;do&quot;&#125;;</span><br><span class="line">    vector&lt;string&gt; words1 = &#123;&quot;Don&apos;t&quot;,&quot;go&quot;,&quot;around&quot;,&quot;saying&quot;,&quot;the&quot;,&quot;world&quot;,&quot;owes&quot;,&quot;you&quot;,&quot;a&quot;,&quot;living;&quot;,&quot;the&quot;,&quot;world&quot;,&quot;owes&quot;,&quot;you&quot;,&quot;nothing;&quot;,&quot;it&quot;,&quot;was&quot;,&quot;here&quot;,&quot;first.&quot;&#125;;</span><br><span class="line">    int maxWidth = 30;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;string&gt; res = solution.fullJustify(words1, maxWidth);</span><br><span class="line">    for(const auto&amp; re :res)&#123;</span><br><span class="line">        for(auto r : re)&#123;</span><br><span class="line">            if(r == &apos; &apos;)&#123;r = &apos;-&apos;;&#125;</span><br><span class="line">            cout &lt;&lt; r;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="73-矩阵置零"><a href="#73-矩阵置零" class="headerlink" title="73_矩阵置零"></a>73_矩阵置零</h2><ul>
<li>这题虽说不太严谨(标记的那个方法)，不过有一种题解很有意思，手撕下；要先判断第一行或者第一列是否有0，需要两个标志，有就要在最后对应行或者列置0，其次在做其他标记</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        bool row = false, col = false;</span><br><span class="line">        for(int j = 0; j &lt; matrix[0].size(); j++)&#123;</span><br><span class="line">            if(matrix[0][j] == 0)&#123;</span><br><span class="line">                col = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i = 0; i &lt; matrix.size(); i++)&#123;</span><br><span class="line">            if(matrix[i][0] == 0)&#123;</span><br><span class="line">                row = true;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int j = 0; j &lt; matrix[0].size(); j++)&#123;</span><br><span class="line">                if(matrix[i][j] == 0)&#123;</span><br><span class="line">                    matrix[0][j] = 0;</span><br><span class="line">                    matrix[i][0] = 0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i = 1; i &lt; matrix.size(); i++)&#123;</span><br><span class="line">            for(int j = 1; j &lt; matrix[0].size(); j++)&#123;</span><br><span class="line">                if(matrix[i][0] == 0 || matrix[0][j] == 0)&#123;</span><br><span class="line">                    matrix[i][j] = 0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(row)&#123;</span><br><span class="line">            for(int i = 1; i &lt; matrix.size(); i++)&#123;</span><br><span class="line">                matrix[i][0] = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(col)&#123;</span><br><span class="line">            for(int j = 1; j &lt; matrix[0].size(); j++)&#123;</span><br><span class="line">                matrix[0][j] = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; matrix = &#123;&#123;1,2,3,4&#125;,</span><br><span class="line">                                   &#123;5,0,7,8&#125;,</span><br><span class="line">                                   &#123;0,10,11,12&#125;,</span><br><span class="line">                                   &#123;13,14,15,0&#125;&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    solution.setZeroes(matrix);</span><br><span class="line">    for(auto ma : matrix)&#123;</span><br><span class="line">        for(auto m : ma)&#123;</span><br><span class="line">            cout &lt;&lt; m &lt;&lt; &quot; &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="74-搜索二维矩阵"><a href="#74-搜索二维矩阵" class="headerlink" title="74_搜索二维矩阵"></a>74_搜索二维矩阵</h2><ul>
<li>思路简单，先确定在哪一行，在对这一行进行二分查找，确定哪一行也是二分查找，不过要考虑这一行最后一个数，写的时候感觉怪怪的；看了题解，，，，才知道原来可以精确定位到行列</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123;</span><br><span class="line">        int row = matrix.size(), col = matrix[0].size(), idx = row * col; //一共有idx个数，并且是升序，直接看成一维的</span><br><span class="line">        if(matrix[0][0] &lt;= target &amp;&amp; target &lt;= matrix[row - 1][col - 1])&#123;</span><br><span class="line">            int l = 0, r = idx - 1;</span><br><span class="line">            while (l &lt;= r)&#123;</span><br><span class="line">//                cout &lt;&lt; &quot;l = &quot; &lt;&lt; l &lt;&lt; &quot; r  = &quot; &lt;&lt; r &lt;&lt; endl;</span><br><span class="line">                int mid = (l + r) / 2;</span><br><span class="line">                if(matrix[mid / col][mid % col] == target)&#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">                if(matrix[mid / col][mid % col] &lt; target)&#123;</span><br><span class="line">                    l = mid + 1;</span><br><span class="line">                &#125; else&#123;</span><br><span class="line">                    r = mid - 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; matrix = &#123;&#123;1,5,7,8&#125;,</span><br><span class="line">                                  &#123;10,12,15,19&#125;&#125;;</span><br><span class="line">    int target = 19;</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.searchMatrix(matrix, target) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="75-数组"><a href="#75-数组" class="headerlink" title="75_数组"></a>75_数组</h2><ul>
<li>首先交换两个元素可以不用中间值，直接用<code>swap</code>函数；其次就是这题要把0都放在头部，2都放在尾部，要是与2交换的是0，还要再交换0这一步；要是还是2，要用<code>while</code>来操作；遍历到最后就不用交换2了，这里就要再加一个判断条件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void sortColors(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int l = 0, r = nums.size();</span><br><span class="line">        r--;</span><br><span class="line">        for(int i = 0; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            while (nums[i] == 2 &amp;&amp; i &lt; r)&#123;</span><br><span class="line">                swap(nums[i], nums[r]);</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">            if(nums[i] == 0)&#123;</span><br><span class="line">                swap(nums[i], nums[l]);</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; nums = &#123;1,0,2,1,1,0&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    solution.sortColors(nums);</span><br><span class="line">    for(const auto&amp; n : nums)&#123;</span><br><span class="line">        cout &lt;&lt; n;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="77-组合"><a href="#77-组合" class="headerlink" title="77_组合"></a>77_组合</h2><ul>
<li>从n个数选k个，不需要排列；总之要避免重复，每次进行循环时，都要从下一个<code>++l</code>开始</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndef Solution_   //代码只编译一次</span><br><span class="line">#define Solution_</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;iterator&gt;     // std::ostream_iterator</span><br><span class="line">#include &lt;algorithm&gt;    // std::copy</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; tmp, int n, int k, int l)&#123;</span><br><span class="line">        if(tmp.size() == k)&#123;</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = l; i &lt;= n; i++)&#123;</span><br><span class="line">            tmp.push_back(i);</span><br><span class="line">            dfs(res, tmp, n, k, ++l);   //++l与l++不一样</span><br><span class="line">            tmp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        vector&lt;int&gt; tmp;</span><br><span class="line">        int l = 1;</span><br><span class="line">        dfs(res, tmp, n, k, l);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; res = solution.combine(4, 2);</span><br><span class="line">    for(const auto&amp; re : res)&#123;</span><br><span class="line">        //如果不加载包含库，copy()貌似只有字符类型</span><br><span class="line">        copy(re.begin(), re.end(), ostream_iterator&lt;int&gt;(cout));</span><br><span class="line">        cout &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<h2 id="78-子集"><a href="#78-子集" class="headerlink" title="78_子集"></a>78_子集</h2><ul>
<li>做个小结，39.组合总和 40.组合总和II 46.全排列 47.全排列II 78.子集 都是一种类型的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndef Solution_</span><br><span class="line">#define Solution_</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;iterator&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void dfs(vector&lt;int&gt;&amp; nums, vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; tmp, int i, int n, int l)&#123;</span><br><span class="line">        if(i == 0)&#123;</span><br><span class="line">            res.emplace_back(); //放一个空的数组，不用push_back(&#123;&#125;)</span><br><span class="line">            return;</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">            if(tmp.size() == i)&#123;</span><br><span class="line">                res.push_back(tmp);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int j = l; j &lt; n; j++)&#123;</span><br><span class="line">                tmp.emplace_back(nums[j]);</span><br><span class="line">                dfs(nums, res, tmp, i, n, ++l);</span><br><span class="line">                tmp.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        vector&lt;int&gt; tmp;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        for(int i = 0; i &lt;= n; i++)&#123;</span><br><span class="line">            int l = 0;</span><br><span class="line">            dfs(nums, res, tmp, i, n, l);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; nums = &#123;1, 0&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; res = solution.subsets(nums);</span><br><span class="line">    for(const auto &amp; re : res)&#123;</span><br><span class="line">        copy(re.begin(), re.end(), ostream_iterator&lt;int&gt;(cout));</span><br><span class="line">        cout &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<h2 id="79-单词搜索"><a href="#79-单词搜索" class="headerlink" title="79_单词搜索"></a>79_单词搜索</h2><ul>
<li>深度优先搜索与回溯，题解与我自己写的思路一样，不过我的超出了时间限制，题解答案也有一千多毫秒</li>
<li>优化的地方小结下：主函数在双重循环下仅调用回溯函数即可，不需要再进行标记操作；标记操作放在回溯函数内；遍历四周上下左右时，可以定义个二维数组，加一或者减一，再对其遍历，之后再让索引限制在边界内；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndef Solution_</span><br><span class="line">#define Solution_</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool check(vector&lt;vector&lt;char&gt;&gt;&amp; board, vector&lt;vector&lt;int&gt;&gt;&amp; visited, int i, int j, string&amp; s, int k) &#123;</span><br><span class="line">        if (board[i][j] != s[k]) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else if (k == s.length() - 1) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[i][j] = true;</span><br><span class="line">        vector&lt;pair&lt;int, int&gt;&gt; directions&#123;&#123;0, 1&#125;, &#123;0, -1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;&#125;;</span><br><span class="line">        bool result = false;</span><br><span class="line">        for (const auto&amp; dir: directions) &#123;</span><br><span class="line">            int newi = i + dir.first, newj = j + dir.second;</span><br><span class="line">            if (newi &gt;= 0 &amp;&amp; newi &lt; board.size() &amp;&amp; newj &gt;= 0 &amp;&amp; newj &lt; board[0].size()) &#123;</span><br><span class="line">                if (!visited[newi][newj]) &#123;</span><br><span class="line">                    bool flag = check(board, visited, newi, newj, s, k + 1);</span><br><span class="line">                    if (flag) &#123;</span><br><span class="line">                        result = true;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[i][j] = false;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123;</span><br><span class="line">        int h = board.size(), w = board[0].size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; visited(h, vector&lt;int&gt;(w));</span><br><span class="line">        for (int i = 0; i &lt; h; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; w; j++) &#123;</span><br><span class="line">                bool flag = check(board, visited, i, j, word, 0);</span><br><span class="line">                if (flag) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;vector&lt;char&gt;&gt; board = &#123;&#123;&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;&#125;,</span><br><span class="line">                                  &#123;&apos;S&apos;,&apos;F&apos;,&apos;E&apos;,&apos;S&apos;&#125;,</span><br><span class="line">                                  &#123;&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;&#125;&#125;;</span><br><span class="line">    string word = &quot;ABCESEEEFS&quot;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.exist(board, word) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<h2 id="80-删除排序数组中的重复项-II"><a href="#80-删除排序数组中的重复项-II" class="headerlink" title="80_删除排序数组中的重复项_II"></a>80_删除排序数组中的重复项_II</h2><ul>
<li>百思不得其解，观摩下神仙写法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndef Solution_</span><br><span class="line">#define Solution_</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;iterator&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int i = 0;</span><br><span class="line">        for(const auto &amp; n : nums)&#123;</span><br><span class="line">            if(i &lt; 2 || n &gt; nums[i - 2]) nums[i++] = n;</span><br><span class="line">        &#125;</span><br><span class="line">        return i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; nums = &#123;0,0,1,1,2,3,3&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.removeDuplicates(nums) &lt;&lt; endl;</span><br><span class="line">    copy(nums.begin(), nums.end(), ostream_iterator&lt;int&gt;(cout));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<h2 id="81-搜索旋转排序数组-II"><a href="#81-搜索旋转排序数组-II" class="headerlink" title="81_搜索旋转排序数组_II"></a>81_搜索旋转排序数组_II</h2><ul>
<li>与I相比，当出现中间指针与左右两边中的一个相等时，会无法判断<code>target</code>在哪个区间；看了题解，真的是一语惊醒梦中人：出现相等的情况，将左指针加一即可！</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool search(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int l = 0, r = nums.size();</span><br><span class="line">        r--;</span><br><span class="line">        while (l &lt;= r)&#123;  //需要包含相等的情况，有可能这个才是目标值</span><br><span class="line">            int mid = (l + r) / 2;</span><br><span class="line">            if(nums[mid] == target)&#123;return true;&#125;</span><br><span class="line"></span><br><span class="line">            if(nums[l] &lt; nums[mid])&#123;</span><br><span class="line">                if(target &gt;= nums[l] &amp;&amp; target &lt; nums[mid])&#123;</span><br><span class="line">//                    cout &lt;&lt; &quot;---&quot; &lt;&lt; endl;</span><br><span class="line">                    r = mid - 1;</span><br><span class="line">                &#125; else&#123;</span><br><span class="line">                    l = mid + 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if(nums[l] &gt; nums[mid])&#123;</span><br><span class="line">                if(target &gt; nums[mid] &amp;&amp; target &lt;= nums[r])&#123;</span><br><span class="line">                    l = mid + 1;</span><br><span class="line">                &#125; else&#123;</span><br><span class="line">                    r = mid - 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                l++;    //去除一个重复干扰项</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; nums = &#123;1,0,1,1,1&#125;;</span><br><span class="line">    int target = 0;</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.search(nums, target) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84_柱状图中最大的矩形"></a>84_柱状图中最大的矩形</h2><ul>
<li>第一次超出时间限制了，做了优化：对于相同的数字，其面积是一样的；因此遍历的时候应该跳过之前计算过的值！不对，只有当这个数字是最小时，才一样；否则有的一样有的不一样；先把相邻的跳过康康能不能通过————居然通过了！</li>
<li>题解有个枚举矩形左右边界的解法，思路很简单，双重循环，但是超出时间限制了0.0；学习下其他方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//共有三个方法</span><br><span class="line"></span><br><span class="line">//正常思路，每遍历一个柱子，都向两边延申、计算面积；保留值更大的那个</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int area(vector&lt;int&gt;&amp; heights, int i, int n)&#123;</span><br><span class="line">        int area_i = heights[i], tmp_i = i;</span><br><span class="line">        while (++tmp_i &lt; n)&#123;</span><br><span class="line">            if(heights[i] &lt;= heights[tmp_i])&#123;</span><br><span class="line">                area_i += heights[i];</span><br><span class="line">            &#125; else&#123;break;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp_i = i;</span><br><span class="line">        while (--tmp_i &gt;= 0)&#123;</span><br><span class="line">            if(heights[i] &lt;= heights[tmp_i])&#123;</span><br><span class="line">                area_i += heights[i];</span><br><span class="line">            &#125; else&#123;break;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return area_i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123;</span><br><span class="line">        int res = 0, n = heights.size();</span><br><span class="line">        for(int i = 0; i &lt; n; ++i)&#123;</span><br><span class="line">            if(i &gt; 0 &amp;&amp; heights[i] == heights[i - 1])&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            int tmp = area(heights, i, n);</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; &quot; -- &quot; &lt;&lt; tmp &lt;&lt; endl;</span><br><span class="line">            if(res &lt; tmp)&#123;</span><br><span class="line">                res = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    //枚举矩形的边界</span><br><span class="line">    /*int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123;</span><br><span class="line">        int n = heights.size();</span><br><span class="line">        int ans = 0;</span><br><span class="line">        // 枚举左边界</span><br><span class="line">        for (int left = 0; left &lt; n; ++left) &#123;</span><br><span class="line">            int minHeight = INT_MAX;</span><br><span class="line">            // 枚举右边界</span><br><span class="line">            for (int right = left; right &lt; n; ++right) &#123;</span><br><span class="line">                // 确定高度</span><br><span class="line">                minHeight = min(minHeight, heights[right]);</span><br><span class="line">                // 计算面积</span><br><span class="line">                ans = max(ans, (right - left + 1) * minHeight);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;*/</span><br><span class="line">&#125;;</span><br><span class="line">//单调栈解法</span><br><span class="line">class Solution1 &#123;</span><br><span class="line">public:</span><br><span class="line">    int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123;</span><br><span class="line">        int n = heights.size();</span><br><span class="line">        vector&lt;int&gt; left(n), right(n);</span><br><span class="line"></span><br><span class="line">        stack&lt;int&gt; mono_stack;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            while (!mono_stack.empty() &amp;&amp; heights[mono_stack.top()] &gt;= heights[i]) &#123;</span><br><span class="line">                mono_stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            left[i] = (mono_stack.empty() ? -1 : mono_stack.top());</span><br><span class="line">            mono_stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mono_stack = stack&lt;int&gt;();</span><br><span class="line">        for (int i = n - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">            while (!mono_stack.empty() &amp;&amp; heights[mono_stack.top()] &gt;= heights[i]) &#123;</span><br><span class="line">                mono_stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            right[i] = (mono_stack.empty() ? n : mono_stack.top());</span><br><span class="line">            mono_stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int ans = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            ans = max(ans, (right[i] - left[i] - 1) * heights[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; heights&#123;4,2,0,3,2,5&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.largestRectangleArea(heights) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="85-最大矩形"><a href="#85-最大矩形" class="headerlink" title="85_最大矩形"></a>85_最大矩形</h2><ul>
<li>先写个思路：应该找矩形对角线的两端，尝试枚举两端法？</li>
<li>这个思路写完了，左上端是对原二维数组进行遍历，遇到1就调用函数计算出最大的面积；重点在调用函数：是对<font color="#FF0000">左上端所在的行列</font>为起点、向右下形成的部分二维数组进行遍历，遇到0(那么这个0所在列就是下次循环的边界条件)-面积计算方法就是长×宽；再<code>break;</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    //找出一端确定时，另一端所有位置的最大面积</span><br><span class="line">    int area(vector&lt;vector&lt;char&gt;&gt;&amp; matrix, int row, int col)&#123;</span><br><span class="line">        int ans = 0, j_tmp = matrix[0].size();</span><br><span class="line">        for(int i = row; i &lt; matrix.size(); ++i)&#123;</span><br><span class="line">            if(matrix[i][col] == 0)&#123;</span><br><span class="line">                ans = max(ans, i - row + 1);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            for(int j = col; j &lt; j_tmp; ++j)&#123;</span><br><span class="line">                int tmp = (i - row + 1) * (j - col + 1);</span><br><span class="line">                if(matrix[i][j] == &apos;0&apos;)&#123;</span><br><span class="line">                    tmp -= (i - row + 1);</span><br><span class="line">                    ans = max(ans, tmp);</span><br><span class="line">                    j_tmp = j;</span><br><span class="line">                    break;</span><br><span class="line">                &#125; else if(j + 1 == j_tmp &amp;&amp; matrix[i][j] == &apos;1&apos;)&#123;</span><br><span class="line">                    ans = max(ans, tmp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int maximalRectangle(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        for(int i = 0; i &lt; matrix.size(); ++i)&#123;</span><br><span class="line">            for(int j = 0; j &lt; matrix[0].size(); ++j)&#123;</span><br><span class="line">                if(matrix[i][j] == &apos;1&apos;)&#123;</span><br><span class="line">                    res = max(res, area(matrix, i, j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;vector&lt;char&gt;&gt; matrix&#123;&#123;&apos;0&apos;,&apos;0&apos;,&apos;0&apos;&#125;,</span><br><span class="line">                                &#123;&apos;0&apos;,&apos;0&apos;,&apos;0&apos;&#125;,</span><br><span class="line">                                &#123;&apos;1&apos;,&apos;1&apos;,&apos;1&apos;&#125;&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.maximalRectangle(matrix) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88_合并两个有序数组"></a>88_合并两个有序数组</h2><ul>
<li>这题是在<code>nums1</code>后默认加了几个0；先把这几个0变成<code>nums2</code>的元素；最后排序</li>
<li>以后排序还是用双指针好点</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">    void merge(vector&lt;int&gt; &amp;nums1, int n, vector&lt;int&gt; &amp;nums2, int m)&#123;</span><br><span class="line">        int ptr = n + m - 1, p1 = n - 1, p2 = m - 1;</span><br><span class="line">        while (p1 != ptr)&#123;</span><br><span class="line">            if(p1 &gt;= 0 &amp;&amp; nums1[p1] &gt; nums2[p2])</span><br><span class="line">                nums1[ptr--] = nums1[p1--];</span><br><span class="line">            else</span><br><span class="line">                nums1[ptr--] = nums2[p2--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; nums1&#123;1, 2, 5, 0, 0, 0&#125;, nums2&#123;2, 3, 4&#125;;</span><br><span class="line">    int n = 3, m = 3;</span><br><span class="line">    Solution solution;</span><br><span class="line">    solution.merge(nums1, n, nums2, m);</span><br><span class="line">    for(const auto &amp;num : nums1)</span><br><span class="line">        cout &lt;&lt; num;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="89-格雷编码"><a href="#89-格雷编码" class="headerlink" title="89_格雷编码"></a>89_格雷编码</h2><ul>
<li>可以看出有对称性，这种对称性是以翻倍的形式存在；^是异或运算符，求幂用<code>cmath</code>里的<code>pow(x,y)</code>；下面暂时用^，好理解点</li>
<li>n = 0时{0}；n = 1时{0,2^0+0}</li>
<li>n = 1时{0,1}；n = 2时{0,1,2^1+1,2^1+0}</li>
<li>n = k时是对n = k -1的数组进行处理，后一半的数字恰好是前一半倒序的数字与2的n-1次幂之和</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void doubled(vector&lt;int&gt; &amp;res, int n)&#123;</span><br><span class="line">        if(n == 0)&#123;</span><br><span class="line">            res.emplace_back(0);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        doubled(res, --n);  //先对n减一，再递归，返回后n是减一的状态</span><br><span class="line">        int i = res.size();</span><br><span class="line">        while (i &gt; 0)&#123;  //^是异或运算符</span><br><span class="line">            res.emplace_back(res[--i] + pow(2, n));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; grayCode(int n) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        doubled(res, n);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    Solution solution;</span><br><span class="line">    int n = 4;</span><br><span class="line">    vector&lt;int&gt; res = solution.grayCode(n);</span><br><span class="line">    for(const auto &amp;r : res)</span><br><span class="line">        cout &lt;&lt; r &lt;&lt; &quot; &quot;;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="90-子集-II"><a href="#90-子集-II" class="headerlink" title="90_子集_II"></a>90_子集_II</h2><ul>
<li>这题与之前的递归有点不太一样；首先一个重点：因为是排列，所以每次递归循环都要从<code>i+1</code>开始，而不是最初的值+1（<code>int start</code>-&gt;<code>start + 1</code>）；就拿第一次循环循环来说从<code>i=0</code>开始递归，之后<code>i=1</code>时<code>start</code>还是0，<code>start + 1</code>为参数传递的话，<code>nums[i]</code>就会重复两次</li>
<li>因为是重复数字，所有要将相同的数字跳过√</li>
<li>这题没有递归出口，一上来就将<code>tmp</code>放入<code>res</code>中</li>
<li>最后别忘了先排个序</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void dfs(vector&lt;vector&lt;int&gt;&gt; &amp;res, vector&lt;int&gt; &amp;tmp, vector&lt;int&gt;&amp; nums, int start)&#123;</span><br><span class="line">        //一开始递归就将tmp放入res</span><br><span class="line">        cout &lt;&lt; &quot;tmp = &quot; ;</span><br><span class="line">        for(const auto &amp;t : tmp)</span><br><span class="line">            cout &lt;&lt; t &lt;&lt; &quot; &quot;;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        res.emplace_back(tmp);</span><br><span class="line">        for(int i = start; i &lt; nums.size(); ++i)&#123;</span><br><span class="line">            cout &lt;&lt; &quot;start = &quot; &lt;&lt; start &lt;&lt; &quot;, i = &quot; &lt;&lt; i &lt;&lt; &quot;, nums[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot; &lt;&lt; nums[i] &lt;&lt; endl;</span><br><span class="line">            if(i &gt; start  &amp;&amp; nums[i] ==nums[i - 1])&#123;</span><br><span class="line">                cout &lt;&lt; &quot;nums[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot; &lt;&lt; nums[i] &lt;&lt; &quot; == &quot; &lt;&lt; &quot;nums[&quot; &lt;&lt; i - 1 &lt;&lt; &quot;] = &quot; &lt;&lt; nums[i - 1] &lt;&lt; endl;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp.emplace_back(nums[i]);</span><br><span class="line">            dfs(res, tmp, nums, i + 1);//不是start+1而是i+1！！</span><br><span class="line">            tmp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        vector&lt;int&gt; tmp;</span><br><span class="line">        //这次回溯无需循环，直接调用函数</span><br><span class="line">        dfs(res, tmp, nums, 0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; nums&#123;1, 2, 2&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; res = solution.subsetsWithDup(nums);</span><br><span class="line">    for(const auto &amp;re : res)&#123;</span><br><span class="line">        for(const auto &amp;r : re)</span><br><span class="line">            cout &lt;&lt; r &lt;&lt; &quot; &quot;;</span><br><span class="line">        cout &lt;&lt; &quot;, &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="93-复原IP地址"><a href="#93-复原IP地址" class="headerlink" title="93_复原IP地址"></a>93_复原IP地址</h2><ul>
<li>这题做起来有点心累，但是执行用时和内存消耗还是十分令人愉悦的；</li>
<li>第一步，限制传入的字符串<code>s</code>的长度，确保肯定能分成四段</li>
<li>第二步，用递归，第一段的地址可能是1位2位3位数字，后面递归用剩下来的字符串</li>
<li>第三步，要判断数字是否有效，单独写了个函数，确保数字字符串在<code>&quot;0&quot;-&quot;255&quot;</code>之间，且不能有前导0</li>
<li>第四步，就是递归的出口了，判断数字有效后要插入<code>.</code>，我用了<code>.</code>的个数来判断，如果<code>.</code>的个数有了3个，那么只需判断剩下的字符是否有效，有效就让<code>tmp</code>加上这一段字符串放入答案中，无论是否有效都会返回；</li>
<li>第五步，返回之后，<code>tmp</code>应该弹出上一个点之后的地址，而不是全部删除，之后在循环里会以2个数字判断是否有效，并继续放入<code>tmp</code></li>
<li>我傻了，字符串可以直接比较大小，去除前导零的情况即可；还有<code>s.substr(index, i)</code>index是可以指向尾部元素的后一个位置的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool effective(string s)&#123;</span><br><span class="line">        if(s.size() == 1)</span><br><span class="line">            return true;</span><br><span class="line">        if(s.size() == 2)&#123;</span><br><span class="line">            if(s[0] != &apos;0&apos;)</span><br><span class="line">                return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if(s.size() == 3)&#123;</span><br><span class="line">            if(s[0] == &apos;1&apos;)</span><br><span class="line">                return true;</span><br><span class="line">            if(s[0] == &apos;2&apos;)&#123;</span><br><span class="line">                if(s[1] &gt;= &apos;0&apos; &amp;&amp; s[1] &lt;= &apos;4&apos;)</span><br><span class="line">                    return true;</span><br><span class="line">                if(s[1] == &apos;5&apos; &amp;&amp; s[2] &lt;= &apos;5&apos;)</span><br><span class="line">                    return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void dfs(vector&lt;string&gt; &amp;res, string tmp, string s, int n)&#123;</span><br><span class="line">//        cout &lt;&lt; &quot;tmp = &quot; &lt;&lt; tmp &lt;&lt; &quot; s = &quot; &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">        if(!tmp.empty() &amp;&amp; !s.empty())&#123;</span><br><span class="line">            tmp.push_back(&apos;.&apos;);</span><br><span class="line">            ++n;</span><br><span class="line">//            cout &lt;&lt; &quot;n = &quot; &lt;&lt; n &lt;&lt; &quot;  &quot; &lt;&lt; tmp &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        if(n == 3)&#123;</span><br><span class="line">            if(effective(s))</span><br><span class="line">                res.emplace_back(tmp += s);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int l = s.size();</span><br><span class="line">        for(int i = 0; i &lt; min(3, l); ++i)&#123;</span><br><span class="line">//            cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">            if(effective(s.substr(0, i + 1)))&#123;</span><br><span class="line">//                tmp += s.substr(0, i + 1);</span><br><span class="line">                string s_tmp = tmp + s.substr(0, i + 1);</span><br><span class="line">                string s1 = (s.size() - i - 1 == 0 ? &quot;&quot; : s.substr(i + 1, s.size() - i - 1));</span><br><span class="line">                dfs(res, s_tmp, s1, n);</span><br><span class="line">//                tmp.clear();    //不能全部删除，只能删除一段！</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;string&gt; restoreIpAddresses(string s) &#123;</span><br><span class="line">        //首先字符串本身有着长度要求</span><br><span class="line">        if(s.size() &lt; 4 || s.size() &gt; 12) return &#123;&#125;;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        //其次将s分成4段，每段中的数字只能是0-255；数字不能以0开头除了0本身</span><br><span class="line">        string tmp; //用于存放每段对应的数字</span><br><span class="line">        dfs(res, tmp, s, 0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    string s(&quot;25525511135&quot;);</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;string&gt; res = solution.restoreIpAddresses(s);</span><br><span class="line">    for(const auto &amp;r : res)</span><br><span class="line">        cout &lt;&lt; r &lt;&lt; &quot;   &quot;;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="118-杨辉三角"><a href="#118-杨辉三角" class="headerlink" title="118_杨辉三角"></a>118_杨辉三角</h2><ul>
<li>这题我看看题解有没有更好的方法，啊对，可以直接用公式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; generate(int numRows) &#123;</span><br><span class="line">        if(numRows == 0) return &#123;&#125;;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        for(int i = 1; i &lt;= numRows; ++i)&#123;</span><br><span class="line">            if(i == 1)</span><br><span class="line">                res.push_back(&#123;1&#125;);</span><br><span class="line">            else if(i == 2)</span><br><span class="line">                res.push_back(&#123;1, 1&#125;);</span><br><span class="line">            else&#123;</span><br><span class="line">                vector&lt;int&gt; tmp = &#123;1&#125;;</span><br><span class="line">                for(int j = 1; j &lt; res.back().size(); ++j)&#123;</span><br><span class="line">                    tmp.push_back(res.back()[j] + res.back()[j - 1]);</span><br><span class="line">                &#125;</span><br><span class="line">                tmp.push_back(1);</span><br><span class="line">                res.push_back(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; res = solution.generate(5);</span><br><span class="line">    for(const auto &amp; re : res) &#123;</span><br><span class="line">        for (const auto &amp;r : re)</span><br><span class="line">            cout &lt;&lt; r &lt;&lt; &quot; &quot;;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="119-杨辉三角-II"><a href="#119-杨辉三角-II" class="headerlink" title="119_杨辉三角_II"></a>119_杨辉三角_II</h2><ul>
<li>emmmm，学习下滚动数组的思想，每一行只用了上一行的值；注意从第0行开始</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; getRow(int rowIndex) &#123;</span><br><span class="line">        if(rowIndex == 0) return &#123;1&#125;;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        for(int i = 0; i &lt;= rowIndex; ++i)&#123;</span><br><span class="line">            if(i == 0)</span><br><span class="line">                res.push_back(&#123;1&#125;);</span><br><span class="line">            else if(i == 1)</span><br><span class="line">                res.push_back(&#123;1, 1&#125;);</span><br><span class="line">            else&#123;</span><br><span class="line">                vector&lt;int&gt; tmp = &#123;1&#125;;</span><br><span class="line">                for(int j = 1; j &lt; res.back().size(); ++j)&#123;</span><br><span class="line">                    tmp.push_back(res.back()[j] + res.back()[j - 1]);</span><br><span class="line">                &#125;</span><br><span class="line">                tmp.push_back(1);</span><br><span class="line">                res.push_back(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;int&gt; tmp = solution.getRow(5);</span><br><span class="line">    for (const auto &amp;r : tmp)</span><br><span class="line">        cout &lt;&lt; r &lt;&lt; &quot; &quot;;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="120-三角形最小路径和"><a href="#120-三角形最小路径和" class="headerlink" title="120_三角形最小路径和"></a>120_三角形最小路径和</h2><ul>
<li>仔细思考后发现，需要考虑相同数字的情况；用动态规划康康</li>
<li>注意几个细节；首先可以直接调用<code>*min_element(f[n - 1].begin(), f[n - 1].end())</code>来获取最后一行的最小值，这样写的好处是即使只有一行，也能正确返回，所以大循环直接从<code>i = 1</code>开始；还有次循环可以直接写成<code>j = 1; j &lt; i</code>；</li>
<li>收藏下一位大佬写的代码！</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) &#123;</span><br><span class="line">        if(triangle.empty()) return 0;</span><br><span class="line">        if(triangle.size() == 1) return triangle[0][0];</span><br><span class="line">        int ans = INT32_MAX;</span><br><span class="line">        int r = triangle.size(), c = triangle.back().size();//行，列</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(r, vector&lt;int&gt;(c, 0));</span><br><span class="line">        for(int i = 0; i &lt; r; ++i)&#123;</span><br><span class="line">            if(i == 0)&#123;</span><br><span class="line">                dp[0][0] = triangle[0][0];</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int j = 0; j &lt; triangle[i].size(); ++j)&#123;</span><br><span class="line">                if(j == 0)</span><br><span class="line">                    dp[i][j] = dp[i - 1][j] + triangle[i][j];</span><br><span class="line">                else if(j + 1 &lt; triangle[i].size())</span><br><span class="line">                    dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - 1]) +  triangle[i][j];</span><br><span class="line">                else</span><br><span class="line">                    dp[i][j] = dp[i - 1][j - 1] + triangle[i][j];</span><br><span class="line"></span><br><span class="line">                if(i + 1 == r)</span><br><span class="line">                    ans = min(ans, dp[i][j]);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//大佬写的，由下至上，只用了一个数组来维护</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) &#123;</span><br><span class="line">        vector&lt;int&gt; dp(triangle.back());</span><br><span class="line">        for(int i = triangle.size() - 2; i &gt;= 0; i --)</span><br><span class="line">            for(int j = 0; j &lt;= i; j ++)</span><br><span class="line">                dp[j] = min(dp[j], dp[j + 1]) + triangle[i][j];</span><br><span class="line">        return dp[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121_买卖股票的最佳时机"></a>121_买卖股票的最佳时机</h2><ul>
<li>这题有点意思，二维动态规划数组和双重循环暴力求解没区别，都会超出时间限制；用动态规划是肯定的，关键在于如何降维数组</li>
<li>时间有限，就直接在网站上手撕了……</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        vector&lt;int&gt; dp(prices.size(), 0);</span><br><span class="line">        int tmp = prices[0];</span><br><span class="line">        for(int i = 1; i &lt; prices.size(); ++i)&#123;</span><br><span class="line">            if(prices[i] &lt;= tmp)&#123;</span><br><span class="line">                dp[i] = dp[i - 1];</span><br><span class="line">                tmp = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                dp[i] = max(dp[i - 1], prices[i] - tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        return dp.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="122-买卖股票的最佳时机-ll"><a href="#122-买卖股票的最佳时机-ll" class="headerlink" title="122_买卖股票的最佳时机_ll"></a>122_买卖股票的最佳时机_ll</h2><ul>
<li>同样是动态规划，自己写的不够简洁；官方题解确实跑得快</li>
<li>贪心算法是将所有上坡的利润都加起来…我写的动态规划好像就是贪心…..</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        int n = prices.size();</span><br><span class="line">        if(n &lt;= 1) return 0;</span><br><span class="line">        int tmp = prices[0];</span><br><span class="line">        vector&lt;int&gt; dp(n, 0);</span><br><span class="line">        for(int i = 1; i &lt; n; ++i)&#123;</span><br><span class="line">            if(prices[i] &lt;= tmp)&#123;</span><br><span class="line">                dp[i] = dp[i - 1];</span><br><span class="line">                tmp = prices[i]; //更新历史最低价</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                if(i + 1 &lt; n &amp;&amp; prices[i] &gt; prices[i + 1])&#123;</span><br><span class="line">                    dp[i] = prices[i] - tmp + dp[i - 1];    //卖出</span><br><span class="line">                    tmp = prices[i + 1]; //更新历史最低价为卖出第二天的价格</span><br><span class="line">                &#125;else if(i + 1 &lt; n)&#123;</span><br><span class="line">                    //不卖</span><br><span class="line">                    dp[i] = dp[i - 1];</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    dp[i] = prices[i] - tmp + dp[i - 1];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="123-买卖股票的最佳时机-III"><a href="#123-买卖股票的最佳时机-III" class="headerlink" title="123_买卖股票的最佳时机_III"></a>123_买卖股票的最佳时机_III</h2><ul>
<li>这题的动态规划没想出来，用了暴力求解，但超出时间限制了；对于动态规划，首先要了解所有的状态有哪些，再去了解之间的转移关系</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices)&#123;</span><br><span class="line">        int n = prices.size();</span><br><span class="line">        if(n &lt;= 1) return 0;</span><br><span class="line">        int buy1 = -prices[0], sell1 = 0, buy2 = -prices[0], sell2 = 0;</span><br><span class="line">        for(int i = 1; i &lt; n; ++i)&#123;</span><br><span class="line">            buy1 = max(buy1, -prices[i]);</span><br><span class="line">            sell1 = max(sell1, buy1 + prices[i]);</span><br><span class="line">            buy2 = max(buy2, sell1 - prices[i]);</span><br><span class="line">            sell2 = max(sell2, buy2 + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return sell2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; prices = &#123;1,2,4,2,5,7,2,4,9,0&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.maxProfit(prices) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128_最长连续序列"></a>128_最长连续序列</h2><ul>
<li>这题先排序，再去重，然后双指针，不过时间复杂度超过了<code>O(n)</code>了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if(nums.size() &lt;= 1) return nums.size();</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        vector&lt;int&gt; num;</span><br><span class="line">        for(const auto &amp;nu : nums)&#123;</span><br><span class="line">            if(num.empty() || nu != num.back())</span><br><span class="line">                num.emplace_back(nu);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int ans = 1, l = 0, r = l + 1;</span><br><span class="line">        while (r &lt; num.size())&#123;</span><br><span class="line">            if(num[r] == num[r - 1] + 1)&#123;</span><br><span class="line">                if(r + 1 == num.size())</span><br><span class="line">                    ans = max(ans, r - l + 1);</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                ans = max(ans, r - l);</span><br><span class="line">                l = r;</span><br><span class="line">            &#125;</span><br><span class="line">            ++r;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; nums = &#123;1,2,0,1&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.longestConsecutive(nums) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="130-被围绕的区域"><a href="#130-被围绕的区域" class="headerlink" title="130_被围绕的区域"></a>130_被围绕的区域</h2><ul>
<li>得先找出所有与边上的<code>O</code>相连的区域，然后再将其余区域都用<code>X</code>代替？</li>
<li>标记的时候不能一行一行来，因为上一行要依赖下一行的信息；只能暴力了，依次对边上的<code>O</code>作标记，还要对其上下左右也标记，一直到没有<code>O</code>为止</li>
<li>从边界开始DFS；官方题解就是简洁，上下左右只需要或运算判断符就好了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void mark(vector&lt;vector&lt;char&gt;&gt;&amp; board, vector&lt;vector&lt;int&gt;&gt; &amp;tmp, int i, int j)&#123;</span><br><span class="line">        if(board[i][j] == &apos;X&apos;) return;</span><br><span class="line">        //cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; &quot; j = &quot; &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">        tmp[i][j] = 1;</span><br><span class="line">        int up = i - 1 == -1 ? 0 : i - 1;</span><br><span class="line">        int down = i + 1 == tmp.size() ? i : i + 1;</span><br><span class="line">        int left = j - 1 == -1 ? 0 : j - 1;</span><br><span class="line">        int right = j + 1 == tmp[0].size() ? j : j + 1;</span><br><span class="line">        if(board[up][j] == &apos;O&apos; &amp;&amp; tmp[up][j] == 0)</span><br><span class="line">            mark(board, tmp, up, j);</span><br><span class="line">        if(board[down][j] == &apos;O&apos; &amp;&amp; tmp[down][j] == 0)</span><br><span class="line">            mark(board, tmp, down, j);</span><br><span class="line">        if(board[i][left] == &apos;O&apos; &amp;&amp; tmp[i][left] == 0)</span><br><span class="line">            mark(board, tmp, i, left);</span><br><span class="line">        if(board[i][right] == &apos;O&apos; &amp;&amp; tmp[i][right] == 0)</span><br><span class="line">            mark(board, tmp, i, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;</span><br><span class="line">        if(board.empty()) return;</span><br><span class="line">        int row = board.size(), col = board[0].size();</span><br><span class="line">        if(row &lt; 3 || col &lt; 3) return;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; tmp(row, vector&lt;int&gt;(col, 0));</span><br><span class="line">        //每个边界点做标记</span><br><span class="line">        int t_tmp = 0;</span><br><span class="line">        while (t_tmp &lt; col)&#123;</span><br><span class="line">            mark(board,tmp, 0, t_tmp);</span><br><span class="line">            mark(board,tmp, row - 1, t_tmp);</span><br><span class="line">            ++t_tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        t_tmp = 0;</span><br><span class="line">        while (t_tmp  &lt; row)&#123;</span><br><span class="line">            mark(board,tmp, t_tmp, 0);</span><br><span class="line">            mark(board,tmp, t_tmp, col - 1);</span><br><span class="line">            ++t_tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 1; i &lt; row - 1; ++i)&#123;</span><br><span class="line">            for(int j = 1; j &lt; col - 1; ++j)&#123;</span><br><span class="line">                if(board[i][j] == &apos;O&apos; &amp;&amp; tmp[i][j] == 0)</span><br><span class="line">                    board[i][j] = &apos;X&apos;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;vector&lt;char&gt;&gt; board(&#123;&#123;&apos;O&apos;,&apos;X&apos;,&apos;X&apos;,&apos;O&apos;,&apos;X&apos;&#125;,</span><br><span class="line">                                  &#123;&apos;X&apos;,&apos;O&apos;,&apos;O&apos;,&apos;X&apos;,&apos;O&apos;&#125;,</span><br><span class="line">                                  &#123;&apos;X&apos;,&apos;O&apos;,&apos;X&apos;,&apos;O&apos;,&apos;X&apos;&#125;,</span><br><span class="line">                                  &#123;&apos;O&apos;,&apos;X&apos;,&apos;O&apos;,&apos;O&apos;,&apos;O&apos;&#125;,</span><br><span class="line">                                  &#123;&apos;X&apos;,&apos;X&apos;,&apos;O&apos;,&apos;X&apos;,&apos;O&apos;&#125;&#125;);</span><br><span class="line">    cout &lt;&lt; &quot;board = &quot; &lt;&lt; endl;</span><br><span class="line">    for(const auto &amp;bo : board)&#123;</span><br><span class="line">        for(const auto &amp;b : bo)</span><br><span class="line">            cout &lt;&lt; b &lt;&lt; &quot; &quot;;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Solution solution;</span><br><span class="line">    solution.solve(board);</span><br><span class="line">    cout &lt;&lt; &quot;res = &quot; &lt;&lt; endl;</span><br><span class="line">    for(const auto &amp;bo : board)&#123;</span><br><span class="line">        for(const auto &amp;b : bo)</span><br><span class="line">            cout &lt;&lt; b &lt;&lt; &quot; &quot;;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131_分割回文串"></a>131_分割回文串</h2><ul>
<li>首先每个字符本身就是个回文字符串，然后…这题思路有点乱</li>
<li>思路不清晰的时候，感觉无从下手，又或者就差临门一脚，好在山重水复疑无路，休息一会后思路又清晰了</li>
<li>每次递归从第一个字符开始切，判断左边是否是回文串，如果是，就将右边字符串放入形参递归，不是就从第二个字符开始切，这样会一直切到最后一个字符；<code>tmp</code>每次递归回来后要弹出一个<code>string</code></li>
<li>我用的是递归加回溯</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isPalindrome(string &amp;hs)&#123;</span><br><span class="line">        if(hs.size() &lt;= 1) return true;</span><br><span class="line">        string s(hs);</span><br><span class="line">        reverse(s.begin(), s.end());</span><br><span class="line">        return s == hs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void dfs(string &amp;s)&#123;</span><br><span class="line">        if(s.empty())&#123;</span><br><span class="line">            ans.emplace_back(tmp);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 1; i &lt;= s.size(); ++i)&#123;</span><br><span class="line">            string lhs(s.begin(), s.begin() + i);</span><br><span class="line">            if(isPalindrome(lhs))&#123;</span><br><span class="line">                string rhs(s.begin() + i, s.end());</span><br><span class="line">                tmp.emplace_back(lhs);</span><br><span class="line">                dfs(rhs);</span><br><span class="line">                tmp.pop_back();</span><br><span class="line">            &#125; else</span><br><span class="line">                continue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123;</span><br><span class="line">        dfs(s);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line">    vector&lt;string&gt; tmp;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    string s = &quot;aabb&quot;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; ans = solution.partition(s);</span><br><span class="line">    for(const auto &amp;an : ans)&#123;</span><br><span class="line">        for(const auto &amp;a : an)</span><br><span class="line">            cout &lt;&lt; a &lt;&lt; &quot; &quot;;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="134-加油站"><a href="#134-加油站" class="headerlink" title="134_加油站"></a>134_加油站</h2><ul>
<li>首先总油量要大于消耗，但大于等于就一定可以走完一圈吗</li>
<li>遇事不决，暴力求解；雾草，，，居然过了，赶紧看看题解有没有好的方法</li>
<li>题解优化了代码，题解牛批，我还是粘贴自己写的烂代码吧</li>
<li><code>int j = (i + cnt) % n;</code>这个代码可以省去一次<code>for</code>循环</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;iterator&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool yep(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost, int p)&#123;</span><br><span class="line">        int n = gas.size();</span><br><span class="line">        int res = 0;</span><br><span class="line">        for(int i = p; i &lt; n; ++i)&#123;</span><br><span class="line">            res = res + gas[i] - cost[i];</span><br><span class="line">            if(res &lt; 0)</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; p; ++i)&#123;</span><br><span class="line">            res = res + gas[i] - cost[i];</span><br><span class="line">            if(res &lt; 0)</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123;</span><br><span class="line">       //所有加油站都遍历一遍，当作起点</span><br><span class="line">        int ans = -1;</span><br><span class="line">        for(int i = 0; i &lt; gas.size(); ++i)&#123;</span><br><span class="line">            if(gas[i] &gt;= cost[i])&#123;</span><br><span class="line">                if(yep(gas, cost, i))&#123;</span><br><span class="line">                    ans = i;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; gas(&#123;1,2,3,4,5&#125;), cost(&#123;3,4,5,1,2&#125;);</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.canCompleteCircuit(gas, cost) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="135-分发糖果"><a href="#135-分发糖果" class="headerlink" title="135_分发糖果"></a>135_分发糖果</h2><ul>
<li>高评分的孩子的糖果是由两边低评分的孩子共同决定的，举个例子，[2,3]，第二个孩子评分比第一个高，那么糖果肯定比第一个多，至于多几个则要看后面有多少比他评分低的孩子；如果后面一个孩子评分高，那就只能多一颗糖果；以此类推…</li>
<li>同理，[3,3]，评分一样，那么第二个孩子的糖果数与前者无关，只与后面有关，如果后面没有人，那一颗足以</li>
<li>关键是要找到一个低谷；感觉用单调栈好一点</li>
<li>栈我不会，，，又是一道心力憔悴的一题…终于做出来是有多么喜悦！！！找波峰或者波谷太麻烦，考虑的因素太多，直接顺着和反着各遍历一次</li>
<li>就是反向遍历的时候要考虑波峰这个位置，要看左右两边哪个大</li>
<li>按照惯例，官方题解也跑一下…</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;numeric&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int candy(vector&lt;int&gt;&amp; ratings) &#123;</span><br><span class="line">        if(ratings.empty()) return 0;</span><br><span class="line">        if(ratings.size() == 1) return 1;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        //关键找到谷峰、谷底</span><br><span class="line">        vector&lt;int&gt; tmp(ratings.size(), 1);</span><br><span class="line">        int i = 1;</span><br><span class="line"></span><br><span class="line">        while (i &lt; ratings.size())&#123;</span><br><span class="line">            if(ratings[i] &gt; ratings[i - 1])</span><br><span class="line">                tmp[i] += tmp[i - 1];</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        --i;</span><br><span class="line">        while (i &gt; 0)&#123;</span><br><span class="line">            if(ratings[i - 1] &gt; ratings[i])&#123;</span><br><span class="line">                if(i - 2 &gt;= 0 &amp;&amp; ratings[i - 1] &gt; ratings[i - 2])&#123;</span><br><span class="line">                    tmp[i - 1] = max(tmp[i - 2], tmp[i]) + 1;</span><br><span class="line">                &#125; else&#123;</span><br><span class="line">                    tmp[i - 1] += tmp[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            --i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(const auto &amp;t : tmp)</span><br><span class="line">            cout &lt;&lt; t &lt;&lt; &quot; &quot;;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        return accumulate(tmp.begin(), tmp.end(), ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; ratings(&#123;29,51,87,87,72,12,13&#125;);</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.candy(ratings) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136_只出现一次的数字"></a>136_只出现一次的数字</h2><ul>
<li>这题暴力了，但是还是写的很烂</li>
<li>异或运算牛批</li>
</ul>
<p><img src="/pictrues/bit.png" alt="位运算"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        for(int i = 0; i &lt; nums.size(); ++i)&#123;</span><br><span class="line">            if(i + 1 == nums.size())</span><br><span class="line">                return nums[i];</span><br><span class="line"></span><br><span class="line">            if(nums[i] == nums[i + 1])</span><br><span class="line">                ++i;</span><br><span class="line">            else</span><br><span class="line">                return nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="137-只出现一次的数字-ll"><a href="#137-只出现一次的数字-ll" class="headerlink" title="137_只出现一次的数字_ll"></a>137_只出现一次的数字_ll</h2><ul>
<li>位运算太高明了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        unordered_map&lt;int, int&gt; map;</span><br><span class="line">        for(const auto &amp;n : nums)</span><br><span class="line">            map[n]++;</span><br><span class="line">        for(auto &amp; iter : map)&#123;</span><br><span class="line">            if(iter.second == 1)</span><br><span class="line">                return iter.first;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="149-直线上最多的点数"><a href="#149-直线上最多的点数" class="headerlink" title="149_直线上最多的点数"></a>149_直线上最多的点数</h2><ul>
<li>这题暴力出来了…没有去重，直接将每个点所在的直线都计算出来，比较点的个数</li>
<li>击败双5%，哈哈哈——去除重复点应该可以大幅减小计算时间</li>
<li>学习下如何储存一条直线</li>
<li>题解用double作哈希表键值会有问题，测试样例<code>[{0,0}, {941150,94911151}, {94911151,94911152}]</code>通不过，用字符串吧</li>
<li>或者将斜率的分子和分母约至最简，<code>for (auto&amp; [_, i] : mp)</code>这个是C++17里的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution_ &#123;</span><br><span class="line">public:</span><br><span class="line">    int res = 2;</span><br><span class="line">    vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; lines;</span><br><span class="line">    int pos = -1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    int maxPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;</span><br><span class="line">        int l =static_cast&lt;int&gt;(points.size());</span><br><span class="line">        if(l &lt;= 2) return l;</span><br><span class="line">        //从第一个点开始建立直线</span><br><span class="line">//        lines.clear();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; tmp;</span><br><span class="line">        tmp.push_back(points[0]);</span><br><span class="line">        tmp.push_back(points[1]);</span><br><span class="line">        lines.push_back(tmp);</span><br><span class="line"></span><br><span class="line">        for(int i = 2; i &lt; l; ++i)&#123;</span><br><span class="line">            //判断当前点是否在已有的直线里，若有则放入，没有则新建</span><br><span class="line">            if(isLineAlready(points[i][0], points[i][1]))&#123;</span><br><span class="line">                lines[pos].push_back(points[i]);</span><br><span class="line">                res = max(res, static_cast&lt;int&gt;(lines[pos].size()));</span><br><span class="line">                pos = -1;</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                tmp.clear();</span><br><span class="line">                tmp.push_back(points[0]);</span><br><span class="line">                tmp.push_back(points[i]);</span><br><span class="line">                lines.push_back(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //递归</span><br><span class="line">        lines.clear();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; p;</span><br><span class="line">        copy(points.begin() + 1, points.end(), inserter(p, p.begin()));</span><br><span class="line">        res = max(res, maxPoints(p));</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool isLineAlready(int x, int y)&#123;</span><br><span class="line">        for(int i = 0; i &lt; lines.size(); ++i)&#123;</span><br><span class="line">            if(lines[i][0][0] == lines[i][1][0] &amp;&amp; lines[i][0][0] == x)&#123;</span><br><span class="line">                pos = i;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            double k = static_cast&lt;double&gt;(lines[i][0][1] - lines[i][1][1]) / (lines[i][0][0] - lines[i][1][0]);</span><br><span class="line">            double k_ = static_cast&lt;double&gt;(y - lines[i][0][1]) / (x - lines[i][0][0]);</span><br><span class="line">            if(abs(k - k_) &lt;= 10e-5)&#123;</span><br><span class="line">                pos = i;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//大佬写的，用哈希表果然比vector快</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    // 求最大公约数</span><br><span class="line">    int gcd(int a, int b) &#123;</span><br><span class="line">        int t;</span><br><span class="line">        if (a &lt; b) swap(a, b);</span><br><span class="line">        while(b &gt; 0) &#123;</span><br><span class="line">            t = a % b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = t;</span><br><span class="line">        &#125;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">    // 斜率 k = (x1 - x2) / (y1 - y2)</span><br><span class="line">    pair&lt;int, int&gt; k (int x1, int x2, int y1, int y2) &#123;</span><br><span class="line">        bool flag = true; // 符号</span><br><span class="line">        int up, down; // 分子, 分母</span><br><span class="line">//        这里的斜率是将横坐标的差值放在分子上</span><br><span class="line">        if (y1 - y2 == 0) return &#123;INT_MAX, INT_MAX&#125;;</span><br><span class="line">        else &#123;</span><br><span class="line">            int dx = x1 - x2;</span><br><span class="line">            int dy = y1 - y2;</span><br><span class="line">            // 符号相反</span><br><span class="line">            if ((dx ^ dy) &lt; 0) flag = false;</span><br><span class="line">            dx = abs(dx), dy = abs(dy);</span><br><span class="line">            up = dx / gcd(dx, dy);</span><br><span class="line">            down = dy / gcd(dx, dy);</span><br><span class="line">        &#125;</span><br><span class="line">        return flag ? make_pair(up, down) : make_pair(-up, down);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int maxPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;</span><br><span class="line">        map&lt;pair&lt;int, int&gt;, int&gt; mp; // (斜率, 数目)</span><br><span class="line">        int ans = 1;</span><br><span class="line">        for (int i = 0; i &lt; points.size(); ++i) &#123;</span><br><span class="line">            for (int j = i + 1; j &lt; points.size(); ++j) &#123;</span><br><span class="line">                ++mp[k(points[i][0], points[j][0], points[i][1], points[j][1])];</span><br><span class="line">            &#125;</span><br><span class="line">            /*for (auto&amp; [_, i] : mp) &#123;</span><br><span class="line">                ans = max(ans, i + 1);</span><br><span class="line">            &#125;*/</span><br><span class="line">            for(const auto &amp;m : mp)&#123;</span><br><span class="line">                ans = max(ans, m.second + 1);</span><br><span class="line">            &#125;</span><br><span class="line">            mp.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; points(&#123;&#123;1,1&#125;, &#123;3,2&#125;, &#123;5,3&#125;, &#123;4,1&#125;, &#123;2,3&#125;, &#123;1,4&#125;&#125;);</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.maxPoints(points) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二刷"><a href="#二刷" class="headerlink" title="二刷"></a>二刷</h3><ul>
<li>再一次做的时候——暴力还是出现各种问题，三重循环、求斜率时应该用<code>double</code>而不是<code>int</code>——三重循环通过了！！！<ul>
<li>而且还比第一次时间更快？</li>
<li>真佩服我自己…之前写的居然还用了递归…</li>
<li>还有个小问题，就是<code>double</code>相比较——虽然我直接写<code>==</code>能通过，但这是不对的，应该写<code>abs(slope - _slope) &lt;= 10e-5</code></li>
</ul>
</li>
</ul>
<p><img src="/pictrues/149_2.png" alt title="提交结果"></p>
<ul>
<li>看到记录斜率去重、如果遇到平行线了呢？这次好好记录下！——第一遍大佬（题解）的记录<ul>
<li>首先是两重循环，第一个点和其余点组成斜率，计算出斜率最多的点数+1</li>
<li>第二次遍历的时候，清空哈希表！</li>
<li>最大公约数Greatest common divisor——有两种写法，而且无需取绝对值（因为参数带入之前就已经取过绝对值-不停的取余</li>
<li>为了解决斜率为负的情况，统一让分母取正</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//二刷手撕</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;</span><br><span class="line">        //有点眼熟、一看题号、原来做过——两点确定一条直线</span><br><span class="line">        int n = points.size();</span><br><span class="line">        if(n &lt; 3)</span><br><span class="line">            return n;</span><br><span class="line">        //至少是两个点</span><br><span class="line">        int ans = 2;</span><br><span class="line">        //先选择第一个点</span><br><span class="line">        for(int i = 0; i &lt; n - 1; ++i)&#123;</span><br><span class="line">            //选择第二个点——如果直线已经用过，则跳过这个点——这里没有实现</span><br><span class="line">            for(int j = i + 1; j &lt; n; ++j)&#123;</span><br><span class="line">                //依次判断后面的点，在不在这条直线上</span><br><span class="line">                int tmp = 2;</span><br><span class="line">                for(int k = j + 1; k &lt; n; ++k)&#123;</span><br><span class="line">                    //斜率无穷大</span><br><span class="line">                    if(points[i][0] == points[j][0] &amp;&amp; points[i][0] == points[k][0])&#123;</span><br><span class="line">                        ++tmp;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //如果三个横坐标，有一对相等，就跳过</span><br><span class="line">                    if(points[i][0] == points[j][0] || points[i][0] == points[k][0])</span><br><span class="line">                        continue;</span><br><span class="line"></span><br><span class="line">                    //斜率有限值</span><br><span class="line">                    double slope = static_cast&lt;double&gt;(points[i][1] - points[j][1]) / (points[i][0] - points[j][0]);</span><br><span class="line">                    double _slope = static_cast&lt;double&gt;(points[i][1] - points[k][1]) / (points[i][0] - points[k][0]);</span><br><span class="line">                    if(abs(slope - _slope) &lt;= 10e-5)</span><br><span class="line">                        ++tmp;</span><br><span class="line">                &#125;</span><br><span class="line">                ans = max(ans, tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br><span class="line">//题解</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    //这里的求最大公约数太妙了</span><br><span class="line">    int gcd(int a, int b) &#123;</span><br><span class="line">        return b ? gcd(b, a % b) : a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int maxPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;</span><br><span class="line">        int n = points.size();</span><br><span class="line">        if (n &lt;= 2) &#123;</span><br><span class="line">            return n;</span><br><span class="line">        &#125;</span><br><span class="line">        int ret = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            if (ret &gt;= n - i || ret &gt; n / 2) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            unordered_map&lt;int, int&gt; mp;</span><br><span class="line">            for (int j = i + 1; j &lt; n; j++) &#123;</span><br><span class="line">                int x = points[i][0] - points[j][0];</span><br><span class="line">                int y = points[i][1] - points[j][1];</span><br><span class="line">                if (x == 0) &#123;</span><br><span class="line">                    y = 1;</span><br><span class="line">                &#125; else if (y == 0) &#123;</span><br><span class="line">                    x = 1;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    if (y &lt; 0) &#123;</span><br><span class="line">                        x = -x;</span><br><span class="line">                        y = -y;</span><br><span class="line">                    &#125;</span><br><span class="line">                    int gcdXY = gcd(abs(x), abs(y));</span><br><span class="line">                    x /= gcdXY, y /= gcdXY;</span><br><span class="line">                &#125;</span><br><span class="line">                //这里是为了，取唯一性</span><br><span class="line">                mp[ y+ x * 20001]++;</span><br><span class="line">            &#125;</span><br><span class="line">            int maxn = 0;</span><br><span class="line">            for(const auto &amp;m : mp)&#123;</span><br><span class="line">                maxn = max(maxn, m.second + 1);</span><br><span class="line">            &#125;</span><br><span class="line">            //c17版本</span><br><span class="line">//            for (auto&amp; [_, num] : mp) &#123;</span><br><span class="line">//                maxn = max(maxn, num + 1);</span><br><span class="line">//            &#125;</span><br><span class="line">            ret = max(ret, maxn);</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150_逆波兰表达式求值"></a>150_逆波兰表达式求值</h2><ul>
<li>…</li>
<li>先了解下定义、a+b，这是中缀表达式，写成后缀表达式就是：ab+</li>
<li>给出的例子都没有包含括号</li>
<li>还可以就是<code>string</code>转其他类型有点忘了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int evalRPN(vector&lt;string&gt;&amp; tokens) &#123;</span><br><span class="line">        stack&lt;int&gt; number;</span><br><span class="line">//        stack&lt;string&gt; symbol;</span><br><span class="line">        for(auto s : tokens)&#123;</span><br><span class="line">            if(isdigit(s[0]) || s.size() &gt; 1)&#123;</span><br><span class="line">                int num = stoi(s);</span><br><span class="line">                number.push(num);</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                int a = number.top();</span><br><span class="line">                number.pop();</span><br><span class="line">                int b = number.top();</span><br><span class="line">                number.pop();</span><br><span class="line">                switch (s[0]) &#123;</span><br><span class="line">                    case &apos;+&apos;:</span><br><span class="line">                        number.push(b + a);</span><br><span class="line">                        break;</span><br><span class="line">                    case &apos;-&apos;:</span><br><span class="line">                        number.push(b - a);</span><br><span class="line">                        break;</span><br><span class="line">                    case &apos;*&apos;:</span><br><span class="line">                        number.push(b * a);</span><br><span class="line">                        break;</span><br><span class="line">                    case &apos;/&apos;:</span><br><span class="line">                        number.push(b / a);</span><br><span class="line">                        break;</span><br><span class="line">                    default:</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; number.top() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return number.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">//    ((10 * (6 / ((9 + 3) * -11))) + 17) + 5</span><br><span class="line">    vector&lt;string&gt; tokens(&#123;&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;/&quot;,&quot;*&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;&#125;);</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.evalRPN(tokens) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="152-乘积最大子数组"><a href="#152-乘积最大子数组" class="headerlink" title="152_乘积最大子数组"></a>152_乘积最大子数组</h2><ul>
<li>这题虽然想到了用<code>f(i)</code>作为第<code>i</code>个元素为结尾的数组的最大乘积，但是不知道怎么遍历，明明第53题类似的，看来不自己深入思考，迟早会忘得干净</li>
<li>动态规划，先重做下53题…</li>
<li>再学习下分治的思想</li>
<li>状态转移方程如下</li>
</ul>
<p><img src="/pictrues/max.png" alt="状态转移方程" title="这个是错的"><br><img src="/pictrues/maxmin.png" alt="状态转移方程" title="正确"></p>
<ul>
<li>求数组的最大值，可以直接用<code>*max_element(maxF.begin(), maxF.end());</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProduct(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;int&gt; ma(nums), mi(nums);</span><br><span class="line">        int ans = nums[0];</span><br><span class="line">        for(int i = 1; i &lt; nums.size(); ++i)&#123;</span><br><span class="line">            ma[i] = max(ma[i - 1] * nums[i], max(mi[i - 1] * nums[i], nums[i]));</span><br><span class="line">            mi[i] = min(ma[i - 1] * nums[i], min(mi[i - 1] * nums[i], nums[i]));</span><br><span class="line">            ans = max(ans, ma[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    //如果是几个负数连在一起呢</span><br><span class="line">    vector&lt;int&gt; nums(&#123;2,-5,-2,-4,3&#125;);</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.maxProduct(nums) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="153-寻找旋转排序数组中的最小值"><a href="#153-寻找旋转排序数组中的最小值" class="headerlink" title="153_寻找旋转排序数组中的最小值"></a>153_寻找旋转排序数组中的最小值</h2><ul>
<li>只要二分法找出右边的数字比左边小即可，注意二分时考虑指针相等的情况，不然会无限循环</li>
<li>53题还是有点不细心，，，</li>
<li>题解写的更清晰些</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution_ &#123;</span><br><span class="line">public:</span><br><span class="line">    int findMin(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int low = 0;</span><br><span class="line">        int high = nums.size() - 1;</span><br><span class="line">        while (low &lt; high) &#123;</span><br><span class="line">            int pivot = low + (high - low) / 2;</span><br><span class="line">            if (nums[pivot] &lt; nums[high]) &#123;</span><br><span class="line">                high = pivot;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                low = pivot + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nums[low];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findMin(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        int l = 0, r = n - 1;</span><br><span class="line">        while(l &lt;= r)&#123;</span><br><span class="line">            int m = (l + r) / 2;</span><br><span class="line">            if(m == n - 1)</span><br><span class="line">                return nums[0];</span><br><span class="line">            if(nums[m] &lt; nums[m + 1] &amp;&amp; nums[l] &lt;= nums[m])&#123;</span><br><span class="line">                l = m + 1;</span><br><span class="line">            &#125;else if(nums[m] &lt; nums[m + 1] &amp;&amp; nums[l] &gt; nums[m])&#123;</span><br><span class="line">                r = m - 1;</span><br><span class="line">            &#125;else if(nums[m] &gt; nums[m + 1])&#123;</span><br><span class="line">                return nums[m + 1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="154-寻找旋转排序数组中的最小值-II"><a href="#154-寻找旋转排序数组中的最小值-II" class="headerlink" title="154_寻找旋转排序数组中的最小值_II"></a>154_寻找旋转排序数组中的最小值_II</h2><ul>
<li>出现了重复的数字，之前有也一题类似的，找目标值，忘了怎么写了….</li>
<li>如果左指针与右指针对应的数字相等，那么一种情况是，两者之间所有数字都相等；如果是刚开始，那么最小数字可能在中间，或者本身就是最小数字</li>
<li>看了题解，如果出现重复的数字，那就必有右端点的替代品，忽略区间的右端点！！！</li>
<li>有个小细节，输出的是左指针，条件比较的是中指针和右指针</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findMin(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = static_cast&lt;int&gt;(nums.size());</span><br><span class="line">        int l = 0, r = n - 1;</span><br><span class="line">        while (l &lt; r)&#123;</span><br><span class="line">            int m = l + (r - l) / 2;</span><br><span class="line">            if(nums[m] &lt; nums[r])&#123;</span><br><span class="line">                r = m;</span><br><span class="line">            &#125; else if(nums[m] &gt; nums[r])&#123;</span><br><span class="line">                l = m + 1;</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                --r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="162-寻找峰值"><a href="#162-寻找峰值" class="headerlink" title="162_寻找峰值"></a>162_寻找峰值</h2><ul>
<li>我这个方法，太笨了，，，复杂度来看应该用二分，而我是从两边同时开始遍历….</li>
<li>判断条件可以直接判断<code>if (nums[i] &gt; nums[i + 1])</code>…题目条件给出相邻的两个元素一定不同，所以只要出现这个条件就一定是<code>i</code>，否则就是数组的最后一个元素，高，实在是高！</li>
<li>还有二分的时候可以递归也可以迭代，如果<code>nums[mid] &gt; nums[mid + 1]</code>那么不能直接返回<code>mid</code>，因为不知道<code>mid-1</code>的情况，最后输出的是<code>l</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /*int findPeakElement(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        for(int i = 0; i &lt; n - 1; ++i)&#123;</span><br><span class="line">            if(nums[i] &gt; nums[i + 1])</span><br><span class="line">                return i;</span><br><span class="line">        &#125;</span><br><span class="line">        return n - 1;</span><br><span class="line">    &#125;*/</span><br><span class="line">    int findPeakElement(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        int l = 0, r = n - 1;</span><br><span class="line">        while(l &lt; r)&#123;</span><br><span class="line">            int mid = (l + r) / 2;</span><br><span class="line">            if(nums[mid] &gt; nums[mid + 1])</span><br><span class="line">                r = mid;    //这里不能直接返回mid</span><br><span class="line">            else</span><br><span class="line">                l = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; nums(&#123;1,2,1&#125;);</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.findPeakElement(nums) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="164-最大间距"><a href="#164-最大间距" class="headerlink" title="164_最大间距"></a>164_最大间距</h2><ul>
<li>学习下基数排序，基数排序可以在<code>O(N)</code>的时间内完成整数之间的排序。</li>
<li>还有基于桶的算法</li>
<li><code>cnt[i] += cnt[i - 1]</code>有点理解了，<code>cnt</code>存放的是比如个位数从小到大排好的个数，比如个位数是2的有一个，对应个位数没有的为0；累加(和是总个数)就相当于目标数组对应的位置了，方便后续再拿出来放回数组</li>
<li>还有就是放回数组的时候为什么要从后往前遍历，从前往后的话，会在十位数的时候出现位置反掉的情况，仅针对十位数相同的数字;因为每次循环过后，数组最后一位数字都是某位（比如个位数）最大的，每次放回数组时，对应的位置会减一，再遇到相同十位数的数字就只能在前面放置</li>
<li>桶排序，感觉本质上差不多；与基数排序的区别就是不用一位一位数的比，直接就分好空间了，大的数只能在后面；而小的数只能在前面，桶的顺序是从小到大的；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">//小项目里写这句话很方便，大项目不推荐</span><br><span class="line">using namespace std;</span><br><span class="line">//基数排序</span><br><span class="line">class Solution_ &#123;</span><br><span class="line">public:</span><br><span class="line">    int maximumGap(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = static_cast&lt;int&gt;(nums.size());</span><br><span class="line">        if (n &lt; 2) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        //相当于10的exp次方</span><br><span class="line">        int exp = 1;</span><br><span class="line">        vector&lt;int&gt; buf(n);</span><br><span class="line">        //先找出最大值</span><br><span class="line">        int maxVal = *max_element(nums.begin(), nums.end());</span><br><span class="line">        //最大值可能不止两位数</span><br><span class="line">        while (maxVal &gt;= exp) &#123;</span><br><span class="line">//            cout &lt;&lt; &quot;exp = &quot; &lt;&lt; exp &lt;&lt; &quot;: &quot; &lt;&lt; endl;</span><br><span class="line">            vector&lt;int&gt; cnt(10);</span><br><span class="line">            for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">                int digit = (nums[i] / exp) % 10; //一开始是个位数，之后就是十位数，再之后就是百位数...</span><br><span class="line">                cnt[digit]++;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int i = 1; i &lt; 10; i++) &#123;</span><br><span class="line">                cnt[i] += cnt[i - 1];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            for (int i = n - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">                int digit = (nums[i] / exp) % 10; //个位数同上</span><br><span class="line">//                cout &lt;&lt; &quot;nums[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot; &lt;&lt; nums[i] &lt;&lt; &quot; digit = &quot; &lt;&lt; digit &lt;&lt; &quot; &quot;;</span><br><span class="line">                buf[cnt[digit] - 1] = nums[i];</span><br><span class="line">//                cout &lt;&lt; &quot;buf[cnt[&quot; &lt;&lt; digit &lt;&lt; &quot;] - 1 = &quot; &lt;&lt; cnt[digit] - 1 &lt;&lt; &quot;] = &quot; &lt;&lt; nums[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">                cnt[digit]--;</span><br><span class="line">//                cout &lt;&lt; &quot;cnt[&quot; &lt;&lt; digit &lt;&lt; &quot;]-- = &quot; &lt;&lt; cnt[digit] &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            copy(buf.begin(), buf.end(), nums.begin());</span><br><span class="line">            exp *= 10;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int ret = 0;</span><br><span class="line">        for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">            ret = max(ret, nums[i] - nums[i - 1]);</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//桶排序</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maximumGap(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        if (n &lt; 2) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        //找出最大值、最小值</span><br><span class="line">        int minVal = *min_element(nums.begin(), nums.end());</span><br><span class="line">        int maxVal = *max_element(nums.begin(), nums.end());</span><br><span class="line">        int d = max(1, (maxVal - minVal) / (n - 1));</span><br><span class="line">        //桶的个数</span><br><span class="line">        int bucketSize = (maxVal - minVal) / d + 1;</span><br><span class="line"></span><br><span class="line">        vector&lt;pair&lt;int, int&gt;&gt; bucket(bucketSize, &#123;-1, -1&#125;);  // 存储 (桶内最小值，桶内最大值) 对，(-1, -1) 表示该桶是空的</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            //idx表示第几个桶</span><br><span class="line">            int idx = (nums[i] - minVal) / d;</span><br><span class="line">            if (bucket[idx].first == -1) &#123;  //如果桶是空的，最小值最大值都是nums[i]</span><br><span class="line">                bucket[idx].first = bucket[idx].second = nums[i];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                bucket[idx].first = min(bucket[idx].first, nums[i]);</span><br><span class="line">                bucket[idx].second = max(bucket[idx].second, nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; &quot;bucketSize = &quot; &lt;&lt; bucketSize &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;bucket = &quot; &lt;&lt; endl;</span><br><span class="line">        for(const auto b : bucket)&#123;</span><br><span class="line">            cout &lt;&lt; b.first &lt;&lt; &quot; &quot; &lt;&lt; b.second &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int ret = 0;</span><br><span class="line">        int prev = -1;</span><br><span class="line">        for (int i = 0; i &lt; bucketSize; i++) &#123;</span><br><span class="line">            if (bucket[i].first == -1) continue;</span><br><span class="line">            if (prev != -1) &#123;</span><br><span class="line">                ret = max(ret, bucket[i].first - bucket[prev].second);</span><br><span class="line">            &#125;</span><br><span class="line">            prev = i;</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; nums(&#123;29,25,3,49,9,37,21,43&#125;);  //8</span><br><span class="line">    Solution solution;</span><br><span class="line">    int ans = solution.maximumGap(nums);</span><br><span class="line">    cout &lt;&lt; &quot;ans = &quot; &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167_两数之和_II_输入有序数组"></a>167_两数之和_II_输入有序数组</h2><ul>
<li>双指针不多说了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123;</span><br><span class="line">        int l = 0, r = numbers.size();</span><br><span class="line">        --r;</span><br><span class="line">        while(l &lt; r)&#123;</span><br><span class="line">            if(numbers[l] + numbers[r] == target)</span><br><span class="line">                break;</span><br><span class="line">            if(numbers[l] + numbers[r] &gt; target)&#123;</span><br><span class="line">                --r;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                ++l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return &#123;l + 1, r + 1&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169_多数元素"></a>169_多数元素</h2><ul>
<li>用<code>map</code>记录个数，消耗比较高</li>
<li>投票算法学习下</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">//#include &lt;unordered_map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /*int majorityElement(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        unordered_map&lt;int, int&gt; map;</span><br><span class="line">        for(auto n : nums)&#123;</span><br><span class="line">            map[n]++;</span><br><span class="line">            if(map[n] &gt; nums.size() / 2)</span><br><span class="line">                return n;</span><br><span class="line">        &#125;</span><br><span class="line">        return nums[0];</span><br><span class="line">    &#125;*/</span><br><span class="line">    //投票算法</span><br><span class="line">    int majorityElement(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int count = 0;</span><br><span class="line">        int tmp = 0;</span><br><span class="line">        for(auto n : nums)&#123;</span><br><span class="line">            if(count == 0)&#123;</span><br><span class="line">                tmp = n;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                if(tmp == n)</span><br><span class="line">                    ++count;</span><br><span class="line">                else</span><br><span class="line">                    --count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; nums(&#123;2,2,1,1,1,2,2&#125;);</span><br><span class="line">    Solution solution;</span><br><span class="line">    int ans = solution.majorityElement(nums);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="174-地下城游戏"><a href="#174-地下城游戏" class="headerlink" title="174_地下城游戏"></a>174_地下城游戏</h2><ul>
<li>自己想的思路和题解一样，但是答案好优美，好简洁</li>
<li>因为我的二维<code>dp</code>是<code>n*m</code>；答案是<code>(n+1)*(m+1)</code>；这样的好处在于，最后一个格子的上边和左边可以直接设为1，而无需考虑血量包或者小怪</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int calculateMinimumHP(vector&lt;vector&lt;int&gt;&gt;&amp; dungeon) &#123;</span><br><span class="line">        if(dungeon.empty()) return 0;</span><br><span class="line">        int row = dungeon.size(), col = dungeon[0].size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(row, vector&lt;int&gt;(col, 0));</span><br><span class="line">        //骑士在进入每一个房间时，血量都要大于0，不然会立即死亡，所以dp[][]表示到达这个房间的最小血量</span><br><span class="line">        //从后往前遍历，只记录到达这个格子的最小血量，遇到血量包，就将这个格子的最小血量初始化为1或者（dp[][] - 血量包），因为你得活着到达这里才能吃到血包</span><br><span class="line">        if(dungeon[row - 1][col - 1] &gt; 0)&#123;</span><br><span class="line">            dp[row - 1][col - 1] = 1;</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">            dp[row - 1][col - 1] = dungeon[row - 1][col - 1] * (-1) + 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i = row - 1; i &gt; -1; --i)&#123;</span><br><span class="line">            for(int j = col - 1; j &gt; -1; --j)&#123;</span><br><span class="line">                if(i == row - 1 &amp;&amp; j == col - 1) continue;</span><br><span class="line">                if(i == row - 1)&#123;</span><br><span class="line">                    if(dungeon[i][j] &gt; 0 &amp;&amp; dungeon[i][j] &gt;= dp[i][j + 1])</span><br><span class="line">                        dp[i][j] = 1;</span><br><span class="line">                    else</span><br><span class="line">                        dp[i][j] = dp[i][j + 1] - dungeon[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">                if(j == col - 1)&#123;</span><br><span class="line">                    if(dungeon[i][j] &gt; 0 &amp;&amp; dungeon[i][j] &gt;= dp[i + 1][j])</span><br><span class="line">                        dp[i][j] = 1;</span><br><span class="line">                    else</span><br><span class="line">                        dp[i][j] = dp[i + 1][j] - dungeon[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">                if(i != row - 1 &amp;&amp; j != col - 1)&#123;</span><br><span class="line">                    int down = (dungeon[i][j] &gt; 0 &amp;&amp; dungeon[i][j] &gt; dp[i + 1][j]) ? 1 : dp[i + 1][j] - dungeon[i][j];</span><br><span class="line">                    int right = (dungeon[i][j] &gt; 0 &amp;&amp; dungeon[i][j] &gt; dp[i][j + 1]) ? 1 : dp[i][j + 1] - dungeon[i][j];</span><br><span class="line">                    dp[i][j] = min(down, right);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[0][0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution_ &#123;</span><br><span class="line">public:</span><br><span class="line">    int calculateMinimumHP(vector&lt;vector&lt;int&gt;&gt;&amp; dungeon) &#123;</span><br><span class="line">        int n = dungeon.size(), m = dungeon[0].size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(m + 1, INT_MAX));</span><br><span class="line">        dp[n][m - 1] = dp[n - 1][m] = 1;</span><br><span class="line">        for (int i = n - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">            for (int j = m - 1; j &gt;= 0; --j) &#123;</span><br><span class="line">                int minn = min(dp[i + 1][j], dp[i][j + 1]);</span><br><span class="line">                dp[i][j] = max(minn - dungeon[i][j], 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[0][0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    //[[1,-3,3],[0,-2,0],[-3,-3,-3]]</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; dungeon(&#123;</span><br><span class="line">        &#123;0,0,0&#125;,</span><br><span class="line">        &#123;1,1,-1&#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    Solution solution;</span><br><span class="line">    int ans = solution.calculateMinimumHP(dungeon);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;ans = &quot; &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="187-重复的DNA序列"><a href="#187-重复的DNA序列" class="headerlink" title="187_重复的DNA序列"></a>187_重复的DNA序列</h2><ul>
<li>题解有三种方法，我只会第一种</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;unordered_set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; findRepeatedDnaSequences(string s) &#123;</span><br><span class="line">        if(s.size() &lt; 10) return vector&lt;string&gt;();</span><br><span class="line">        //用set更好一点</span><br><span class="line">        /*unordered_map&lt;string, int&gt; map;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        for(int i = 0; i &lt; s.size() - 9; ++i)&#123;</span><br><span class="line">            string tmp = s.substr(i, 10);</span><br><span class="line">            ++map[tmp];</span><br><span class="line">            if(map[tmp] &gt; 1)&#123;</span><br><span class="line">                ans.push_back(tmp);</span><br><span class="line">                map[tmp] = INT32_MIN;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;*/</span><br><span class="line">        unordered_set&lt;string&gt; set, res;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        for(int i = 0; i &lt; s.size() - 9; ++i)&#123;</span><br><span class="line">            string tmp = s.substr(i, 10);</span><br><span class="line">            if(set.find(tmp) != set.end())&#123;</span><br><span class="line">                res.insert(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            set.insert(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        copy(res.begin(), res.end(), inserter(ans, ans.end()));</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="188-买卖股票的最佳时机-IV"><a href="#188-买卖股票的最佳时机-IV" class="headerlink" title="188_买卖股票的最佳时机_IV"></a>188_买卖股票的最佳时机_IV</h2><ul>
<li>参考了之前卖两次的思路；不仅买还有卖，所以应该是<code>2*k</code>个变量，一维数组即可，可以写成一列的形式</li>
<li>第0行表示第一次买；第1行表示第一次卖——卖的时候比较卖和不卖两种情况——买的时候比较买和不买两种情况</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        if(k == 0 || prices.empty()) return 0;</span><br><span class="line">        //卖或者不卖、买或者不买</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt; dp(2 * k, 0);</span><br><span class="line">        for(int j = 0; j &lt; prices.size(); ++j)&#123;</span><br><span class="line">            for(int i = 0; i &lt; 2 * k; ++i)&#123;</span><br><span class="line">                if(j == 0 )&#123;</span><br><span class="line">                    if(i % 2 == 0)</span><br><span class="line">                        dp[i] = -prices[0];</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    if(i == 0) //第一次买</span><br><span class="line">                        dp[i] = max(dp[i], -prices[j]);</span><br><span class="line">                    else&#123;</span><br><span class="line">                        if(i % 2 == 1)  //第i次卖</span><br><span class="line">                            dp[i] = max(dp[i], dp[i - 1] + prices[j]);</span><br><span class="line">                        else    //第i次买</span><br><span class="line">                            dp[i] = max(dp[i], dp[i - 1] - prices[j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="189-旋转数组"><a href="#189-旋转数组" class="headerlink" title="189_旋转数组"></a>189_旋转数组</h2><ul>
<li>本来想露一手的，…… ，还是老老实实本本分分吧</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void rotate(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        k %= n;</span><br><span class="line">        if(n &lt; 2 || k == 0) return;</span><br><span class="line">        vector&lt;int&gt; tmp(nums.begin() + n - k, inserter(tmp, tmp.end()));</span><br><span class="line">        copy(nums.begin(), nums.begin() + n - k - 1, tmp.end());</span><br><span class="line">        nums = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//额外的数组</span><br><span class="line">class Solution1 &#123;</span><br><span class="line">public:</span><br><span class="line">    void rotate(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        vector&lt;int&gt; newArr(n);</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            newArr[(i + k) % n] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        nums.assign(newArr.begin(), newArr.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//翻转数组</span><br><span class="line">class Solution2 &#123;</span><br><span class="line">public:</span><br><span class="line">    void reverse(vector&lt;int&gt;&amp; nums, int start, int end) &#123;</span><br><span class="line">        while (start &lt; end) &#123;</span><br><span class="line">            swap(nums[start], nums[end]);</span><br><span class="line">            start += 1;</span><br><span class="line">            end -= 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void rotate(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        k %= nums.size();</span><br><span class="line">        reverse(nums, 0, nums.size() - 1);</span><br><span class="line">        reverse(nums, 0, k - 1);</span><br><span class="line">        reverse(nums, k, nums.size() - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//环状替换</span><br><span class="line">class Solution3 &#123;</span><br><span class="line">public:</span><br><span class="line">    void rotate(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        k = k % n;</span><br><span class="line">        int count = gcd(k, n); //最大公约数,C++14好像没有</span><br><span class="line">        for (int start = 0; start &lt; count; ++start) &#123;</span><br><span class="line">            int current = start;</span><br><span class="line">            int prev = nums[start];</span><br><span class="line">            do &#123;</span><br><span class="line">                int next = (current + k) % n;</span><br><span class="line">                swap(nums[next], prev);</span><br><span class="line">                current = next;</span><br><span class="line">            &#125; while (start != current);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198_打家劫舍"></a>198_打家劫舍</h2><ul>
<li>本想用递归的，但感觉一次遍历即可</li>
<li>这种小聪明不能再犯了，，，这题一看就是动态规划</li>
<li>ohhhhhhhhh；虽然做出来了，但是和题解有些出入</li>
</ul>
<p><img src="/pictrues/198.png" alt="转移方程"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int rob(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        //dp[i]表示选择偷第i家的最大金钱数</span><br><span class="line">        vector&lt;int&gt; dp(n + 1, 0);</span><br><span class="line">        dp[1] = nums[0];</span><br><span class="line">        int ans = dp[1];</span><br><span class="line">        for(int i = 1; i &lt; n; ++i)&#123;</span><br><span class="line">            //cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">           //更新dp[i + 1]</span><br><span class="line">            for(int j = 0; j &lt; i; ++j)&#123;</span><br><span class="line">                //cout &lt;&lt; &quot;j = &quot; &lt;&lt; j &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">                dp[i + 1] = max(dp[i + 1], dp[j] + nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            ans = max(ans, dp[i + 1]);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//滚动数组</span><br><span class="line">class Solution_ &#123;</span><br><span class="line">public:</span><br><span class="line">    int rob(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if (nums.empty()) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int size = nums.size();</span><br><span class="line">        if (size == 1) &#123;</span><br><span class="line">            return nums[0];</span><br><span class="line">        &#125;</span><br><span class="line">//      dp[i]表示到了第i家，最大金钱数，而且至于前两次有关</span><br><span class="line">        int first = nums[0], second = max(nums[0], nums[1]);</span><br><span class="line">        for (int i = 2; i &lt; size; i++) &#123;</span><br><span class="line">            int temp = second;</span><br><span class="line">            second = max(first + nums[i], second);</span><br><span class="line">            first = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        return second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; nums(&#123;2,1,1,2&#125;);</span><br><span class="line">    Solution solution;</span><br><span class="line">    int ans = solution.rob(nums);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200_岛屿数量"></a>200_岛屿数量</h2><ul>
<li>每遇到一个未标记的1就将所有与这个1相连的1标记，然后遍历下一个？？这个思路属于DFS，康康题解BFS咋写</li>
<li>emmmm 并查集直接看《算法导论》第3版，第21章 Data Structures for Disjoint Sets；还有这个方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution_ &#123;</span><br><span class="line">public:</span><br><span class="line">    void mark(vector&lt;vector&lt;char&gt;&gt;&amp; grid, int i, int j, vector&lt;char&gt;::size_type m, vector&lt;char&gt;::size_type n)&#123;</span><br><span class="line">        if(grid[i][j] == &apos;1&apos; &amp;&amp; !tmp[i][j])</span><br><span class="line">            tmp[i][j] = true;</span><br><span class="line">        else</span><br><span class="line">            return;</span><br><span class="line">        int up = (i == 0) ? 0 : i - 1;</span><br><span class="line">        int down = (i + 1 == m) ? i : i + 1;</span><br><span class="line">        int left = (j == 0) ? 0 : j - 1;</span><br><span class="line">        int right = (j + 1 == n) ? j : j + 1;</span><br><span class="line">        mark(grid, up, j, m, n);</span><br><span class="line">        mark(grid, down, j, m, n);</span><br><span class="line">        mark(grid, i, left, m, n);</span><br><span class="line">        mark(grid, i, right, m, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        //每遇到一个未标记的1就将所有与这个1相连的1标记，然后遍历下一个？？</span><br><span class="line">        auto m = grid.size(), n = grid[0].size();</span><br><span class="line">        tmp = vector&lt;vector&lt;bool&gt;&gt;(m, vector&lt;bool&gt;(n, false));</span><br><span class="line">        int ans = 0;</span><br><span class="line">        for(int i = 0; i &lt; m; ++i)&#123;</span><br><span class="line">            for(int j = 0; j &lt; n; ++j)&#123;</span><br><span class="line">                if(grid[i][j] == &apos;1&apos; &amp;&amp; !tmp[i][j])&#123;</span><br><span class="line">                    ++ans;</span><br><span class="line">                    mark(grid, i, j, m, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;bool&gt;&gt; tmp;</span><br><span class="line">&#125;;</span><br><span class="line">//并查集</span><br><span class="line">class UnionFind &#123;</span><br><span class="line">public:</span><br><span class="line">    UnionFind(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        count = 0;</span><br><span class="line">        auto m = grid.size();</span><br><span class="line">        auto n = grid[0].size();</span><br><span class="line">        for (int i = 0; i &lt; m; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                if (grid[i][j] == &apos;1&apos;) &#123;</span><br><span class="line">                    parent.push_back(static_cast&lt;int&gt;(i * n) + j);//相当于拉成一维数组、所在的位置</span><br><span class="line">                    ++count;    //1的个数</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    parent.push_back(-1);</span><br><span class="line">                &#125;</span><br><span class="line">                rank.push_back(0);//？？为啥不直接初始化？</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int find(int i) &#123;</span><br><span class="line">        //i是转换之后的位置</span><br><span class="line">        //现在的parent[i]要么是-1要么就是_i * n + _j == i</span><br><span class="line">        if (parent[i] != i) &#123;</span><br><span class="line">            //这里会更改，递归...</span><br><span class="line">            parent[i] = find(parent[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return parent[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void unite(int x, int y) &#123;</span><br><span class="line">        //x,y是上下左右所在的...长度！</span><br><span class="line">        int rootx = find(x);</span><br><span class="line">        int rooty = find(y);</span><br><span class="line">        //两个1不在一个集合</span><br><span class="line">        if (rootx != rooty) &#123;</span><br><span class="line">            if (rank[rootx] &lt; rank[rooty]) &#123;</span><br><span class="line">                swap(rootx, rooty);</span><br><span class="line">            &#125;</span><br><span class="line">            parent[rooty] = rootx;</span><br><span class="line">            if (rank[rootx] == rank[rooty]) rank[rootx] += 1;</span><br><span class="line">            --count; //这里注意减减了，最终结果就是岛屿的数量</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int getCount() const &#123;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    vector&lt;int&gt; parent;</span><br><span class="line">    vector&lt;int&gt; rank;   //用来降低并查集的高度,find的时候就更快</span><br><span class="line">    int count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        int nr = static_cast&lt;int&gt;(grid.size());</span><br><span class="line">        if (!nr) return 0;</span><br><span class="line">        int nc = static_cast&lt;int&gt;(grid[0].size());</span><br><span class="line"></span><br><span class="line">        UnionFind uf(grid);</span><br><span class="line">//        int num_islands = 0;</span><br><span class="line">        for (int r = 0; r &lt; nr; ++r) &#123;</span><br><span class="line">            for (int c = 0; c &lt; nc; ++c) &#123;</span><br><span class="line">                if (grid[r][c] == &apos;1&apos;) &#123;</span><br><span class="line">                    grid[r][c] = &apos;0&apos;;</span><br><span class="line">                    if (r - 1 &gt;= 0 &amp;&amp; grid[r-1][c] == &apos;1&apos;) uf.unite(r * nc + c, (r-1) * nc + c);</span><br><span class="line">                    if (r + 1 &lt; nr &amp;&amp; grid[r+1][c] == &apos;1&apos;) uf.unite(r * nc + c, (r+1) * nc + c);</span><br><span class="line">                    if (c - 1 &gt;= 0 &amp;&amp; grid[r][c-1] == &apos;1&apos;) uf.unite(r * nc + c, r * nc + c - 1);</span><br><span class="line">                    if (c + 1 &lt; nc &amp;&amp; grid[r][c+1] == &apos;1&apos;) uf.unite(r * nc + c, r * nc + c + 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return uf.getCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209_长度最小的子数组"></a>209_长度最小的子数组</h2><ul>
<li>滑动窗口我硬是写不出来，总是哪里出错，我还是太菜了…</li>
<li>再学习下前缀树和，二分法题解用的是<code>lower_bound</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        if (n == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int ans = INT_MAX;</span><br><span class="line">        int start = 0, end = 0;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        while (end &lt; n) &#123;</span><br><span class="line">            sum += nums[end];</span><br><span class="line">            while (sum &gt;= s) &#123;</span><br><span class="line">                //在循环里面更新ans的值</span><br><span class="line">                ans = min(ans, end - start + 1);</span><br><span class="line">                sum -= nums[start];</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans == INT_MAX ? 0 : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//前缀树</span><br><span class="line">class Solution_ &#123;</span><br><span class="line">public:</span><br><span class="line">    int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        if (n == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int ans = INT_MAX;</span><br><span class="line">        vector&lt;int&gt; sums(n + 1, 0);</span><br><span class="line">        // 为了方便计算，令 size = n + 1</span><br><span class="line">        // sums[0] = 0 意味着前 0 个元素的前缀和为 0</span><br><span class="line">        // sums[1] = A[0] 前 1 个元素的前缀和为 A[0]</span><br><span class="line">        // 以此类推</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            sums[i] = sums[i - 1] + nums[i - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            int target = s + sums[i - 1];</span><br><span class="line">            auto bound = lower_bound(sums.begin(), sums.end(), target);</span><br><span class="line">            if (bound != sums.end()) &#123;</span><br><span class="line">                ans = min(ans, static_cast&lt;int&gt;((bound - sums.begin()) - (i - 1)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans == INT_MAX ? 0 : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; nums(&#123;1,2,3,4,5&#125;);</span><br><span class="line">    int target = 11;</span><br><span class="line">    Solution solution;</span><br><span class="line">    int ans = solution.minSubArrayLen(target, nums);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="213-打家劫舍-II"><a href="#213-打家劫舍-II" class="headerlink" title="213_打家劫舍_II"></a>213_打家劫舍_II</h2><ul>
<li>看之前那题还以为是题解，没想到是我写的…原来我还是挺厉害的</li>
<li>我写的<code>dp[i]</code>表示偷这间屋子的最大金额，最终答案是将所有<code>dp</code>比较取最大值；题解更容易理解<code>dp[i]</code>表示从开始到现在这个屋子的最大金额，最终结果直接输出最后的数字</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int robRange(vector&lt;int&gt;&amp; nums, int start, int end) &#123;</span><br><span class="line">        int first = nums[start], second = max(nums[start], nums[start + 1]);</span><br><span class="line">        for (int i = start + 2; i &lt;= end; i++) &#123;</span><br><span class="line">            int temp = second;</span><br><span class="line">            second = max(first + nums[i], second);</span><br><span class="line">            first = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        return second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int rob(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int length = nums.size();</span><br><span class="line">        if (length == 1) &#123;</span><br><span class="line">            return nums[0];</span><br><span class="line">        &#125; else if (length == 2) &#123;</span><br><span class="line">            return max(nums[0], nums[1]);</span><br><span class="line">        &#125;</span><br><span class="line">        return max(robRange(nums, 0, length - 2), robRange(nums, 1, length - 1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215_数组中的第K个最大元素"></a>215_数组中的第K个最大元素</h2><ul>
<li>这题用了选择排序，能过，但是时间消耗很大；但是直接用<code>sort()</code>却很快，以后看STL是重点了解下为什么这么快；好像是快速排序</li>
<li>先重点学习下十大经典排序算法中的快速排序和堆排序；之前了解的桶排序、基数排序也忘得差不多了</li>
<li>心静不下来….</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;ctime&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution_ &#123;</span><br><span class="line">public:</span><br><span class="line">    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        return nums[nums.size() - k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//快速排序</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int quickSelect(vector&lt;int&gt;&amp; a, int l, int r, int index) &#123;</span><br><span class="line">        //调用函数，返回</span><br><span class="line">        int q = randomPartition(a, l, r);</span><br><span class="line">        if (q == index) &#123;</span><br><span class="line">            return a[q];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return q &lt; index ? quickSelect(a, q + 1, r, index) : quickSelect(a, l, q - 1, index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inline int randomPartition(vector&lt;int&gt;&amp; a, int l, int r) &#123;</span><br><span class="line">        //i是l和r之间的随机数</span><br><span class="line">        int i = rand() % (r - l + 1) + l;</span><br><span class="line">        swap(a[i], a[r]);</span><br><span class="line">        return partition(a, l, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inline int partition(vector&lt;int&gt;&amp; a, int l, int r) &#123;</span><br><span class="line">        int x = a[r], i = l - 1;</span><br><span class="line">        for (int j = l; j &lt; r; ++j) &#123;</span><br><span class="line">            if (a[j] &lt;= x) &#123;</span><br><span class="line">                swap(a[++i], a[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(a[i + 1], a[r]);</span><br><span class="line">        return i + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        srand(time(nullptr));</span><br><span class="line">        return quickSelect(nums, 0, nums.size() - 1, nums.size() - k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="216-组合总和-III"><a href="#216-组合总和-III" class="headerlink" title="216_组合总和_III"></a>216_组合总和_III</h2><ul>
<li>dfs搞定</li>
<li>题解用了9位二进制，每一位二进制代表对应的数字有没有被选中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;iterator&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;unordered_set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void dfs(int k, int n, int pos)&#123;</span><br><span class="line">        if(k == 0)&#123;</span><br><span class="line">            if(n == 0)</span><br><span class="line">                ans.push_back(tmp);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = pos; i &lt; 10; ++i)&#123;</span><br><span class="line">            //如果数字在里面，说明还没被加进和里</span><br><span class="line">            if(set.find(i) != set.end())&#123;</span><br><span class="line">                if(k == 1 &amp;&amp; (n &lt; 1 || n &gt; 9))</span><br><span class="line">                    return;</span><br><span class="line"></span><br><span class="line">                tmp.push_back(i);</span><br><span class="line">                set.erase(i);</span><br><span class="line">                dfs(k - 1, n - i, i + 1);</span><br><span class="line">                tmp.pop_back();</span><br><span class="line">                set.insert(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123;</span><br><span class="line">        //k是个数，n是和</span><br><span class="line">        for(int i = 1; i &lt; 10; ++i)&#123;</span><br><span class="line">            set.insert(i);</span><br><span class="line">        &#125;</span><br><span class="line">        int pos = 1;</span><br><span class="line">        dfs(k, n, pos);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">    vector&lt;int&gt; tmp;</span><br><span class="line">    unordered_set&lt;int&gt; set;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int k = 3, n = 9;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; ans(solution.combinationSum3(k, n));</span><br><span class="line">    for(const auto &amp; a : ans)&#123;</span><br><span class="line">        copy(a.begin(), a.end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot;));</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="217-存在重复元素"><a href="#217-存在重复元素" class="headerlink" title="217_存在重复元素"></a>217_存在重复元素</h2><ul>
<li>一次遍历？</li>
<li>也可以先排序，这排序十种面试前要滚瓜烂熟！！！</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        unordered_map&lt;int, int&gt; map;</span><br><span class="line">        for(const auto&amp; n : nums)&#123;</span><br><span class="line">            map[n]++;</span><br><span class="line">            if(map[n] == 2)</span><br><span class="line">                return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="218-天际线问题"><a href="#218-天际线问题" class="headerlink" title="218_天际线问题"></a>218_天际线问题</h2><ul>
<li>好家伙，这几道题目都在一起…分治、递归、归并</li>
<li>归并时，天际线的高度永远是左天际线和右天际线的较大值。</li>
</ul>
<p><img src="/pictrues/218.png" alt="天际线" title="天际线"></p>
<ul>
<li>还是两两合并，最后一起合并好理解一点；我还是选择了线性扫描…</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;iterator&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; getSkyline(vector&lt;vector&lt;int&gt;&gt;&amp; buildings) &#123;</span><br><span class="line">        vector&lt;pair&lt;int,int&gt;&gt; h;</span><br><span class="line">        multiset&lt;int&gt; m;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">        //1、将每一个建筑分成“两个部分”，例如:[2,9,10]可以转换成[2，-10][9,10]，我们用负值来表示左边界</span><br><span class="line">        for(const auto&amp; b:buildings)</span><br><span class="line">        &#123;</span><br><span class="line">            h.emplace_back(b[0], -b[2]);</span><br><span class="line">            h.emplace_back(b[1], b[2]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //2、根据x值对分段进行排序</span><br><span class="line">        sort(h.begin(),h.end());</span><br><span class="line">        int prev = 0, cur = 0;</span><br><span class="line">        m.insert(0);</span><br><span class="line"></span><br><span class="line">        //3、遍历</span><br><span class="line">        for (auto &amp;i:h)</span><br><span class="line">        &#123;</span><br><span class="line">            //m是multiset，会对高度进行排序</span><br><span class="line">            if (i.second &lt; 0) m.insert(-i.second);  //左端点，高度入堆</span><br><span class="line">            else m.erase(m.find(i.second));         //右端点，高度出堆</span><br><span class="line"></span><br><span class="line">            cur = *m.rbegin();                      //当前最大高度高度</span><br><span class="line"></span><br><span class="line">            if (cur != prev) &#123;                      //当前最大高度不等于最大高度perv表示这是一个转折点</span><br><span class="line">                res.push_back(&#123;i.first, cur&#125;);      //添加坐标</span><br><span class="line">                prev = cur;                         //更新最大高度</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; buildings = &#123;&#123;2,9,10&#125;, &#123;3,7,15&#125;, &#123;5,12,12&#125;, &#123;15,20,10&#125;, &#123;19,24,8&#125;&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; ans(solution.getSkyline(buildings));</span><br><span class="line">    for(const auto &amp;a : ans)&#123;</span><br><span class="line">        copy(a.begin(), a.end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot;));</span><br><span class="line">        cout &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二刷-1"><a href="#二刷-1" class="headerlink" title="二刷"></a>二刷</h3><ul>
<li>完蛋，一点印象都没有<ul>
<li>隐隐约约记得分治，把多个矩阵合并起来，然后再那啥？ </li>
<li>仔细审题，建筑按照左端点x坐标从小到大排序了</li>
<li>左右两端在整数范围内</li>
<li>下次一定！！明天吧，今天有点晚了</li>
</ul>
</li>
</ul>
<h2 id="219-存在重复元素-II"><a href="#219-存在重复元素-II" class="headerlink" title="219_存在重复元素_II"></a>219_存在重复元素_II</h2><ul>
<li>冲!</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool containsNearbyDuplicate(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        //简单题直接冲</span><br><span class="line">        unordered_map&lt;int, int&gt; map;</span><br><span class="line">        for(int i = 0; i &lt; nums.size(); ++i)&#123;</span><br><span class="line">            if(map.find(nums[i]) == map.end())&#123;</span><br><span class="line">                //若找不到，就加入</span><br><span class="line">                map[nums[i]] = i;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                if(i - map[nums[i]] &lt;= k)</span><br><span class="line">                    return true;</span><br><span class="line">                else</span><br><span class="line">                    map[nums[i]] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="220-存在重复元素-III"><a href="#220-存在重复元素-III" class="headerlink" title="220_存在重复元素_III"></a>220_存在重复元素_III</h2><ul>
<li>不仅要考虑数组边界；还要考虑整数边界；按题意来看，滑动窗口的长度只要不超过<code>k+1</code>即可，又把窗口里面的数字给排序了，我觉得这个方法比较笨，而且由于各种边界问题没通过</li>
<li>。。。可是，我一眼就看到题解的滑动窗口和有序集合</li>
<li>题解还用到了桶排序，因为滑动窗口内，排序更容易找出符合条件的解</li>
<li>而且桶排序比有序集合要快很多</li>
<li>下图是宫水三叶大佬的题解</li>
</ul>
<p><img src="/pictrues/220.png" alt="桶排序" title="桶排序"></p>
<p><img src="/pictrues/220_1.png" alt="桶排序" title="桶排序"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//滑动窗口、有序集合</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool containsNearbyAlmostDuplicate(vector&lt;int&gt;&amp; nums, int k, int t) &#123;</span><br><span class="line">        int n = static_cast&lt;int&gt;(nums.size());</span><br><span class="line">        set&lt;int&gt; rec;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            //第二次遇到lower_bound()函数</span><br><span class="line">            auto iter = rec.lower_bound(max(nums[i], INT_MIN + t) - t);</span><br><span class="line">            if (iter != rec.end() &amp;&amp; *iter &lt;= min(nums[i], INT_MAX - t) + t) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            rec.insert(nums[i]);</span><br><span class="line">            if (i &gt;= k) &#123;</span><br><span class="line">                rec.erase(nums[i - k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221_最大正方形"></a>221_最大正方形</h2><ul>
<li>为什么我的暴力给出的结果不对…还是用下题解；原来我只是在第一层</li>
<li>动态规划，我觉得状态转移方程写不出来，但又感觉能写出来，看题解还是要会证明</li>
<li>动态规划最重要的就是想清楚 <code>d[i,j]</code> 代表着什么，这个太重要了。 这道题中的 <code>d[i, j]</code> 代表的是，以坐标点<code>(i,j)</code> 为右下角的正方形最大边长；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        if (matrix.size() == 0 || matrix[0].size() == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int maxSide = 0;</span><br><span class="line">        int rows = matrix.size(), columns = matrix[0].size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(rows, vector&lt;int&gt;(columns));</span><br><span class="line">        for (int i = 0; i &lt; rows; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; columns; j++) &#123;</span><br><span class="line">                if (matrix[i][j] == &apos;1&apos;) &#123;</span><br><span class="line">                    if (i == 0 || j == 0) &#123;</span><br><span class="line">                        dp[i][j] = 1;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        dp[i][j] = min(min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                    maxSide = max(maxSide, dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int maxSquare = maxSide * maxSide;</span><br><span class="line">        return maxSquare;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="223-矩形面积"><a href="#223-矩形面积" class="headerlink" title="223_矩形面积"></a>223_矩形面积</h2><ul>
<li>这题我也不知道放在哪儿</li>
<li>首先改一下参数名字，方便理解很多，其次就是分几种情况，我以为要写很多，其实几行就可以了，我还是太菜了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) &#123;</span><br><span class="line">        // 调整矩阵的位置，保证第一个矩阵在左下角</span><br><span class="line">        if (A &gt; E)</span><br><span class="line">        &#123;</span><br><span class="line">            return computeArea(E, F, G, H, A, B, C, D);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 计算两个面积之和</span><br><span class="line">        int sum = abs(A-C)*abs(B-D) + abs(E-G)*abs(F-H);</span><br><span class="line"></span><br><span class="line">        // 没有重叠，直接返回两个面积</span><br><span class="line">        if (C &lt;= E || B &gt;= H || D &lt;= F)</span><br><span class="line">        &#123;</span><br><span class="line">            return sum;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 计算重叠的区域</span><br><span class="line">        int overlap = abs(max(A, E)-min(C, G)) * abs(max(B, F)-min(D, H));</span><br><span class="line"></span><br><span class="line">        return sum - overlap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="228-汇总区间"><a href="#228-汇总区间" class="headerlink" title="228_汇总区间"></a>228_汇总区间</h2><ul>
<li>这题目，，有点绕，也就是说找出连续的数字，将他们合并起来！</li>
<li><code>to_string()</code>函数又忘了，通过了，但是内存消耗倒数…</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;iterator&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; summaryRanges(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if(nums.empty())</span><br><span class="line">            return vector&lt;string&gt;();</span><br><span class="line">        auto n = nums.size();</span><br><span class="line"></span><br><span class="line">        if(n == 1)&#123;</span><br><span class="line">            return vector&lt;string&gt;&#123;to_string(nums[0])&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int pre = 0;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        for(int i = 1; i &lt; n; ++i)&#123;</span><br><span class="line">            //不相等才更新pre，这里漏掉最后一个数字，即最后一个数字与前一个不相等</span><br><span class="line">            if(nums[i] != (nums[i - 1] + 1))&#123;</span><br><span class="line">                if(i - pre == 1)&#123;</span><br><span class="line">                    ans.emplace_back(to_string(nums[pre]));</span><br><span class="line">                    pre = i;</span><br><span class="line">                &#125; else&#123;</span><br><span class="line">                    string str = to_string(nums[pre]);</span><br><span class="line">                    str += &quot;-&gt;&quot;;</span><br><span class="line">                    str += to_string(nums[i - 1]);</span><br><span class="line">                    ans.push_back(str);</span><br><span class="line">                    pre = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if(i == n - 1)&#123;</span><br><span class="line">                if(pre == n - 1)&#123;</span><br><span class="line">                    ans.emplace_back(to_string(nums[pre]));</span><br><span class="line">                &#125; else&#123;</span><br><span class="line">                    string str = to_string(nums[pre]);</span><br><span class="line">                    str += &quot;-&gt;&quot;;</span><br><span class="line">                    str += to_string(nums[i]);</span><br><span class="line">                    ans.push_back(str);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//感觉题解好点，while能够方便处理最后的情况</span><br><span class="line">class Solution1 &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; summaryRanges(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;string&gt; ret;</span><br><span class="line">        int i = 0;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        while (i &lt; n) &#123;</span><br><span class="line">            int low = i;</span><br><span class="line">            i++;</span><br><span class="line">            while (i &lt; n &amp;&amp; nums[i] == nums[i - 1] + 1) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            int high = i - 1;</span><br><span class="line">            string temp = to_string(nums[low]);</span><br><span class="line">            if (low &lt; high) &#123;</span><br><span class="line">                temp.append(&quot;-&gt;&quot;);</span><br><span class="line">                temp.append(to_string(nums[high]));</span><br><span class="line">            &#125;</span><br><span class="line">            ret.push_back(move(temp));</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; nums = &#123;0,2,3,4,6,8,9&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;string&gt; ans = solution.summaryRanges(nums);</span><br><span class="line">    copy(ans.begin(), ans.end(), ostream_iterator&lt;string&gt;(cout, &quot; &quot;));</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="229-求众数-II"><a href="#229-求众数-II" class="headerlink" title="229_求众数_II"></a>229_求众数_II</h2><ul>
<li>排序+双指针过了，但是时间消耗很多，难道排序这块出了点问题？</li>
<li>隐含条件：如果两个人的票数都超过了三分之一，剩余的票就不到三分之一了；最终答案元素不会超过两个</li>
<li>摩尔投票法…没听说过</li>
<li>大佬的理解：摩尔投票法本质上就是宾果消消乐游戏，每次消除3个不同的数。由于数组长度为n，因此消消乐最多进行[n/3]次。因此，我们想要的答案（超过[n/3]的数字）一定没有被消除完，一定存在最后活下来的两个数当中。 但是，存活的两个数不一定都是想要的真正的答案，最后再遍历确认一下这两个数是不是答案即可。</li>
<li>这种计数法…以前有道题做过，<code>count++</code>、<code>count--</code>；对，一定做过</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//排序+双指针</span><br><span class="line">class Solution1 &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; majorityElement(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        //出现的次数！！！空间复杂度为常数，那就不能用哈希了</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        vector&lt;int&gt; ans;</span><br><span class="line">        int i = 0;</span><br><span class="line">        while(i &lt; n)&#123;</span><br><span class="line">            if(!ans.empty() &amp;&amp; nums[i] == ans.back())&#123;</span><br><span class="line">                ++i;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //超过n / 3</span><br><span class="line">            int pos = i + n / 3;</span><br><span class="line">            if(pos &lt; n)&#123;</span><br><span class="line">                if(nums[i] == nums[pos])&#123;</span><br><span class="line">                    ans.push_back(nums[i]);</span><br><span class="line">                    i = pos + 1;</span><br><span class="line">                &#125; else&#123;</span><br><span class="line">                    ++i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//消消乐</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; majorityElement(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;int&gt; ans;</span><br><span class="line">        if (nums.empty()) return ans;</span><br><span class="line"></span><br><span class="line">        int cand1, cand2;</span><br><span class="line">        int count1, count2;</span><br><span class="line">        cand1 = cand2 = count1 = count2 = 0;</span><br><span class="line"></span><br><span class="line">        // 抵消阶段</span><br><span class="line">        for (int i = 0; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            if (nums[i] == cand1) count1++;</span><br><span class="line">            else if (nums[i] == cand2) count2++;</span><br><span class="line">            else if (count1 &amp;&amp; count2) &#123;</span><br><span class="line">                count1--;</span><br><span class="line">                count2--;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (!count1) &#123;</span><br><span class="line">                cand1 = nums[i];</span><br><span class="line">                count1++;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                cand2 = nums[i];</span><br><span class="line">                count2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 计数阶段</span><br><span class="line">        count1 = count2 = 0;</span><br><span class="line">        for (int i = 0; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            if (nums[i] == cand1) count1++;</span><br><span class="line">            else if(nums[i] == cand2) count2++; // 必须用else if，保证每个数只算到一个候选人头上</span><br><span class="line">            else &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (count1 &gt; nums.size() / 3) ans.push_back(cand1);</span><br><span class="line">        if (count2 &gt; nums.size() / 3) ans.push_back(cand2);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="238-除自身以外数组的乘积"><a href="#238-除自身以外数组的乘积" class="headerlink" title="238_除自身以外数组的乘积"></a>238_除自身以外数组的乘积</h2><ul>
<li>不能用除法</li>
<li>一个前缀，一个后缀，但想不出来，怎么用常数空间；输出数组不算进复杂度之内，那就在数组数组下文章即可</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;iterator&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution1 &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        auto n = nums.size();</span><br><span class="line">        if(n &lt; 2)</span><br><span class="line">            return nums;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; tmp(2, vector&lt;int&gt;(n, 0));</span><br><span class="line">        int l = 0, r = n - 1;</span><br><span class="line">        while(l &lt; n)&#123;</span><br><span class="line">            tmp[0][l] = (l == 0 ? nums[l] : (tmp[0][l - 1] * nums[l]));</span><br><span class="line">            tmp[1][r] = (r == n - 1 ? nums[r] : (tmp[1][r + 1] * nums[r]));</span><br><span class="line">            ++l;</span><br><span class="line">            --r;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; ans(n, 0);</span><br><span class="line">        ans[0] = tmp[1][1];</span><br><span class="line">        r = 1;</span><br><span class="line">        while(r &lt; n)&#123;</span><br><span class="line">            if(r != n - 1)</span><br><span class="line">                ans[r] = tmp[0][r - 1] * tmp[1][r + 1];</span><br><span class="line">            else</span><br><span class="line">                ans[r] = tmp[0][r - 1];</span><br><span class="line">            ++r;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//题解</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int length = nums.size();</span><br><span class="line">        vector&lt;int&gt; answer(length);</span><br><span class="line"></span><br><span class="line">        // answer[i] 表示索引 i 左侧所有元素的乘积</span><br><span class="line">        // 因为索引为 &apos;0&apos; 的元素左侧没有元素， 所以 answer[0] = 1</span><br><span class="line">        answer[0] = 1;</span><br><span class="line">        for (int i = 1; i &lt; length; i++) &#123;</span><br><span class="line">            answer[i] = nums[i - 1] * answer[i - 1];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // R 为右侧所有元素的乘积</span><br><span class="line">        // 刚开始右边没有元素，所以 R = 1</span><br><span class="line">        int R = 1;</span><br><span class="line">        for (int i = length - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">            // 对于索引 i，左边的乘积为 answer[i]，右边的乘积为 R</span><br><span class="line">            answer[i] = answer[i] * R;</span><br><span class="line">            // R 需要包含右边所有的乘积，所以计算下一个结果时需要将当前值乘到 R 上</span><br><span class="line">            R *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; nums = &#123;1,2,3,4&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;int&gt; ans(solution.productExceptSelf(nums));</span><br><span class="line">    copy(ans.begin(), ans.end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot;));</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239_滑动窗口最大值"></a>239_滑动窗口最大值</h2><ul>
<li>除了暴力，我想不到好的方法…</li>
<li>每日一题的背包问题，花费了不少精力，，，出现问题是好事！把问题解决了就说明理解了</li>
<li>优先队列——之前有一题，应该也是每日一题，有小根堆、大根堆</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        priority_queue&lt;pair&lt;int, int&gt;&gt; q;</span><br><span class="line">        for (int i = 0; i &lt; k; ++i) &#123;</span><br><span class="line">            q.emplace(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; ans = &#123;q.top().first&#125;;</span><br><span class="line">        for (int i = k; i &lt; n; ++i) &#123;</span><br><span class="line">            q.emplace(nums[i], i);</span><br><span class="line">            while (q.top().second &lt;= i - k) &#123;</span><br><span class="line">                q.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(q.top().first);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="240-搜索二维矩阵-II"><a href="#240-搜索二维矩阵-II" class="headerlink" title="240_搜索二维矩阵_II"></a>240_搜索二维矩阵_II</h2><ul>
<li>总是少了很多特例，比如只有一个数字、只有一行、只有一列、、或者更新中点时，一直停留在原地…</li>
<li>对哦，我怎么把暴力法给忘了呢！！</li>
<li>同样是二分，为什么我的这么烂</li>
<li>题解四最容易理解，从左下角出发，根据条件判断向上还是向右；至于为什么从左下角出发：选左上角，往右走和往下走都增大，不能选；选右下角，往上走和往左走都减小，不能选；选左下角，往右走增大，往上走减小，可选；选右上角，往下走增大，往左走减小，可选</li>
<li>大佬：这个二维数组就类似一棵排序二叉树，对于每一个数来说，上方的数都小于它，右边的数都大于它，所以把左下角作为根节点开始查找！</li>
<li>看来每日一题（困难）要CV了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123;</span><br><span class="line">        auto m = matrix.size(), n = matrix[0].size();</span><br><span class="line"></span><br><span class="line">        if(target &lt; matrix[0][0] || target &gt; matrix[m - 1][n - 1])</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        int x = m - 1, y = 0;</span><br><span class="line">        while(x &gt;= 0 &amp;&amp; y &lt; n)&#123;</span><br><span class="line">            if(matrix[x][y] == target) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;else if(matrix[x][y] &gt; target)&#123;</span><br><span class="line">                --x;</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                ++y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="260-只出现一次的数字-III"><a href="#260-只出现一次的数字-III" class="headerlink" title="260_只出现一次的数字_III"></a>260_只出现一次的数字_III</h2><ul>
<li>想用异或前缀和实现，但是会出现其他干扰，即异或答案是对的，但不是想要的答案，甚至有的数字都没有出现过</li>
<li>要不就反着再遍历一次？也没用，而且我不是常数空间…</li>
<li>题解真的是太牛皮了…可是为什么至选择一位不为0呢，想了想好像是理所当然的，非0即1！！</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; singleNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int ret = 0;</span><br><span class="line">        for (int n : nums)</span><br><span class="line">            ret ^= n;</span><br><span class="line">        int div = 1;</span><br><span class="line">        while ((div &amp; ret) == 0)</span><br><span class="line">            div &lt;&lt;= 1;</span><br><span class="line"></span><br><span class="line">        int a = 0, b = 0;</span><br><span class="line">        for (int n : nums)</span><br><span class="line">            if (div &amp; n)</span><br><span class="line">                a ^= n;</span><br><span class="line">            else</span><br><span class="line">                b ^= n;</span><br><span class="line">        return vector&lt;int&gt;&#123;a, b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="268-丢失的数字"><a href="#268-丢失的数字" class="headerlink" title="268_丢失的数字"></a>268_丢失的数字</h2><ul>
<li>这里求个和就解决了，我真机智</li>
<li>看了评论；数学求和有溢出风险，不过题解的位运算真的惊艳到我了<ul>
<li>先对<code>[0,n]</code>求异或，然后将结果分别对<code>nums</code>数组元素进行异或，最终可以得到缺失的值</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;numeric&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int missingNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        // 这里accumulate是有返回值的</span><br><span class="line">        int sum = accumulate(nums.begin(), nums.end(), 0);</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        int tmp = n * (n + 1) / 2;</span><br><span class="line">        return tmp - sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="274-H-指数"><a href="#274-H-指数" class="headerlink" title="274_H 指数"></a>274_H 指数</h2><ul>
<li>暴力居然成功了（注意点是引用次数至少大于等于h），，，应该用动态规划</li>
<li>原来是排序！好好学习下计数排序——我还是太菜了，评论都说排序是最傻的方法…</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//暴力</span><br><span class="line">class Solution1 &#123;</span><br><span class="line">public:</span><br><span class="line">    int hIndex(vector&lt;int&gt;&amp; citations) &#123;</span><br><span class="line">        if(citations.empty())</span><br><span class="line">            return 0;</span><br><span class="line">        //论文数与至少的引用数一样</span><br><span class="line">        auto n = citations.size();</span><br><span class="line"></span><br><span class="line">        //大于等于i次引用的一共有几篇；应该遍历一次就应该知道最终答案，每遍历一个数字，就要更新对应的数字</span><br><span class="line">        vector&lt;int&gt; tmp(n, 0);</span><br><span class="line">        for(const auto &amp;c : citations)&#123;</span><br><span class="line">            if(c &gt;= n)&#123;</span><br><span class="line">                //所有的元素都要加一</span><br><span class="line">                for(auto &amp;t : tmp)&#123;</span><br><span class="line">                    ++t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else if(c &gt; 0)&#123;</span><br><span class="line">                for(int i = 0; i &lt; c; ++i)&#123;</span><br><span class="line">                    ++tmp[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = n - 1; i &gt;= 0; --i)&#123;</span><br><span class="line">            if(tmp[i] == i + 1)</span><br><span class="line">                return i + 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//排序</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int hIndex(vector&lt;int&gt;&amp; citations) &#123;</span><br><span class="line">        sort(citations.begin(), citations.end());</span><br><span class="line">        //这里要从后往前遍历</span><br><span class="line">        int i = 0;</span><br><span class="line">        while(i &lt; citations.size() &amp;&amp; citations[citations.size() - 1 - i] &gt; i)&#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        return i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二刷-2"><a href="#二刷-2" class="headerlink" title="二刷"></a>二刷</h3><ul>
<li>本来想二刷的，但看到了之前的几行代码，然后二刷了个寂寞<ul>
<li>这样吧，把<code>i = 0</code>改成最后。不太好改！</li>
<li>因为<code>i</code>就是最后要输出的结果！！</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//上面那个好像就是自己写的，这才是题解！！！</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int hIndex(vector&lt;int&gt;&amp; citations) &#123;</span><br><span class="line">        sort(citations.begin(), citations.end());</span><br><span class="line">        int h = 0, i = citations.size() - 1;</span><br><span class="line">        while (i &gt;= 0 &amp;&amp; citations[i] &gt; h) &#123;</span><br><span class="line">            h++;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        return h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="275-H-指数-II"><a href="#275-H-指数-II" class="headerlink" title="275_H 指数_II"></a>275_H 指数_II</h2><ul>
<li>二分、左边界、返回<code>n - l</code>——搞定</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int hIndex(vector&lt;int&gt;&amp; citations) &#123;</span><br><span class="line">        //这个，，，是跟上题一样好像，对数时间，先用二分看看</span><br><span class="line">        if(citations.back() == 0) return 0;</span><br><span class="line"></span><br><span class="line">        //应该是左边界</span><br><span class="line">        int n = citations.size();</span><br><span class="line">        int l = 0, r = n;</span><br><span class="line">        while(l &lt; r)&#123;</span><br><span class="line">            int mid = l + (r - l) / 2;</span><br><span class="line">            if(citations[mid] &gt;= (n - mid))&#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                l = mid + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //最后l所在的元素是起点，一直到最后元素的个数才是答案</span><br><span class="line">        return n - l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二刷-3"><a href="#二刷-3" class="headerlink" title="二刷"></a>二刷</h3><ul>
<li>既然排好序了，那就用二分法<ul>
<li>手撕下</li>
<li>可以，一次过</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//二刷</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int hIndex(vector&lt;int&gt;&amp; citations) &#123;</span><br><span class="line">        //下标是i，那么个数就是i+1个</span><br><span class="line">        //直观来看，应该看下标i对应的数字 是否大于 以及之后所有的数字的个数+1（包含本身）</span><br><span class="line">        if(citations.empty()) return 0;</span><br><span class="line">        int n = citations.size();</span><br><span class="line">        int l = 0, r = n;</span><br><span class="line"></span><br><span class="line">        while(l &lt; r)&#123;</span><br><span class="line">            int mid = (r - l) / 2 + l;</span><br><span class="line">            int tmp = n - mid; //个数</span><br><span class="line">            if(citations[mid] &gt;= tmp)&#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                l = mid + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //l对应的位置就是符合条件的位置</span><br><span class="line">        return n - l;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="278-第一个错误的版本"><a href="#278-第一个错误的版本" class="headerlink" title="278_第一个错误的版本"></a>278_第一个错误的版本</h2><ul>
<li>这是之前的每日一题，还是简单题，（看过了labuladong的二分题解后）再做一遍；之后粘贴下两次的代码，比较下，如何防止边界溢出等等…</li>
<li>原来我之前已经改好了…</li>
<li>这里有个接口，就不放在<code>Clion</code>里了，也就是查找左边界</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// The API isBadVersion is defined for you.</span><br><span class="line">// bool isBadVersion(int version);</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int firstBadVersion(int n) &#123;</span><br><span class="line">        int l = 1, r = n;</span><br><span class="line">        while(l &lt; r)&#123;</span><br><span class="line">            //这里超出整数边界了</span><br><span class="line">            //long long mid = (l + r) / 2;</span><br><span class="line">            //get新知识点     int mid = left + (right - left) / 2; // 防止计算时溢出</span><br><span class="line">            int mid = l + (r - l) / 2;</span><br><span class="line">            //这样就不用long long</span><br><span class="line">            if(isBadVersion(mid))&#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                l = mid + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279_完全平方数"></a>279_完全平方数</h2><ul>
<li>这是每日一题的背包问题，正好做到了，再复习下！康康那个算法小抄</li>
<li>因为不知道放在哪个类别，因为背包用到了<code>vector</code>，所以就放在这里吧:)</li>
<li>思考了半天！终于自己写出了完全背包，对背包题的理解进一步加深！这里放个链接，<a href="https://cosmicxk.github.io/2019/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#more" target="_blank" rel="noopener">背包心得</a>——背包问题，这里就不在赘述，注释也写的很清楚</li>
<li>不过这题用完全背包遍历了很多没有必要的状态！题解用的直接是动态规划！——不过题解好像就是完全背包经过状态压缩得到的！</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;iterator&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution1 &#123;</span><br><span class="line">public:</span><br><span class="line">    int numSquares(int n) &#123;</span><br><span class="line">        //完全背包——每个物品的数量无限</span><br><span class="line">        //先算出平方数的种数</span><br><span class="line">        int l = static_cast&lt;int&gt;(sqrt(n));</span><br><span class="line">        //一般前者是物体，后者是重量——这里的dp只能是方法的个数，而不是最大或者最小，这个要另外再判断</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(l + 1, vector&lt;int&gt;(n + 1, 0));</span><br><span class="line">        //重量为0，置1——边界初始化</span><br><span class="line">        for(int j = 1; j &lt; n + 1; ++j)&#123;</span><br><span class="line">            //这里的j是1的个数，因为只有1这个平方数</span><br><span class="line">            dp[1][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        //dp[i][j]表示前i个平方数，和为j，所用到的最小个数</span><br><span class="line">        for(int i = 2; i &lt; l + 1; ++i)&#123;</span><br><span class="line">            for(int j = 1; j &lt; n + 1; ++j)&#123;</span><br><span class="line">                //不选第i个平方数，这里i要大于1——所以这里直接赋值，而不是取小</span><br><span class="line">                dp[i][j] = dp[i - 1][j];</span><br><span class="line">                //选第i个物品——这里是取小，而不是加，因为要最小个数，而不是一共有多少种</span><br><span class="line">                if(j &gt;= (i * i))&#123;</span><br><span class="line">                    //还有是dp[i][j - i * i]而不是dp[i - 1][j - i * i]，因为是完全背包</span><br><span class="line">                    //比如和为12，取平方数4，那么12-4=8也可以取平方数4！即和为8的前4个平方数的最小个数</span><br><span class="line">                    //还有个问题如果是9，直接取平方数3，所以是dp[3][9]=1</span><br><span class="line">                    dp[i][j] = min(dp[i][j], dp[i][j - i * i] + 1); //取了这个平方数，这里就要加1</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(const auto&amp; d : dp)&#123;</span><br><span class="line">            copy(d.begin(), d.end(), ostream_iterator&lt;int&gt;(cout, &quot;    &quot;));</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[l][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//题解</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int numSquares(int n) &#123;</span><br><span class="line">        vector&lt;int&gt; f(n + 1);</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            //这里i每次都会重新生成minn——用来记录最小个数</span><br><span class="line">            int minn = INT_MAX;</span><br><span class="line">            //这里的j就是平方数，从1开始！</span><br><span class="line">            for (int j = 1; j * j &lt;= i; j++) &#123;</span><br><span class="line">                minn = min(minn, f[i - j * j]);</span><br><span class="line">            &#125;</span><br><span class="line">            //这个加一是选择数字的个数——第二个for循环是选择</span><br><span class="line">            f[i] = minn + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n = 12;</span><br><span class="line">    Solution solution;</span><br><span class="line">    int ans = solution.numSquares(n);</span><br><span class="line">    cout &lt;&lt; &quot;ans = &quot; &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283_移动零"></a>283_移动零</h2><ul>
<li>还是比较简单的，双指针即可，再学习下题解是怎么做的</li>
<li>题解没有覆盖，而是<code>swap</code>交换，毕竟是移动0</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//自己手撕</span><br><span class="line">class Solution1 &#123;</span><br><span class="line">public:</span><br><span class="line">    void moveZeroes(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if(nums.empty())</span><br><span class="line">            return;</span><br><span class="line"></span><br><span class="line">        //双指针？</span><br><span class="line">        int pre = 0, cur = 0;</span><br><span class="line">        while(cur &lt; nums.size())&#123;</span><br><span class="line">            if(nums[cur] == 0)&#123;</span><br><span class="line">                ++cur;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                //如果不是0，得分情况</span><br><span class="line">                if(pre == cur)&#123;</span><br><span class="line">                    //说明还没有出现0！</span><br><span class="line">                    ++pre;</span><br><span class="line">                    ++cur;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    //pre还停留在上个0的起始位置，之后就是连续的覆盖</span><br><span class="line">                    nums[pre++] = nums[cur];</span><br><span class="line">                    ++cur;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(cur != pre)&#123;</span><br><span class="line">            while(pre &lt; nums.size())&#123;</span><br><span class="line">                nums[pre++] = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//题解交换</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void moveZeroes(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size(), left = 0, right = 0;</span><br><span class="line">        while (right &lt; n) &#123;</span><br><span class="line">            //如果不为0，那么两个指针一样，即自己交换自己</span><br><span class="line">            if (nums[right]) &#123;</span><br><span class="line">                swap(nums[left], nums[right]);</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="284-顶端迭代器"><a href="#284-顶端迭代器" class="headerlink" title="284_顶端迭代器"></a>284_顶端迭代器</h2><ul>
<li>恕我直言，这题没看懂，力扣没看懂的题不是一次两次了！不知道我从小语文就很差嘛！</li>
<li>这里引用大佬的思路</li>
</ul>
<p><img src="/pictrues/284.png" alt title="题解"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Iterator &#123;</span><br><span class="line">    struct Data;</span><br><span class="line">    Data* data;</span><br><span class="line">public:</span><br><span class="line">    Iterator(const vector&lt;int&gt;&amp; nums);</span><br><span class="line">    Iterator(const Iterator&amp; iter);</span><br><span class="line"></span><br><span class="line">    // Returns the next element in the iteration.</span><br><span class="line">    int next();</span><br><span class="line"></span><br><span class="line">    // Returns true if the iteration has more elements.</span><br><span class="line">    bool hasNext() const;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class PeekingIterator : public Iterator &#123;</span><br><span class="line">private:</span><br><span class="line">    int _val;</span><br><span class="line">    bool _next;</span><br><span class="line">public:</span><br><span class="line">    PeekingIterator(const vector&lt;int&gt;&amp; nums) : Iterator(nums) &#123;</span><br><span class="line">        _next = Iterator::hasNext();</span><br><span class="line">        if(_next) _val = Iterator::next();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int peek() &#123;</span><br><span class="line">        return _val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int next() &#123;</span><br><span class="line">        int cur = _val;</span><br><span class="line">        _next = Iterator::hasNext();</span><br><span class="line">        if(_next) _val = Iterator::next();</span><br><span class="line">        return cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool hasNext() const &#123;</span><br><span class="line">        return _next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="287-寻找重复数"><a href="#287-寻找重复数" class="headerlink" title="287_寻找重复数"></a>287_寻找重复数</h2><ul>
<li>之前做过这样的思路——投票<ul>
<li>重复的数，票数是最多的！但是忘了是哪一题了</li>
</ul>
</li>
<li>最好的情况是只有两个不同的数字，其中一个只有一个，剩下的全是重复的另一个；最坏的情况是1~n的数字都有，重复的那个只出现两次</li>
<li>想了半天想不出来（不用哈希）——问题是题解的三种方法我居然看不懂！！</li>
<li>居然还可以用快慢指针！！！这里截一下大佬的题解——以后面试，也不能一招吃遍鲜，那样显得底蕴太少<ul>
<li>最近见到好多<code>do-while</code>循环体</li>
</ul>
</li>
</ul>
<p><img src="/pictrues/287.png" alt title="快慢指针"></p>
<p><img src="/pictrues/287_1.png" alt title="下标0位置不可能在环内"></p>
<ul>
<li>看到这个图的时候，我知道懂了！</li>
</ul>
<p><img src="/pictrues/287_2.png" alt title="下标与元素的值进行映射"></p>
<ul>
<li><p>这题与142题的区别</p>
<ul>
<li>慢指针走一步 <code>slow = slow.next</code> ==&gt; 本题 <code>slow = nums[slow]</code></li>
<li>快指针走两步 <code>fast = fast.next.next</code> ==&gt; 本题 <code>fast = nums[nums[fast]]</code></li>
</ul>
</li>
<li><p>光顾着博客和力扣了，第二天才发现本地<code>Clion</code>还空着….</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//快慢指针</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findDuplicate(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int slow = 0, fast = 0;</span><br><span class="line">        //这里是判断环</span><br><span class="line">        do &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">        &#125; while (slow != fast);</span><br><span class="line"></span><br><span class="line">        //这里慢指针置0，之后两指针都依次走一步，相遇点即是重复点</span><br><span class="line">        slow = 0;</span><br><span class="line">        while (slow != fast) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        return slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="289-生命游戏"><a href="#289-生命游戏" class="headerlink" title="289_生命游戏"></a>289_生命游戏</h2><ul>
<li>细胞自动机学一下——复制原矩阵、复合状态</li>
<li>还有种思路很厉害——也需要遍历周围8个格子——可以一次过！</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//根据大佬的思路重新手撕一遍</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    //</span><br><span class="line">    void gameOfLife(vector&lt;vector&lt;int&gt;&gt;&amp; board) &#123;</span><br><span class="line">        int r = static_cast&lt;int&gt;(board.size());</span><br><span class="line">        int c = static_cast&lt;int&gt;(board[0].size());</span><br><span class="line"></span><br><span class="line">        int neighbors[3] = &#123;-1, 0, 1&#125;;</span><br><span class="line">        //遍历原矩阵，只针对活着的细胞，格子为1或者个位数为1</span><br><span class="line">        for(int i = 0; i &lt; r; ++i)&#123;</span><br><span class="line">            for(int j = 0; j &lt; c; ++j)&#123;</span><br><span class="line">                //活着的细胞个位数一定为1</span><br><span class="line">                if(board[i][j] % 10 == 0)</span><br><span class="line">                    continue;</span><br><span class="line"></span><br><span class="line">                //这里学习下，遍历周围8个格子的小技巧，首先自己是排除在外的</span><br><span class="line">                for(int _i = 0; _i &lt; 3; ++_i)&#123;</span><br><span class="line">                    for(int _j = 0; _j &lt; 3; ++_j)&#123;</span><br><span class="line">                        if(!(_i == 1 &amp;&amp; _j == 1))&#123;</span><br><span class="line">                            int _r = i + neighbors[_i];</span><br><span class="line">                            int _c = j + neighbors[_j];</span><br><span class="line">                            //不能超出边界，周围8个格子都加10</span><br><span class="line">                            if(_r &gt;= 0 &amp;&amp; _r &lt; r &amp;&amp; _c &gt;= 0 &amp;&amp; _c &lt; c)&#123;</span><br><span class="line">                                board[_r][_c] += 10;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //二次遍历</span><br><span class="line">        for(int i = 0; i &lt; r; ++i)&#123;</span><br><span class="line">            for(int j = 0; j &lt; c; ++j)&#123;</span><br><span class="line">                //四个规则，活细胞三个，死细胞一个</span><br><span class="line">                if(board[i][j] % 10 == 1)&#123;</span><br><span class="line">                    if(board[i][j] &lt; 21) board[i][j] = 0;</span><br><span class="line">                    if(board[i][j] == 21 || board[i][j] == 31) board[i][j] = 1;</span><br><span class="line">                    if(board[i][j] &gt; 31) board[i][j] = 0;</span><br><span class="line"></span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    if(board[i][j] == 30)&#123;</span><br><span class="line">                        board[i][j] = 1;</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line">                        //死细胞周围不是正好3个活细胞，也要重置</span><br><span class="line">                        board[i][j] = 0;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="295-数据流的中位数"><a href="#295-数据流的中位数" class="headerlink" title="295_数据流的中位数"></a>295_数据流的中位数</h2><ul>
<li><p>感觉数据结构可能会有数组，就放在数组这儿了</p>
</li>
<li><p>粘贴下昨晚写的思路</p>
<ul>
<li>首先每次放入数字，都要排好序，还要有一个总数，再加上两个指针</li>
<li>有了总数，可以迅速定位中位数，或者直接根据下标访问数字，来求中位数，但是又要排好序</li>
<li>直接用<code>vector&lt;int&gt;(101)</code>，对应的元素放数字（也就是下标的个数），并且初始化两个指针，之后根据放入的数字在指针左还是右，以及指针左右两边的数字总数（这个应该不需要，还是需要一个数来记录下左边的总数吧，不然后面不好判断指针是否需要移动），判断是否需要移动指针</li>
<li>指针移动时，找到数组第一个不为0的元素即可，就是判断是否移动，比较麻烦点，因为会有很多重复的数字，要不是提示所有整数都在0-100之间，还真不容易想到</li>
</ul>
</li>
<li><p>做到最后我傻眼了，怎么还有负数？</p>
<ul>
<li>如果这样，那得用双向链表了？<ul>
<li>双向链表在移动指针时比较方便</li>
</ul>
</li>
<li>成功了，但是消耗比较高</li>
</ul>
</li>
<li><p>看看题解咋做的</p>
<ul>
<li>方法一，数组 + <code>sort()</code>排序超时</li>
<li>方法二，还是数组 + 插入排序，又忘了这个函数<code>lower_bound(store.begin(), store.end(), num)</code>返回的是位置</li>
<li>方法三，原来堆这么好用嘛<ul>
<li>两个堆，一个放大数、一个放小数，之后要平衡这两个堆！（优先级队列？）</li>
<li>最大堆可以比最小堆多一个元素</li>
<li>完全平衡时，返回两个堆顶元素，否则，返回大堆的顶元素</li>
<li>好处就是不用比较，直接按步骤来，先放入<code>lo</code>，如果两个堆数目不等——再将<code>lo</code>的最大元素放入<code>hi</code><ul>
<li>这里会出现一个问题，<code>hi</code>会有数字比<code>lo</code>小，所以应该是先放<code>lo</code>，再放<code>hi</code>，——这一步是为了确保<code>hi</code>的数字比<code>lo</code>大；然后反过来，确保<code>lo</code>长度不会比<code>hi</code>小!</li>
</ul>
</li>
<li>默认生成的优先级队列，第一个元素是最大的——如果加入<code>greater&lt;int&gt;</code>，那么第一个数字就是最小的</li>
</ul>
</li>
<li>方法四，自平衡二叉树<ul>
<li>也是用的双指针，看看是怎么实现的，<code>multiset&lt;int&gt;</code>是不是从小到大默认排好序的？艹，一种植物</li>
<li>之后根据奇偶数来更新</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//双向链表，手撕</span><br><span class="line">struct myList&#123;</span><br><span class="line">    myList* pre;</span><br><span class="line">    myList* next;</span><br><span class="line">    int val;</span><br><span class="line">    //构造函数</span><br><span class="line">    myList() : pre(nullptr), next(nullptr), val(0)&#123;&#125;</span><br><span class="line">    explicit myList(int val) : pre(nullptr), next(nullptr), val(val)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class MedianFinder1 &#123;</span><br><span class="line">public:</span><br><span class="line">    /* initialize your data structure here. */</span><br><span class="line">    MedianFinder1() : l(nullptr), r(nullptr), n(0)&#123;</span><br><span class="line">        head = new myList(INT32_MIN);</span><br><span class="line">        tail = new myList(INT32_MAX);</span><br><span class="line">        head-&gt;next = tail;</span><br><span class="line">        tail-&gt;pre = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void addNum(int num) &#123;</span><br><span class="line">        if(!l)&#123;</span><br><span class="line">            ++n;</span><br><span class="line">            //第一次放数据</span><br><span class="line">            head-&gt;next = new myList(num);</span><br><span class="line">            head-&gt;next-&gt;pre = head;</span><br><span class="line">            head-&gt;next-&gt;next = tail;</span><br><span class="line">            tail-&gt;pre = head-&gt;next;</span><br><span class="line">            //初始化两个指针</span><br><span class="line">            l = head-&gt;next;</span><br><span class="line">            r = head-&gt;next;</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">            ++n;</span><br><span class="line">            //因该先加节点，再判断奇偶数！——不对，这样也不好判断</span><br><span class="line">            if(n % 2 == 0)&#123;</span><br><span class="line">                //俩指针需要分开</span><br><span class="line">                if(l-&gt;val &gt;= num)&#123;</span><br><span class="line">                    myList* carry = l-&gt;pre;</span><br><span class="line">                    //找到第一个比num不大的节点</span><br><span class="line">                    while (carry-&gt;pre != nullptr &amp;&amp; carry-&gt;val &gt;= num)&#123;</span><br><span class="line">                        carry = carry-&gt;pre;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //在carry的右边新建节点</span><br><span class="line">                    auto tmp = carry-&gt;next;</span><br><span class="line">                    carry-&gt;next = new myList(num);</span><br><span class="line">                    carry-&gt;next-&gt;pre = carry;</span><br><span class="line">                    tmp-&gt;pre = carry-&gt;next;</span><br><span class="line">                    carry-&gt;next-&gt;next = tmp;</span><br><span class="line">                    //左指针左移</span><br><span class="line">                    l = l-&gt;pre;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    myList* carry = r-&gt;next;</span><br><span class="line">                    //找到第一个比num不小的节点</span><br><span class="line">                    while (carry-&gt;next != nullptr &amp;&amp; carry-&gt;val &lt; num)&#123;</span><br><span class="line">                        carry = carry-&gt;next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //在carry的左边新建节点</span><br><span class="line">                    auto tmp = carry-&gt;pre;</span><br><span class="line">                    tmp-&gt;next = new myList(num);</span><br><span class="line">                    tmp-&gt;next-&gt;pre = tmp;</span><br><span class="line"></span><br><span class="line">                    carry-&gt;pre = tmp-&gt;next;</span><br><span class="line">                    tmp-&gt;next-&gt;next = carry;</span><br><span class="line">                    //右指针右移</span><br><span class="line">                    r = r-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                //俩指针需要归一</span><br><span class="line">                if(l-&gt;val &gt;= num)&#123;</span><br><span class="line">                    auto carry = l-&gt;pre;</span><br><span class="line">                    while(carry-&gt;pre != nullptr &amp;&amp; carry-&gt;val &gt;= num)&#123;</span><br><span class="line">                        carry = carry-&gt;pre;</span><br><span class="line">                    &#125;</span><br><span class="line">                    auto tmp = carry-&gt;next;</span><br><span class="line">                    carry-&gt;next = new myList(num);</span><br><span class="line">                    carry-&gt;next-&gt;pre = carry;</span><br><span class="line">                    carry-&gt;next-&gt;next = tmp;</span><br><span class="line">                    tmp-&gt;pre = carry-&gt;next;</span><br><span class="line">                    //右指针左移</span><br><span class="line">                    r = r-&gt;pre;</span><br><span class="line">                &#125;else if(r-&gt;val &lt;= num)&#123;</span><br><span class="line">                    auto carry = r-&gt;next;</span><br><span class="line">                    while (carry-&gt;next != nullptr &amp;&amp; carry-&gt;val &lt;= num)&#123;</span><br><span class="line">                        carry = carry-&gt;next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    auto tmp = carry-&gt;pre;</span><br><span class="line">                    tmp-&gt;next = new myList(num);</span><br><span class="line">                    tmp-&gt;next-&gt;pre = tmp;</span><br><span class="line">                    tmp-&gt;next-&gt;next = carry;</span><br><span class="line">                    carry-&gt;pre = tmp-&gt;next;</span><br><span class="line">                    //左指针右移</span><br><span class="line">                    l = l-&gt;next;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    l-&gt;next = new myList(num);</span><br><span class="line">                    l-&gt;next-&gt;pre = l;</span><br><span class="line">                    l-&gt;next-&gt;next = r;</span><br><span class="line">                    r-&gt;pre = l-&gt;next;</span><br><span class="line">                    //归一</span><br><span class="line">                    l = l-&gt;next;</span><br><span class="line">                    r = r-&gt;pre;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    double findMedian() &#123;</span><br><span class="line">        </span><br><span class="line">        return static_cast&lt;double&gt;(l-&gt;val + r-&gt;val) / 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    //这两个指针用来</span><br><span class="line">    myList* l;</span><br><span class="line">    myList* r;</span><br><span class="line">    //head和tail之间存放数据</span><br><span class="line">    myList* head;</span><br><span class="line">    myList* tail;</span><br><span class="line">    //用来判断奇偶数</span><br><span class="line">    int n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//插入排序</span><br><span class="line">class MedianFinder2 &#123;</span><br><span class="line">    vector&lt;int&gt; store; // resize-able container</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    // Adds a number into the data structure.</span><br><span class="line">    void addNum(int num)</span><br><span class="line">    &#123;</span><br><span class="line">        if (store.empty())</span><br><span class="line">            store.push_back(num);</span><br><span class="line">        else</span><br><span class="line">            store.insert(lower_bound(store.begin(), store.end(), num), num);     // binary search and insertion combined</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Returns the median of current data stream</span><br><span class="line">    double findMedian()</span><br><span class="line">    &#123;</span><br><span class="line">        int n = store.size();</span><br><span class="line">        return n &amp; 1 ? store[n / 2] : (store[n / 2 - 1] + store[n / 2]) * 0.5;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//优先级队列</span><br><span class="line">class MedianFinder3 &#123;</span><br><span class="line">    priority_queue&lt;int&gt; lo;                              // max heap</span><br><span class="line">    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; hi;   // min heap</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    // Adds a number into the data structure.</span><br><span class="line">    void addNum(int num)</span><br><span class="line">    &#123;</span><br><span class="line">        lo.push(num);                                    // Add to max heap</span><br><span class="line">        //确保hi的数字比lo大</span><br><span class="line">        hi.push(lo.top());</span><br><span class="line">        lo.pop();</span><br><span class="line"></span><br><span class="line">        if (lo.size() &lt; hi.size()) &#123;</span><br><span class="line">            //平衡，确保`lo`长度不会比`hi`小</span><br><span class="line">            lo.push(hi.top());</span><br><span class="line">            hi.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Returns the median of current data stream</span><br><span class="line">    double findMedian()</span><br><span class="line">    &#123;</span><br><span class="line">        return lo.size() &gt; hi.size() ? (double) lo.top() : (lo.top() + hi.top()) * 0.5;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//自平衡二叉树</span><br><span class="line">class MedianFinder &#123;</span><br><span class="line">    multiset&lt;int&gt; data;</span><br><span class="line">    multiset&lt;int&gt;::iterator lo_median, hi_median;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    MedianFinder() : lo_median(data.end()), hi_median(data.end())&#123;&#125;</span><br><span class="line"></span><br><span class="line">    void addNum(int num)&#123;</span><br><span class="line">        const size_t n = data.size();   // store previous size</span><br><span class="line">        data.insert(num);               // insert into multiset</span><br><span class="line"></span><br><span class="line">        if (!n) &#123;</span><br><span class="line">            // no elements before, one element now</span><br><span class="line">            lo_median = hi_median = data.begin();</span><br><span class="line">        &#125;</span><br><span class="line">        else if (n &amp; 1) &#123;</span><br><span class="line">            // odd size before (i.e. lo == hi), even size now (i.e. hi = lo + 1)</span><br><span class="line">            if (num &lt; *lo_median)       // num &lt; lo</span><br><span class="line">                lo_median--;</span><br><span class="line">            else                        // num &gt;= hi</span><br><span class="line">                hi_median++;            // insertion at end of equal range</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            // even size before (i.e. hi = lo + 1), odd size now (i.e. lo == hi)</span><br><span class="line">            if (num &gt; *lo_median &amp;&amp; num &lt; *hi_median) &#123;</span><br><span class="line">                lo_median++;                    // num in between lo and hi</span><br><span class="line">                hi_median--;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (num &gt;= *hi_median)         // num inserted after hi</span><br><span class="line">                lo_median++;</span><br><span class="line">            else                                // num &lt;= lo &lt; hi</span><br><span class="line">                lo_median = --hi_median;        // insertion at end of equal range spoils lo</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    double findMedian()&#123;</span><br><span class="line">        return (*lo_median + *hi_median) * 0.5;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这题告一段落了</li>
</ul>
<h2 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300_最长递增子序列"></a>300_最长递增子序列</h2><ul>
<li>这题想了两天没啥好的思路，总感觉似曾相识<ul>
<li>印象中，之前用了递归，因为不是遇到大的数字就选择，也可以不选这个数字，因为这个数字可能过大，导致整体长度小</li>
<li>之前递归不出所料应该超时了，，，看看能不能用动态规划</li>
<li>这题我属实不会</li>
<li>看了题解的一句话——定义 <code>dp[i]</code> 为考虑前 <code>i</code> 个元素，以第 <code>i</code> 个数字结尾的最长上升子序列的长度，注意 <code>nums[i]</code> 必须被选取。<ul>
<li>我就知道似曾相识！！最后结果就是遍历一遍数组，取最大值，这个在之前某个题目里用到过！当时还特地问了师兄，末尾为什么一定得选择</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = (int)nums.size();</span><br><span class="line">        if (n == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; dp(n, 0);</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i] = 1;</span><br><span class="line">            for (int j = 0; j &lt; i; ++j) &#123;</span><br><span class="line">                //这个if是啥意思——哦哦，递增序列，一直递推下去就是一直递增的</span><br><span class="line">                if (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                    dp[i] = max(dp[i], dp[j] + 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //*max_element()好久不见</span><br><span class="line">        return *max_element(dp.begin(), dp.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>还可以用贪心？麻了麻了</li>
</ul>
<h2 id="303-区域和检索-数组不可变"><a href="#303-区域和检索-数组不可变" class="headerlink" title="303_区域和检索-数组不可变"></a>303_区域和检索-数组不可变</h2><ul>
<li>看题意应该是只构造一次？<ul>
<li>知识点应该是前缀和</li>
<li>可以一次过，就是需要注意<code>i</code>、<code>j</code>本身都包含在内</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class NumArray &#123;</span><br><span class="line">public:</span><br><span class="line">    NumArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        //i~j，包含这两个坐标，若这两个相等，总和就是数字本身，为了方便还是加个0</span><br><span class="line">        sum.emplace_back(0);</span><br><span class="line">        int tmp = 0;</span><br><span class="line">        for(auto num : nums)&#123;</span><br><span class="line">            tmp += num;</span><br><span class="line">            sum.emplace_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int sumRange(int left, int right) &#123;</span><br><span class="line">        return sum[right + 1] - sum[left];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    vector&lt;int&gt; sum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="304-二维区域和检索-矩阵不可变"><a href="#304-二维区域和检索-矩阵不可变" class="headerlink" title="304_二维区域和检索-矩阵不可变"></a>304_二维区域和检索-矩阵不可变</h2><ul>
<li>仔细想了想，前缀和还是能实现的，对应区域相减时，要把剩余的区域也减掉<ul>
<li>生成前缀和的时候要一行一行的来</li>
<li>要把重复的区域加上或者减去</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class NumMatrix &#123;</span><br><span class="line">public:</span><br><span class="line">    NumMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) : row(matrix.size()), col(matrix[0].size()), sum(matrix) &#123;</span><br><span class="line">        // 这里初始化 sum，先初始化边界 —— 第一行、第一列</span><br><span class="line">        for(int i = 1; i &lt; row; ++i)&#123;</span><br><span class="line">            sum[i][0] += sum[i - 1][0];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int j = 1; j &lt; col; ++j)&#123;</span><br><span class="line">            sum[0][j] += sum[0][j - 1];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i = 1; i &lt; row; ++i)&#123;</span><br><span class="line">            for(int j = 1; j &lt; col; ++j)&#123;</span><br><span class="line">                // 这里有三个部分</span><br><span class="line">                sum[i][j] += (sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int sumRegion(int row1, int col1, int row2, int col2) &#123;</span><br><span class="line">        if(row1 == 0 &amp;&amp; col1 == 0)&#123;</span><br><span class="line">            return sum[row2][col2];</span><br><span class="line">        &#125;else if(row1 == 0)&#123;</span><br><span class="line">            return sum[row2][col2] - sum[row2][col1 - 1];</span><br><span class="line">        &#125;else if(col1 == 0)&#123;</span><br><span class="line">            return sum[row2][col2] - sum[row1 - 1][col2];</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            // 两个都不为 0</span><br><span class="line">            return sum[row2][col2] - sumRegion(0, 0, row1 - 1, col2) - sumRegion(0, 0, row2, col1 - 1) + sumRegion(0, 0, row1 - 1, col1 - 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; sum;</span><br><span class="line">    int row;</span><br><span class="line">    int col;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>题解比我优化的好<ul>
<li>两个维度初始化都多出一个，腾出空间，省去判断边界的麻烦！</li>
</ul>
</li>
</ul>
<h2 id="307-区域和检索-数组可修改"><a href="#307-区域和检索-数组可修改" class="headerlink" title="307_区域和检索 - 数组可修改"></a>307_区域和检索 - 数组可修改</h2><ul>
<li>一维数组前缀和，修改了对应的元素后，那么后面所有的总和都要改变，但是这样每改一次，牵一发而动全身不妥<ul>
<li>可以记录下位置以及元素，之后返回结果的时候再更新</li>
<li>如何判断区间内是否存在元素被修改</li>
</ul>
</li>
</ul>
<h2 id="363-矩形区域不超过K的最大数值和"><a href="#363-矩形区域不超过K的最大数值和" class="headerlink" title="363_矩形区域不超过K的最大数值和"></a>363_矩形区域不超过K的最大数值和</h2><ul>
<li>看题解之前毫无思路，看了之后…降维打击！</li>
<li>矩阵的每列和（相当于把矩阵压扁、压成一维的），然后题目就变成了数组中找区间和</li>
<li>至于怎么找，仔细思考下如何用二分</li>
<li>学习下<code>set.lower_bound</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;iterator&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    //求最大区间和</span><br><span class="line">    void numAns(vector&lt;int&gt; &amp;tmp, int k)&#123;</span><br><span class="line">        //0是必要的，要不然遇到s - k = 0 时会找不到正确位置</span><br><span class="line">        set&lt;int&gt; res(&#123;0&#125;);</span><br><span class="line">        int s = 0;</span><br><span class="line">        for(auto t : tmp)&#123;</span><br><span class="line">            //累加和</span><br><span class="line">            s += t;</span><br><span class="line">            //s - k是从0开始到i的累加和</span><br><span class="line">            auto iter = res.lower_bound(s - k);</span><br><span class="line">            cout &lt;&lt; &quot;s = &quot; &lt;&lt; s &lt;&lt; &quot; s - k = &quot; &lt;&lt; s - k &lt;&lt; &quot; iter-&gt;&quot; &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">            //如果存在不低于s - k的值，那么从i开始到s这一段就是最大累加和（不超过k）</span><br><span class="line">            if(iter != res.end())&#123;</span><br><span class="line">                ans = max(ans, s - *iter);</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; &quot;ans = &quot; &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">            res.insert(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int maxSumSubmatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) &#123;</span><br><span class="line">        int r = matrix.size(), c = matrix[0].size();</span><br><span class="line">        for(int i = 0; i &lt; r; ++i)&#123;</span><br><span class="line">            vector&lt;int&gt; tmp(c, 0);</span><br><span class="line">            for(int j = i; j &lt; r; ++j)&#123;</span><br><span class="line">                //第i行和第j行之间压缩成一维数组</span><br><span class="line">                for(int m = 0; m &lt; c; ++m)&#123;</span><br><span class="line">                    tmp[m] += matrix[j][m];</span><br><span class="line">                &#125;</span><br><span class="line">                cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; &quot; j = &quot; &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">                copy(tmp.begin(), tmp.end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot;));</span><br><span class="line">                cout &lt;&lt; endl;</span><br><span class="line">                //对tmp求区间和</span><br><span class="line">                numAns(tmp, k);</span><br><span class="line">                if(ans == k)</span><br><span class="line">                    return k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int ans = INT32_MIN;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; matrix(&#123;&#123;2, 2, -1&#125;&#125;);</span><br><span class="line">    int k = 3;</span><br><span class="line">    Solution solution;</span><br><span class="line">    int ans = solution.maxSumSubmatrix(matrix, k);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="368-最大整除子集"><a href="#368-最大整除子集" class="headerlink" title="368_最大整除子集"></a>368_最大整除子集</h2><ul>
<li>思路一开始就错了，本来以为找到类似等比数列，再递归剩下的数，最后比较大小；但是一开始找的数列并不一定就是最长的</li>
<li>不应该是剩下来的，而是全部；也不对，有的数哪怕符合也不能要！</li>
<li>试试动态规划，也不太对，手画了一下，感觉是二叉树，求最长路径；用栈试试</li>
<li>…..</li>
<li>看题解；想到了升序，还是有点对头的；这题好难</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; largestDivisibleSubset(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int len = nums.size();</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line"></span><br><span class="line">        // 第 1 步：动态规划找出最大子集的个数、最大子集中的最大整数</span><br><span class="line">        vector&lt;int&gt; dp(len, 1);</span><br><span class="line">        int maxSize = 1;</span><br><span class="line">        int maxVal = dp[0];</span><br><span class="line">        for (int i = 1; i &lt; len; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; i; j++) &#123;</span><br><span class="line">                // 题目中说「没有重复元素」很重要</span><br><span class="line">                if (nums[i] % nums[j] == 0) &#123;</span><br><span class="line">                    //这个比较......</span><br><span class="line">                    dp[i] = max(dp[i], dp[j] + 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (dp[i] &gt; maxSize) &#123;</span><br><span class="line">                maxSize = dp[i];</span><br><span class="line">                maxVal = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 第 2 步：倒推获得最大子集</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        if (maxSize == 1) &#123;</span><br><span class="line">            res.push_back(nums[0]);</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = len - 1; i &gt;= 0 &amp;&amp; maxSize &gt; 0; i--) &#123;</span><br><span class="line">            if (dp[i] == maxSize &amp;&amp; maxVal % nums[i] == 0) &#123;</span><br><span class="line">                res.push_back(nums[i]);</span><br><span class="line">                maxVal = nums[i];</span><br><span class="line">                maxSize--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="377-组合总和-Ⅳ"><a href="#377-组合总和-Ⅳ" class="headerlink" title="377_组合总和_Ⅳ"></a>377_组合总和_Ⅳ</h2><ul>
<li>用递归超时…优化下</li>
<li>优化不了，题解说要动态规划…做这题花了一个多小时，笔试直接凉凉</li>
<li>这动态规划太牛了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int combinationSum4(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        //dp[target]表示和为target的总个数</span><br><span class="line">        vector&lt;int&gt; dp(target + 1);</span><br><span class="line">        dp[0] = 1;</span><br><span class="line">        for (int i = 1; i &lt;= target; i++) &#123;</span><br><span class="line">            for (int&amp; num : nums) &#123;</span><br><span class="line">                //防止溢出</span><br><span class="line">                if (num &lt;= i &amp;&amp; dp[i - num] &lt; INT_MAX - dp[i]) &#123;</span><br><span class="line">                    //在计算dp[i]dp[i] 时，应该计算所有的dp[i−num] 之和。</span><br><span class="line">                    dp[i] += dp[i - num];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; nums(&#123;1,2,3&#125;);</span><br><span class="line">    int target = 32;    //181997601</span><br><span class="line">    Solution solution;</span><br><span class="line">    int ans = solution.combinationSum4(nums, target);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="403-青蛙过河"><a href="#403-青蛙过河" class="headerlink" title="403_青蛙过河"></a>403_青蛙过河</h2><ul>
<li>这题得好好康康，深度优先搜索居然没想出来，因为习惯贪心了，却又发现贪心不了；不优化的话，深度优先搜索估计会超时</li>
<li>动态规划<code>dp[i][k] = dp[j][k - 1] || dp[j][k] || dp[j][k + 1];</code>这个转移方程不怎么理解</li>
<li><code>dp[i][k]</code>表示青蛙能否达到现在所处的石子编号为<code>i</code>且上一次跳跃距离为<code>k</code>的状态。</li>
<li>为什么是<code>n*n</code>，因为一开始的步数是0，每次都增加一个步数，也不过<code>n-1</code>；所以<del>行</del>列一共<code>n</code>维</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="690-员工的重要性"><a href="#690-员工的重要性" class="headerlink" title="690_员工的重要性"></a>690_员工的重要性</h2><ul>
<li>还可以，深度优先搜索和广度优先搜索</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">// Definition for Employee.</span><br><span class="line">class Employee &#123;</span><br><span class="line">public:</span><br><span class="line">    int id;</span><br><span class="line">    int importance;</span><br><span class="line">    vector&lt;int&gt; subordinates;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void sum(vector&lt;Employee*&gt; &amp;employees, int pos)&#123;</span><br><span class="line">        //有id，肯定有重要性，先求和再判断有没有下属</span><br><span class="line">        ans += employees[pos]-&gt;importance;</span><br><span class="line">        if(employees[pos]-&gt;subordinates.empty()) return;</span><br><span class="line">        for(auto id : employees[pos]-&gt;subordinates)&#123;</span><br><span class="line">            int p = map[id];</span><br><span class="line">            sum(employees, p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int getImportance(vector&lt;Employee*&gt; employees, int id) &#123;</span><br><span class="line">        if(employees.empty()) return 0;</span><br><span class="line">        int i = 0;</span><br><span class="line">        // 记录位置信息，方便查找</span><br><span class="line">        for(auto &amp;e : employees)&#123;</span><br><span class="line">            map[e-&gt;id] = i;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        int pos = map[id];</span><br><span class="line">        sum(employees, pos);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    unordered_map&lt;int, int&gt; map;</span><br><span class="line">    int ans;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1011-在D天内送达包裹的能力"><a href="#1011-在D天内送达包裹的能力" class="headerlink" title="1011_在D天内送达包裹的能力"></a>1011_在D天内送达包裹的能力</h2><ul>
<li>直觉是动态规划，不知状态、不知转移过程</li>
<li>看论文多了，这题居然已经是两天前的了，昨天的每日一题也是直接看了个大概，看样子还是坚持下去</li>
<li>方法妙在先确定D，之后就可以用贪心比较——送达的天数，之后不满足条件，可以用二分法找D，最后输出应该是左端点吧</li>
<li>注意条件右端点满足答案，但是，判断还会继续进行，不对，计算天数错误</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;numeric&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">// 自己手写了一遍，加强记忆</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int shipWithinDays(vector&lt;int&gt;&amp; weights, int D)&#123;</span><br><span class="line">        // 这应该是最小的载重</span><br><span class="line">        int l = *max_element(weights.begin(), weights.end());</span><br><span class="line">        int r = accumulate(weights.begin(), weights.end(), 0);</span><br><span class="line">        // 如果是输出左端点，那么while里应该是小于</span><br><span class="line">        while (l &lt; r)&#123;</span><br><span class="line">            cout &lt;&lt; &quot;l = &quot; &lt;&lt; l &lt;&lt; &quot; r = &quot; &lt;&lt; r &lt;&lt;endl;</span><br><span class="line">            int mid = (l + r) / 2;</span><br><span class="line">            cout &lt;&lt; &quot;mid = &quot; &lt;&lt; mid &lt;&lt; endl;</span><br><span class="line">            int D_ = 1, tmp = 0;</span><br><span class="line">            for(auto w : weights)&#123;</span><br><span class="line">                if((tmp + w) &lt;= mid)&#123;</span><br><span class="line">                    tmp += w;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                ++D_;</span><br><span class="line">                tmp = w;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; &quot;D_ = &quot; &lt;&lt; D_ &lt;&lt; endl;</span><br><span class="line">            if(D_ &gt; D)&#123;</span><br><span class="line">                //说明载重小了</span><br><span class="line">                l = mid + 1;</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution_ &#123;</span><br><span class="line">public:</span><br><span class="line">    int shipWithinDays(vector&lt;int&gt;&amp; weights, int D) &#123;</span><br><span class="line">        // 确定二分查找左右边界</span><br><span class="line">        int left = *max_element(weights.begin(), weights.end()), right = accumulate(weights.begin(), weights.end(), 0);</span><br><span class="line">        while (left &lt; right) &#123;</span><br><span class="line">            int mid = (left + right) / 2;</span><br><span class="line">            // need 为需要运送的天数</span><br><span class="line">            // cur 为当前这一天已经运送的包裹重量之和</span><br><span class="line">            int need = 1, cur = 0;</span><br><span class="line">            for (int weight: weights) &#123;</span><br><span class="line">                if (cur + weight &gt; mid) &#123;</span><br><span class="line">                    ++need;</span><br><span class="line">                    cur = 0;</span><br><span class="line">                &#125;</span><br><span class="line">                cur += weight;</span><br><span class="line">            &#125;</span><br><span class="line">            if (need &lt;= D) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                left = mid + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; weights(&#123;1,2,3,4,5,6,7,8,9,10&#125;);</span><br><span class="line">    int D = 5;</span><br><span class="line">    Solution solution;</span><br><span class="line">    int ans = solution.shipWithinDays(weights, D);</span><br><span class="line">    cout &lt;&lt; &quot;ans = &quot; &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1018-可被5整除的二进制前缀"><a href="#1018-可被5整除的二进制前缀" class="headerlink" title="1018_可被5整除的二进制前缀"></a>1018_可被5整除的二进制前缀</h2><ul>
<li>数组很长，全部转化为整数类型会超出边界，因为只需被5整除，所以被除数的个位为0或者5即可</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;bool&gt; prefixesDivBy5(vector&lt;int&gt;&amp; A) &#123;</span><br><span class="line">        vector&lt;bool&gt; res;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        for(int i : A)&#123;</span><br><span class="line">            ans = 2 * ans + i;</span><br><span class="line">            if(ans &gt;= 10)&#123;ans -= 10;&#125;</span><br><span class="line">            if(ans % 5 == 0)&#123;</span><br><span class="line">                if(ans == 0 || ans &gt;= 5)&#123;</span><br><span class="line">                    res.push_back(true);</span><br><span class="line">                &#125; else&#123;</span><br><span class="line">                    res.push_back(false);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                res.push_back(false);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; A = &#123;1,0,0,1&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;bool&gt; res = solution.prefixesDivBy5(A);</span><br><span class="line">    for(auto i : res)&#123;</span><br><span class="line">        cout &lt;&lt; i;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1723-完成所有工作的最短时间"><a href="#1723-完成所有工作的最短时间" class="headerlink" title="1723_完成所有工作的最短时间"></a>1723_完成所有工作的最短时间</h2><ul>
<li>本来每日一题是不打算写进博客的，准备以后做到，再重新做一遍的时候写，但看了看题号，还是写一下吧，可能不会做到这题了，也可能要好久…</li>
<li>我用递归加剪枝做出来了，题解又用了二分，并且与之前一题十分相似，先找出最小的工作量，然后确定上下限，最后二分判断？</li>
<li>好像是轮船载重那题，还有一道是降维打击那题？</li>
<li>官方题解确实速度更快</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;numeric&gt;</span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void dfs(vector&lt;int&gt; &amp;workers, vector&lt;int&gt;&amp; jobs, int pos, int mean, int k)&#123;</span><br><span class="line">        // 递归出口</span><br><span class="line">        if(flag) return;</span><br><span class="line">        if(pos == 0)&#123;</span><br><span class="line">            //找最小的工人</span><br><span class="line">            auto iter_min = min_element(workers.begin(), workers.end());</span><br><span class="line">            //找完最小值，加上之后，还要再找最大值</span><br><span class="line">            auto iter_max = max_element(workers.begin(), workers.end());</span><br><span class="line">            int tmp = max(*iter_min + jobs[pos], *iter_max);</span><br><span class="line">            ans = min(ans, tmp);</span><br><span class="line">            if(ans == mean)&#123;</span><br><span class="line">                flag = true;</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 对工人进行遍历</span><br><span class="line">        for(int i = 0; i &lt; k; ++i)&#123;</span><br><span class="line">            if((i &gt; 0 &amp;&amp; workers[i] == workers[i - 1]) || workers[i] &gt; mean)</span><br><span class="line">                continue;</span><br><span class="line">            // 到这里是小于均值的工人</span><br><span class="line">            workers[i] += jobs[pos];</span><br><span class="line">            dfs(workers, jobs, pos - 1, mean, k);</span><br><span class="line">            workers[i] -= jobs[pos];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int minimumTimeRequired(vector&lt;int&gt;&amp; jobs, int k) &#123;</span><br><span class="line">        // 从小到大排序</span><br><span class="line">        sort(jobs.begin(), jobs.end());</span><br><span class="line">        int sum = accumulate(jobs.begin(), jobs.end(), 0);</span><br><span class="line">        int mean = sum / k, pos = static_cast&lt;int&gt;(jobs.size()) - 1;</span><br><span class="line">        vector&lt;int&gt; workers(k, 0);</span><br><span class="line">        // 如果答案就是平均数，那就可以直接输出，在回溯里还要再加一个记号</span><br><span class="line">        dfs(workers, jobs, pos, mean, k);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int ans = INT32_MAX;</span><br><span class="line">    bool flag = false;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//题解</span><br><span class="line">class Solution_ &#123;</span><br><span class="line">public:</span><br><span class="line">    bool backtrack(vector&lt;int&gt;&amp; jobs, vector&lt;int&gt;&amp; workloads, int idx, int limit) &#123;</span><br><span class="line">        if (idx &gt;= jobs.size()) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        int cur = jobs[idx];</span><br><span class="line">        for (auto&amp; workload : workloads) &#123;</span><br><span class="line">            if (workload + cur &lt;= limit) &#123;</span><br><span class="line">                workload += cur;</span><br><span class="line">                if (backtrack(jobs, workloads, idx + 1, limit)) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">                workload -= cur;</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果当前工人未被分配工作，那么下一个工人也必然未被分配工作</span><br><span class="line">            // 或者当前工作恰能使该工人的工作量达到了上限</span><br><span class="line">            // 这两种情况下我们无需尝试继续分配工作</span><br><span class="line">            if (workload == 0 || workload + cur == limit) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool check(vector&lt;int&gt;&amp; jobs, int k, int limit) &#123;</span><br><span class="line">        vector&lt;int&gt; workloads(k, 0);</span><br><span class="line">        return backtrack(jobs, workloads, 0, limit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int minimumTimeRequired(vector&lt;int&gt;&amp; jobs, int k) &#123;</span><br><span class="line">        sort(jobs.begin(), jobs.end(), greater&lt;&gt;());</span><br><span class="line">        int l = jobs[0], r = accumulate(jobs.begin(), jobs.end(), 0);</span><br><span class="line">        while (l &lt; r) &#123;</span><br><span class="line">            int mid = (l + r) &gt;&gt; 1;</span><br><span class="line">            if (check(jobs, k, mid)) &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                l = mid + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//动态规划</span><br><span class="line">class Solution1 &#123;</span><br><span class="line">public:</span><br><span class="line">    int minimumTimeRequired(vector&lt;int&gt;&amp; jobs, int k) &#123;</span><br><span class="line">        int n = jobs.size();</span><br><span class="line">        vector&lt;int&gt; sum(1 &lt;&lt; n);</span><br><span class="line">        for (int i = 1; i &lt; (1 &lt;&lt; n); i++) &#123;</span><br><span class="line">            int x = __builtin_ctz(i), y = i - (1 &lt;&lt; x);</span><br><span class="line">            sum[i] = sum[y] + jobs[x];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(k, vector&lt;int&gt;(1 &lt;&lt; n));</span><br><span class="line">        for (int i = 0; i &lt; (1 &lt;&lt; n); i++) &#123;</span><br><span class="line">            dp[0][i] = sum[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; k; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; (1 &lt;&lt; n); j++) &#123;</span><br><span class="line">                int minn = INT_MAX;</span><br><span class="line">                for (int x = j; x; x = (x - 1) &amp; j) &#123;</span><br><span class="line">                    minn = min(minn, max(dp[i - 1][j - x], sum[x]));</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][j] = minn;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[k - 1][(1 &lt;&lt; n) - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; jobs(&#123;4,5,4,5,4&#125;);</span><br><span class="line">    int k = 2;</span><br><span class="line">    Solution_ solution;</span><br><span class="line">    int ans = solution.minimumTimeRequired(jobs, k);</span><br><span class="line">    cout &lt;&lt; &quot;ans = &quot; &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><ul>
<li>啊，之前一直忘记写<font color="#FF0000">delete</font>了……希望内存不要泄露太多；在哪里分配的就要在哪里删除，（否则，new出来的指针既不是类成员变量，又只是函数内部可见，不delete使用完谁也释放不了）</li>
<li>第二题就是链表，自以为做出来了就可以不认真看题解了，，直到百题，，还是看书意识到不对劲；</li>
<li>第二题用的是内置指针，然后用delete手动删除；第十九题试一下智能指针<code>shared_ptr</code>；如果使用智能指针，需要在类里面添加，并让析构函数负责删除；但似乎有点麻烦，因为题里给的函数是普通的指针</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void delete_list(ListNode * head)&#123;</span><br><span class="line">    ListNode *h1 = head;</span><br><span class="line">    ListNode *h2;</span><br><span class="line">    while (h1 != nullptr)&#123;</span><br><span class="line">        h2 = h1-&gt;next;</span><br><span class="line">        delete h1;</span><br><span class="line">        h1 = h2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>声明一个节点</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct ListNode&#123;	</span><br><span class="line">    int val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>给一个节点赋值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ListNode* head = new ListNode;	</span><br><span class="line">head-&gt;val = 0;</span><br><span class="line">head-&gt;next = NULL;</span><br></pre></td></tr></table></figure>

<ul>
<li>获取链表的长度、输出链表的所有值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int len = 1;			</span><br><span class="line">while(head-&gt;next!=NULL)			</span><br><span class="line">       &#123;</span><br><span class="line">           len++;</span><br><span class="line">           p=p-&gt;next;</span><br><span class="line">       &#125;</span><br><span class="line">for(int i = 0; i &lt; len; i++)&#123;</span><br><span class="line">       cout &lt;&lt; head-&gt;val &lt;&lt; &quot; &quot;;</span><br><span class="line">       head = head-&gt;next;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2_两数相加"></a>2_两数相加</h2><ul>
<li>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</li>
<li>输出：7 -&gt; 0 -&gt; 8</li>
<li>342+4</li>
<li>=807</li>
</ul>
<blockquote>
<p>C/C++</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct ListNode &#123;       //Definition for singly-linked list.</span><br><span class="line">    int val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode() : val(0), next(nullptr) &#123;&#125;;</span><br><span class="line">    explicit ListNode(int val) : val(val), next(nullptr) &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void delete_list(ListNode * head)&#123;</span><br><span class="line">    ListNode *h1 = head;</span><br><span class="line">    ListNode *h2;</span><br><span class="line">    while (h1 != nullptr)&#123;</span><br><span class="line">        h2 = h1-&gt;next;</span><br><span class="line">        delete h1;</span><br><span class="line">        h1 = h2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;</span><br><span class="line">        auto* l3 = new ListNode();</span><br><span class="line">        ListNode* p = l3;           //这只是一个节点,要想p=p-&gt;next,要根据构造函数创建新的节点</span><br><span class="line">        int carry = 0;              //进位</span><br><span class="line"></span><br><span class="line">        while(l1 != nullptr || l2 != nullptr)  &#123;</span><br><span class="line">            int sum = 0;        //对应节点之和</span><br><span class="line">            if(l1 != nullptr)&#123;</span><br><span class="line">                sum += l1-&gt;val;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            if(l2 != nullptr)&#123;</span><br><span class="line">                sum += l2-&gt;val;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            sum += carry;</span><br><span class="line">            p-&gt;next = new ListNode(sum % 10);</span><br><span class="line">            carry = floor(sum / 10);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        if(carry &gt; 0)&#123;</span><br><span class="line">            p-&gt;next = new ListNode(carry);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //return l3-&gt;next; 并没有释放头节点</span><br><span class="line">        p = l3;</span><br><span class="line">        l3 = l3-&gt;next;</span><br><span class="line">        delete p;</span><br><span class="line">        return l3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    auto *l1 = new ListNode(6);</span><br><span class="line">    auto carry = l1;</span><br><span class="line">    carry-&gt;next = new ListNode(9);</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    carry-&gt;next = new ListNode(2);</span><br><span class="line"></span><br><span class="line">    auto *l2 = new ListNode(3);</span><br><span class="line">    carry = l2;</span><br><span class="line">    carry-&gt;next = new ListNode(3);</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    carry-&gt;next = new ListNode(2);</span><br><span class="line"></span><br><span class="line">    Solution s;</span><br><span class="line">    ListNode *l3 = s.addTwoNumbers(l1, l2);</span><br><span class="line">    carry = l3;</span><br><span class="line">    while (carry != nullptr) &#123;</span><br><span class="line">        cout &lt;&lt; carry-&gt;val &lt;&lt; &quot; &quot;;</span><br><span class="line">        carry = carry-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    delete_list(l1);</span><br><span class="line">    delete_list(l2);</span><br><span class="line">    delete_list(l3);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19_删除链表的倒数第N个节点"></a>19_删除链表的倒数第N个节点</h2><ul>
<li>两次遍历，先遍历链表的长度，再根据<code>len-n</code>遍历得到删除的节点，将前一个节点的指针指向后一个节点，即可删除</li>
<li>两个指针，一个<code>slow</code>一个<code>fast</code>，刚开始都指向头部，再将<code>fast</code>往后移n个距离，最后同时遍历这两个指针，直到<code>fast-&gt;next == nullptr</code>，将<code>slow-&gt;next = slow-&gt;next-&gt;next</code></li>
</ul>
<h3 id="两次遍历"><a href="#两次遍历" class="headerlink" title="两次遍历"></a>两次遍历</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    shared_ptr&lt;ListNode&gt; next;</span><br><span class="line">    ListNode() : val(0), next(nullptr) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;创建了&quot; &lt;&lt; 0 &lt;&lt; &quot;节点&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    explicit ListNode(int x) : val(x), next(nullptr) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;创建了&quot; &lt;&lt; val &lt;&lt; &quot;节点&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~ListNode()&#123;</span><br><span class="line">        cout &lt;&lt; &quot;节点 &quot; &lt;&lt; val &lt;&lt; &quot; 已自动删除&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    shared_ptr&lt;ListNode&gt; removeNthFromEnd(shared_ptr&lt;ListNode&gt; head, int n) &#123;</span><br><span class="line">        if(!head)&#123;return head;&#125;</span><br><span class="line">        int len = 0;</span><br><span class="line">        auto carry1 = make_shared&lt;ListNode&gt;();</span><br><span class="line">        carry1-&gt;next = head;</span><br><span class="line">        while (carry1-&gt;next)&#123;   //当carry1变成nullptr时，就自动删除了</span><br><span class="line">            len++;</span><br><span class="line">            carry1 = carry1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        auto carry = make_shared&lt;ListNode&gt;();</span><br><span class="line">        carry-&gt;next = head;   //  再次初始化</span><br><span class="line">        while (len - n &gt; 0)&#123;</span><br><span class="line">            carry = carry-&gt;next;</span><br><span class="line">            len--;</span><br><span class="line">        &#125;</span><br><span class="line">        if(carry-&gt;next == head)&#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">            carry-&gt;next = carry-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    shared_ptr&lt;ListNode&gt; head = make_shared&lt;ListNode&gt;(1);</span><br><span class="line">    cout &lt;&lt; &quot;head: &quot; &lt;&lt; head.use_count() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;----&quot; &lt;&lt; endl;</span><br><span class="line">    auto carry = head;</span><br><span class="line">    cout &lt;&lt; &quot;head: &quot; &lt;&lt; head.use_count() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;carry: &quot; &lt;&lt; carry.use_count() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;----&quot; &lt;&lt; endl;</span><br><span class="line">    carry-&gt;next = make_shared&lt;ListNode&gt;(2);</span><br><span class="line">    cout &lt;&lt; &quot;head: &quot; &lt;&lt; head.use_count() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;carry: &quot; &lt;&lt; carry.use_count() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;----&quot; &lt;&lt; endl;</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    cout &lt;&lt; &quot;head: &quot; &lt;&lt; head.use_count() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;carry: &quot; &lt;&lt; carry.use_count() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;----&quot; &lt;&lt; endl;</span><br><span class="line">    carry-&gt;next = make_shared&lt;ListNode&gt;(3);</span><br><span class="line">    cout &lt;&lt; &quot;head: &quot; &lt;&lt; head.use_count() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;carry: &quot; &lt;&lt; carry.use_count() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;----&quot; &lt;&lt; endl;</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    cout &lt;&lt; &quot;head: &quot; &lt;&lt; head.use_count() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;carry: &quot; &lt;&lt; carry.use_count() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;----&quot; &lt;&lt; endl;</span><br><span class="line">    carry-&gt;next = make_shared&lt;ListNode&gt;(4);</span><br><span class="line">    cout &lt;&lt; &quot;head: &quot; &lt;&lt; head.use_count() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;carry: &quot; &lt;&lt; carry.use_count() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;----&quot; &lt;&lt; endl;</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    cout &lt;&lt; &quot;head: &quot; &lt;&lt; head.use_count() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;carry: &quot; &lt;&lt; carry.use_count() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;----&quot; &lt;&lt; endl;</span><br><span class="line">    carry-&gt;next = make_shared&lt;ListNode&gt;(5);</span><br><span class="line">    cout &lt;&lt; &quot;head: &quot; &lt;&lt; head.use_count() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;carry: &quot; &lt;&lt; carry.use_count() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;----&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Solution solution;</span><br><span class="line">    shared_ptr&lt;ListNode&gt; res = solution.removeNthFromEnd(head, 5);</span><br><span class="line">    cout &lt;&lt; &quot;res:&quot; &lt;&lt; res.use_count() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;head: &quot; &lt;&lt; head.use_count() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;carry: &quot; &lt;&lt; carry.use_count() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;----&quot; &lt;&lt; endl;</span><br><span class="line">    carry = res;</span><br><span class="line">    cout &lt;&lt; &quot;res:&quot; &lt;&lt; res.use_count() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;head: &quot; &lt;&lt; head.use_count() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;carry: &quot; &lt;&lt; carry.use_count() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;----&quot; &lt;&lt; endl;</span><br><span class="line">    while (carry)&#123;</span><br><span class="line">        cout &lt;&lt; carry-&gt;val &lt;&lt; endl;</span><br><span class="line">        carry = carry-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; &quot;++++&quot; &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="两个指针"><a href="#两个指针" class="headerlink" title="两个指针"></a>两个指针</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;</span><br><span class="line">        if(head == nullptr)&#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *slow = new ListNode;</span><br><span class="line">        ListNode *fast = new ListNode;</span><br><span class="line">        slow-&gt;next = head;</span><br><span class="line">        fast-&gt;next = head;</span><br><span class="line">        while (n &gt; 0)&#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        while (fast-&gt;next != nullptr)&#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        if(slow-&gt;next == head)&#123;</span><br><span class="line">            return head-&gt;next;</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">            slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    auto *head = new ListNode(1);</span><br><span class="line">    ListNode *carry = head;</span><br><span class="line">    carry-&gt;next = new ListNode(2);</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    carry-&gt;next = new ListNode(3);</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    carry-&gt;next = new ListNode(4);</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    carry-&gt;next = new ListNode(5);</span><br><span class="line"></span><br><span class="line">    Solution solution;</span><br><span class="line">    ListNode *res = solution.removeNthFromEnd(head, 1);</span><br><span class="line"></span><br><span class="line">    while (res != nullptr)&#123;</span><br><span class="line">        cout &lt;&lt; res-&gt;val;</span><br><span class="line">        res = res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21_合并两个有序链表"></a>21_合并两个有序链表</h2><h3 id="迭代-1"><a href="#迭代-1" class="headerlink" title="迭代"></a>迭代</h3><ul>
<li>本来是将结果放入一个新的链表里，看了答案只需改变指针方向即可</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 自己写的</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;</span><br><span class="line">        auto *carry = new ListNode;</span><br><span class="line">        auto *head = carry;</span><br><span class="line">        while (l2 != nullptr &amp;&amp; l1 != nullptr)&#123;</span><br><span class="line">            if(l1-&gt;val &gt; l2-&gt;val)&#123;</span><br><span class="line">                carry-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">                carry = carry-&gt;next;</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                carry-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">                carry = carry-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(l2 != nullptr)&#123;</span><br><span class="line">            carry-&gt;next = l2;</span><br><span class="line">        &#125;</span><br><span class="line">        if(l1 != nullptr)&#123;</span><br><span class="line">            carry-&gt;next = l1;</span><br><span class="line">        &#125;</span><br><span class="line">        return head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 迭代</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;</span><br><span class="line">        ListNode* preHead = new ListNode(-1);</span><br><span class="line">        ListNode* prev = preHead;</span><br><span class="line">        while (l1 != nullptr &amp;&amp; l2 != nullptr) &#123;</span><br><span class="line">            if (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">                prev-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                prev-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = prev-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        prev-&gt;next = l1 == nullptr ? l2 : l1;</span><br><span class="line">        return preHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    auto *l1 = new ListNode(1);</span><br><span class="line">    ListNode *carry = l1;</span><br><span class="line">    carry-&gt;next = new ListNode(2);</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    carry-&gt;next = new ListNode(4);</span><br><span class="line"></span><br><span class="line">    auto *l2 = new ListNode(1);</span><br><span class="line">    carry = l2;</span><br><span class="line">    carry-&gt;next = new ListNode(3);</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    carry-&gt;next = new ListNode(4);</span><br><span class="line"></span><br><span class="line">    Solution solution;</span><br><span class="line">    auto l = solution.mergeTwoLists(l1, l2);</span><br><span class="line">    while (l != nullptr)&#123;</span><br><span class="line">        cout &lt;&lt; l-&gt;val &lt;&lt; &quot; &quot;;</span><br><span class="line">        l = l-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h3><ul>
<li>牛皮</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;</span><br><span class="line">        if(l1 == nullptr)&#123;</span><br><span class="line">            return l2;</span><br><span class="line">        &#125; else if(l2 == nullptr)&#123;</span><br><span class="line">            return l1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(l1-&gt;val &lt; l2-&gt;val)&#123;</span><br><span class="line">            l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);</span><br><span class="line">            return l1;</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">            l2-&gt;next = mergeTwoLists(l1, l2-&gt;next);</span><br><span class="line">            return l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    auto *l1 = new ListNode(1);</span><br><span class="line">    ListNode *carry = l1;</span><br><span class="line">    carry-&gt;next = new ListNode(2);</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    carry-&gt;next = new ListNode(4);</span><br><span class="line"></span><br><span class="line">    auto *l2 = new ListNode(1);</span><br><span class="line">    carry = l2;</span><br><span class="line">    carry-&gt;next = new ListNode(3);</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    carry-&gt;next = new ListNode(4);</span><br><span class="line"></span><br><span class="line">    Solution solution;</span><br><span class="line">    auto l = solution.mergeTwoLists(l1, l2);</span><br><span class="line">    while (l != nullptr)&#123;</span><br><span class="line">        cout &lt;&lt; l-&gt;val &lt;&lt; &quot; &quot;;</span><br><span class="line">        l = l-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="23-合并K个升序链表"><a href="#23-合并K个升序链表" class="headerlink" title="23_合并K个升序链表"></a>23_合并K个升序链表</h2><ul>
<li>参照之前的合并2个升序链表，可以遍历链表型的数组</li>
</ul>
<h3 id="顺序合并"><a href="#顺序合并" class="headerlink" title="顺序合并"></a>顺序合并</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2)&#123;</span><br><span class="line">        if(l1 == nullptr)&#123;return l2;&#125;</span><br><span class="line">        auto *head = new ListNode(-1);</span><br><span class="line">        ListNode *carry = head;</span><br><span class="line">        while (l1 != nullptr &amp;&amp; l2 != nullptr)&#123;</span><br><span class="line">            if(l1-&gt;val &gt; l2-&gt;val)&#123;</span><br><span class="line">                carry-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                carry-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            carry = carry-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        carry-&gt;next = l1 == nullptr ? l2 : l1;</span><br><span class="line">        return head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123;</span><br><span class="line">        int len = lists.size(), i = 0;</span><br><span class="line">        if(len == 1)&#123;</span><br><span class="line">            return lists[0];</span><br><span class="line">        &#125;</span><br><span class="line">        auto *prehead = new ListNode(-1);</span><br><span class="line">        while (i &lt; len)&#123;</span><br><span class="line">            ListNode *tmp = prehead-&gt;next;</span><br><span class="line">            prehead-&gt;next = mergeTwoLists(tmp, lists[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        return prehead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;ListNode*&gt; lists;</span><br><span class="line">    auto *l1 = new ListNode(1);</span><br><span class="line">    ListNode *carry = l1;</span><br><span class="line">    carry-&gt;next = new ListNode(4);</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    carry-&gt;next = new ListNode(5);</span><br><span class="line">    lists.push_back(l1);</span><br><span class="line">    auto *l2 = new ListNode(1);</span><br><span class="line">    carry = l2;</span><br><span class="line">    carry-&gt;next = new ListNode(3);</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    carry-&gt;next = new ListNode(4);</span><br><span class="line">    lists.push_back(l2);</span><br><span class="line">    auto *l3 = new ListNode(2);</span><br><span class="line">    carry = l3;</span><br><span class="line">    carry-&gt;next = new ListNode(6);</span><br><span class="line">    lists.push_back(l3);</span><br><span class="line">    Solution solution;</span><br><span class="line">    auto *res = solution.mergeKLists(lists);</span><br><span class="line">    while (res != nullptr)&#123;</span><br><span class="line">        std::cout &lt;&lt; res-&gt;val &lt;&lt; &quot; &quot;;</span><br><span class="line">        res = res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24_两两交换链表中的节点"></a>24_两两交换链表中的节点</h2><ul>
<li>刚开始是想遍历来着，后来悟了，发现每次都是两两交换，递归搞定</li>
<li>写了几次递归，注意要先写递归的出口:)</li>
</ul>
<h3 id="递归-3"><a href="#递归-3" class="headerlink" title="递归"></a>递归</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* swapPairs(ListNode* head) &#123;</span><br><span class="line">        if(head == nullptr || head-&gt;next == nullptr)&#123;return head;&#125;</span><br><span class="line">        auto *l = head;</span><br><span class="line">        auto *r = l-&gt;next;</span><br><span class="line">        l-&gt;next = swapPairs(r-&gt;next);</span><br><span class="line">        r-&gt;next = l;</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    auto *head = new ListNode(1);</span><br><span class="line">    ListNode *carry = head;</span><br><span class="line">    carry-&gt;next = new ListNode(2);</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    carry-&gt;next = new ListNode(3);</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    carry-&gt;next = new ListNode(4);</span><br><span class="line">    Solution solution;</span><br><span class="line">    auto *res = solution.swapPairs(head);</span><br><span class="line">    while (res != nullptr)&#123;</span><br><span class="line">        std::cout &lt;&lt; res-&gt;val &lt;&lt; &quot; &quot;;</span><br><span class="line">        res = res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25_K 个一组翻转链表"></a>25_K 个一组翻转链表</h2><ul>
<li>同样可以用递归来交换，难点在于如何反转一个链表</li>
<li>若只有两个节点，只需改变指针位置即可</li>
<li>若有三个节点及以上，我是用一个数组储存节点的值，再从后往前遍历数组生成新的链表</li>
<li><font color="#FF0000"></font></li>
<li>_反转链表</li>
</ul>
<h3 id="递归-4"><a href="#递归-4" class="headerlink" title="递归"></a>递归</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* reverseKGroup(ListNode* head, int k) &#123;</span><br><span class="line">        int len = 0;</span><br><span class="line">        auto *tmp = head;</span><br><span class="line">        while (tmp != nullptr)&#123;</span><br><span class="line">            len++;</span><br><span class="line">            tmp = tmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        if(len &lt; k || len == 0 || len == 1)&#123;return head;&#125;</span><br><span class="line"></span><br><span class="line">        tmp = head;     // 初始化tmp;</span><br><span class="line">        int i = 0;</span><br><span class="line">        vector&lt;int&gt; vec;</span><br><span class="line">        auto *res = new ListNode(-1);</span><br><span class="line">        ListNode *carry = res;</span><br><span class="line">        while (i &lt; k)&#123;</span><br><span class="line">            vec.push_back(tmp-&gt;val);</span><br><span class="line">            tmp = tmp-&gt;next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        while (i != 0)&#123;</span><br><span class="line">            carry-&gt;next = new ListNode(vec[i - 1]);</span><br><span class="line">            carry = carry-&gt;next;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        carry-&gt;next = reverseKGroup(tmp, k);</span><br><span class="line">        return res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    auto *head = new ListNode(1);</span><br><span class="line">    ListNode *carry = head;</span><br><span class="line">    carry-&gt;next = new ListNode(2);</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    carry-&gt;next = new ListNode(3);</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    carry-&gt;next = new ListNode(4);</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    carry-&gt;next = new ListNode(5);</span><br><span class="line">    int k = 3;</span><br><span class="line">    Solution solution;</span><br><span class="line">    auto *res = solution.reverseKGroup(head, 2);</span><br><span class="line">    while (res != nullptr)&#123;</span><br><span class="line">        std::cout &lt;&lt; res-&gt;val &lt;&lt; &quot; &quot;;</span><br><span class="line">        res = res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="61-旋转链表"><a href="#61-旋转链表" class="headerlink" title="61_旋转链表"></a>61_旋转链表</h2><ul>
<li>一次通过，自然的想到让其收尾相连，然后转圈圈（注意长度互补：如果<code>k</code>为2，那么顺时针走<code>l-2</code>步），再收尾断开</li>
</ul>
<p><img src="/pictrues/list.png" alt="list" title="list"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* rotateRight(ListNode* head, int k) &#123;</span><br><span class="line">        if(head == nullptr)&#123;return nullptr;&#125;</span><br><span class="line">        ListNode* head_last = head;</span><br><span class="line">        int l = 1;  //长度</span><br><span class="line">        while (head_last-&gt;next != nullptr)&#123;</span><br><span class="line">            head_last = head_last-&gt;next;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(k == 0 || k % l == 0)&#123;return head;&#125;;</span><br><span class="line">        head_last-&gt;next = head;</span><br><span class="line">        k = k &lt; l ? (l - k) : (l - k % l);</span><br><span class="line">        while (k &gt; 0)&#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            head_last = head_last-&gt;next;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        head_last-&gt;next = nullptr;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    auto* head = new ListNode(1);</span><br><span class="line">    ListNode* tmp = head;</span><br><span class="line">    tmp-&gt;next = new ListNode(2);</span><br><span class="line">    tmp = tmp-&gt;next;</span><br><span class="line">    tmp-&gt;next = new ListNode(3);</span><br><span class="line">    tmp = tmp-&gt;next;</span><br><span class="line">    tmp-&gt;next = new ListNode(4);</span><br><span class="line">    tmp = tmp-&gt;next;</span><br><span class="line">    tmp-&gt;next = new ListNode(5);</span><br><span class="line">    Solution solution;</span><br><span class="line">    ListNode* res = solution.rotateRight(head, 2);</span><br><span class="line">    while (res != nullptr)&#123;</span><br><span class="line">        cout &lt;&lt; res-&gt;val &lt;&lt; &quot; &quot;;</span><br><span class="line">        res = res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="82-删除排序链表中的重复元素-II"><a href="#82-删除排序链表中的重复元素-II" class="headerlink" title="82_删除排序链表中的重复元素_II"></a>82_删除排序链表中的重复元素_II</h2><ul>
<li>刚开始想直接在原链表进行修改，但感觉有点绕；定义了一个新的链表，考虑特殊情况：原链表是空指针或者只有一个数，直接返回原链表；之后在遍历，判断其相同数字的个数，根据条件来增加节点，最后要考虑最后一个数字是否也是重复的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* deleteDuplicates(ListNode* head) &#123;</span><br><span class="line">        if(head == nullptr || head-&gt;next == nullptr)&#123;return head;&#125;</span><br><span class="line">        int n = 0, tmp = head-&gt;val;</span><br><span class="line">        auto *res = new ListNode();</span><br><span class="line">        auto *carry = res;</span><br><span class="line">        while (head != nullptr)&#123;</span><br><span class="line">            cout &lt;&lt; head-&gt;val &lt;&lt; &quot; - &quot; &lt;&lt; endl;</span><br><span class="line">            if(tmp == head-&gt;val)&#123;</span><br><span class="line">                n++;</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                if(n &lt; 2)&#123;</span><br><span class="line">                    carry-&gt;next = new ListNode(tmp);</span><br><span class="line">                    carry = carry-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                tmp = head-&gt;val;</span><br><span class="line">                if(head-&gt;next == nullptr)&#123;</span><br><span class="line">                    carry-&gt;next = new ListNode(tmp);</span><br><span class="line">                &#125;</span><br><span class="line">                n = 1;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    auto *head = new ListNode(1);</span><br><span class="line">    auto *carry = head;</span><br><span class="line">    carry-&gt;next = new ListNode(2);</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    carry-&gt;next = new ListNode(3);</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    carry-&gt;next = new ListNode(3);</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    carry-&gt;next = new ListNode(4);</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    carry-&gt;next = new ListNode(4);</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    carry-&gt;next = new ListNode(5);</span><br><span class="line">    Solution solution;</span><br><span class="line">    ListNode *res = solution.deleteDuplicates(head);</span><br><span class="line">    carry = res;</span><br><span class="line">    while (carry != nullptr)&#123;</span><br><span class="line">        cout &lt;&lt; carry-&gt;val &lt;&lt; &quot; &quot;;</span><br><span class="line">        carry = carry-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83_删除排序链表中的重复元素"></a>83_删除排序链表中的重复元素</h2><ul>
<li>这题是在原链表修改的，需要考虑最后可能会存在的几个重复数字；用两个指针，前一个和后一个，再比较他们值的大小</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* deleteDuplicates(ListNode* head) &#123;</span><br><span class="line">        if(head == nullptr || head-&gt;next == nullptr)&#123;return head;&#125;</span><br><span class="line">        ListNode *pre = head, *cur = head-&gt;next;</span><br><span class="line">        while (cur != nullptr)&#123;</span><br><span class="line">            if(pre-&gt;val != cur-&gt;val)&#123;</span><br><span class="line">                pre-&gt;next = cur;</span><br><span class="line">                pre = pre-&gt;next;</span><br><span class="line">//                cout &lt;&lt; pre-&gt;val &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            if(cur-&gt;next == nullptr &amp;&amp; pre-&gt;val == cur-&gt;val)&#123;</span><br><span class="line">                pre-&gt;next = nullptr;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    auto *head = new ListNode(1);</span><br><span class="line">    auto *carry = head;</span><br><span class="line">    carry-&gt;next = new ListNode(1);</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    carry-&gt;next = new ListNode(2);</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    carry-&gt;next = new ListNode(3);</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    carry-&gt;next = new ListNode(3);</span><br><span class="line">    Solution solution;</span><br><span class="line">    ListNode *res = solution.deleteDuplicates(head);</span><br><span class="line">    carry = res;</span><br><span class="line">    while (carry != nullptr)&#123;</span><br><span class="line">        cout &lt;&lt; carry-&gt;val &lt;&lt; &quot; &quot;;</span><br><span class="line">        carry = carry-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="86-分隔链表"><a href="#86-分隔链表" class="headerlink" title="86_分隔链表"></a>86_分隔链表</h2><ul>
<li>这题虽然用时和消耗比较高，但好歹和题解思路一样：维护两个链表，再把他们连接起来</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* partition(ListNode* head, int x) &#123;</span><br><span class="line">        auto *res = new ListNode(), *right = new ListNode();</span><br><span class="line">        auto *l = res, * r = right;</span><br><span class="line">        while (head != nullptr)&#123;</span><br><span class="line">            if(head-&gt;val &lt; x)&#123;</span><br><span class="line">                l-&gt;next = new ListNode(head-&gt;val);</span><br><span class="line">                l = l-&gt;next;</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                r-&gt;next = new ListNode(head-&gt;val);</span><br><span class="line">                r = r-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        l-&gt;next = right-&gt;next;</span><br><span class="line">        return res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    auto *head = new ListNode(1);</span><br><span class="line">    auto *carry = head;</span><br><span class="line">    carry-&gt;next = new ListNode(4);</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    carry-&gt;next = new ListNode(3);</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    carry-&gt;next = new ListNode(2);</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    carry-&gt;next = new ListNode(5);</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    carry-&gt;next = new ListNode(2);</span><br><span class="line">    int x = 3;</span><br><span class="line">    Solution solution;</span><br><span class="line">    auto *res = solution.partition(head, x);</span><br><span class="line">    carry = res;</span><br><span class="line">    while (carry != nullptr)&#123;</span><br><span class="line">        cout &lt;&lt; carry-&gt;val &lt;&lt; &quot; &quot;;</span><br><span class="line">        carry = carry-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92_反转链表_II"></a>92_反转链表_II</h2><ul>
<li>这里的<code>left</code>和<code>right</code>是类似于数组里的位置，并不是节点的值</li>
<li>要保存<code>left</code>和<code>right</code>之间的值，从后往前生成新的链表；还要保存两个断点的指针；最后将三段链表链接起来</li>
<li>不过这是一般的思路；还是跟206_反转链表这题有关</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* reverseBetween(ListNode* head, int left, int right) &#123;</span><br><span class="line">        if(left == right) return head;</span><br><span class="line">        //先找到left、right位置对应的节点</span><br><span class="line">        auto *pre = new ListNode(); //重新定义新的头部</span><br><span class="line">        auto *carry = pre;</span><br><span class="line">        auto *prel = head, *prer = head;</span><br><span class="line">        while (left &gt; 1)&#123;</span><br><span class="line">            carry-&gt;next = new ListNode(prel-&gt;val);</span><br><span class="line">            carry = carry-&gt;next;    //carry在prel之前</span><br><span class="line">            prel = prel-&gt;next;</span><br><span class="line">            --left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bool flag = false;</span><br><span class="line">        vector&lt;int&gt; tmp;</span><br><span class="line">        while (right &gt; 1)&#123;</span><br><span class="line">            if(prer == prel) flag = true;</span><br><span class="line">            if(flag) tmp.emplace_back(prer-&gt;val);</span><br><span class="line">            prer = prer-&gt;next;</span><br><span class="line">            --right;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp.emplace_back(prer-&gt;val);    //最后prel节点的数字</span><br><span class="line"></span><br><span class="line">//        cout &lt;&lt; carry-&gt;val &lt;&lt; &quot; &quot; &lt;&lt; prel-&gt;val &lt;&lt; &quot; &quot; &lt;&lt; prer-&gt;val &lt;&lt; endl;</span><br><span class="line">        auto *mid = new ListNode();</span><br><span class="line">        auto *mid_tmp = mid;</span><br><span class="line">        for(int i = tmp.size(); i &gt; 0; --i)&#123;</span><br><span class="line">            mid_tmp-&gt;next = new ListNode(tmp[i - 1]);</span><br><span class="line">            mid_tmp = mid_tmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">//        cout &lt;&lt; tmp.size() &lt;&lt; &quot; - &quot; &lt;&lt; mid-&gt;next-&gt;val &lt;&lt; &quot; &quot; &lt;&lt; mid_tmp-&gt;val &lt;&lt; endl;</span><br><span class="line">        carry-&gt;next = mid-&gt;next;    //第一次链接</span><br><span class="line">        mid_tmp-&gt;next = prer-&gt;next; //第二次链接</span><br><span class="line"></span><br><span class="line">        return pre-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    auto *head = new ListNode(1);</span><br><span class="line">    auto *carry = head;</span><br><span class="line">    carry-&gt;next = new ListNode(2);</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    carry-&gt;next = new ListNode(3);</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    carry-&gt;next = new ListNode(4);</span><br><span class="line">    carry = carry-&gt;next;</span><br><span class="line">    carry-&gt;next = new ListNode(5);</span><br><span class="line">    Solution solution;</span><br><span class="line">    auto *res = solution.reverseBetween(head, 4, 5);</span><br><span class="line">    carry = res;</span><br><span class="line">    while (carry != nullptr)&#123;</span><br><span class="line">        cout &lt;&lt; carry-&gt;val &lt;&lt; &quot; &quot;;</span><br><span class="line">        carry = carry-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="138-复制带随机指针的链表"><a href="#138-复制带随机指针的链表" class="headerlink" title="138_复制带随机指针的链表"></a>138_复制带随机指针的链表</h2><ul>
<li>有了之前那个深拷贝图题的摧残，这题自然也就不在话下，dfs搞定</li>
<li>再练习下bfs；这题的bfs好像行不通，看看题解——迭代、新旧节点交替</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Node &#123;</span><br><span class="line">public:</span><br><span class="line">    int val;</span><br><span class="line">    Node* next;</span><br><span class="line">    Node* random;</span><br><span class="line">    </span><br><span class="line">    Node(int _val) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        next = NULL;</span><br><span class="line">        random = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    unordered_map&lt;Node*, Node*&gt; map;</span><br><span class="line">    Node* copyRandomList(Node* head) &#123;</span><br><span class="line">        if(!head) return nullptr;</span><br><span class="line"></span><br><span class="line">        if(map.find(head) != map.end())</span><br><span class="line">            return map[head];</span><br><span class="line"></span><br><span class="line">        Node* res = new Node(head-&gt;val);</span><br><span class="line">        map[head] = res;</span><br><span class="line"></span><br><span class="line">        res-&gt;next = copyRandomList(head-&gt;next);</span><br><span class="line">        res-&gt;random = copyRandomList(head-&gt;random);</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="二刷-4"><a href="#二刷-4" class="headerlink" title="二刷"></a>二刷</h3><ul>
<li>前几天 剑指Offer 刚做过，不过那时候，两个方法都不会，这次再来复习下<ul>
<li>看了第一次写的，居然用了递归……应该是题解，那就有三种方法了</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 哈希 + 循环</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    Node* copyRandomList(Node* head) &#123;</span><br><span class="line">        if(!head) return nullptr;</span><br><span class="line">        // 先建立 原节点 与 新节点 的对应关系</span><br><span class="line">        unordered_map&lt;Node*, Node*&gt; map;</span><br><span class="line">        auto carry = head;</span><br><span class="line">        while(carry != nullptr)&#123;</span><br><span class="line">            map[carry] = new Node(carry-&gt;val);</span><br><span class="line">            carry = carry-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">		// 这一句也可以不要</span><br><span class="line">        map[nullptr] = nullptr;</span><br><span class="line">        // 这里再将节点连线</span><br><span class="line">        carry = head;</span><br><span class="line">        while(carry != nullptr)&#123;</span><br><span class="line">            // next</span><br><span class="line">            map[carry]-&gt;next = map[carry-&gt;next];</span><br><span class="line">            map[carry]-&gt;random = map[carry-&gt;random];</span><br><span class="line">            carry = carry-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return map[head];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>再写一下拆分</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 拆分</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    Node* copyRandomList(Node* head) &#123;</span><br><span class="line">        if(!head) return nullptr;</span><br><span class="line">        auto carry = head;</span><br><span class="line">        //添加新的节点的时候，就连好两条线</span><br><span class="line">        while(carry != nullptr)&#123;</span><br><span class="line">            // 先保存下一个节点</span><br><span class="line">            auto tmp = carry-&gt;next;</span><br><span class="line">            // next</span><br><span class="line">            carry-&gt;next = new Node(carry-&gt;val);</span><br><span class="line">            carry-&gt;next-&gt;next = tmp;</span><br><span class="line">            // random 这里不太好弄，得把 next 连好才行</span><br><span class="line">            carry = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        carry = head;</span><br><span class="line">        while(carry != nullptr)&#123;</span><br><span class="line">            auto tmp = carry-&gt;next;</span><br><span class="line">            // random，这里还要判断是否不为空</span><br><span class="line">            if(carry-&gt;random != nullptr) tmp-&gt;random = carry-&gt;random-&gt;next;</span><br><span class="line">            carry = tmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        // 拆分</span><br><span class="line">        carry = head;</span><br><span class="line">        auto nHead = carry-&gt;next;</span><br><span class="line">        auto cur = nHead;</span><br><span class="line">        while(carry != nullptr)&#123;</span><br><span class="line">            carry-&gt;next = cur-&gt;next;</span><br><span class="line">            // 这里也要判断是否不为空</span><br><span class="line">            if(cur-&gt;next != nullptr) cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">            carry = carry-&gt;next;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return nHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141_环形链表"></a>141_环形链表</h2><ul>
<li>哈希表、快慢指针</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool hasCycle(ListNode *head) &#123;</span><br><span class="line">        if(!head || !head-&gt;next) return false;</span><br><span class="line">        auto l = head, r = head-&gt;next;</span><br><span class="line">        while(r != nullptr)&#123;</span><br><span class="line">            l = l-&gt;next;</span><br><span class="line">            r = r-&gt;next;</span><br><span class="line">            if(!r)</span><br><span class="line">                return false;</span><br><span class="line">            r = r-&gt;next;</span><br><span class="line">            if(l == r)</span><br><span class="line">                return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142_环形链表_II"></a>142_环形链表_II</h2><ul>
<li>先判断有没有环？</li>
<li>这题用了哈希表，第一个重复的就是入环的点，没有就<code>return nullptr;</code>；进阶要求是使用常熟空间，再想想其他方法</li>
<li>大佬写的，快慢指针在同一起跑线，有环会在某一点相遇，之后再来一个慢指针，与相遇的点齐头并进，一次一步，之后再相遇的点就是入环点</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">/*</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *detectCycle(ListNode *head) &#123;</span><br><span class="line">        if(!head) return nullptr;</span><br><span class="line">        unordered_set&lt;ListNode*&gt; set;</span><br><span class="line">        auto carry = head;</span><br><span class="line">        while(carry)&#123;</span><br><span class="line">            if(set.find(carry) == set.end())</span><br><span class="line">                set.insert(carry);</span><br><span class="line">            else</span><br><span class="line">                return carry;</span><br><span class="line">            carry = carry-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *detectCycle(ListNode *head) &#123;</span><br><span class="line">        if(!head) return nullptr;</span><br><span class="line">        auto l = head, r = l;</span><br><span class="line">        bool flag = false;</span><br><span class="line">        while(r != nullptr)&#123;</span><br><span class="line">            l = l-&gt;next;</span><br><span class="line">            r = r-&gt;next;</span><br><span class="line">            if(!r)</span><br><span class="line">                break;</span><br><span class="line">            r = r-&gt;next;</span><br><span class="line">            if(l == r)&#123;</span><br><span class="line">                flag = true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!flag)</span><br><span class="line">            return nullptr;</span><br><span class="line"></span><br><span class="line">        auto pos = head;</span><br><span class="line">        while(pos != l)&#123;</span><br><span class="line">            pos = pos-&gt;next;</span><br><span class="line">            l = l-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="143-重排链表"><a href="#143-重排链表" class="headerlink" title="143_重排链表"></a>143_重排链表</h2><ul>
<li>内存消耗可以，用时比较拉跨</li>
<li>题解用了线性表，用下标访问节点</li>
<li>还有种方法，找中点、反转后半段链表、再合并，反转链表在后边，先留着</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">/*class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void updateR(ListNode* &amp;r)&#123;</span><br><span class="line">        auto tmp = r;</span><br><span class="line">        while(r-&gt;next != nullptr &amp;&amp; r-&gt;next != tmp)&#123;</span><br><span class="line">            r = r-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void reorderList(ListNode* head) &#123;</span><br><span class="line">        if(!head || !head-&gt;next) return;</span><br><span class="line">        auto l = head, r = l;</span><br><span class="line">        updateR(r);</span><br><span class="line">        while(l != r)&#123;</span><br><span class="line">            auto tmp = l-&gt;next;</span><br><span class="line">            l-&gt;next = r;</span><br><span class="line">            r-&gt;next = tmp;</span><br><span class="line">            l = tmp;</span><br><span class="line">            updateR(r);</span><br><span class="line">        &#125;</span><br><span class="line">        l-&gt;next = nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void reorderList(ListNode *head) &#123;</span><br><span class="line">        if (head == nullptr) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;ListNode *&gt; vec;</span><br><span class="line">        ListNode *node = head;</span><br><span class="line">        while (node != nullptr) &#123;</span><br><span class="line">            vec.emplace_back(node);</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        int i = 0, j = vec.size() - 1;</span><br><span class="line">        while (i &lt; j) &#123;</span><br><span class="line">            vec[i]-&gt;next = vec[j];</span><br><span class="line">            i++;</span><br><span class="line">            if (i == j) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            vec[j]-&gt;next = vec[i];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        vec[i]-&gt;next = nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="146-LRU-缓存机制"><a href="#146-LRU-缓存机制" class="headerlink" title="146_LRU 缓存机制"></a>146_LRU 缓存机制</h2><ul>
<li>这题没想到用链表而且还是手写的…</li>
<li>倒是想到了队列，每次用到都放（移动）在前面或者后面，这样另一面就是没用到的了</li>
<li>双向链表在<code>new</code>的时候，也要<code>delete</code>；巧妙结合了<code>map</code>与<code>list</code>的特性，类似于<code>key---node(key, value)</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct DLinkedNode &#123;</span><br><span class="line">    int key, value;</span><br><span class="line">    DLinkedNode* prev;</span><br><span class="line">    DLinkedNode* next;</span><br><span class="line">    DLinkedNode(): key(0), value(0), prev(nullptr), next(nullptr) &#123;&#125;</span><br><span class="line">    DLinkedNode(int _key, int _value): key(_key), value(_value), prev(nullptr), next(nullptr) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class LRUCache &#123;</span><br><span class="line">private:</span><br><span class="line">    unordered_map&lt;int, DLinkedNode*&gt; cache;</span><br><span class="line">    DLinkedNode* head;</span><br><span class="line">    DLinkedNode* tail;</span><br><span class="line">    int size;</span><br><span class="line">    int capacity;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    LRUCache(int _capacity): capacity(_capacity), size(0) &#123;</span><br><span class="line">        // 使用伪头部和伪尾部节点</span><br><span class="line">        head = new DLinkedNode();</span><br><span class="line">        tail = new DLinkedNode();</span><br><span class="line">        head-&gt;next = tail;</span><br><span class="line">        tail-&gt;prev = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int get(int key) &#123;</span><br><span class="line">        if (!cache.count(key)) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果 key 存在，先通过哈希表定位，再移到头部</span><br><span class="line">        DLinkedNode* node = cache[key];</span><br><span class="line">        moveToHead(node);</span><br><span class="line">        return node-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void put(int key, int value) &#123;</span><br><span class="line">        if (!cache.count(key)) &#123;</span><br><span class="line">            // 如果 key 不存在，创建一个新的节点</span><br><span class="line">            DLinkedNode* node = new DLinkedNode(key, value);</span><br><span class="line">            // 添加进哈希表</span><br><span class="line">            cache[key] = node;</span><br><span class="line">            // 添加至双向链表的头部</span><br><span class="line">            addToHead(node);</span><br><span class="line">            ++size;</span><br><span class="line">            if (size &gt; capacity) &#123;</span><br><span class="line">                // 如果超出容量，删除双向链表的尾部节点</span><br><span class="line">                DLinkedNode* removed = removeTail();</span><br><span class="line">                // 删除哈希表中对应的项</span><br><span class="line">                cache.erase(removed-&gt;key);</span><br><span class="line">                // 防止内存泄漏</span><br><span class="line">                delete removed;</span><br><span class="line">                --size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部</span><br><span class="line">            DLinkedNode* node = cache[key];</span><br><span class="line">            node-&gt;value = value;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void addToHead(DLinkedNode* node) &#123;</span><br><span class="line">        node-&gt;prev = head;</span><br><span class="line">        node-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;next-&gt;prev = node;</span><br><span class="line">        head-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void removeNode(DLinkedNode* node) &#123;</span><br><span class="line">        node-&gt;prev-&gt;next = node-&gt;next;  //双向链表的删除节点真是秒啊</span><br><span class="line">        node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void moveToHead(DLinkedNode* node) &#123;</span><br><span class="line">        removeNode(node);   //调用删除和增加节点函数</span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DLinkedNode* removeTail() &#123;</span><br><span class="line">        DLinkedNode* node = tail-&gt;prev;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>2021.10.31 开始二刷的第二天<ul>
<li>想了半天，一直在 <code>unordered_map</code> 与 <code>queue</code> 死磕</li>
<li>看到双向链表，愣了一下，不知道怎么处理，看了题解才知道<ul>
<li>靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的。</li>
<li>插入节点、删除节点！！！</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="147-对链表进行插入排序"><a href="#147-对链表进行插入排序" class="headerlink" title="147_对链表进行插入排序"></a>147_对链表进行插入排序</h2><ul>
<li>感觉不是很难</li>
<li>有了上一题的思路，这题用了伪头节点，需要注意的是，最后的<code>head</code>已不是输出的答案，而是伪头节点的<code>next</code>！！</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* insertionSortList(ListNode* head) &#123;</span><br><span class="line">        auto h = new ListNode();</span><br><span class="line">        h-&gt;next = head;</span><br><span class="line">        auto pre = h, carry = head;</span><br><span class="line">        while(carry != nullptr)&#123;</span><br><span class="line">            carry = carry-&gt;next;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">            //cout &lt;&lt; pre-&gt;val &lt;&lt; &quot; -&gt; &quot; &lt;&lt; carry-&gt;val &lt;&lt; endl;</span><br><span class="line">            while(carry != nullptr &amp;&amp; carry-&gt;val &lt; pre-&gt;val)&#123;</span><br><span class="line">                pre-&gt;next = carry-&gt;next;</span><br><span class="line">                auto tmp = h;</span><br><span class="line">                while(tmp-&gt;next-&gt;val &lt; carry-&gt;val)</span><br><span class="line">                    tmp = tmp-&gt;next;</span><br><span class="line">                //cout &lt;&lt; &quot;tmp = &quot; &lt;&lt; tmp-&gt;val &lt;&lt; endl;</span><br><span class="line">                carry-&gt;next = tmp-&gt;next;</span><br><span class="line">                tmp-&gt;next = carry;</span><br><span class="line">                carry = pre-&gt;next;</span><br><span class="line">                /*if(carry)</span><br><span class="line">                    cout &lt;&lt; &quot;pre = &quot; &lt;&lt; pre-&gt;val &lt;&lt; &quot; carry = &quot; &lt;&lt; carry-&gt;val &lt;&lt; endl;*/</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head = h-&gt;next;</span><br><span class="line">        delete h;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148_排序链表"></a>148_排序链表</h2><ul>
<li>这题可以直接用上一题的解法…</li>
<li>排序算法要多看看，这题用上一题的方法，执行用时很高，想想其他的办法</li>
<li>用一个数组来维护所有节点的值，居然会快很多…</li>
<li>时间复杂度是 O(n \log n)O(nlogn) 的排序算法包括归并排序、堆排序和快速排序（快速排序的最差时间复杂度是 O(n^2)O(n2)），其中最适合链表的排序算法是归并排序。</li>
<li>合并两条链表那题又刷了一遍，还是错了两次…</li>
<li>后来发现是中点那个函数出了问题，对于三个节点的链表，会无限循环；嗯，两个节点的链表也会…</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//自顶向下归并排序</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* midpoint(ListNode* head)&#123;</span><br><span class="line">        auto mid = head, cur = mid;</span><br><span class="line">        while (cur != nullptr)&#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            if(!cur)</span><br><span class="line">                break;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            if(!cur)</span><br><span class="line">                break;</span><br><span class="line">            mid = mid-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return mid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;</span><br><span class="line">        if(!l1) return l2;</span><br><span class="line">        if(!l2) return l1;</span><br><span class="line"></span><br><span class="line">        auto carry1 = l1, carry2 = l2;</span><br><span class="line">        while(carry1 != nullptr &amp;&amp; carry2 != nullptr)&#123;</span><br><span class="line">            ListNode* prev = nullptr;</span><br><span class="line">            while (carry1 != nullptr &amp;&amp; carry1-&gt;val &lt;= carry2-&gt;val)&#123;</span><br><span class="line">                prev = carry1;</span><br><span class="line">                carry1 = carry1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            if(prev != nullptr)</span><br><span class="line">                prev-&gt;next = carry2;</span><br><span class="line">            prev = nullptr;</span><br><span class="line">            while (carry1 != nullptr &amp;&amp; carry2 != nullptr &amp;&amp; carry2-&gt;val &lt;= carry1-&gt;val)&#123;</span><br><span class="line">                prev = carry2;</span><br><span class="line">                carry2 = carry2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            if(prev != nullptr)</span><br><span class="line">                prev-&gt;next = carry1;</span><br><span class="line">        &#125;</span><br><span class="line">        return l1-&gt;val &lt;= l2-&gt;val ? l1 : l2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode* sortList(ListNode* head) &#123;</span><br><span class="line">        if(!head || !head-&gt;next) return head;</span><br><span class="line">        //找中点</span><br><span class="line">        auto mid = midpoint(head);</span><br><span class="line">        //拆分链表</span><br><span class="line">        auto tmp = mid-&gt;next;</span><br><span class="line">        mid-&gt;next = nullptr;</span><br><span class="line"></span><br><span class="line">        auto l = head;</span><br><span class="line">        while (l != nullptr)&#123;</span><br><span class="line">            cout &lt;&lt; l-&gt;val &lt;&lt; &quot;-&gt;&quot;;</span><br><span class="line">            l = l-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        l = tmp;</span><br><span class="line">        while (l != nullptr)&#123;</span><br><span class="line">            cout &lt;&lt; l-&gt;val &lt;&lt; &quot;-&gt;&quot;;</span><br><span class="line">            l = l-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        //对两条链表分别排序</span><br><span class="line">        auto h1 = sortList(head);</span><br><span class="line">        auto h2 = sortList(tmp);</span><br><span class="line">        //合并两个有序链表</span><br><span class="line">        auto res = mergeTwoLists(h1, h2);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160_相交链表"></a>160_相交链表</h2><ul>
<li>题解很妙，创建两个指针 pA 和 pB，分别初始化为链表 A 和 B 的头结点。然后让它们向后逐结点遍历。当 pA 到达链表的尾部时，将它重定位到链表 B 的头结点; 类似的，当 pB 到达链表的尾部时，将它重定位到链表 A 的头结点。</li>
<li>这样就相当于，总长度是一样的，而终点就是相交的的点，而且只一次遍历即可</li>
<li>我之前是用了环形链表找第一个入环点的思路</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /*ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;</span><br><span class="line">        if(!headA || !headB) return nullptr;</span><br><span class="line">        auto tail = headA;</span><br><span class="line">        while(tail-&gt;next != nullptr)&#123;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tail-&gt;next = headA;</span><br><span class="line">        auto l = headB, r = l;</span><br><span class="line">        while(r != nullptr)&#123;</span><br><span class="line">            r = r-&gt;next;</span><br><span class="line">            if(!r)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            r = r-&gt;next;</span><br><span class="line">            l = l-&gt;next;</span><br><span class="line">            if(l == r)</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!r)&#123;</span><br><span class="line">            tail-&gt;next = nullptr;</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        auto carry = headB;</span><br><span class="line">        while(carry != r)&#123;</span><br><span class="line">            carry = carry-&gt;next;</span><br><span class="line">            r = r-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tail-&gt;next = nullptr;</span><br><span class="line">        return carry;</span><br><span class="line"></span><br><span class="line">    &#125;*/</span><br><span class="line">    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;</span><br><span class="line">        auto carry1 = headA, carry2 = headB;</span><br><span class="line">        while (carry1 != carry2)&#123;</span><br><span class="line">            if(!carry1)</span><br><span class="line">                carry1 = headB;</span><br><span class="line">            else</span><br><span class="line">                carry1 = carry1-&gt;next;</span><br><span class="line">            if(!carry2)</span><br><span class="line">                carry2 = headA;</span><br><span class="line">            else</span><br><span class="line">                carry2 = carry2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return carry1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二刷-5"><a href="#二刷-5" class="headerlink" title="二刷"></a>二刷</h3><ul>
<li>这题要多留个心眼——二刷；看下双指针是怎么证明的</li>
<li>关键点在于不相交的情况下，第二次遍历时会同时变空，因为总长度是一样的；所以循环里只需判断是否会同时变空，若是；直接返回空！</li>
<li>还是题解写的更优雅点</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;</span><br><span class="line">        if (headA == nullptr || headB == nullptr) &#123;</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *pA = headA, *pB = headB;</span><br><span class="line">        while (pA != pB) &#123;</span><br><span class="line">            pA = pA == nullptr ? headB : pA-&gt;next;</span><br><span class="line">            pB = pB == nullptr ? headA : pB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return pA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//自己手撕</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;</span><br><span class="line">        //复习下</span><br><span class="line">        auto a = headA;</span><br><span class="line">        auto b = headB;</span><br><span class="line">        while(a != b)&#123;</span><br><span class="line">            if(!a-&gt;next &amp;&amp; !b-&gt;next)&#123;</span><br><span class="line">                return nullptr;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if(!a-&gt;next)&#123;</span><br><span class="line">                a = headB;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                a = a-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if(!b-&gt;next)&#123;</span><br><span class="line">                b = headA;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                b = b-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202_快乐数"></a>202_快乐数</h2><ul>
<li>这题放在链表是有原因的，但是我没想到，，只用了数学的方法…</li>
<li>反了，数学的方法需要找规律，我用的就是哈希表记录重复的数字</li>
<li>快慢指针自然也就没想到</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;unordered_set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    //n为正整数</span><br><span class="line">    bool isHappy(int n) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;n = &quot; &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">//        if(n % 10 == 0)</span><br><span class="line">//            return true;</span><br><span class="line"></span><br><span class="line">        if(record.find(n) != record.end())</span><br><span class="line">            return false;</span><br><span class="line">        else</span><br><span class="line">            record.insert(n);</span><br><span class="line"></span><br><span class="line">        int ans = 0;</span><br><span class="line">        while (n &gt; 0)&#123;</span><br><span class="line">            int tmp = n % 10;</span><br><span class="line">            ans += (tmp * tmp);</span><br><span class="line">            n -= tmp;</span><br><span class="line">            n /= 10;</span><br><span class="line">        &#125;</span><br><span class="line">        if(ans == 1)</span><br><span class="line">            return true;</span><br><span class="line">        return isHappy(ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    unordered_set&lt;int&gt; record;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    Solution solution;</span><br><span class="line">    int n = 5;</span><br><span class="line">    auto res = solution.isHappy(n);</span><br><span class="line">    cout &lt;&lt; &quot;res = &quot; &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203_移除链表元素"></a>203_移除链表元素</h2><ul>
<li>这题比较简单，看看题解有无好的算法</li>
<li>哨兵的思想还是可以的，之前几题都接触过，在头部插一个为头节点</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* removeElements(ListNode* head, int val) &#123;</span><br><span class="line">        if(!head) return nullptr;</span><br><span class="line">        auto* h = new ListNode();</span><br><span class="line">        h-&gt;next = head;</span><br><span class="line">        auto prev = h, curr = head;</span><br><span class="line">        while (curr != nullptr)&#123;</span><br><span class="line">            if(curr-&gt;val == val)&#123;</span><br><span class="line">                prev-&gt;next = curr-&gt;next;</span><br><span class="line">            &#125; else</span><br><span class="line">                prev = prev-&gt;next;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return h-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二刷-6"><a href="#二刷-6" class="headerlink" title="二刷"></a>二刷</h3><ul>
<li>二刷留念</li>
<li>和第一次写的基本差不多，哈哈哈哈</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* removeElements(ListNode* head, int val) &#123;</span><br><span class="line">        //二刷</span><br><span class="line">        //设置个虚拟头节点</span><br><span class="line">        ListNode* h = new ListNode();</span><br><span class="line">        h-&gt;next = head;</span><br><span class="line"></span><br><span class="line">        auto pre = h;</span><br><span class="line">        auto cur = head;</span><br><span class="line">        while(cur != nullptr)&#123;</span><br><span class="line">            if(cur-&gt;val == val)&#123;</span><br><span class="line">                pre-&gt;next = cur-&gt;next;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                pre = cur;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return h-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206_反转链表"></a>206_反转链表</h2><ul>
<li>迭代本能的想到了栈或者队列，但是这题全然不需要，只是每次迭代的时候要保存下一个节点</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">// 栈</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">        if(!head)&#123;</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* nhead = new ListNode();</span><br><span class="line">        auto carry = nhead;</span><br><span class="line"></span><br><span class="line">        stack&lt;ListNode*&gt; stk;</span><br><span class="line">        stk.push(head);</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        while(!stk.empty())&#123;</span><br><span class="line">            while(head != nullptr)&#123;</span><br><span class="line">                stk.push(head);</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            auto tmp = stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">            carry-&gt;next = new ListNode(tmp-&gt;val);</span><br><span class="line">            carry = carry-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return nhead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution_ &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">        ListNode* prev = nullptr;</span><br><span class="line">        auto curr = head;</span><br><span class="line">        while(curr != nullptr)&#123;</span><br><span class="line">            auto tmp = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        return prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234_回文链表"></a>234_回文链表</h2><ul>
<li>这还真不好判断</li>
<li>这个没有重载<code>==</code>，不好比较两个链表是否相等</li>
<li>先计算出总长度<code>len</code>，然后从中间一直到最后将链表反转，然后两个头依次比较是否相等；看看题解是怎么写的</li>
<li>三种方法；第一种：将数值依次保存在数组中，然后用双指针进行比较，这是最简单的方法；第二种：递归没怎么看懂，先用全局变量保存下前节点（相对与回文链表来说），递归会递归到最后一个节点，然后进行比较，问题在于怎么在回溯的同时，全局变量会….嗷！直接<code>next</code>即可，手撕下！第三种：反转的时候，可以用快慢指针，然后可以直接反转前半段链表！之后再依次进行比较</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//自己手撕反转</span><br><span class="line">class Solution1 &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isPalindrome(ListNode* head) &#123;</span><br><span class="line">        if(!head)</span><br><span class="line">            return true;</span><br><span class="line">        //反转下链表？那就先保存下(深拷贝)原链表；不，这样，从中间开始反转，先算出长度</span><br><span class="line">        int len = 0;</span><br><span class="line">        auto carry = head;</span><br><span class="line">        while (carry != nullptr)&#123;</span><br><span class="line">            ++len;</span><br><span class="line">            carry = carry-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(len == 1)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //找到中间点；长度有奇偶性，应该是没关系的</span><br><span class="line">        int n = len / 2;</span><br><span class="line">        carry = head;</span><br><span class="line">        while (n &gt; 1)&#123;</span><br><span class="line">            carry = carry-&gt;next;</span><br><span class="line">            --n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //现在carry是第一段链表的末尾、中间点的前一个</span><br><span class="line">        auto h = carry-&gt;next;</span><br><span class="line">        if(len % 2 == 0)</span><br><span class="line">            carry-&gt;next = nullptr;</span><br><span class="line">        auto node = h-&gt;next;</span><br><span class="line">        h-&gt;next = nullptr;</span><br><span class="line">        while(node != nullptr)&#123;</span><br><span class="line">            auto tmp = node-&gt;next;</span><br><span class="line">            node-&gt;next = h;</span><br><span class="line">            h = node;</span><br><span class="line">            node = tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int i = 0;</span><br><span class="line">        while (i &lt; (len / 2))&#123;</span><br><span class="line">            if(h-&gt;val != head-&gt;val)</span><br><span class="line">                return false;</span><br><span class="line">            h = h-&gt;next;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//递归</span><br><span class="line">class Solution2 &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* pre = nullptr;</span><br><span class="line">    bool ans = true;</span><br><span class="line">    bool isPalindrome(ListNode* head) &#123;</span><br><span class="line">        if(!head)</span><br><span class="line">            return true;</span><br><span class="line"></span><br><span class="line">        pre = head;</span><br><span class="line">        dfs(head);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void dfs(ListNode* head)&#123;</span><br><span class="line">        if(!head || !ans)</span><br><span class="line">            return;</span><br><span class="line">        dfs(head-&gt;next);</span><br><span class="line">        if(pre-&gt;val != head-&gt;val)</span><br><span class="line">            ans = false;</span><br><span class="line">        pre = pre-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//题解递归</span><br><span class="line">class Solution3 &#123;</span><br><span class="line">    ListNode* frontPointer;</span><br><span class="line">public:</span><br><span class="line">    bool recursivelyCheck(ListNode* currentNode) &#123;</span><br><span class="line">        if (currentNode != nullptr) &#123;</span><br><span class="line">            if (!recursivelyCheck(currentNode-&gt;next)) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            //这里比较之前，要先递归到最后一个节点；</span><br><span class="line">            if (currentNode-&gt;val != frontPointer-&gt;val) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            frontPointer = frontPointer-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool isPalindrome(ListNode* head) &#123;</span><br><span class="line">        frontPointer = head;</span><br><span class="line">        return recursivelyCheck(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//快慢指针，前半段链表反转</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isPalindrome(ListNode* head) &#123;</span><br><span class="line">        if(!head || !head-&gt;next)</span><br><span class="line">            return true;</span><br><span class="line"></span><br><span class="line">        auto slow = head;</span><br><span class="line">        auto fast = head;</span><br><span class="line">        auto pre = head;</span><br><span class="line">        while (fast-&gt;next != nullptr)&#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">            //反转</span><br><span class="line">            auto tmp = slow-&gt;next;</span><br><span class="line">            if(slow == head)</span><br><span class="line">                head-&gt;next = nullptr;</span><br><span class="line">            else</span><br><span class="line">                slow-&gt;next = pre;</span><br><span class="line">            pre = slow;</span><br><span class="line">            slow = tmp;</span><br><span class="line"></span><br><span class="line">            if(!fast)</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(fast != nullptr)&#123;</span><br><span class="line">            //奇数</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        while (pre != nullptr)&#123;</span><br><span class="line">            if(pre-&gt;val != slow-&gt;val)</span><br><span class="line">                return false;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="237-删除链表中的节点"><a href="#237-删除链表中的节点" class="headerlink" title="237_删除链表中的节点"></a>237_删除链表中的节点</h2><ul>
<li>一开始没读懂题目，直接蒙了</li>
<li>还有指针作为参数是，会生成一个临时的指针，具有相同的地址，所指的对象相同</li>
<li>优化之后，发现跟题解一样</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//手撕原版</span><br><span class="line">class Solution1 &#123;</span><br><span class="line">public:</span><br><span class="line">    void deleteNode(ListNode* node) &#123;</span><br><span class="line">        //读懂了题目，思路就是：将node的值变为下一个节点的值，并断开连接，若还有下一个节点，那就依次添加新的相同值的节点</span><br><span class="line">        auto carry = node-&gt;next;</span><br><span class="line">        node-&gt;val = carry-&gt;val;</span><br><span class="line">        node-&gt;next = nullptr;</span><br><span class="line">        carry = carry-&gt;next;</span><br><span class="line">        while (carry != nullptr)&#123;</span><br><span class="line">            node-&gt;next = new ListNode(carry-&gt;val);</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">            carry = carry-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//手撕版本2.0；看了时间消耗排名，就知道我写的有点烦了，再优化下！</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void deleteNode(ListNode* node) &#123;</span><br><span class="line">        //先改值，再改变指针的指向</span><br><span class="line">        node-&gt;val = node-&gt;next-&gt;val;</span><br><span class="line">        node-&gt;next = node-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><ul>
<li><strong><em><code>string</code>是一种内置类型，定义的对象可以直接用<code>cout &lt;&lt; s</code>来输出！</em></strong></li>
<li><code>append(): Appends characters to the end</code></li>
<li><code>push_back(): Appends a character to the end</code></li>
<li><code>s.size()</code>类型比<code>int</code>大</li>
</ul>
<h2 id="3-最长字串"><a href="#3-最长字串" class="headerlink" title="3_最长字串"></a>3_最长字串</h2><ul>
<li>输入    <code>&quot;pwwkew&quot;</code></li>
<li>输出    <code>3</code></li>
<li>注意 <code>pwke</code> 不是子串<br><img src="/pictrues/3.jpg" alt="思路" title="思路"></li>
</ul>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using  namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLongestSubstring(string s) &#123;</span><br><span class="line">        string set;</span><br><span class="line">        int i = 0, j = 0, len = 0;</span><br><span class="line">        if(s.size() == 0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        for(j; j &lt; s.size(); j++)&#123;</span><br><span class="line">            if(set.find(s[j]) == -1)&#123;</span><br><span class="line">                set.push_back(s[j]);</span><br><span class="line">                int len1 = set.size();  //unsigned 型（unsignedint 或 unsigned long)</span><br><span class="line">                len = max(len, len1);	// len = max&lt;int&gt;(len, set.size());</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                while(set.find(s[j]) != -1)&#123; // find返回值是元素对应的位置</span><br><span class="line">                    set.erase(0, 1);</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                set.push_back(s[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string s = &quot;abcabcdbb&quot;;</span><br><span class="line">    Solution sl;</span><br><span class="line">    int len = sl.lengthOfLongestSubstring(s);</span><br><span class="line">    cout &lt;&lt; len &lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>2021.11.1 二刷<ul>
<li>这次没有用字符串，而是用哈希表，不过速度变慢了好像！</li>
</ul>
</li>
</ul>
<h2 id="5-最长回文字串"><a href="#5-最长回文字串" class="headerlink" title="5_最长回文字串"></a>5_最长回文字串</h2><ul>
<li>输入<code>&quot;babad&quot;</code>； 输出<code>&quot;bab&quot;</code></li>
<li>输入<code>&quot;cbbd&quot;</code>； 输出<code>&quot;bb&quot;</code></li>
<li>思路<br><img src="/pictrues/5.jpg" alt="思路" title="思路"></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using  namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int start = 0, l = 1;</span><br><span class="line">    string sl;</span><br><span class="line">    void search(int left, int right, string s)&#123;</span><br><span class="line">        while(left &gt;= 0 &amp;&amp; right &lt; s.size() &amp;&amp; s[left] == s[right])&#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(right - left - 1 &gt; l)&#123;</span><br><span class="line">            l = right - left - 1;</span><br><span class="line">            start = left + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    string longestPalindrome(string s) &#123;</span><br><span class="line">        for(int i = 0; i &lt; s.size(); i++)&#123;</span><br><span class="line">            search(i-1, i+1, s);</span><br><span class="line">            search(i+0, i+1, s);</span><br><span class="line">        &#125;</span><br><span class="line">        return sl.append(s, start, l);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string s = &quot;babad&quot;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    string l = solution.longestPalindrome(s);</span><br><span class="line">    for(int i = 0; i &lt; l.size(); i++)&#123;</span><br><span class="line">        cout &lt;&lt; l[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-Z形变换"><a href="#6-Z形变换" class="headerlink" title="6_Z形变换"></a>6_Z形变换</h2><ul>
<li>输入<code>&quot;LEETCODEISHIRING&quot;</code><br><img src="/pictrues/Z%E5%BD%A2.png" alt="Z形" title="Z形"></li>
<li>输出<code>&quot;LCIRETOESIIGEDHN&quot;</code>，行数3<br><img src="/pictrues/Z%E5%BD%A21.png" alt="Z形" title="Z形"></li>
<li>输出<code>&quot;LDREOEIIECIHNTSG&quot;</code>，行数4</li>
<li>思路<br><img src="/pictrues/Z.jpg" alt="思路" title="思路"></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string convert(string s, int numRows) &#123;</span><br><span class="line">        if(numRows == 1)&#123;return s;&#125;</span><br><span class="line">        string l;   // 存放输出</span><br><span class="line">        int numColumns = 1;</span><br><span class="line">        bool flag = true;   // 方向</span><br><span class="line">        vector&lt;vector&lt;char&gt;&gt; a(numRows, vector&lt;char&gt;(numColumns));</span><br><span class="line">        int n = 0, len = 0;</span><br><span class="line">        while (len &lt; s.size())&#123;</span><br><span class="line">            if(flag)&#123;</span><br><span class="line">                a[n].push_back(s[len]);</span><br><span class="line">                len ++;</span><br><span class="line">                n ++;</span><br><span class="line">                if(n &gt;= numRows)&#123;n -= 2; flag = false;&#125;</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                a[n].push_back(s[len]);</span><br><span class="line">                len ++;</span><br><span class="line">                n --;</span><br><span class="line">                if(n &lt; 0)&#123;n += 2; flag = true;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; numRows; i++)&#123;</span><br><span class="line">            for(int j = 1; j &lt; a[i].size(); j++)&#123;</span><br><span class="line">                l.push_back(a[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return l ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string s = &quot;LEETCODEISHIRING&quot;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    string l = solution.convert(s, 3);</span><br><span class="line">    for(int i = 0; i &lt; l.size(); i++)&#123;</span><br><span class="line">        cout &lt;&lt; l[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-字符串转整数"><a href="#8-字符串转整数" class="headerlink" title="8_字符串转整数"></a>8_字符串转整数</h2><ul>
<li>根据要求，维护一个指针，遍历，只有三种情况<code>“+···”、“-···”、“···”</code>才可继续下一步</li>
<li><code>···</code>表示数字，之后再化成整形，注意<font color="#FF0000">int</font>是否溢出溢出</li>
<li><code>s[i] - &#39;0&#39; &gt; 7</code>一个是字符类型，ASCALL码，一个是int型</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;cctype&gt;   // ctype.h</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int myAtoi(string s)&#123;</span><br><span class="line">        int i = 0, res = 0;</span><br><span class="line">        int flag = 1;</span><br><span class="line">        while (s[i] == &apos; &apos;)&#123;i++;&#125;</span><br><span class="line">        if(s[i] == &apos;-&apos;)&#123;flag = -1;&#125;</span><br><span class="line">        if(s[i] == &apos;-&apos; || s[i] == &apos;+&apos;)&#123;i++;&#125;</span><br><span class="line">        while (i &lt; s.size() &amp;&amp; isdigit(s[i]))&#123;</span><br><span class="line">            if(res &gt; INT32_MAX / 10 || (res == INT32_MAX / 10 &amp;&amp; (s[i] - &apos;0&apos;) &gt; 7))&#123;</span><br><span class="line">                return flag &gt; 0 ? INT32_MAX : INT32_MIN;</span><br><span class="line">            &#125;</span><br><span class="line">            res = 10 * res + (int)(s[i] - &apos;0&apos;);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        return flag &gt; 0 ? res : -res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string s = &quot;2147483646&quot;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.myAtoi(s) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-正则表达式匹配"><a href="#10-正则表达式匹配" class="headerlink" title="10_正则表达式匹配"></a>10_正则表达式匹配</h2><h3 id="递归-5"><a href="#递归-5" class="headerlink" title="递归"></a>递归</h3><ul>
<li>从前有座山，山里有个庙，庙里有个老和尚在给小和尚讲故事，讲的什么呀，讲的是从前有座山，山里有个庙······</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isMatch(string s, string p) &#123;</span><br><span class="line">        if(p.empty()) return s.empty();</span><br><span class="line"></span><br><span class="line">        bool firstmatch = !s.empty() &amp;&amp; (s[0] == p[0] || p[0] == &apos;.&apos;);</span><br><span class="line"></span><br><span class="line">        if(p.size() &gt;= 2 &amp;&amp; p[1] == &apos;*&apos;)&#123;</span><br><span class="line">            return isMatch(s, p.substr(2, p.size() - 2)) || (firstmatch &amp;&amp; isMatch(s.substr(1, s.size() - 1), p));</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">            return firstmatch &amp;&amp; isMatch(s.substr(1, s.size() - 1), p.substr(1, p.size() - 1));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string s = &quot;aa&quot;, p = &quot;*&quot;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    std::cout &lt;&lt; solution.isMatch(s, p) &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="12-整数转罗马数字"><a href="#12-整数转罗马数字" class="headerlink" title="12_整数转罗马数字"></a>12_整数转罗马数字</h2><ul>
<li>输入<code>3</code>，输出<code>III</code>、输入<code>9</code>，输出<code>IX</code></li>
<li>以下整数与罗马数字两两对应</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1&#125;;</span><br><span class="line">&#123;&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="贪心算法-1"><a href="#贪心算法-1" class="headerlink" title="贪心算法"></a>贪心算法</h3><ul>
<li>尽可能地找最大值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string intToRoman(int num) &#123;</span><br><span class="line">        int val[] = &#123;1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1&#125;;</span><br><span class="line">        string sym[] = &#123;&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;&#125;;</span><br><span class="line">        string s;</span><br><span class="line">        for(int i = 0; i &lt; 13; i++)&#123;</span><br><span class="line">            while (num &gt;= val[i])&#123;   // 不用if，是因为38里有3个10，而不是减一次就去减9</span><br><span class="line">                num -= val[i];</span><br><span class="line">                s.append(sym[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    Solution solution;</span><br><span class="line">    int x = 671;</span><br><span class="line">    std::cout &lt;&lt; solution.intToRoman(x) &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13_罗马数字转整数"></a>13_罗马数字转整数</h2><ul>
<li>只要这个<code>s[i]</code>字符对应的数字比<code>s[i+1]</code>小，就减去<code>s[i]</code>字符对应的数字</li>
<li>照这个思路最后一位字符对应的数字一定是加</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int romanToInt(string s) &#123;</span><br><span class="line">        int val[] = &#123;1000, 500, 100, 50, 10, 5, 1&#125;;</span><br><span class="line">        string sym = &quot;MDCLXVI&quot;;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for(int i = 0; i &lt; s.size(); i++)&#123;</span><br><span class="line">            int j = sym.find(s[i]);</span><br><span class="line">            if(i &lt; s.size() - 1 &amp;&amp; j &gt; sym.find(s[i + 1]))&#123;</span><br><span class="line">                sum -= val[j];</span><br><span class="line">            &#125; else sum += val[j];</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    string s = &quot;LVIII&quot;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    std::cout &lt;&lt; solution.romanToInt(s) &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14_最长公共前缀"></a>14_最长公共前缀</h2><ul>
<li>输入：<code>[&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</code></li>
<li>输出：<code>&quot;fl&quot;</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        string s;</span><br><span class="line">        int len = 0;	// 计算出最短的字符长度</span><br><span class="line">        for(auto &amp; str : strs)&#123;</span><br><span class="line">            len = max&lt;int&gt;(len, str.size());</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; len; i++)&#123;</span><br><span class="line">            int j = 0;</span><br><span class="line">            while (j &lt; strs.size() - 1 &amp;&amp; strs[j][i] == strs[j+1][i])&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            if(j == strs.size() - 1)&#123;</span><br><span class="line">                s.push_back(strs[0][i]);</span><br><span class="line">            &#125; else break;</span><br><span class="line">        &#125;</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;string&gt; strs = &#123;&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    int i = 0;</span><br><span class="line">    string s = solution.longestCommonPrefix(strs);</span><br><span class="line">    while (i &lt; s.size())&#123;</span><br><span class="line">        std::cout &lt;&lt; s[i];</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20_有效的括号"></a>20_有效的括号</h2><h3 id="递归-6"><a href="#递归-6" class="headerlink" title="递归"></a>递归</h3><ul>
<li>复杂度比较高</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isValid(string s) &#123;</span><br><span class="line">        int len = s.size();</span><br><span class="line">        cout &lt;&lt; &quot;len = &quot; &lt;&lt; len &lt;&lt; endl;</span><br><span class="line">        if(len % 2 == 1)&#123;return false;&#125;</span><br><span class="line">        if(len == 2 &amp;&amp; ((s[0] == &apos;(&apos; &amp;&amp; s[1] == &apos;)&apos;) || (s[0] == &apos;[&apos; &amp;&amp; s[1] == &apos;]&apos;) || (s[0] == &apos;&#123;&apos; &amp;&amp; s[1] == &apos;&#125;&apos;)))&#123;return true;&#125;</span><br><span class="line">        bool flag = false;</span><br><span class="line">        string l;</span><br><span class="line">        for(int i = 0; i &lt; len - 1; i++)&#123;</span><br><span class="line">            if((s[i] == &apos;(&apos; &amp;&amp; s[i + 1] == &apos;)&apos;) || (s[i] == &apos;[&apos; &amp;&amp; s[i + 1] == &apos;]&apos;) || (s[i] == &apos;&#123;&apos; &amp;&amp; s[i + 1] == &apos;&#125;&apos;))&#123;</span><br><span class="line">                flag = true;</span><br><span class="line">                if(i == 0)&#123;</span><br><span class="line">                    l = s.substr(2, len - 2);</span><br><span class="line">                &#125; else&#123;</span><br><span class="line">                    l = s.substr(0, i) + s.substr(i + 2, len - i - 1);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(flag)&#123;</span><br><span class="line">            return isValid(l);</span><br><span class="line">        &#125; else return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    Solution solution;</span><br><span class="line">    string s = &quot;(([])&#123;&#125;)&quot;;</span><br><span class="line">    std::cout &lt;&lt; solution.isValid(s) &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="栈-1"><a href="#栈-1" class="headerlink" title="栈"></a>栈</h3><ul>
<li><code>HashMap</code>头文件<code>&lt;unordered_map&gt;</code>，栈头文件<code>&lt;stack&gt;</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isValid(string s) &#123;</span><br><span class="line">        int n = s.size();</span><br><span class="line">        if (n % 2 == 1) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        unordered_map&lt;char, char&gt; pairs = &#123;</span><br><span class="line">                &#123;&apos;)&apos;, &apos;(&apos;&#125;,</span><br><span class="line">                &#123;&apos;]&apos;, &apos;[&apos;&#125;,</span><br><span class="line">                &#123;&apos;&#125;&apos;, &apos;&#123;&apos;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        stack&lt;char&gt; stk;</span><br><span class="line">        for (char ch: s) &#123;</span><br><span class="line">            if (pairs.count(ch)) &#123;  // 先找右括号</span><br><span class="line">                if (stk.empty() || stk.top() != pairs[ch]) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">                stk.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;  // 左括号依次弹入堆栈</span><br><span class="line">                stk.push(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stk.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    Solution solution;</span><br><span class="line">    string s = &quot;(([])&#123;&#125;)&quot;;</span><br><span class="line">    std::cout &lt;&lt; solution.isValid(s) &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="28-实现strStr"><a href="#28-实现strStr" class="headerlink" title="28_实现strStr()"></a>28_实现strStr()</h2><ul>
<li>字符串比较，可以直接用<code>string</code>里的<code>compare()</code>函数，也可以用<code>substr()</code>函数</li>
<li>不用再写一个一个元素进行比较的算法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int strStr(string haystack, string needle) &#123;</span><br><span class="line">        int l = needle.size(), n = haystack.size();</span><br><span class="line">        for(int start = 0; start &lt; n - l + 1; start++)&#123;</span><br><span class="line">            if(haystack.compare(start, l, needle) == 0)&#123;</span><br><span class="line">                return start;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	int strStr_(string haystack, string needle) &#123;</span><br><span class="line">        if(needle.empty()) return 0;</span><br><span class="line">        int l = needle.size(), r = haystack.size();</span><br><span class="line">        if(r &lt; l) return -1;    //加上这句运行更快？？</span><br><span class="line">        for(int i = 0; i &lt; (r - l + 1); ++i)&#123;</span><br><span class="line">            //i &lt; (haystack.size() - l + 1)应该是string::size_type没有负数，类型不一样</span><br><span class="line">            //for循环是先进入再判断条件吗，不对一开始就为false，一次也不执行，那就是要加括号？？</span><br><span class="line">            //substr的长度是总长度</span><br><span class="line">            if(haystack.substr(i, l) == needle)</span><br><span class="line">                return i;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    string haystack = &quot;mississippi&quot;;</span><br><span class="line">    string needle = &quot;issipi&quot;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.strStr(haystack, needle);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="30-串联所有单词的字串"><a href="#30-串联所有单词的字串" class="headerlink" title="30_串联所有单词的字串"></a>30_串联所有单词的字串</h2><ul>
<li>这题应该另起山头-哈希表，或者二叉树什么的，比较字符串的时候没有用<code>substr</code>，而是用了<code>unordered_map</code>里的<code>count</code>，是否有字符串类型的<code>key</code></li>
<li><code>map</code>的<code>value</code>是单词对应的个数</li>
<li>另一个核心思路是滑动窗口：之前有个题目是一个字符进行比较，而现在是一个单词(的<font color="#FF0000">长度</font>)，为了方便比较，将<code>words</code>转换成哈希表<code>m1</code></li>
<li>对<code>s</code>起始<font color="#FF0000">一个单词长度</font>进行遍历，<code>left</code>、<code>right</code>分别是窗口的左右边，每次更新增加一个单词的长度<code>one_word</code>，<code>right</code>一直更新到<code>s</code>末尾</li>
<li><code>s</code>中从<code>i</code>开始的第一个单词<code>s_tmp</code>，如果<code>m1</code>有，则将其放入新建的哈希表<code>m2</code>，其键值每次都加一，可以直接写成<code>m2[s_tmp]++</code>，如果数量超过了原本的数量，从<code>left</code>开始删除单词并更新<code>left</code>，直到数量相等，之后判断<code>m2</code>单词总数量<font color="#FF0000"><code>count</code></font>是否等于题目单词的总个数，等于保存<code>left</code></li>
<li>如果<code>m1</code>没有，更新<code>m2</code>、<code>left</code>、<code>count</code></li>
<li>注意的是，如果单词长度是3，那么<code>i</code>只需遍历到<code>s[2]</code>即可，之后就重复了</li>
</ul>
<h3 id="滑动窗口-1"><a href="#滑动窗口-1" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    // 滑动窗口</span><br><span class="line">    vector&lt;int&gt; findSubstring(string s, vector&lt;string&gt;&amp; words) &#123;</span><br><span class="line">        if(words.empty() || words[0].empty())&#123;return &#123;0&#125;;&#125;</span><br><span class="line">        int one_word = words[0].size();</span><br><span class="line">        int nums_word = words.size();</span><br><span class="line">        int len = nums_word * one_word;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        unordered_map&lt;string, int&gt; m1;</span><br><span class="line">        for(const auto&amp; str : words)&#123;m1[str]++;&#125;</span><br><span class="line"></span><br><span class="line">        for(int i = 0; i &lt; one_word; i++)&#123;</span><br><span class="line">            int left = i, right = i, count = 0;</span><br><span class="line">            unordered_map&lt;string, int&gt; m2;</span><br><span class="line">            while (right &lt; s.size() &amp;&amp; left + len &lt;= s.size())&#123;</span><br><span class="line">                string s_tmp = s.substr(right, one_word);</span><br><span class="line">                right += one_word;</span><br><span class="line">                if(m1.count(s_tmp) &gt; 0)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    m2[s_tmp]++;</span><br><span class="line">                    while (m2[s_tmp] &gt; m1[s_tmp])&#123;</span><br><span class="line">                        string s_tmp_l = s.substr(left, one_word);</span><br><span class="line">                        m2[s_tmp_l]--;</span><br><span class="line">                        count--;</span><br><span class="line">                        left += one_word;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if(count == nums_word)&#123;</span><br><span class="line">                        res.push_back(left);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else&#123;</span><br><span class="line">                    left = right;</span><br><span class="line">                    m2.clear();</span><br><span class="line">                    count = 0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">//    string s = &quot;wordgoodgoodgoodbestword&quot;;</span><br><span class="line">//    vector&lt;string&gt; words = &#123;&quot;word&quot;,&quot;good&quot;,&quot;best&quot;,&quot;good&quot;&#125;;</span><br><span class="line">    string s = &quot;aaa&quot;;</span><br><span class="line">    vector&lt;string&gt; words = &#123;&quot;a&quot;,&quot;a&quot;&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;int&gt; res = solution.findSubstring(s, words);</span><br><span class="line">    for(int i : res)&#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32_最长有效括号"></a>32_最长有效括号</h2><ul>
<li>动态规划不是一般人能想出来的</li>
<li>之前使用栈来判断是否有效，而这次是把字符对应的下标放入栈中，用来更新<font color="#FF0000">最大</font>长度：当前下标标减去栈顶的下标，这两者对应的字符都是右括号</li>
<li>如果是以<code>()</code>为开头，栈也为空，先把-1放入栈，再1-(-1)=2</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int longestValidParentheses(string s) &#123;</span><br><span class="line">        int max_len = 0;</span><br><span class="line">        stack&lt;int&gt; stk;</span><br><span class="line">        stk.push(-1);</span><br><span class="line">        for(int i = 0; i &lt; s.size(); i++)&#123;</span><br><span class="line">            if(s[i] == &apos;(&apos;)&#123;</span><br><span class="line">                stk.push(i);</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                stk.pop();</span><br><span class="line">                if(stk.empty())&#123;</span><br><span class="line">                    stk.push(i);</span><br><span class="line">                &#125; else&#123;</span><br><span class="line">                    max_len = max(max_len, i - stk.top());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return max_len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    string s = &quot;)()()(&quot;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    std::cout &lt;&lt; solution.longestValidParentheses(s) &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="38-外观数列"><a href="#38-外观数列" class="headerlink" title="38_外观数列"></a>38_外观数列</h2><ul>
<li>计算个数的时候，注意字符串的开头和结尾，还有递归函数是有返回值的</li>
</ul>
<h3 id="递归-7"><a href="#递归-7" class="headerlink" title="递归"></a>递归</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    string s = &quot;1&quot;;</span><br><span class="line">public:</span><br><span class="line">    string countAndSay(int n) &#123;</span><br><span class="line">        if(n == 1)&#123;return s;&#125;</span><br><span class="line">        int nums = 0;</span><br><span class="line">        char ch = s[0];</span><br><span class="line">        string tmp;</span><br><span class="line">        for(int i = 0; i &lt; s.size(); i++)&#123;</span><br><span class="line">            if(s[i] == ch)&#123;</span><br><span class="line">                nums++;</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                tmp.push_back(nums + &apos;0&apos;);</span><br><span class="line">                tmp.push_back(ch);</span><br><span class="line">                ch = s[i];</span><br><span class="line">                nums = 1;</span><br><span class="line">            &#125;</span><br><span class="line">            if(i + 1 == s.size())&#123;</span><br><span class="line">                tmp.push_back(nums + &apos;0&apos;);</span><br><span class="line">                tmp.push_back(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s = tmp;</span><br><span class="line">        s = countAndSay(n - 1);</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int n = 1;</span><br><span class="line">    Solution solution;</span><br><span class="line">    string res = solution.countAndSay(n);</span><br><span class="line">    for(char ch : res)&#123;</span><br><span class="line">        cout &lt;&lt; ch;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="43-字符串相乘"><a href="#43-字符串相乘" class="headerlink" title="43_字符串相乘"></a>43_字符串相乘</h2><ul>
<li>整形<code>int</code>与字符型<code>char</code>转换，直接加减‘0’即可，前面无需加括号说明类型</li>
<li>这题思路与下图一样，但我写了半天，一直在进位这里绕不出去，应该换个数据结构….</li>
</ul>
<p><img src="/pictrues/mul.png" alt="mul" title="mul"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string multiply(string num1, string num2) &#123;</span><br><span class="line">        //每一位相乘结果在res[i+1] res[i+j+1]这两位里 累加即可</span><br><span class="line">        if(num1 == &quot;0&quot; || num2 == &quot;0&quot;)&#123;return &quot;0&quot;;&#125;</span><br><span class="line"></span><br><span class="line">        int size1 = num1.length(), size2 = num2.length();</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt; memo(size1+size2, 0);   //只用一个数组来维护结果</span><br><span class="line">        string res = &quot;&quot;;</span><br><span class="line">        for(int i = size1-1; i&gt;=0; i--)&#123;</span><br><span class="line">            int n1 = num1[i]-&apos;0&apos;;</span><br><span class="line">            for(int j = size2-1; j&gt;=0; j--)&#123;</span><br><span class="line">                int n2 = num2[j]-&apos;0&apos;;</span><br><span class="line">                int tempSum = memo[i+j+1]+n1*n2;</span><br><span class="line">                memo[i+j+1] = tempSum % 10;</span><br><span class="line">                memo[i+j] += tempSum / 10;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bool flag = true;   //去除第一个为0的数字</span><br><span class="line">        for(int i = 0; i&lt;memo.size(); i++)&#123;</span><br><span class="line">            if(memo[i] != 0 || !flag)&#123;</span><br><span class="line">                flag = false;</span><br><span class="line">                res.push_back(memo[i]+&apos;0&apos;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    string nums1 = &quot;456&quot;, nums2 = &quot;123&quot;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    string res = solution.multiply(nums1, nums2);</span><br><span class="line">    cout &lt;&lt; &quot;res = &quot;;</span><br><span class="line">    for(auto re : res)&#123;</span><br><span class="line">        cout &lt;&lt; re;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="44-通配符匹配"><a href="#44-通配符匹配" class="headerlink" title="44_通配符匹配"></a>44_通配符匹配</h2><ul>
<li>跟之前的正则表达式匹配好像，温故而知新，‘*’可以匹配任意字符串，包括空字符串，即0个或者多个，在递归的过程中，只需用<code>||</code>即可</li>
<li>就相当于每次都会有一个分支，类似于前面的回溯，会遍历所有种情况，这题用这种方法超出时间限制了</li>
<li>学习下动态规划（字符串匹配）—状态转移方程+边界条件</li>
<li><code>dp[i][j]</code>表示<code>s</code>前<code>i</code>个字符和<code>p</code>前<code>j</code>个字符是否匹配，即<code>bool</code>类型（题解用了int类型的二维数组）；这里就有一个初始情况：<code>dp[0][j]</code>，初始化对字符串<code>p</code>遍历，只有<code>p[j-1] == &#39;*&#39;</code>时，才能为true，一旦不等就跳出循环，当然<code>dp[0][0] = true</code></li>
<li>状态转移方程<code>dp[i][j] = dp[i - 1][j - 1]</code>、<code>dp[i][j] = dp[i][j - 1]</code>、<code>dp[i][j] = dp[i - 1][j]</code>要分几种情况讨论</li>
</ul>
<p><img src="/pictrues/dp.png" alt="dp" title="dp"></p>
<ul>
<li>所有的<code>dp[j][0]</code>和<code>dp[0][j]</code>都是边界条件，最终的答案即为<code>d[m][n]</code></li>
</ul>
<h3 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isMatch(string s, string p) &#123;</span><br><span class="line">        int m = s.size(), n = p.size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1));</span><br><span class="line">        dp[0][0] = true;</span><br><span class="line">        for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">            if (p[i - 1] == &apos;*&apos;) &#123;</span><br><span class="line">                dp[0][i] = true;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt;= m; ++i) &#123;</span><br><span class="line">            for (int j = 1; j &lt;= n; ++j) &#123;</span><br><span class="line">                if (p[j - 1] == &apos;*&apos;) &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - 1] || dp[i - 1][j];</span><br><span class="line">                &#125;</span><br><span class="line">                else if (p[j - 1] == &apos;?&apos; || s[i - 1] == p[j - 1]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - 1][j - 1];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string s, p;</span><br><span class="line">    s = &quot;babbbbaabababaabbababaababbabbababbbaaaababbbabbbbbbbbbbaabbb&quot;;</span><br><span class="line">    p = &quot;b**bb**a**bba*b**a*bbb**aba***babbb*aa****aabb*bbb***b&quot;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.isMatch(s, p) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49_字母异位词分组"></a>49_字母异位词分组</h2><ul>
<li>哈希表的键值可以是各种类型的！字符串也可以进行排序！</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">        unordered_map&lt;string, vector&lt;string&gt;&gt; map;</span><br><span class="line">        for(const auto&amp; str : strs)&#123;</span><br><span class="line">            string key = str;</span><br><span class="line">            sort(key.begin(), key.end());</span><br><span class="line">            map[key].emplace_back(str);</span><br><span class="line">        &#125;</span><br><span class="line">        for(auto &amp; i : map)&#123;</span><br><span class="line">            res.emplace_back(i.second);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;string&gt; strs = &#123;&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; res = solution.groupAnagrams(strs);</span><br><span class="line">    for(auto i : res)&#123;</span><br><span class="line">        for(auto j : i)&#123;</span><br><span class="line">            for(auto k : j)&#123;</span><br><span class="line">                cout &lt;&lt; k;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; &quot;,&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="58-最后一个单词的长度"><a href="#58-最后一个单词的长度" class="headerlink" title="58_最后一个单词的长度"></a>58_最后一个单词的长度</h2><ul>
<li>这个思路就是一次遍历，更新单词的长度，遇到空格，就初始化</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLastWord(string s) &#123;</span><br><span class="line">        if(s.empty())&#123;return 0;&#125;</span><br><span class="line">//        s.push_back(&apos; &apos;);</span><br><span class="line">        int res = 0, tmp = 0;</span><br><span class="line">        for(auto i : s)&#123;</span><br><span class="line">            if(i == &apos; &apos; &amp;&amp; tmp != 0)&#123;</span><br><span class="line">//                res = tmp;</span><br><span class="line">                tmp = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            if(i != &apos; &apos;)&#123;</span><br><span class="line">                tmp++;</span><br><span class="line">                res = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    string s = &quot;     &quot;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.lengthOfLastWord(s) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="60-排列序列"><a href="#60-排列序列" class="headerlink" title="60_排列序列"></a>60_排列序列</h2><ul>
<li>发现自己的思维会停留在类似的题里，例如那道全排列，所以自然就想到先得出所有全排列的二维数组，再输出第几个，数字大点就超时了</li>
<li>换个思路，按照每个位置可以放几个数，给出<code>k</code>时，其实就可以得出答案了，如<code>n=3, k=2</code>，三个位置，第一个位置放1有（3-1）！也就是后面有2种顺序，再根据<code>k</code>，第一个位置只能放1，放2就超出<code>k</code>的范围了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int factorial(int i)&#123;</span><br><span class="line">        if(i == 0)&#123; //这里写0，是因为参数可能一开始就会输入0</span><br><span class="line">            return 1;</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">            return i * factorial(i - 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    string getPermutation(int n, int k) &#123;</span><br><span class="line">        string res;</span><br><span class="line">        vector&lt;int&gt; number;</span><br><span class="line">        for(int i = 1; i &lt;= n; i++)&#123;</span><br><span class="line">            number.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 1; i &lt;= n; i++)&#123;    //i代表第i个位置</span><br><span class="line">            int num = 0, tmp = factorial(n - i);    //num代表数字1到n的第几个</span><br><span class="line">            while (tmp &lt; k &amp;&amp; num &lt; number.size())&#123;</span><br><span class="line">                num++;</span><br><span class="line">                k -= tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(number[num] + &apos;0&apos;);</span><br><span class="line">            number.erase(number.begin() + num);</span><br><span class="line">        &#125;</span><br><span class="line">        return res; //差点忘了返回值，我说怎么一直报错呢，哈哈哈</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    Solution solution;</span><br><span class="line">    string res = solution.getPermutation(9, 78494);</span><br><span class="line">    for(auto s : res)&#123;</span><br><span class="line">        cout &lt;&lt; s &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="65-有效数字"><a href="#65-有效数字" class="headerlink" title="65_有效数字"></a>65_有效数字</h2><ul>
<li>这题虽说标记为困难，但逻辑比较简单，写起来比较繁琐，要考虑多种可能性</li>
<li>首先根据条件，判断是否有<code>e</code>或者<code>E</code>，如果没有直接判断是否有效（小数或者整数）；如果有，那就拆分字符串为两段：前半段必须有效（小数或者整数），后半段必须是整数</li>
<li>还是康康题解学习下自动机，没怎么看得懂0.0，还是康了一位<a href="https://www.youtube.com/watch?v=5gmtCtAooZE&feature=youtu.be" target="_blank" rel="noopener">yutuber大佬</a>，太强了！</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isNumber(string s) &#123;</span><br><span class="line">        while (s[0] == &apos; &apos;)&#123;s.erase(0, 1);&#125;</span><br><span class="line">        while (s[s.size() - 1] == &apos; &apos;)&#123;s.pop_back();&#125;</span><br><span class="line">        bool numberSeen = false;</span><br><span class="line">        bool dotSeen = false;</span><br><span class="line">        bool eSeen = false;</span><br><span class="line">        for(int i = 0; i &lt; s.size(); i++)&#123;</span><br><span class="line">            if(isdigit(s[i]))&#123;</span><br><span class="line">                numberSeen = true;</span><br><span class="line">            &#125; else if(s[i] == &apos;e&apos; || s[i] == &apos;E&apos;)&#123;</span><br><span class="line">                if(eSeen || !numberSeen)&#123;return false;&#125;</span><br><span class="line">                eSeen = true;</span><br><span class="line">                numberSeen = false;</span><br><span class="line">            &#125; else if(s[i] == &apos;.&apos;)&#123;</span><br><span class="line">                if(dotSeen || eSeen)&#123;return false;&#125;</span><br><span class="line">                dotSeen = true;</span><br><span class="line">            &#125; else if(s[i] == &apos;+&apos; || s[i] == &apos;-&apos;)&#123;</span><br><span class="line">                if(i != 0 &amp;&amp; (s[i - 1] != &apos;e&apos; &amp;&amp; s[i - 1] != &apos;E&apos;))&#123;return false;&#125;</span><br><span class="line">            &#125; else return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return numberSeen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    string s = &quot;-8e2.3  &quot;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.isNumber(s) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二刷-7"><a href="#二刷-7" class="headerlink" title="二刷"></a>二刷</h3><ul>
<li>二刷留念</li>
<li>有什么可留念的！这题我真的是……一言难尽，诸位如果不做这题，会遗憾终生的</li>
</ul>
<p><img src="/pictrues/65.png" alt title="有效数字"></p>
<ul>
<li>状态机、正则匹配还要学一学！</li>
</ul>
<p><img src="/pictrues/65_1.png" alt title="有限状态机"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isNumber(string s) &#123;</span><br><span class="line">        bool signSeen = false;</span><br><span class="line">        bool intSeen = false;</span><br><span class="line">        bool dotSeen = false;</span><br><span class="line">        bool eSeen = false;</span><br><span class="line"></span><br><span class="line">        for(auto ch : s)&#123;</span><br><span class="line">            //每遍历一个字符，都要先进行判断，然后再相应的赋值</span><br><span class="line">            if(ch == &apos;+&apos; || ch == &apos;-&apos;)&#123;</span><br><span class="line">                //e前后都是可以出现正负号，遍历到e会复位，所以只需判断之前有无正负号</span><br><span class="line">                //而且前面不能有数字，只能是第一位或者紧挨着e后面，不能只看前面有没有小数点，也要看e</span><br><span class="line">                if(signSeen || intSeen || (dotSeen &amp;&amp; !eSeen)) return false;</span><br><span class="line">                signSeen = true;</span><br><span class="line"></span><br><span class="line">            &#125;else if(isdigit(ch))&#123;</span><br><span class="line">                //如果是数字</span><br><span class="line">                intSeen = true;</span><br><span class="line"></span><br><span class="line">            &#125;else if(ch == &apos;.&apos;)&#123;</span><br><span class="line">                //如果是小数点，前面没有数字、后面也没有数字</span><br><span class="line">                if(dotSeen || eSeen) return false;</span><br><span class="line">                dotSeen = true;</span><br><span class="line"></span><br><span class="line">            &#125;else if(ch == &apos;e&apos; || ch == &apos;E&apos;)&#123;</span><br><span class="line">                //e后面必须要有数字，相应的复位；前面也必须是小数或者整数</span><br><span class="line">                //还要判断是否已经出现e！！！</span><br><span class="line">                if(!intSeen || eSeen) return false;</span><br><span class="line">                signSeen = false;</span><br><span class="line">                intSeen = false;</span><br><span class="line">                //这里要不要把小数点也置0呢，在符号位那边判断吧</span><br><span class="line">                eSeen = true;</span><br><span class="line"></span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                //其余符号</span><br><span class="line">                return false;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //最终结果都是看有没有数字</span><br><span class="line">        return intSeen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="67-二进制求和"><a href="#67-二进制求和" class="headerlink" title="67_二进制求和"></a>67_二进制求和</h2><ul>
<li>这两题的思路在43_字符串相乘那题试过，但是没有成功</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string addBinary(string a, string b) &#123;</span><br><span class="line">        int carry = 0, ans, l_a = a.size(), l_b = b.size();</span><br><span class="line">        l_a--; l_b--;</span><br><span class="line">        string res;</span><br><span class="line">        while (l_a &gt;= 0 &amp;&amp; l_b &gt;= 0)&#123;</span><br><span class="line">            ans = (a[l_a] - &apos;0&apos;) + (b[l_b] - &apos;0&apos;) + carry;</span><br><span class="line">            res.insert(res.begin(), (ans % 2) + &apos;0&apos;);</span><br><span class="line">            carry = ans / 2;</span><br><span class="line">            l_a--; l_b--;</span><br><span class="line">        &#125;</span><br><span class="line">        while (l_a &gt;= 0)&#123;</span><br><span class="line">            ans = (a[l_a] - &apos;0&apos;) + carry;</span><br><span class="line">            res.insert(res.begin(), (ans % 2) + &apos;0&apos;);</span><br><span class="line">            carry = ans / 2;</span><br><span class="line">            l_a--;</span><br><span class="line">        &#125;</span><br><span class="line">        while (l_b &gt;= 0)&#123;</span><br><span class="line">            ans = (b[l_b] - &apos;0&apos;) + carry;</span><br><span class="line">            res.insert(res.begin(), (ans % 2) + &apos;0&apos;);</span><br><span class="line">            carry = ans / 2;</span><br><span class="line">            l_b--;</span><br><span class="line">        &#125;</span><br><span class="line">        if(carry != 0)&#123;res.insert(0, 1, carry + &apos;0&apos;);&#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    string a = &quot;11&quot;, b = &quot;1&quot;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    string res = solution.addBinary(a, b);</span><br><span class="line">    for(auto re : res)&#123;</span><br><span class="line">        cout &lt;&lt; re &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="71-简化路径"><a href="#71-简化路径" class="headerlink" title="71_简化路径"></a>71_简化路径</h2><ul>
<li>这题做的过程比较苦恼，题解还没有官方，，，遇到<code>/../</code>，就要弹出上一个文件名，而不是弹出两个字符，这样用<code>vector&lt;string&gt;</code>类型好点，最后再将他们串联起来，还有像<code>/...</code>、<code>/..../</code>等等都相当于文件名</li>
<li>这题也算熟悉了Linux的路径名：<code>/</code>+字符串，我一直考虑<code>/</code>+字符串+<code>/</code></li>
<li>学习了新的循环格式<code>for_each( v.begin(), v.end(), [&amp;](string str){ result += str ;} );</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string simplifyPath(string path) &#123;</span><br><span class="line">        path += &apos;/&apos;;</span><br><span class="line">        string tmp = &quot;/&quot;;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        for(auto p : path)&#123;</span><br><span class="line">            if(p != &apos;/&apos;)&#123;</span><br><span class="line">                tmp += p;</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                if(tmp == &quot;/.&quot;)&#123;</span><br><span class="line">                    tmp.clear();</span><br><span class="line">                    tmp += &apos;/&apos;;</span><br><span class="line">                &#125; else if(tmp == &quot;/..&quot;)&#123;</span><br><span class="line">                    if(!res.empty())&#123;res.pop_back();&#125;</span><br><span class="line">                    tmp.clear();</span><br><span class="line">                    tmp += &apos;/&apos;;</span><br><span class="line">                &#125; else if(tmp == &quot;/&quot;)&#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125; else&#123;</span><br><span class="line">                    res.push_back(tmp);</span><br><span class="line">                    tmp.clear();</span><br><span class="line">                    tmp += &apos;/&apos;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        string ans;</span><br><span class="line"></span><br><span class="line">        for_each(res.begin(), res.end(), [&amp;](const string&amp; s)&#123;ans += s;&#125;);</span><br><span class="line">        if(ans.empty())&#123;ans += &apos;/&apos;;&#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    string path = &quot;/a/c//.//.....//..//.//.//.//b/../.&quot;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    string res = solution.simplifyPath(path);</span><br><span class="line">    for(auto re : res)&#123;</span><br><span class="line">        cout &lt;&lt; re;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72_编辑距离"></a>72_编辑距离</h2><ul>
<li>这题毫无头绪，想了好几天，还是最后看了那位yutuber的视频，不得不说动态规划还是很牛批</li>
<li>上一题那个不同路径||，我以为已经会动态规划了，其实是只知其形不知其义</li>
<li>上一个状态是什么，hors-ros、horse-ro、hors-ro这三个状态放在平面格子上可以看成左边、上边、对角线，前面两个状态只需添加一个字符就可以变成horse-ros，第三个状态似乎需要两步(其实只需一步)因为添加的字母不一样，如果字母一样呢？答案是不变的；举个例子：hors-ro之间转变的步数与horse-roe之间转变的步数是一样的、那么hors-ro可以先看成horse-roe，再替换字符变成horse-ros</li>
<li>妙极了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minDistance(string word1, string word2) &#123;</span><br><span class="line">        int m = word1.size(), n = word2.size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0));</span><br><span class="line">        //因为要取最小值，如果中间格子都是0的话，那结果也会是0，得先初始化下，值稍微取大点</span><br><span class="line">        for(int i = 0; i &lt;= m; i++)&#123;</span><br><span class="line">            for(int j = 0; j &lt;= n; j++)&#123;</span><br><span class="line">                dp[i][j] = INT32_MAX;</span><br><span class="line">                dp[0][j] = j;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][0] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">            for(int j = 0; j &lt; n; j++)&#123;</span><br><span class="line">                if(word1[i] == word2[j])&#123;</span><br><span class="line">                    dp[i + 1][j + 1] = dp[i][j];</span><br><span class="line">                &#125; else&#123;</span><br><span class="line">                    dp[i + 1][j + 1] = min(dp[i][j], min(dp[i + 1][j], dp[i][j + 1])) + 1;</span><br><span class="line">                  &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    string word1 = &quot;horse&quot;, word2 = &quot;ros&quot;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.minDistance(word1, word2);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="76-最小覆盖字串"><a href="#76-最小覆盖字串" class="headerlink" title="76_最小覆盖字串"></a>76_最小覆盖字串</h2><ul>
<li>发现了一个难点，就是如何判断子字符串包含所有的目标字符，我用了哈希表，先初始化对应的个数；遇到一个目标字符就将个数减一，个数变为0，就删除这一键值；哈希表为空，就说明都包含了；一开始比较顺利，但是添加新的键值再删除，发现不为空(后来发现用<code>emplace</code>函数也不行)</li>
<li>双指针，要先找出可行子串；再收缩；再扩张；题解是用两个<code>map</code>进行比较：对，遍历一遍，比较个数；每次遇到目标字符，都要进行此操作</li>
<li>看来做题目不能看进阶，得先做出来，要不然容易束缚思维(时间复杂度、空间复杂度之类的；比如时间O(n)，并不是只用一次遍历，甚至可以再套一次遍历，只要范围比前一个循环小，也可)</li>
<li><code>map</code>比较的时候，都得遍历一遍；以后输出改用更高位格的<code>copy()</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    unordered_map &lt;char, int&gt; ori, cnt;</span><br><span class="line"></span><br><span class="line">    bool check() &#123;</span><br><span class="line">        for (const auto &amp;p: ori) &#123;</span><br><span class="line">            if (cnt[p.first] &lt; p.second) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string minWindow(string s, string t) &#123;</span><br><span class="line">        for (const auto &amp;c: t) &#123;</span><br><span class="line">            ++ori[c];   //记录字符串t中字母的个数</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int l = 0, r = -1;</span><br><span class="line">        int len = INT_MAX, ansL = -1;</span><br><span class="line"></span><br><span class="line">        while (r &lt; int(s.size())) &#123;</span><br><span class="line">            if (ori.find(s[++r]) != ori.end()) &#123;    //在判断条件时，r已经加一了，如果有这个目标字母</span><br><span class="line">                ++cnt[s[r]];    //则记录下这个字母的个数，到时跟ori作比较</span><br><span class="line">            &#125;</span><br><span class="line">            //当且仅当cnt记录的 所有 字母的个数都 超出或者等于 对应的ori，才执行</span><br><span class="line">            while (check() &amp;&amp; l &lt;= r) &#123;</span><br><span class="line">                if (r - l + 1 &lt; len) &#123;  //如果这次符合的子字符串 比 之前的 短；则更新len,ansL</span><br><span class="line">                    len = r - l + 1;</span><br><span class="line">                    ansL = l;</span><br><span class="line">                &#125;</span><br><span class="line">                if (ori.find(s[l]) != ori.end()) &#123;</span><br><span class="line">                    --cnt[s[l]];</span><br><span class="line">                &#125;</span><br><span class="line">                ++l;    //l也可以直接到下一个目标字符，这样上一个条件就不用判断了</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ansL == -1 ? &quot;&quot; : s.substr(ansL, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    string res = solution.minWindow(s, t);</span><br><span class="line">	//如果不加载包含库，copy()貌似只有字符类型；#include &lt;iterator&gt;  -- std::ostream_iterator   #include &lt;algorithm&gt; -- std::copy</span><br><span class="line">    copy(res.begin(), res.end(), ostreambuf_iterator&lt;char&gt;(cout));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="87-扰乱字符串"><a href="#87-扰乱字符串" class="headerlink" title="87_扰乱字符串"></a>87_扰乱字符串</h2><ul>
<li>完全没思路，因为我不知道什么情况下会是<code>false</code>；后来发现题目给的二叉树不一定非得从中间分开，可以是任意位置，而且每次递归都可以是任意位置好像？因为题解循环的时候，就是从<code>i = 1</code>至最后把字符串分成两个字串，然后递归比较这两个字串按两种情况进行比较；这么一看还是很清晰的</li>
<li>当然出口条件得先设置</li>
<li>这种思路叫做递归+剪枝！</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    //C++递归+剪枝</span><br><span class="line">    bool isScramble(string s1, string s2) &#123;</span><br><span class="line">        int n = s1.length();</span><br><span class="line">        int m = s2.length();</span><br><span class="line">        if(m != n)</span><br><span class="line">            return false;   //一条语句可不用加&#123;&#125;</span><br><span class="line">        if(s1 == s2)</span><br><span class="line">            return true;</span><br><span class="line">        //这里确保s1,s2字母都相同</span><br><span class="line">        string s3 = s1;</span><br><span class="line">        sort(s3.begin(), s3.end());</span><br><span class="line">        string s4 = s2;</span><br><span class="line">        sort(s4.begin(), s4.end());</span><br><span class="line">        if(s3 != s4)</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        for(int i = 1; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            string x1 = s1.substr(0, i);</span><br><span class="line">            string y1 = s1.substr(i, n-i);</span><br><span class="line">            string x2 = s2.substr(0, i);</span><br><span class="line">            string y2 = s2.substr(i, n-i);</span><br><span class="line">            //前两部分一一对应是一种情况，另一种情况是交叉对应；因为是递归，只需考虑根循环即可</span><br><span class="line">            string x3 = s2.substr(0, n-i);</span><br><span class="line">            string y3 = s2.substr(n-i,i);</span><br><span class="line">            if(isScramble(x1,x2) &amp;&amp; isScramble(y1,y2))</span><br><span class="line">                return true;</span><br><span class="line">            if(isScramble(y1,x3) &amp;&amp; isScramble(x1,y3))</span><br><span class="line">                return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    string s1(&quot;great&quot;), s2(&quot;rgtea&quot;);</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.isScramble(s1, s2) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="91-解码方法"><a href="#91-解码方法" class="headerlink" title="91_解码方法"></a>91_解码方法</h2><ul>
<li>判断条件顺序很重要，先判断能不能解码，再分类，可以提高速度</li>
<li>如果出现0，那么0后面的数字可以直接pass，而且是第一次出现0的位置（×）</li>
<li>不对不对，如果出现0只能看前一个数字（这里有点坑，在代码里应该与字符进行比较）是否是1或者2，是那么这个0可以解码并且继续，不是，那么返回0</li>
<li>之后将数字一个一组或者两个一组（在1-26范围内）；计算出可能的解码情况；有点类似于排列组合</li>
<li>试试动态规划；<code>dp[i]</code>与前两项<code>dp[i-1]</code>、<code>dp[i-2]</code>都有关是我想不到的，我一直在凑与<code>dp[i-1]</code>的关系。。。</li>
<li>当本身一个数字解码时的情况：<code>dp[i]=dp[i-1]</code>；当与前一个数字组合解码时：<code>dp[i]=dp[i-2]</code></li>
<li>条件判断逻辑很重要，稍有不慎就会漏判或者误判</li>
<li>首先为了不让<code>s[i-1]</code>超出边界，分为<code>i==0</code>和<code>i&gt;0</code>两个部分；对于<code>s[i-2]</code>用三目运算符，<code>i==1?1:s[i-2]</code></li>
<li>其次，先判断整体能否解码，再判断只能一个数字解码、只能两个数字解码、两个都可以解码</li>
<li>做题做到现在，<font color="#FF0000">审题真的很重要</font>！！</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int numDecodings(string s) &#123;</span><br><span class="line">        int l = s.size();</span><br><span class="line">        vector&lt;int&gt; tmp(l, 0);</span><br><span class="line">        for(int i = 0; i &lt; l; ++i)&#123;</span><br><span class="line">            if(i == 0)&#123;</span><br><span class="line">                if(s[i] == &apos;0&apos;)</span><br><span class="line">                    break;</span><br><span class="line">                else</span><br><span class="line">                    tmp[0] = 1;</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                if(s[i] == &apos;0&apos; &amp;&amp; (s[i - 1] &gt; &apos;2&apos; || s[i - 1] == &apos;0&apos;))</span><br><span class="line">                    break;  //如果不属于这种情况，那么说明是可解码的</span><br><span class="line">                else if(s[i] == &apos;0&apos; &amp;&amp; (s[i - 1] == &apos;2&apos; || s[i - 1] == &apos;1&apos;))&#123;</span><br><span class="line">                    tmp[i] = (i == 1 ? 1 : tmp[i - 2]);</span><br><span class="line">                &#125;</span><br><span class="line">                //s[i] &lt;= &apos;6&apos; &amp;&amp; (s[i - 1] == &apos;2&apos;) || s[i - 1] == &apos;1&apos;)忽略了17</span><br><span class="line">                else if(((s[i] &gt; &apos;6&apos; &amp;&amp; s[i - 1] &gt;= &apos;2&apos;) || s[i - 1] &gt; &apos;2&apos;) || s[i - 1] == &apos;0&apos;)&#123;</span><br><span class="line">                    tmp[i] = tmp[i - 1];    //只能一个数字解码</span><br><span class="line">                &#125;</span><br><span class="line">                else    //一个数字、两个数字解码</span><br><span class="line">                    tmp[i] = tmp[i - 1] + (i == 1 ? 1 : tmp[i - 2]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return s.empty() ? 0 : tmp[l - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    string s = &quot;2611055971756562&quot;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.numDecodings(s) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="97-交错字符串"><a href="#97-交错字符串" class="headerlink" title="97_ 交错字符串"></a>97_ 交错字符串</h2><ul>
<li>唉，又超时了</li>
<li>这题还是用动态规划好，而且其中一个要点就是规划前要将边界初始化，还有就是让下标不能超出边界</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isInterleave(string s1, string s2, string s3) &#123;</span><br><span class="line">        if(s3.size() != s2.size() + s1.size()) return false;    //这一步写错了，找了半天发现比较的是s1和s2+s3</span><br><span class="line">        auto dp =vector&lt;vector&lt;int&gt;&gt;(s1.size() + 1, vector&lt;int&gt;(s2.size() + 1, 0));</span><br><span class="line">        dp[0][0] = 1;</span><br><span class="line">        for(int i = 0; i &lt;= s1.size(); ++i)&#123;</span><br><span class="line">            for(int j = 0; j &lt;= s2.size(); ++j)&#123;</span><br><span class="line">                if(j &gt; 0)&#123;</span><br><span class="line">                    if(dp[i][j - 1] == 1 &amp;&amp; s2[j - 1] == s3[i + j - 1]) dp[i][j] = 1; //还有个条件那就是对应字符应该相等</span><br><span class="line">                &#125;</span><br><span class="line">                if(i &gt; 0)&#123;</span><br><span class="line">                    if(dp[i - 1][j] == 1 &amp;&amp; s1[i - 1] == s3[i + j - 1]) dp[i][j] = 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[s1.size()][s2.size()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string s1(&quot;aabcc&quot;),s2(&quot;dbbca&quot;),s3(&quot;aadbbcbcac&quot;);</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.isInterleave(s1, s2, s3) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="115-不同的子序列"><a href="#115-不同的子序列" class="headerlink" title="115_不同的子序列"></a>115_不同的子序列</h2><ul>
<li>这题咋写递归，都超时！！！</li>
<li>试试动态规划，还不行就看题解，这题好像跟米哈游春招笔试第一道1807差不多，得写动态规划</li>
<li>不容易啊，终于做出来了，还会涉及字符串长度会超出整数边界；这里直接用<code>using st = std::string ::size_type</code>一劳永逸</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int numDistinct(string s, string t) &#123;</span><br><span class="line">        using st = std::string ::size_type;</span><br><span class="line">        st ls = s.size(), lt = t.size();</span><br><span class="line">        if(ls &lt; lt) return 0;</span><br><span class="line">        vector&lt;vector&lt;st&gt;&gt; dp(ls, vector&lt;st&gt;(lt, 0));</span><br><span class="line">        //边界初始化</span><br><span class="line">        for(st i = 0; i &lt; ls; ++i)&#123;</span><br><span class="line">            if(s[i] == t[0])</span><br><span class="line">                dp[i][0] += 1;</span><br><span class="line">            if(i &gt; 0)</span><br><span class="line">                dp[i][0] += dp[i - 1][0];</span><br><span class="line">        &#125;</span><br><span class="line">        for(st j = 1; j &lt; lt; ++j)&#123;</span><br><span class="line">            for(st i = j; i &lt; ls; ++i)&#123;</span><br><span class="line">                if(s[i] == t[j])</span><br><span class="line">                    dp[i][j] = dp[i - 1][j - 1];</span><br><span class="line"></span><br><span class="line">                dp[i][j] += dp[i - 1][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[ls - 1][lt - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    string s(&quot;rabbbit&quot;), t(&quot;b&quot;);</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.numDistinct(s, t) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="125-验证回文串"><a href="#125-验证回文串" class="headerlink" title="125_验证回文串"></a>125_验证回文串</h2><ul>
<li>这题还是可以的，用了<code>isalnum()</code>函数，判断字符是否是字母还是数字</li>
<li>在学习下其他方法：翻转API，直接判断两个字符串是否相等，不过要将原字符串处理下只留下字母和数字；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isPalindrome(string s) &#123;</span><br><span class="line">        if(s.empty()) return true;</span><br><span class="line">        int n = s.size();</span><br><span class="line">        int l = 0, r = n - 1;</span><br><span class="line">        bool flag = true;</span><br><span class="line">        while (l &lt;= r)&#123;</span><br><span class="line">            if(isalnum(s[l]) &amp;&amp; isalnum(s[r]))&#123;</span><br><span class="line">                if(tolower(s[l]) != tolower(s[r]))&#123;</span><br><span class="line">                    flag = false;</span><br><span class="line">                    break;</span><br><span class="line">                &#125; else&#123;</span><br><span class="line">                    ++l;</span><br><span class="line">                    --r;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if(isalnum(s[l]))</span><br><span class="line">                --r;</span><br><span class="line">            else if(isalnum(s[r]))</span><br><span class="line">                ++l;</span><br><span class="line">            else&#123;</span><br><span class="line">                ++l;</span><br><span class="line">                --r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    string s(&quot;A man, a plan, a canal: Panama&quot;);</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.isPalindrome(s) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="126-单词接龙-II"><a href="#126-单词接龙-II" class="headerlink" title="126_单词接龙_II"></a>126_单词接龙_II</h2><ul>
<li>思路应该是先找出所有的路径，然后再保留最短的路径；写完之后，用了好几个函数，代码也有五六十行；不出所料，超出时间限制了；思路一步一步来，先在字典里找出所有与<code>beginWord</code>只有一位字母不同的单词，之后循环再递归</li>
<li>好家伙，这是最短路径，需要抽象成图的模型，做这题花了一个多小时，那再笔试时是不是就可以放弃了…</li>
<li>判断是否只有一个字母不一样的方法还是一样的，我觉得我有可以了；这里面的映射有点像图论里的邻接矩阵</li>
<li>官方答案也会超时…这题一定是在跟我过不去！！！复制了好多题解都超时</li>
<li>构图的时候要无环图，有环图会增加不必要的时间</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int INF = 1 &lt;&lt; 20;</span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    unordered_map&lt;string, int&gt; wordId;</span><br><span class="line">    vector&lt;string&gt; idWord;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; edges;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; findLadders(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123;</span><br><span class="line">        int id = 0;</span><br><span class="line">        for (const string&amp; word : wordList) &#123;</span><br><span class="line">            if (!wordId.count(word)) &#123;</span><br><span class="line">                wordId[word] = id++;</span><br><span class="line">                idWord.push_back(word);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   //map里的int是对应的位置</span><br><span class="line">        if (!wordId.count(endWord))</span><br><span class="line">            return &#123;&#125;;</span><br><span class="line">        if (!wordId.count(beginWord)) &#123; //如果找不到起始单词，就放入map里</span><br><span class="line">            wordId[beginWord] = id++;</span><br><span class="line">            idWord.push_back(beginWord);</span><br><span class="line">        &#125;</span><br><span class="line">        edges.resize(idWord.size());//构建行数是idWord.size()的二维数组</span><br><span class="line">        for (int i = 0; i &lt; idWord.size(); i++) &#123;</span><br><span class="line">            for (int j = i + 1; j &lt; idWord.size(); j++) &#123;</span><br><span class="line">                if (transformCheck(idWord[i], idWord[j])) &#123;</span><br><span class="line">                    edges[i].push_back(j);</span><br><span class="line">                    edges[j].push_back(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        const int dest = wordId[endWord];//终点所在的位置</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">        queue&lt;vector&lt;int&gt;&gt; q;</span><br><span class="line">        vector&lt;int&gt; cost(id, INF);//其中cost[i]表示beginWord对应的点到第 i 个点的代价（即转换次数）。初始情况下其所有元素初始化为无穷大。</span><br><span class="line">        q.push(vector&lt;int&gt;&#123;wordId[beginWord]&#125;);</span><br><span class="line"></span><br><span class="line">        cost[wordId[beginWord]] = 0;//自己与自己的转换次数是0</span><br><span class="line">        while (!q.empty()) &#123;</span><br><span class="line">            vector&lt;int&gt; now = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line"></span><br><span class="line">            int last = now.back();</span><br><span class="line">            if (last == dest) &#123;</span><br><span class="line">                vector&lt;string&gt; tmp;</span><br><span class="line">                for (int index : now) &#123;</span><br><span class="line">                    tmp.push_back(idWord[index]);</span><br><span class="line">                &#125;</span><br><span class="line">                res.push_back(tmp);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                for (int i = 0; i &lt; edges[last].size(); i++) &#123;</span><br><span class="line">                    int to = edges[last][i];</span><br><span class="line">                    if (cost[last] + 1 &lt;= cost[to]) &#123;</span><br><span class="line">                        cost[to] = cost[last] + 1;</span><br><span class="line">                        vector&lt;int&gt; tmp(now);</span><br><span class="line">                        tmp.push_back(to);</span><br><span class="line">                        q.push(tmp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool transformCheck(const string&amp; str1, const string&amp; str2) &#123;</span><br><span class="line">        int differences = 0;</span><br><span class="line">        for (int i = 0; i &lt; str1.size() &amp;&amp; differences &lt; 2; i++) &#123;  //限制条件可以缩短时间</span><br><span class="line">            if (str1[i] != str2[i]) &#123;</span><br><span class="line">                ++differences;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return differences == 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    string beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;;</span><br><span class="line">    vector&lt;string&gt; wordList = &#123;&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; res = solution.findLadders(beginWord, endWord, wordList);</span><br><span class="line">    cout &lt;&lt; &quot;-------&quot; &lt;&lt; endl;</span><br><span class="line">    for(const auto &amp; re : res)&#123;</span><br><span class="line">        for(const auto &amp; s : re)</span><br><span class="line">            cout &lt;&lt; s &lt;&lt; &quot; &quot;;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二刷-8"><a href="#二刷-8" class="headerlink" title="二刷"></a>二刷</h3><ul>
<li>第一次做的时候，觉得这题是最难的，都不想看第二遍！——也是因为第一次没有过，哪怕抄了题解<ul>
<li>今天2021.6.26，把这题二刷下，看看双向BFS的本质！——只要找到一个相同的单词，就说明最短，因为是一层一层遍历的</li>
</ul>
</li>
<li>首先如何快速找到仅有单个字母不同的单词？26个英文字母遍历一遍？那就要先存入哈希了</li>
<li>两个队列的话，是怎么记录，如果找到同一个单词的话，的前后单词演变或者路径呢<ul>
<li>而且两个队列应该是先后更新，一起更新很容易错过！</li>
<li>关键在于找到之后，如何回溯，要是每个单词记录下上一个单词就好了！那应该用什么数据结构；而且每一层也要记录单词</li>
<li>学习下双层BFS的套路</li>
<li>做到最后才发现……原来是要返回所有的最短路径啊！！！艹(一种植物)！我还以为是找其中一个呢，已经花了好多时间，明天再做</li>
<li>那也差不多，只要找到一个单词，那就说明这一层上所有的相同单词都是最短路径</li>
<li>最后，<code>unordered_map&lt;string, string&gt;</code>这里出现了点问题，层次遍历的时候，会不会有多个父节点？<ul>
<li>出现了，多个父节点，指向同一个单词！！！雾草，要不用<code>unordered_map&lt;string, vector&lt;string&gt;&gt;</code>？</li>
<li>这样的话，为什么还要用双向BFS？直接从尾部开始不就好了？因为反转也挺麻烦</li>
<li>这就是图！</li>
</ul>
</li>
<li>尾队列出现了死循环！对，因为没有删除一开始就存在的<code>endWord</code>，那么<code>beginWord</code>也有可能在<code>set</code>中，如果不删，那么在寻找仅单个字符不同单词时，会再次放入映射父节点，从而乱套</li>
</ul>
</li>
<li>发现之前没有认真看题解评论，这次找了个大佬评论CV，终于过了，得好好学习下</li>
<li>双向搜索适合127！！！因为不需要记录来时的路径！<ul>
<li>惭愧，这题二刷了三四天！还没有完全掌握（主要是一鼓作气、再而衰、三而竭），我觉得这题得隔几天就温习下！！</li>
</ul>
</li>
</ul>
<h2 id="127-单词接龙"><a href="#127-单词接龙" class="headerlink" title="127_单词接龙"></a>127_单词接龙</h2><ul>
<li>这题是算出最短路径的长度，就是上一题求解数组的长度仅此而已吗？不，要明白为什么会是最短，是因为有<code>cost</code>数组，在广度优先搜索的时候只能搜索转换次数更大的单词，而不是回退原来已经转换过的单词；</li>
<li>还有就算上一题原封不动的提交，耗时也很高；学习下双向搜索</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;unordered_set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    unordered_map&lt;string, int&gt; wordId;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; edge;</span><br><span class="line">    int nodeNum = 0;</span><br><span class="line"></span><br><span class="line">    void addWord(string&amp; word) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;wordId.count(&quot; &lt;&lt; word &lt;&lt; &quot;) = &quot; &lt;&lt; wordId.count(word) &lt;&lt; endl;</span><br><span class="line">        if (!wordId.count(word)) &#123;</span><br><span class="line">            wordId[word] = nodeNum++;   //nodeNum++相当于给单词标记了位置</span><br><span class="line">            cout &lt;&lt; &quot; --- &quot; &lt;&lt; wordId.count(word) &lt;&lt; endl;</span><br><span class="line">            edge.emplace_back();    //增加行数</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void addEdge(string&amp; word) &#123;</span><br><span class="line">        addWord(word);  //只当没有word的时候才会加入map里</span><br><span class="line">        int id1 = wordId[word];</span><br><span class="line">        for (char&amp; it : word) &#123;</span><br><span class="line">            char tmp = it;</span><br><span class="line">            it = &apos;*&apos;;   //这个是引用，会改变原word，相当于把所有与word一个字母不同的单词都放入map里了</span><br><span class="line">            addWord(word);</span><br><span class="line">            int id2 = wordId[word];</span><br><span class="line">            cout &lt;&lt; &quot;id1 = &quot; &lt;&lt; id1 &lt;&lt; &quot; tmp = &quot; &lt;&lt; tmp &lt;&lt; &quot; id2 = &quot; &lt;&lt; id2 &lt;&lt; endl;</span><br><span class="line">            edge[id1].push_back(id2);</span><br><span class="line">            edge[id2].push_back(id1);</span><br><span class="line">            it = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int ladderLength(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123;</span><br><span class="line">        for (string&amp; word : wordList)</span><br><span class="line">            addEdge(word);</span><br><span class="line">        addEdge(beginWord); //beginWord最后在加</span><br><span class="line"></span><br><span class="line">        if (!wordId.count(endWord))</span><br><span class="line">            return 0;</span><br><span class="line"></span><br><span class="line">        /*for(const auto &amp;m : wordId)</span><br><span class="line">            cout &lt;&lt; m.first &lt;&lt; &quot;&lt;-&gt;&quot; &lt;&lt; m.second &lt;&lt; &quot; &quot;;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        for(const auto &amp;ed : edge)&#123;</span><br><span class="line">            for(const auto &amp;e : ed)</span><br><span class="line">                cout &lt;&lt; e &lt;&lt; &quot; &quot;;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;*/</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt; disBegin(nodeNum, INT_MAX); //这一步相当于单向搜索的cost，用来记录转换次数</span><br><span class="line">        int beginId = wordId[beginWord];</span><br><span class="line">        disBegin[beginId] = 0;</span><br><span class="line">        queue&lt;int&gt; queBegin;</span><br><span class="line">        queBegin.push(beginId);</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt; disEnd(nodeNum, INT_MAX);</span><br><span class="line">        int endId = wordId[endWord];</span><br><span class="line">        disEnd[endId] = 0;</span><br><span class="line">        queue&lt;int&gt; queEnd;</span><br><span class="line">        queEnd.push(endId);</span><br><span class="line"></span><br><span class="line">        while (!queBegin.empty() &amp;&amp; !queEnd.empty()) &#123;</span><br><span class="line">            int queBeginSize = queBegin.size();</span><br><span class="line">            for (int i = 0; i &lt; queBeginSize; ++i) &#123;</span><br><span class="line">                int nodeBegin = queBegin.front();</span><br><span class="line">                queBegin.pop();</span><br><span class="line">                if (disEnd[nodeBegin] != INT_MAX) &#123;</span><br><span class="line">                    return (disBegin[nodeBegin] + disEnd[nodeBegin]) / 2 + 1;</span><br><span class="line">                &#125;</span><br><span class="line">                for (int&amp; it : edge[nodeBegin]) &#123;</span><br><span class="line">                    if (disBegin[it] == INT_MAX) &#123;</span><br><span class="line">                        disBegin[it] = disBegin[nodeBegin] + 1;</span><br><span class="line">                        queBegin.push(it);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            int queEndSize = queEnd.size();</span><br><span class="line">            for (int i = 0; i &lt; queEndSize; ++i) &#123;</span><br><span class="line">                int nodeEnd = queEnd.front();</span><br><span class="line">                queEnd.pop();</span><br><span class="line">                if (disBegin[nodeEnd] != INT_MAX) &#123;</span><br><span class="line">                    return (disBegin[nodeEnd] + disEnd[nodeEnd]) / 2 + 1;</span><br><span class="line">                &#125;</span><br><span class="line">                for (int&amp; it : edge[nodeEnd]) &#123;</span><br><span class="line">                    if (disEnd[it] == INT_MAX) &#123;</span><br><span class="line">                        disEnd[it] = disEnd[nodeEnd] + 1;</span><br><span class="line">                        queEnd.push(it);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//大佬写的</span><br><span class="line">class Solution_ &#123;</span><br><span class="line">public:</span><br><span class="line">    int ladderLength(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123;</span><br><span class="line">        unordered_set&lt;string&gt; words(wordList.begin(), wordList.end());</span><br><span class="line">        if ( words.empty() || words.find(endWord) == words.end() ) return 0;</span><br><span class="line">        words.erase(beginWord);</span><br><span class="line">        queue&lt;string&gt; que;</span><br><span class="line">        que.push(beginWord);</span><br><span class="line">        unordered_set&lt;string&gt; visited;</span><br><span class="line">        visited.insert(beginWord);</span><br><span class="line">        int step = 1;</span><br><span class="line">        while ( !que.empty() ) &#123;</span><br><span class="line">            // 找到没有被访问过, 而且能够由当前单词转换而成的单词</span><br><span class="line">            int n = que.size();</span><br><span class="line">            // 每一轮(每一层step加个1)</span><br><span class="line">            while ( n-- ) &#123;</span><br><span class="line">                string curWord = que.front();</span><br><span class="line">                que.pop();</span><br><span class="line">                // 当前单词的每个字符都替换成其他的25个字符, 然后在单词表中查询</span><br><span class="line">                // 是不是包含转换后的单词</span><br><span class="line">                // 这里千万不能遍历单词表, 因为单词表很长, 而哈希表使用的红黑树</span><br><span class="line">                // 的查询效率比遍历单词表高很多</span><br><span class="line">                for ( int i = 0; i &lt; curWord.size(); ++i ) &#123;</span><br><span class="line">                    char originalChar = curWord[i];</span><br><span class="line">                    for ( int j = 0; j &lt; 26; ++j ) &#123;</span><br><span class="line">                        if ( char(&apos;a&apos; + j) == originalChar ) continue;</span><br><span class="line">                        curWord[i] = (char)(&apos;a&apos; + j);</span><br><span class="line">                        if ( words.find(curWord) != words.end() &amp;&amp; visited.find(curWord) == visited.end() ) &#123;</span><br><span class="line">                            if ( curWord == endWord ) return step + 1;</span><br><span class="line">                            else &#123;</span><br><span class="line">                                que.push(curWord);</span><br><span class="line">                                visited.insert(curWord);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    curWord[i] = originalChar;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++step;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;;</span><br><span class="line">    vector&lt;string&gt; wordList = &#123;&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    int res = solution.ladderLength(beginWord, endWord, wordList);</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="132-分割回文串-II"><a href="#132-分割回文串-II" class="headerlink" title="132_分割回文串_II"></a>132_分割回文串_II</h2><ul>
<li>切割的次数最少，直接递归加回溯的话，第一个可行解一般是都切成一个一个字符；难道要按次数循环嘛？或者按次数递归？</li>
<li>按次数循环，超出时间限制了…这种算法应该是暴力求解，还是用递归可能有效</li>
<li>递归也超时了….</li>
<li>难道要先找出最长的回文字串？再依次处理剩下的？</li>
<li>不，你需要动态规划，<code>g[i][j]</code>一般而言<code>i&lt;j</code>，难怪<code>i&gt;=j</code>时，一定是回文串，因为是空字符串或者就一个字符</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//动态规划</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minCut(string s) &#123;</span><br><span class="line">        int n = s.size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; g(n, vector&lt;int&gt;(n, true));</span><br><span class="line"></span><br><span class="line">        for (int i = n - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">            for (int j = i + 1; j &lt; n; ++j) &#123;</span><br><span class="line">                g[i][j] = (s[i] == s[j]) &amp;&amp; g[i + 1][j - 1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt; f(n, INT_MAX);</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            if (g[0][i]) &#123;</span><br><span class="line">                f[i] = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                for (int j = 0; j &lt; i; ++j) &#123;</span><br><span class="line">                    if (g[j + 1][i]) &#123;</span><br><span class="line">                        f[i] = min(f[i], f[j] + 1);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return f[n - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    string s(&quot;ababababababababababa&quot;);</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.minCut(s) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139_单词拆分"></a>139_单词拆分</h2><ul>
<li>这题与之前的字典题好像，不知道需不需要构图；</li>
<li>第一步在字典中找到所有与原字符串吻合的字串？然后拼接？字典中某个单词可重复使用…</li>
<li>不能拼接，每找一个，都要拆成两个部分，再分别判断；但是超出时间限制了</li>
<li>每次找到一个单词时，都需要将两边拆开，那如果有多个重复的呢？那就把所有重复的去掉，剩下来的单词放在数组里？？</li>
<li>上面思路是暴力求解，时间消耗倒数；以后遇到字符串，多想想动态规划</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;unordered_set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123;</span><br><span class="line">        auto wordDictSet = unordered_set &lt;string&gt; ();</span><br><span class="line">        for (auto &amp;word: wordDict) &#123;</span><br><span class="line">            wordDictSet.insert(word);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        auto dp = vector &lt;bool&gt; (s.size() + 1);</span><br><span class="line">        dp[0] = true;</span><br><span class="line">        for (int i = 1; i &lt;= s.size(); ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; i; ++j) &#123;</span><br><span class="line">                if (dp[j] &amp;&amp; wordDictSet.find(s.substr(j, i - j)) != wordDictSet.end()) &#123;</span><br><span class="line">                    dp[i] = true;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[s.size()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string s(&quot;catsandog&quot;);</span><br><span class="line">    vector&lt;string&gt; wordDict(&#123;&quot;cats&quot;,&quot;dog&quot;,&quot;sand&quot;,&quot;and&quot;,&quot;cat&quot;&#125;);</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.wordBreak(s, wordDict) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="140-单词拆分-ll"><a href="#140-单词拆分-ll" class="headerlink" title="140_单词拆分_ll"></a>140_单词拆分_ll</h2><ul>
<li>想起了被分割回文串支配的恐惧</li>
<li>这个不用构图，顺着字符一个一个来就行；还好，接着就直接往下递归</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;unordered_set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    unordered_set&lt;string&gt; set;</span><br><span class="line">    string w;</span><br><span class="line">    void dfs(string &amp;s)&#123;</span><br><span class="line">        if(s.empty())&#123;</span><br><span class="line">            res.emplace_back(w);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i = 1; i &lt;= s.size(); ++i)&#123;</span><br><span class="line">            if(set.find(s.substr(0, i)) != set.end())&#123;</span><br><span class="line">                string ww(w);</span><br><span class="line">                w += string(&quot; &quot;);</span><br><span class="line">                w += s.substr(0, i);</span><br><span class="line">                string tmp(s.substr(i, s.size()));</span><br><span class="line">                dfs(tmp);</span><br><span class="line">                w = ww; //回溯后这里要还原</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;string&gt; wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123;</span><br><span class="line">        for(const auto &amp; word : wordDict)</span><br><span class="line">            set.insert(word);</span><br><span class="line"></span><br><span class="line">        //两个都是非空</span><br><span class="line">        for(int i = 1; i &lt;= s.size(); ++i)&#123;</span><br><span class="line">            if(set.find(s.substr(0, i)) != set.end())&#123;</span><br><span class="line">                w = s.substr(0, i);</span><br><span class="line">                string tmp(s.substr(i, s.size()));</span><br><span class="line">                dfs(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    string s(&quot;catsanddog&quot;);</span><br><span class="line">    vector&lt;string&gt; wordDict(&#123;&quot;cat&quot;, &quot;cats&quot;, &quot;and&quot;, &quot;sand&quot;, &quot;dog&quot;&#125;);</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;string&gt; res = solution.wordBreak(s, wordDict);</span><br><span class="line">    for(const auto &amp; re : res)</span><br><span class="line">        cout &lt;&lt; re &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="151-翻转字符串里的单词"><a href="#151-翻转字符串里的单词" class="headerlink" title="151_翻转字符串里的单词"></a>151_翻转字符串里的单词</h2><ul>
<li>要考虑边界的问题，很容易想到从后往前遍历；然后记录一个单词头尾的位置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string reverseWords(string s) &#123;</span><br><span class="line">        if(s.empty()) return string();</span><br><span class="line">        int l = s.size();</span><br><span class="line">        string ans;</span><br><span class="line">        bool isSeen = false;</span><br><span class="line">        int pos = -1;</span><br><span class="line">        for(int i = l - 1; i &gt;= 0; --i)&#123;</span><br><span class="line">            if(s[i] == &apos; &apos;)&#123;</span><br><span class="line">                if(isSeen)&#123;</span><br><span class="line">                    if(!ans.empty())</span><br><span class="line">                        ans.push_back(&apos; &apos;);</span><br><span class="line"></span><br><span class="line">                    ans += s.substr(i + 1, pos - i);</span><br><span class="line">                    isSeen = false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                if(!isSeen)</span><br><span class="line">                    pos = i;</span><br><span class="line">                isSeen = true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        if(s[0] != &apos; &apos;)&#123;</span><br><span class="line">            if(!ans.empty())</span><br><span class="line">                ans.push_back(&apos; &apos;);</span><br><span class="line">            ans += s.substr(0, pos + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string s(&quot;  hello world!  &quot;);</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.reverseWords(s) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="165-比较版本号"><a href="#165-比较版本号" class="headerlink" title="165_比较版本号"></a>165_比较版本号</h2><ul>
<li>两个链表相加那题，<code>while</code>条件里是或；只要有一个不为空即可；这样简洁了代码，只需一个<code>while</code>即可</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int compareVersion(string version1, string version2) &#123;</span><br><span class="line">        int v1_l = 0, v1_r = 0;</span><br><span class="line">        int v2_l = 0, v2_r = 0;</span><br><span class="line">        int ans1 = 0, ans2 = 0;</span><br><span class="line">        while(v1_r &lt; version1.size() || v2_r &lt; version2.size())&#123;</span><br><span class="line">            ans1 = 0;</span><br><span class="line">            ans2 = 0;</span><br><span class="line">            //v1_r</span><br><span class="line">            while(v1_r &lt; version1.size() &amp;&amp; version1[v1_r] != &apos;.&apos;)&#123;</span><br><span class="line">                ++v1_r;</span><br><span class="line">            &#125;</span><br><span class="line">            if(v1_r == version1.size())&#123;</span><br><span class="line">                if(v1_l == v1_r)</span><br><span class="line">                    ans1 = 0;</span><br><span class="line">                else&#123;</span><br><span class="line">                    ans1 = stoi(version1.substr(v1_l, v1_r - v1_l));</span><br><span class="line">                    v1_l = v1_r;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;  //version1[v1_r] == &apos;.&apos;</span><br><span class="line">                ans1 = stoi(version1.substr(v1_l, v1_r - v1_l));</span><br><span class="line">                ++v1_r;</span><br><span class="line">                v1_l = v1_r;</span><br><span class="line">            &#125;</span><br><span class="line">            //cout &lt;&lt; &quot;v1: &quot; &lt;&lt; endl;</span><br><span class="line">            //cout &lt;&lt; &quot;ans1 = &quot; &lt;&lt; ans1 &lt;&lt; &quot;   l = &quot; &lt;&lt; v1_l &lt;&lt; &quot; r = &quot; &lt;&lt; v1_r &lt;&lt; endl;</span><br><span class="line">            //v2_r</span><br><span class="line">            while(v2_r &lt; version2.size() &amp;&amp; version2[v2_r] != &apos;.&apos;)&#123;</span><br><span class="line">                ++v2_r;</span><br><span class="line">            &#125;</span><br><span class="line">            if(v2_r == version2.size())&#123;</span><br><span class="line">                if(v2_l == v2_r)</span><br><span class="line">                    ans2 = 0;</span><br><span class="line">                else&#123;</span><br><span class="line">                    ans2 = stoi(version2.substr(v2_l, v2_r - v2_l));</span><br><span class="line">                    v2_l = v2_r;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;  //version1[v2_r] == &apos;.&apos;</span><br><span class="line">                ans2 = stoi(version2.substr(v2_l, v2_r - v2_l));</span><br><span class="line">                ++v2_r;</span><br><span class="line">                v2_l = v2_r;</span><br><span class="line">            &#125;</span><br><span class="line">            /*cout &lt;&lt; &quot;v2: &quot; &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; &quot;ans2 = &quot; &lt;&lt; ans2 &lt;&lt; &quot;   l = &quot; &lt;&lt; v2_l &lt;&lt; &quot; r = &quot; &lt;&lt; v2_r &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; &quot;--------&quot; &lt;&lt; endl;*/</span><br><span class="line">            //比较结果</span><br><span class="line">            if(ans1 &lt; ans2)</span><br><span class="line">                return -1;</span><br><span class="line">            if(ans1 &gt; ans2)</span><br><span class="line">                return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="166-分数到小数"><a href="#166-分数到小数" class="headerlink" title="166_分数到小数"></a>166_分数到小数</h2><ul>
<li>我在犹豫这题要不要放在整数边界里….</li>
<li>因为<code>int</code>最小值比最大值少一个，所以可先记录结果符号，再将其余的数都转为负数；这里里的<code>intPart</code>要用<code>long long</code>类型，不然，又会出现整数边界问题</li>
<li>哦对，思路是小学数学里的长除法…</li>
<li>记录出现的重复数字可以不一定是<code>unordered_map</code>，字符串也可以直接寻找…</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string fractionToDecimal(int numerator, int denominator) &#123;</span><br><span class="line">        if(numerator == 0) return &quot;0&quot;;</span><br><span class="line">        bool pot = false, repeat = false, symbol = false;</span><br><span class="line">        if((numerator &lt; 0 &amp;&amp; denominator &gt; 0) || (numerator &gt; 0 &amp;&amp; denominator &lt; 0))&#123;</span><br><span class="line">            symbol = true;</span><br><span class="line">        &#125;</span><br><span class="line">        numerator = numerator &lt; 0 ? numerator : numerator * (-1);</span><br><span class="line">        denominator = denominator &lt; 0 ? denominator : denominator * (-1);</span><br><span class="line">        int pos = -1;</span><br><span class="line"></span><br><span class="line">        long long numerator_ = numerator;</span><br><span class="line"></span><br><span class="line">        while (numerator_ != 0)&#123;</span><br><span class="line">//            cout &lt;&lt; &quot;ans = &quot; &lt;&lt; ans &lt;&lt; &quot;  numerator = &quot; &lt;&lt; numerator &lt;&lt; endl;</span><br><span class="line">            //计算整数部分</span><br><span class="line">            long long intPart = numerator_ / denominator;</span><br><span class="line">            //ans为空</span><br><span class="line">            if(ans.empty())&#123;</span><br><span class="line">//                cout &lt;&lt; &quot;intPart = &quot; &lt;&lt; intPart &lt;&lt; endl;</span><br><span class="line">                if(symbol)</span><br><span class="line">                    ans.append(&quot;-&quot;);</span><br><span class="line">                ans.append(to_string(intPart));</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                //ans不为空，说明肯定有小数点了，之后判断重复</span><br><span class="line">                //如果重复了</span><br><span class="line">                if(numRecord.find(numerator_) != numRecord.end())&#123;</span><br><span class="line">//                    cout &lt;&lt; numerator &lt;&lt; &quot; repeat!&quot; &lt;&lt; endl;</span><br><span class="line">                    repeat = true;</span><br><span class="line">                    pos = numRecord[numerator_];</span><br><span class="line">                    break;</span><br><span class="line">                &#125;else</span><br><span class="line">                    //如果不重复</span><br><span class="line">                    ans.append(to_string(intPart));</span><br><span class="line">            &#125;</span><br><span class="line">            //放置小数点之后开始记录分子值，先记录再更新numerator！</span><br><span class="line">            if(pot)</span><br><span class="line">                numRecord[numerator_] = static_cast&lt;int&gt;(ans.size()) - 1;</span><br><span class="line">            //小数部分 这里会超出整数边界</span><br><span class="line">            numerator_ = 10 * (numerator_ % denominator);</span><br><span class="line">            if(numerator_ != 0 &amp;&amp; !pot)&#123;</span><br><span class="line">                ans.append(&quot;.&quot;);</span><br><span class="line">                pot = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(repeat)&#123;</span><br><span class="line">            ans.insert(pos, 1, &apos;(&apos;);</span><br><span class="line">            ans.append(&quot;)&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    string ans;</span><br><span class="line">    unordered_map&lt;int, int&gt; numRecord;  //key保存分子的值，value保存当前整数部分字符串的位置</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int numerator = -2147483648, denominator = 1;</span><br><span class="line">    Solution solution;</span><br><span class="line">    string ans = solution.fractionToDecimal(numerator, denominator);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="168-Excel表列名称"><a href="#168-Excel表列名称" class="headerlink" title="168_Excel表列名称"></a>168_Excel表列名称</h2><ul>
<li>26进制转换，总感觉哪里怪怪的，其余二进制、八进制、十六进制都是从0开始计数的，26进制是从1开始计数，差点整不会了</li>
<li>不停的计算出余数，因为不管你有多少个26，最后一位肯定在0-26之间，而这个余数就是最后一位</li>
<li>也就是不停的在头部放入字符，之后再更新剩下来的值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string convertToTitle(int columnNumber) &#123;</span><br><span class="line">        //26进制，应该比较简单</span><br><span class="line">        vector&lt;string&gt; tmp(&#123;&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;,&quot;H&quot;,&quot;I&quot;,&quot;J&quot;,&quot;K&quot;,&quot;L&quot;,&quot;M&quot;,&quot;N&quot;,&quot;O&quot;,&quot;P&quot;,&quot;Q&quot;</span><br><span class="line">                                   ,&quot;R&quot;,&quot;S&quot;,&quot;T&quot;,&quot;U&quot;,&quot;V&quot;,&quot;W&quot;,&quot;X&quot;,&quot;Y&quot;,&quot;Z&quot;&#125;);</span><br><span class="line">        string ans;</span><br><span class="line">        while (columnNumber &gt; 0)&#123;</span><br><span class="line">            //余数</span><br><span class="line">            int remainder = columnNumber % 26;</span><br><span class="line">            string s(ans);</span><br><span class="line">            ans.clear();</span><br><span class="line">            if(remainder == 0)&#123;</span><br><span class="line">                ans.append(tmp.back());</span><br><span class="line">                ans += s;</span><br><span class="line">                if(columnNumber == 26)</span><br><span class="line">                    break;</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                ans.append(tmp[remainder - 1]);</span><br><span class="line">                ans += s;</span><br><span class="line">            &#125;</span><br><span class="line">            columnNumber = (columnNumber - remainder) / 26;</span><br><span class="line">//            cout &lt;&lt; &quot;columnNumber = &quot; &lt;&lt; columnNumber &lt;&lt; endl;</span><br><span class="line">            if(remainder == 0)</span><br><span class="line">                columnNumber -= 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int columnNumber = 51;</span><br><span class="line">    Solution solution;</span><br><span class="line">    string ans = solution.convertToTitle(columnNumber);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二刷-9"><a href="#二刷-9" class="headerlink" title="二刷"></a>二刷</h3><ul>
<li>记得当时数字1<del>26和0</del>25有点傻傻分不清<ul>
<li>52对应AZ，即26*1+26，和一般的进制相比，最后一位数其实应该小于26才对</li>
<li>要看是否是26的倍数，如果是应该添加26对应的字母而不是0对应的字母</li>
<li>但是<code>string</code>的<code>insert()</code>函数报错，说是没有这个函数？噢，必须要有三个参数<ul>
<li><code>string&amp; insert (size_t pos, const char* s, size_t n);</code>以及<code>string&amp; insert (size_t pos, const char* s);</code>里面的字符参数是指针，而数组下标的是引用</li>
<li>应该是这个<code>string&amp; insert (size_t pos,   size_t n, char c);</code></li>
</ul>
</li>
</ul>
</li>
<li>看了题解才发现，直接用<code>n + &#39;A&#39;</code>来代替数组！！</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//二刷手撕</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string convertToTitle(int columnNumber) &#123;</span><br><span class="line">        //1对应A、26对应Z、52对应AZ</span><br><span class="line">        string ans;</span><br><span class="line">        vector&lt;char&gt; tmp = &#123;&apos; &apos;,&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;,&apos;F&apos;,&apos;G&apos;,&apos;H&apos;,</span><br><span class="line">                            &apos;I&apos;,&apos;J&apos;,&apos;K&apos;,&apos;L&apos;,&apos;M&apos;,&apos;N&apos;,&apos;O&apos;,&apos;P&apos;,&apos;Q&apos;,</span><br><span class="line">                            &apos;R&apos;,&apos;S&apos;,&apos;T&apos;,&apos;U&apos;,&apos;V&apos;,&apos;W&apos;,&apos;X&apos;,&apos;Y&apos;,&apos;Z&apos;&#125;;</span><br><span class="line">        while(columnNumber &gt; 0)&#123;</span><br><span class="line">            //是否是26的倍数</span><br><span class="line">            if(columnNumber % 26 == 0)&#123;</span><br><span class="line">                ans.insert(0, 1, tmp[26]);</span><br><span class="line">                //这里相当于右移</span><br><span class="line">                columnNumber = (columnNumber - 26) / 26;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                //看“个位数”</span><br><span class="line">                int n = columnNumber % 26;</span><br><span class="line">                ans.insert(0, 1, tmp[n]);</span><br><span class="line">                //注意这里要减去n</span><br><span class="line">                columnNumber = (columnNumber - n) / 26;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//题解</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string convertToTitle(int columnNumber) &#123;</span><br><span class="line">        string ans;</span><br><span class="line">        while (columnNumber &gt; 0) &#123;</span><br><span class="line">            //这里就无需判断余数是否为0了</span><br><span class="line">            int a0 = (columnNumber - 1) % 26 + 1;</span><br><span class="line">            //这里优先级不会冲突吗——不冲突</span><br><span class="line">            ans += a0 - 1 + &apos;A&apos;;</span><br><span class="line">            columnNumber = (columnNumber - a0) / 26;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(ans.begin(), ans.end());</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="171-Excel表列序号"><a href="#171-Excel表列序号" class="headerlink" title="171_Excel表列序号"></a>171_Excel表列序号</h2><ul>
<li>小试身手下：）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    //可以不用哈希数来记录字母</span><br><span class="line">    int titleToNumber(string columnTitle) &#123;</span><br><span class="line">        /*unordered_map&lt;char, int&gt; map;</span><br><span class="line">        int i = 1;</span><br><span class="line">        for(char c = &apos;A&apos;; c &lt;= &apos;Z&apos;; ++c)&#123;</span><br><span class="line">            map[c] = i++;</span><br><span class="line">        &#125;*/</span><br><span class="line">        int ans = 0;</span><br><span class="line">        for(auto c : columnTitle)&#123;</span><br><span class="line">            ans *= 26;</span><br><span class="line">            ans += (c - &apos;A&apos; + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二刷-10"><a href="#二刷-10" class="headerlink" title="二刷"></a>二刷</h3><ul>
<li>有句话怎么说来着，得心应手<ul>
<li>有个小问题，<code>ans</code> 应该是 <code>long long</code> 类型，不然有可能会超出整数边界</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int titleToNumber(string columnTitle) &#123;</span><br><span class="line">        // 先手撕，再做笔记；记得先减一再加一好像</span><br><span class="line">        // 还有不需要事先用数组记录大写的字母</span><br><span class="line">        if(columnTitle.empty()) return -1;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        // 正序遍历</span><br><span class="line">        for(auto ch : columnTitle)&#123;</span><br><span class="line">            int num = ch - &apos;A&apos; + 1;</span><br><span class="line">            ans = ans * 26 + num;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="179-最大数"><a href="#179-最大数" class="headerlink" title="179_最大数"></a>179_最大数</h2><ul>
<li>好家伙，自定义排序用<code>sort()</code>+<code>lamda</code>匿名函数！！！</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;iterator&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution_ &#123;</span><br><span class="line">public:</span><br><span class="line">    //与计数排序还是基数排序来着有点像，之前是先比较个位数，在比较十位数，以此类推</span><br><span class="line">    //这次应该是先比较每个元素的第一位数字，再往后推，这个方法似乎行不通</span><br><span class="line">    //比如3，31；应该是331最大而不是313  3，35；应该是353最大而不是335</span><br><span class="line">    //还是应该首字母相同的进行比较</span><br><span class="line"></span><br><span class="line">    bool smaller(string lhs, string rhs)&#123;</span><br><span class="line">//        cout &lt;&lt; &quot;lhs = &quot; &lt;&lt; lhs &lt;&lt; &quot; rhs = &quot; &lt;&lt; rhs &lt;&lt; endl;</span><br><span class="line">        if(rhs.empty()) return false;</span><br><span class="line">        if(lhs.empty()) return true;</span><br><span class="line">        string l = lhs + rhs;</span><br><span class="line">        string r = rhs + lhs;</span><br><span class="line">        return l &lt; r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string largestNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        //选择排序</span><br><span class="line">        if(nums.empty()) return string();</span><br><span class="line">        vector&lt;string&gt; nums_str;</span><br><span class="line">        nums_str.reserve(nums.size());</span><br><span class="line">        for(auto t : nums)</span><br><span class="line">            nums_str.emplace_back(to_string(t));</span><br><span class="line"></span><br><span class="line">        for(int i = 0; i &lt; nums_str.size() - 1; ++i)&#123;</span><br><span class="line">//            cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">            int tmp = i;</span><br><span class="line">            for(int j = i + 1; j &lt; nums_str.size(); ++j)&#123;</span><br><span class="line">//                cout &lt;&lt; &quot;j = &quot; &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">                if(smaller(nums_str[j], nums_str[tmp]))</span><br><span class="line">                    tmp = j;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">//            cout &lt;&lt; &quot;min = &quot; &lt;&lt; nums_str[tmp] &lt;&lt; endl;</span><br><span class="line">            swap(nums_str[i], nums_str[tmp]);</span><br><span class="line"></span><br><span class="line">            /*copy(nums_str.begin(), nums_str.end(), ostream_iterator&lt;string&gt;(cout, &quot; &quot;));</span><br><span class="line">            cout &lt;&lt; endl;*/</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        string ans;</span><br><span class="line">        for(int i = nums_str.size(); i &gt; 0; --i)&#123;</span><br><span class="line">            ans += nums_str[i - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        while (ans[0] == &apos;0&apos; &amp;&amp; ans.size() &gt; 1)&#123;</span><br><span class="line">            ans.erase(0, 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string largestNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;string&gt; v;</span><br><span class="line">        for(int t:nums) v.push_back(to_string(t));</span><br><span class="line">        sort(v.begin(), v.end(), [](const string &amp;a,const string &amp;b)&#123;</span><br><span class="line">            return a+b &gt; b+a; //两个字符串先后组合大小降序排列</span><br><span class="line">        &#125;);</span><br><span class="line">        if(v[0]==&quot;0&quot;) return &quot;0&quot;;</span><br><span class="line">        string ans=&quot;&quot;;</span><br><span class="line">        for(string t:v) ans+=t;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; nums = &#123;432, 43243&#125;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    string ans = solution.largestNumber(nums);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="205-同构字符串"><a href="#205-同构字符串" class="headerlink" title="205_同构字符串"></a>205_同构字符串</h2><ul>
<li>每个字母不一定距离一样，但同一个字母距离必须一样；距离就是映射到另一个字母与原字母的差值</li>
<li>既然如此，那就<code>map</code>大法好；试了下，得要两个<code>map</code>，因为两个字符串是等价的，你能来，我也能去</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isIsomorphic(string s, string t) &#123;</span><br><span class="line">        unordered_map&lt;char, int&gt; map;</span><br><span class="line">        unordered_map&lt;char, int&gt; map1;</span><br><span class="line"></span><br><span class="line">        for(int i = 0; i &lt; s.size(); ++i)&#123;</span><br><span class="line">            // s -&gt; t</span><br><span class="line">            if(map.find(s[i]) == map.end())</span><br><span class="line">                map[s[i]] = s[i] - t[i];</span><br><span class="line">            else&#123;</span><br><span class="line">                if(map[s[i]] != s[i] - t[i])</span><br><span class="line">                    return false;</span><br><span class="line">            &#125;</span><br><span class="line">            // t -&gt; s</span><br><span class="line">            if(map1.find(t[i]) == map1.end())</span><br><span class="line">                map1[t[i]] = t[i] - s[i];</span><br><span class="line">            else&#123;</span><br><span class="line">                if(map1[t[i]] != t[i] - s[i])</span><br><span class="line">                    return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//大佬</span><br><span class="line">class Solution_ &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isIsomorphic(string s, string t) &#123;</span><br><span class="line">        for(int i=0; i&lt;s.length(); i++)&#123;</span><br><span class="line">            if(s.find(s[i])!=t.find(t[i])) return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    string s(&quot;badc&quot;), t(&quot;baba&quot;);</span><br><span class="line">    Solution solution;</span><br><span class="line">    bool ans = solution.isIsomorphic(s, t);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="214-最短回文串"><a href="#214-最短回文串" class="headerlink" title="214_最短回文串"></a>214_最短回文串</h2><ul>
<li>用动态规划的第一层循环要从后往前，不然会出现初始化边界问题</li>
<li>这题思路对的，就是找到从起始位置开始的最长回文串，枚举法以及之前分割回文串的动态规划的时间复杂度都是<code>O(n²)</code>，会超出时间限制</li>
<li>一次学到这么多新的算法，还真有点吃不消</li>
<li>先将KMP算法搞懂再说，这题码一下，以后有机会再看</li>
<li>KMP算法比字符串哈希还要快</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;iterator&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">// KMP algorithm</span><br><span class="line">class Solution_ &#123;</span><br><span class="line">public:</span><br><span class="line">    string shortestPalindrome(string s) &#123;</span><br><span class="line">        int n = static_cast&lt;int&gt;(s.size());</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt; fail(n, -1);</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">            int j = fail[i - 1];</span><br><span class="line"></span><br><span class="line">            while (j != -1 &amp;&amp; s[j + 1] != s[i]) &#123;</span><br><span class="line">                j = fail[j];</span><br><span class="line">            &#125;</span><br><span class="line">            if (s[j + 1] == s[i]) &#123;</span><br><span class="line">                fail[i] = j + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int best = -1;</span><br><span class="line">        for (int i = n - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">            while (best != -1 &amp;&amp; s[best + 1] != s[i]) &#123;</span><br><span class="line">                best = fail[best];</span><br><span class="line">            &#125;</span><br><span class="line">            if (s[best + 1] == s[i]) &#123;</span><br><span class="line">                ++best;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        string add = (best == n - 1 ? &quot;&quot; : s.substr(best + 1, n));</span><br><span class="line">        reverse(add.begin(), add.end());</span><br><span class="line">        return add + s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//字符串哈希</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string shortestPalindrome(string s) &#123;</span><br><span class="line">        int n = s.size();</span><br><span class="line">        int base = 131, mod = 1000000007;</span><br><span class="line">        int left = 0, right = 0, mul = 1;</span><br><span class="line">        int best = -1;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            left = ((long long)left * base + s[i]) % mod;</span><br><span class="line">            right = (right + (long long)mul * s[i]) % mod;</span><br><span class="line">            if (left == right) &#123;</span><br><span class="line">                best = i;</span><br><span class="line">            &#125;</span><br><span class="line">            mul = (long long)mul * base % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        string add = (best == n - 1 ? &quot;&quot; : s.substr(best + 1, n));</span><br><span class="line">        reverse(add.begin(), add.end());</span><br><span class="line">        return add + s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string s = &quot;aacecaaa&quot;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    string ans = solution.shortestPalindrome(s);</span><br><span class="line">    cout &lt;&lt; &quot;ans = &quot; &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="224-基本计算器"><a href="#224-基本计算器" class="headerlink" title="224_基本计算器"></a>224_基本计算器</h2><ul>
<li>想到用栈，但感觉要考虑的东西很多</li>
<li>题解的方法相当于一层一层的将括号去掉，在顺序遍历的同时；妙哇</li>
</ul>
<p><img src="/pictrues/224.png" alt="符号更新" title="符号更新"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int calculate(string s) &#123;</span><br><span class="line">        stack&lt;int&gt; ops;</span><br><span class="line">        ops.push(1);</span><br><span class="line">        int sign = 1;</span><br><span class="line"></span><br><span class="line">        int ret = 0;</span><br><span class="line">        int n = static_cast&lt;int&gt;(s.length());</span><br><span class="line">        int i = 0;</span><br><span class="line">        //这样写，很方便计算连着的数字之间有空格，也不对，如果有空格long num = 0重新初始化了</span><br><span class="line">        while (i &lt; n) &#123;</span><br><span class="line">            if (s[i] == &apos; &apos;) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; else if (s[i] == &apos;+&apos;) &#123;</span><br><span class="line">                sign = ops.top();</span><br><span class="line">                i++;</span><br><span class="line">            &#125; else if (s[i] == &apos;-&apos;) &#123;</span><br><span class="line">                sign = -ops.top();</span><br><span class="line">                i++;</span><br><span class="line">            &#125; else if (s[i] == &apos;(&apos;) &#123;</span><br><span class="line">                //这里放进去，把括号当成一个数字，主要考虑了括号前的符号</span><br><span class="line">                ops.push(sign);</span><br><span class="line">                i++;</span><br><span class="line">            &#125; else if (s[i] == &apos;)&apos;) &#123;</span><br><span class="line">                ops.pop();</span><br><span class="line">                i++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                long num = 0;</span><br><span class="line">                while (i &lt; n &amp;&amp; s[i] &gt;= &apos;0&apos; &amp;&amp; s[i] &lt;= &apos;9&apos;) &#123;</span><br><span class="line">                    num = num * 10 + (s[i] - &apos;0&apos;);</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                //遇到数字就会’加‘进答案里</span><br><span class="line">                ret += sign * num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string s = &quot;(1+(4+5+2)-3)+(6+8)&quot;;</span><br><span class="line">    Solution solution;</span><br><span class="line">    int ans = solution.calculate(s);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="227-基本计算器-II"><a href="#227-基本计算器-II" class="headerlink" title="227_基本计算器_II"></a>227_基本计算器_II</h2><ul>
<li>没想到居然通过了，思路是遇到一个数字先存着，要将正负号一起相乘再存，然后遇到乘除就找出下一个数与前一个数相乘，再存着，最后确保栈里所有的数字能够直接相加即可</li>
<li>当然前提是整个字符串是有效的、看到逆波兰式我就知道我忘光光了</li>
<li>逆波兰式——看了好一会，就是将数字压入栈，遇到符号就弹出两个数字（要注意顺序）进行对应的运算，运算结果再压入栈，最后栈中只剩一个数字就是最终答案</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int calculate(string s) &#123;</span><br><span class="line">        //这里乘除代替了括号...还要考虑连着的数字</span><br><span class="line">        int n = static_cast&lt;int&gt;(s.size());</span><br><span class="line">        int i = 0, sign = 1;</span><br><span class="line">        stack&lt;long long&gt; stk;</span><br><span class="line"></span><br><span class="line">        //遇到一个数字，不应该直接加，而是看后面有没有乘除符号</span><br><span class="line">        while(i &lt; n)&#123;</span><br><span class="line">            //cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">            if(s[i] == &apos; &apos;) &#123;</span><br><span class="line">                ++i;</span><br><span class="line"></span><br><span class="line">            &#125;else if(s[i] == &apos;+&apos; || s[i] == &apos;-&apos;)&#123;</span><br><span class="line">                //遇到加减，就先把之前的和累加</span><br><span class="line">                sign = (s[i] == &apos;-&apos; ? -1 : 1);</span><br><span class="line">                ++i;</span><br><span class="line"></span><br><span class="line">            &#125;else if(isdigit(s[i]))&#123;</span><br><span class="line">                //这里把所有连着的数字解出来</span><br><span class="line">                long long num = s[i] - &apos;0&apos;;</span><br><span class="line">                while(isdigit(s[++i]))&#123;</span><br><span class="line">                    num = num * 10 + s[i] - &apos;0&apos;;</span><br><span class="line">                &#125;</span><br><span class="line">                //cout &lt;&lt; &quot;num = &quot; &lt;&lt; num * sign &lt;&lt; endl;</span><br><span class="line">                stk.push(num * sign);</span><br><span class="line"></span><br><span class="line">            &#125; else if(s[i] == &apos;*&apos; || s[i] == &apos;/&apos;)&#123;</span><br><span class="line">                auto tmp = s[i];</span><br><span class="line">                auto pre = stk.top();</span><br><span class="line">                stk.pop();</span><br><span class="line">                //cout &lt;&lt; &quot;pre = &quot; &lt;&lt; pre &lt;&lt; endl;</span><br><span class="line">                //这里需要找到下一个数字</span><br><span class="line">                ++i;</span><br><span class="line">                while(s[i] == &apos; &apos;)&#123;</span><br><span class="line">                    ++i;</span><br><span class="line">                &#125;</span><br><span class="line">                //s[i]现在是数字</span><br><span class="line">                long long num = s[i] - &apos;0&apos;;</span><br><span class="line">                while(isdigit(s[++i]))&#123;</span><br><span class="line">                    num = num * 10 + s[i] - &apos;0&apos;;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if(tmp == &apos;*&apos;)&#123;</span><br><span class="line">                    stk.push(pre * num);</span><br><span class="line">                &#125;</span><br><span class="line">                if(tmp == &apos;/&apos;)&#123;</span><br><span class="line">                    stk.push(pre / num);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //栈里面应该都是有正负的数字</span><br><span class="line">        int ans = 0;</span><br><span class="line">        cout &lt;&lt; &quot;stk = &quot;;</span><br><span class="line">        while(!stk.empty())&#123;</span><br><span class="line">            cout &lt;&lt; stk.top() &lt;&lt; &quot; &quot;;</span><br><span class="line">            ans += static_cast&lt;int&gt;(stk.top());</span><br><span class="line">            stk.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    string s = &quot;3+2*2&quot;; //(&apos;+&apos;, &apos;-&apos;, &apos;*&apos;, &apos;/&apos;)</span><br><span class="line">    Solution solution;</span><br><span class="line">    int ans = solution.calculate(s);</span><br><span class="line">    cout &lt;&lt; &quot;ans = &quot; &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="241-为运算表达式设计优先级"><a href="#241-为运算表达式设计优先级" class="headerlink" title="241_为运算表达式设计优先级"></a>241_为运算表达式设计优先级</h2><ul>
<li>这题…用递归？？</li>
<li>居然没有官方题解——分治！</li>
<li>好像分治就是递归啊；每找到一个运算符，就分治成左边与右边（直接调用自己）；因为每个运算符两边一定是存在数字的；之后就是双重循环生成一个新的数组；考虑特殊情况，即最后数组为空，那就说明没有运算符，直接将字符串的数字放入数组</li>
<li>大佬写的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; diffWaysToCompute(string expression) &#123;</span><br><span class="line">        // 存储中间值</span><br><span class="line">        vector&lt;int&gt; count;</span><br><span class="line">        for(int i = 0; i &lt; expression.size(); i++) &#123;</span><br><span class="line">            char c = expression[i];</span><br><span class="line">            // 找到运算符</span><br><span class="line">            if(c == &apos;+&apos; || c == &apos;-&apos; || c == &apos;*&apos;) &#123;</span><br><span class="line">                // 运算符左边的运算结果</span><br><span class="line">                vector&lt;int&gt; left = diffWaysToCompute(expression.substr(0, i));</span><br><span class="line">                // 运算符右边的运算结果</span><br><span class="line">                vector&lt;int&gt; right = diffWaysToCompute(expression.substr(i + 1));</span><br><span class="line">                // 左右两边继续运算</span><br><span class="line">                for(int&amp; l : left) &#123;</span><br><span class="line">                    for(int&amp; r : right) &#123;</span><br><span class="line">                        switch(c) &#123;</span><br><span class="line">                            case &apos;+&apos;:</span><br><span class="line">                                count.push_back(l + r);</span><br><span class="line">                                break;</span><br><span class="line">                            case &apos;-&apos;:</span><br><span class="line">                                count.push_back(l - r);</span><br><span class="line">                                break;</span><br><span class="line">                            case &apos;*&apos;:</span><br><span class="line">                                count.push_back(l * r);</span><br><span class="line">                                break;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // count为空说明当前无运算符，只是单独的数字，直接放入count中</span><br><span class="line">        if(count.size() == 0) &#123;</span><br><span class="line">            count.push_back(stoi(expression));</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242_有效的字母异位词"></a>242_有效的字母异位词</h2><ul>
<li>排序思路写的和题解一模一样</li>
<li>对于哈希表，有个折中的思路，就是对于纯字母来说，一共26个，可以直接用长度为26的数组，而且只用一个，先记录<code>s</code>中，各个字母的个数，然后用另一个字符串做测试，在遍历的同时，将对应的数组元素减一，如果出现小于0，直接返回<code>false</code>；因为不存在的字母初始值就是0！！！</li>
<li>对于进阶问题，不一定是字母，也有可能是其他乱七八糟的符号，就直接用哈希表了，也是只用一个即可</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isAnagram(string s, string t) &#123;</span><br><span class="line">        if(s.size() != t.size())</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        sort(s.begin(), s.end());</span><br><span class="line">        sort(t.begin(), t.end());</span><br><span class="line"></span><br><span class="line">        return s == t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="273-整数转换英文表示"><a href="#273-整数转换英文表示" class="headerlink" title="273_整数转换英文表示"></a>273_整数转换英文表示</h2><ul>
<li>这题看着不难，就是有多个0时，不好判断（我是从后往前遍历），有这样的特例容易打乱思路——而且这题也花了不少时间！</li>
<li>直接看题解吧</li>
<li>看到分治，瞬间觉得我的思路就是暴力！——题解居然没有C++的！直接复制大佬的，题解的分治也是三个一组分开！</li>
<li>数组是真的方便</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//大佬写的</span><br><span class="line">class Solution &#123;</span><br><span class="line">    // 提前加好空格</span><br><span class="line">    vector&lt;string&gt; dict1 = &#123;&quot;Zero&quot;,     &quot; One&quot;,       &quot; Two&quot;,      &quot; Three&quot;,</span><br><span class="line">                            &quot; Four&quot;,    &quot; Five&quot;,      &quot; Six&quot;,      &quot; Seven&quot;,</span><br><span class="line">                            &quot; Eight&quot;,   &quot; Nine&quot;,      &quot; Ten&quot;,      &quot; Eleven&quot;,</span><br><span class="line">                            &quot; Twelve&quot;,  &quot; Thirteen&quot;,  &quot; Fourteen&quot;, &quot; Fifteen&quot;,</span><br><span class="line">                            &quot; Sixteen&quot;, &quot; Seventeen&quot;, &quot; Eighteen&quot;, &quot; Nineteen&quot;&#125;;</span><br><span class="line">    vector&lt;string&gt; dict2 = &#123;&quot; Twenty&quot;, &quot; Thirty&quot;, &quot; Forty&quot;,</span><br><span class="line">                            &quot; Fifty&quot;,  &quot; Sixty&quot;,  &quot; Seventy&quot;,</span><br><span class="line">                            &quot; Eighty&quot;, &quot; Ninety&quot;, &quot; Hundred&quot;&#125;;</span><br><span class="line">    vector&lt;string&gt; dict3 = &#123;&quot;&quot;,  // dict3[0]占位</span><br><span class="line">                            &quot; Thousand&quot;, &quot; Million&quot;, &quot; Billion&quot;&#125;;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    string numberToWords(int num) &#123;</span><br><span class="line">        if (num == 0) return dict1[0];  // 0, 特别处理</span><br><span class="line"></span><br><span class="line">        string str;</span><br><span class="line">        size_t i = 0;  // 10^3, ^6, ^9</span><br><span class="line">        while (num) &#123;  // 大于0时循环处理</span><br><span class="line">            string ts = getStringof3Nums(num % 1000);</span><br><span class="line">            if (!ts.empty())  // 返回空, 说明此3位全是0</span><br><span class="line">                str.assign(ts.append(dict3[i]) + str);</span><br><span class="line">            num /= 1000;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return str.substr(1);  // 去掉最前面的空格</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * @brief 3个数一组进行处理</span><br><span class="line">     *</span><br><span class="line">     * @param n</span><br><span class="line">     * @return string</span><br><span class="line">     */</span><br><span class="line">    string getStringof3Nums(int n) &#123;  // 1000</span><br><span class="line">        string str = &quot;&quot;;</span><br><span class="line">        // 处理百位</span><br><span class="line">        if (n / 100) str += dict1[n / 100] + dict2[8];</span><br><span class="line">        n %= 100;</span><br><span class="line">        if (n == 0) return str;</span><br><span class="line"></span><br><span class="line">        // 处理 0 &lt; n &lt;= 19</span><br><span class="line">        if (n &lt;= 19) return str += dict1[n];</span><br><span class="line"></span><br><span class="line">        // 处理20 &lt; n &lt; 99</span><br><span class="line">        str += dict2[n / 10 - 2];</span><br><span class="line">        if (n % 10) str += dict1[n % 10];</span><br><span class="line"></span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int num = 12345;</span><br><span class="line">    Solution solution;</span><br><span class="line">    string ans(solution.numberToWords(num));</span><br><span class="line">    cout &lt;&lt; &quot;ans = &quot; &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="282-给表达式添加运算符"><a href="#282-给表达式添加运算符" class="headerlink" title="282_给表达式添加运算符"></a>282_给表达式添加运算符</h2><ul>
<li><p>通过递归…应该是回溯，算出每一种情况，这并不难（每次都有四种选择）</p>
</li>
<li><p>最麻烦的在于数字0</p>
<ul>
<li>如果第一个就是0，那么后面只有放置运算符 </li>
<li>如果0前面紧挨着的是运算符，那么也只有在后面放置运算符！</li>
</ul>
</li>
<li><p>上面的问题解决后，测试的答案，为什么会有重复的？？黑人问号</p>
<ul>
<li>思考了半天——为什么要有循环呢，参数不是已经有了<code>pos</code>么，一直递归下去，<code>tmp</code>字符串也是会慢慢增加的；循环的话，从递归开始到结束，会进入下一个循环（没错，从第二个字符开始递归，而且之前的<code>tmp</code>没有弹出，只有排列组合才需循环！！）</li>
<li>怪不得，在递归位置加一的时候，有种违和感——直接<code>pos + 1</code>，写<code>i + 1</code>时，愣了一下…</li>
</ul>
</li>
<li><p>最终，还是有一个问题，那就是字符串超出<code>int</code>整数边界！不知道<code>long long</code>与<code>int</code>作比较会怎么样</p>
<ul>
<li>改成<code>long long</code>后，直接超出时间限制了…是写成死循环了，还是复杂度太高？</li>
</ul>
</li>
<li><p>题解没有C++版的——粘贴了一位大佬的，<code>function + Lambda</code>——用了一个变量来临时记录目前的运算总和</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;iterator&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//大佬写的</span><br><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; addOperators(string num, int target)</span><br><span class="line">    &#123;</span><br><span class="line">        int n = num.size();</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        string path = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">        std::function&lt;void(int, long long, long long)&gt; backtrace = [&amp;] (int idx, long long cur_res, long long pre_add)</span><br><span class="line">        &#123;</span><br><span class="line">            if (idx == n)</span><br><span class="line">            &#123;</span><br><span class="line">                if (cur_res == target)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(path);</span><br><span class="line">                    return ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            int pn = path.size();</span><br><span class="line">            for (int i = idx; i &lt; n; i ++)</span><br><span class="line">            &#123;</span><br><span class="line">                string x_str = num.substr(idx, i - idx + 1);</span><br><span class="line">                //这里改成long long 而不是int</span><br><span class="line">                long long x = stoll(x_str);</span><br><span class="line"></span><br><span class="line">                if (idx == 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    path += x_str;</span><br><span class="line">                    backtrace(i + 1, x, x);</span><br><span class="line">                    path.resize(pn);</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    path += &apos;+&apos; + x_str;</span><br><span class="line">                    backtrace(i + 1, cur_res + x, x);</span><br><span class="line">                    path.resize(pn);</span><br><span class="line"></span><br><span class="line">                    path += &apos;-&apos; + x_str;</span><br><span class="line">                    backtrace(i + 1, cur_res - x, -1 * x);</span><br><span class="line">                    path.resize(pn);</span><br><span class="line"></span><br><span class="line">                    path += &apos;*&apos; + x_str;</span><br><span class="line">                    backtrace(i + 1, cur_res - pre_add + pre_add * x, pre_add * x);</span><br><span class="line">                    path.resize(pn);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (x == 0)</span><br><span class="line">                    return ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        backtrace(0, 0, 0);</span><br><span class="line">        return res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string num(&quot;2147483648&quot;);</span><br><span class="line">    int target = -2147483648;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;string&gt; ans(solution.addOperators(num, target));</span><br><span class="line">    cout &lt;&lt; &quot; ans =  &quot;;</span><br><span class="line">    copy(ans.begin(), ans.end(), ostream_iterator&lt;string&gt;(cout, &quot; &quot;));</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="290-单词规律"><a href="#290-单词规律" class="headerlink" title="290_单词规律"></a>290_单词规律</h2><ul>
<li>感觉就是映射！遇到空格要跳过</li>
<li>容易出错的点<ul>
<li>映射是双向的，如果某个字符串已经对应了一个字符，那么其就不能再对应另一个字符了</li>
<li>还有，字符数与对应的以空格为间隔的字符串数目必须一样！</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">#include &lt;unordered_set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool wordPattern(string pattern, string s) &#123;</span><br><span class="line">        //开头再来一个补丁</span><br><span class="line">        if((pattern.empty() &amp;&amp; !s.empty()) || (!pattern.empty() &amp;&amp; s.empty()))</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        //截取单词，以空格为间隔——每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。</span><br><span class="line">        unordered_map&lt;char, string&gt; map;</span><br><span class="line">        unordered_set&lt;string&gt; set;</span><br><span class="line">        int i = 0, j = 0;</span><br><span class="line">        while(i &lt; pattern.size() &amp;&amp; j &lt; s.size())&#123;</span><br><span class="line">            //先取出对应的字符串</span><br><span class="line">            int pos = j;</span><br><span class="line">            //找出空格</span><br><span class="line">            while(s[pos] != &apos; &apos; &amp;&amp; pos &lt; s.size())&#123;</span><br><span class="line">                ++pos;</span><br><span class="line">            &#125;</span><br><span class="line">            //对应的字符串，这里的pos已经是空格所在的位置了，无需再加一</span><br><span class="line">            string tmp(s.substr(j, pos - j));</span><br><span class="line"></span><br><span class="line">            if(map.find(pattern[i]) == map.end())&#123;</span><br><span class="line">                //加之前，先判断是不是用过了</span><br><span class="line">                if(set.find(tmp) != set.end())</span><br><span class="line">                    return false;</span><br><span class="line">                set.insert(tmp);</span><br><span class="line">                pair&lt;char, string&gt; p = make_pair(pattern[i], tmp);</span><br><span class="line">                map.insert(p);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                if(map[pattern[i]] != tmp)&#123;</span><br><span class="line">//                    cout &lt;&lt; pattern[i] &lt;&lt; &quot; &quot; &lt;&lt; map[pattern[i]] &lt;&lt; &quot;!=&quot; &lt;&lt; tmp &lt;&lt; endl;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++i;</span><br><span class="line">            j = pos + 1;</span><br><span class="line">            //这里再加一个补丁</span><br><span class="line">            if((i &lt; pattern.size() &amp;&amp; j &gt;= s.size()) || (i &gt;= pattern.size() &amp;&amp; j &lt; s.size()))</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string pattern(&quot;abba&quot;), str(&quot;dog cat cat dog&quot;);</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.wordPattern(pattern, str) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="299-猜数字游戏"><a href="#299-猜数字游戏" class="headerlink" title="299_猜数字游戏"></a>299_猜数字游戏</h2><ul>
<li>直接用两个数组看看，不用哈希表了——可以，一次过！<ul>
<li>没有官方题解，其余思路差不多</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string getHint(string secret, string guess) &#123;</span><br><span class="line">        //先计算对应位置上一样的数字？之后去除，再看看又几个重复的？</span><br><span class="line">        //想到一个好方法，既然都是数字，那肯定在0~9范围之内！用两个数组！不，三个，不用哈希表了，还是两个</span><br><span class="line"></span><br><span class="line">        int n = secret.size();</span><br><span class="line">        //类似于计数排序</span><br><span class="line">        vector&lt;int&gt; sec(10, 0), gue(10, 0);</span><br><span class="line">        int a = 0, b = 0;</span><br><span class="line"></span><br><span class="line">        for(int i = 0; i &lt; n; ++i)&#123;</span><br><span class="line">            if(secret[i] == guess[i])&#123;</span><br><span class="line">                ++a;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                sec[secret[i] - &apos;0&apos;]++;</span><br><span class="line">                gue[guess[i] - &apos;0&apos;]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i = 0; i &lt; 10; ++i)&#123;</span><br><span class="line">            if(sec[i] &amp;&amp; gue[i])&#123;</span><br><span class="line">                //有重复</span><br><span class="line">                b += min(sec[i], gue[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        string ans;</span><br><span class="line">        //to_string返回的是右值，不能+=</span><br><span class="line">        ans += to_string(a) + &quot;A&quot; + to_string(b) + &quot;B&quot;;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="301-删除无效的括号"><a href="#301-删除无效的括号" class="headerlink" title="301_删除无效的括号"></a>301_删除无效的括号</h2><ul>
<li>这题不好写，不太会<ul>
<li>我总觉得加字母，是故意为难人！</li>
<li>看评论，雾草，这题面试居然会问！</li>
<li>记录下之前的思路，看了题解想手撕，但是撕不出来0.0，会有一个问题——计算出最小的左右括号删除数量，那么在用哈希表去重的时候，如何保证删除后的字符串括号是有效的呢<ul>
<li>删除最小数量的括号，首先要确保括号成对；最小数量，应该使用BFS，那一层上的所有的可行解；就算括号成对，但也不一定有效，每一层应该都是删一个括号；有些是必须删除的，而有些则是有多种选择；还有字母会碍点事</li>
</ul>
</li>
<li>还有两个变量，已经遍历的左右括号的数量<ul>
<li>若是前面的左右括号相等，再遇到右括号的话，则必须删除这个右括号！！！</li>
</ul>
</li>
<li>每次递归应该只删除一个括号<ul>
<li>遇到括号，都可以选择删或者不删，在某些条件下是必须删的，在某些条件下不能删</li>
</ul>
</li>
<li>递归条件还有漏洞<ul>
<li>输入<code>&quot;)()(&quot;</code>；输出<code>[&quot;)(&quot;,&quot;()&quot;]</code>；——必须删、不能删，产生矛盾，也要返回</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void dfs(string&amp; tmp, int leftSeen, int rightSeen, int leftDel, int rightDel, string&amp; s, int pos, int n)&#123;</span><br><span class="line">        //出口条件首先是，要删除的左右括号数量满足最小条件；其次遍历到的左右括号一一对应，这样就判断是否重复</span><br><span class="line">        if(pos == n)&#123;</span><br><span class="line">            //这里判断是否有效且不重复</span><br><span class="line">            if(leftSeen == rightSeen &amp;&amp; leftDel == left_parenthesis &amp;&amp; rightDel == right_parenthesis &amp;&amp; record.find(tmp) == record.end())&#123;</span><br><span class="line">                ans.emplace_back(tmp);</span><br><span class="line">                //保存记录</span><br><span class="line">                record.insert(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //若还没有遍历结束，删多了</span><br><span class="line">        if(leftDel &gt; left_parenthesis || rightDel &gt; right_parenthesis)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //因为是递归，只用到s[pos]，无需for循环，之后就根据已有的左右括号数量判断能不能删除</span><br><span class="line">        //字母也需要弹入、弹出</span><br><span class="line">        if(isalpha(s[pos]))&#123;</span><br><span class="line">            tmp.push_back(s[pos]);</span><br><span class="line">            dfs(tmp, leftSeen, rightSeen, leftDel, rightDel, s, pos + 1, n);</span><br><span class="line">            tmp.pop_back();</span><br><span class="line">        &#125;else if(s[pos] == &apos;(&apos;)&#123;</span><br><span class="line">            //先看看能不能删</span><br><span class="line">            //不删，左括号似乎没有硬性要求——就算是第一个也可以删</span><br><span class="line">            if(leftDel == left_parenthesis)&#123;</span><br><span class="line">                tmp.push_back(s[pos]);</span><br><span class="line">                dfs(tmp, leftSeen + 1, rightSeen, leftDel, rightDel, s, pos + 1, n);</span><br><span class="line">                tmp.pop_back();</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                //删</span><br><span class="line">                dfs(tmp, leftSeen, rightSeen, leftDel + 1, rightDel, s, pos + 1, n);</span><br><span class="line">                //也可以不删</span><br><span class="line">                tmp.push_back(s[pos]);</span><br><span class="line">                dfs(tmp, leftSeen + 1, rightSeen, leftDel, rightDel, s, pos + 1, n);</span><br><span class="line">                tmp.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else if(s[pos] == &apos;)&apos;)&#123;</span><br><span class="line">            //这里有两个条件是重叠的，加个补丁</span><br><span class="line">            if(rightDel == right_parenthesis &amp;&amp; leftSeen == rightSeen)&#123;</span><br><span class="line">                //矛盾，也是一个返回条件</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if(rightDel == right_parenthesis)&#123;</span><br><span class="line">                //不能删</span><br><span class="line">                tmp.push_back(s[pos]);</span><br><span class="line">                dfs(tmp, leftSeen, rightSeen + 1, leftDel, rightDel, s, pos + 1, n);</span><br><span class="line">                tmp.pop_back();</span><br><span class="line">            &#125;else if(leftSeen == rightSeen)&#123;</span><br><span class="line">                //必须删</span><br><span class="line">                dfs(tmp, leftSeen, rightSeen, leftDel, rightDel + 1, s, pos + 1, n);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                //既可以删，也可以不删</span><br><span class="line">                dfs(tmp, leftSeen, rightSeen, leftDel, rightDel + 1, s, pos + 1, n);</span><br><span class="line">                tmp.push_back(s[pos]);</span><br><span class="line">                dfs(tmp, leftSeen, rightSeen + 1, leftDel, rightDel, s, pos + 1, n);</span><br><span class="line">                tmp.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;string&gt; removeInvalidParentheses(string s) &#123;</span><br><span class="line">        int n = s.size();</span><br><span class="line">        //计算出最小删除的左括号、右括号数量</span><br><span class="line">        for(int i = 0; i &lt; n; ++i)&#123;</span><br><span class="line">            //必须要有左括号，遇到右括号才能相互抵消</span><br><span class="line">            if(s[i] == &apos;(&apos;)&#123;</span><br><span class="line">                ++left_parenthesis;</span><br><span class="line">            &#125;else if(s[i] == &apos;)&apos;)&#123;</span><br><span class="line">                if(left_parenthesis == 0)&#123;</span><br><span class="line">                    ++right_parenthesis;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    --left_parenthesis;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //如何用哈希表去重，因为删除了某几个括号，剩下来的不一定有效</span><br><span class="line">        //保持有效，就是让已经遍历到的左右括号一一对应，或者个数相等</span><br><span class="line">        //去重是删除之后剩下来的结果</span><br><span class="line">        string tmp;</span><br><span class="line">        dfs(tmp, 0, 0, 0, 0, s, 0, n);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    unordered_set&lt;string&gt; record;</span><br><span class="line">    int left_parenthesis = 0;</span><br><span class="line">    int right_parenthesis = 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>这题差点忘了要写在IDE里的</p>
<ul>
<li>我是根据字符的种类分三种情况，然后又细分为删或者不删，必须删，不能删</li>
<li>题解是根据删，不删两种情况，再来细分字符的种类以及特殊情况，还可以再优化下</li>
</ul>
</li>
<li><p>还有因为是最短路径，所以一般采用广度优先搜索，这种比较暴力，没有DFS剪枝来进行优化</p>
<ul>
<li>暴力的地方在于，删除之后要额外判断剩下来的字符串是否有效——还是用最小删除的括号方法来判断</li>
</ul>
</li>
</ul>
<h2 id="306-累加数"><a href="#306-累加数" class="headerlink" title="306_累加数"></a>306_累加数</h2><ul>
<li><p>这题没有官方题解</p>
<ul>
<li>得要回溯，代码量比较多</li>
<li>这里的坑在于前两个数不一定都是一位数，也可能是多位，所以得罗列所有的情况</li>
<li>一遇到对的就返回，循环的时候得看剩余的数字个数够不够（前面数字相加的长度）</li>
</ul>
</li>
<li><p>这里直接 CV 了</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /*功能说明:接受两个数字字符串作为输入，输出他们和的字符串*/</span><br><span class="line">    string addString(const string&amp; a, const string&amp; b) &#123;</span><br><span class="line">        int length = (a.size() &gt; b.size()) ? a.size() : b.size();</span><br><span class="line">        string c(length + 1, &apos; &apos;);</span><br><span class="line">        int ptr1 = a.size() - 1, ptr2 = b.size() - 1, ptr3 = c.size() - 1, carryNum = 0, thisSum = 0;</span><br><span class="line">        while (ptr1 &gt;= 0 || ptr2 &gt;= 0) &#123;</span><br><span class="line">            int numA = (ptr1 &gt;= 0) ? a[ptr1--] - &apos;0&apos; : 0;</span><br><span class="line">            int numB = (ptr2 &gt;= 0) ? b[ptr2--] - &apos;0&apos; : 0;</span><br><span class="line">            thisSum = numA + numB + carryNum;</span><br><span class="line">            if (thisSum &gt;= 10) &#123;</span><br><span class="line">                carryNum = 1;</span><br><span class="line">                thisSum %= 10;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                carryNum = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            c[ptr3--] = thisSum + &apos;0&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        if (carryNum &gt; 0) &#123;</span><br><span class="line">            c[0] = &apos;1&apos;;</span><br><span class="line">            return c;</span><br><span class="line">        &#125;</span><br><span class="line">        else </span><br><span class="line">            return c.substr(1);   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*回溯模版</span><br><span class="line">      参数说明:</span><br><span class="line">      num:目标字符串</span><br><span class="line">      startIndex:当前开始回溯的下标</span><br><span class="line">      res:保存结果</span><br><span class="line">      endIndex:当前step用到的终点下标(也就是字符串c的下一个开始)*/</span><br><span class="line">    void backtrack(const string&amp; num, int startIndex, bool&amp; res, int endIndex) &#123;</span><br><span class="line">        //如果已经到达目标字符串的末端，则成功，该字符串是一个累加序列</span><br><span class="line">        if (endIndex &gt;= num.size()) &#123;</span><br><span class="line">            res = true;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //选择第一个数a，开始下标为startIndex，长度为lengthOfa</span><br><span class="line">        for (int lengthOfa = 1; startIndex + lengthOfa &lt;= num.size(); ++lengthOfa) &#123;</span><br><span class="line">            //选择第二个数b，开始下标为startIndex + lengthOfa，长度为lengthOfb</span><br><span class="line">            for (int lengthOfb = 1; startIndex + lengthOfa + lengthOfb &lt;= num.size(); ++lengthOfb) &#123;</span><br><span class="line">                string a = num.substr(startIndex, lengthOfa);</span><br><span class="line">                string b = num.substr(startIndex + lengthOfa, lengthOfb);</span><br><span class="line"></span><br><span class="line">                //如果字符串长度大于1，且以0开头，则跳过当前结果不做考虑（题目规定）</span><br><span class="line">                if ((a.size() &gt; 1 &amp;&amp; a[0] == &apos;0&apos;) || (b.size() &gt; 1 &amp;&amp; b[0] == &apos;0&apos;))</span><br><span class="line">                    continue;</span><br><span class="line"></span><br><span class="line">                //a + b 的字符串结果</span><br><span class="line">                string sum = addString(a, b);</span><br><span class="line"></span><br><span class="line">                //将剩余的字符串赋给c</span><br><span class="line">                string c = num.substr(startIndex + lengthOfa + lengthOfb);</span><br><span class="line"></span><br><span class="line">                //判断sum和c的开始部分是否相等</span><br><span class="line">                if (sum.size() &gt; c.size() || sum != c.substr(0, sum.size()))</span><br><span class="line">                    continue;</span><br><span class="line"></span><br><span class="line">                //相等表示可以进入下一个step的回溯了，注意，本阶段到字符串c的下标处我们都已经使用过了,</span><br><span class="line">                //所以让endIndex = startIndex + lengthOfa + lengthOfb + sum.size()</span><br><span class="line">                backtrack(num, startIndex + lengthOfa, res, startIndex + lengthOfa + lengthOfb + sum.size());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    bool isAdditiveNumber(string num) &#123;</span><br><span class="line">        if (num.size() == 0)</span><br><span class="line">            return false;</span><br><span class="line">        bool res = false;</span><br><span class="line">        backtrack(num, 0, res, 0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94_二叉树的中序遍历"></a>94_二叉树的中序遍历</h2><ul>
<li>这还是第一次正式对二叉树排序，之前都是回溯+剪枝找可行解来着</li>
<li>既然学了中序，那把先序和后序也做了，提前把递归理解还真的是如虎添翼</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">//    先序：考察到一个节点后，即刻输出该节点的值，并继续遍历其左右子树。(根左右)</span><br><span class="line">//    中序：考察到一个节点后，将其暂存，遍历完左子树后，再输出该节点的值，然后遍历右子树。(左根右)</span><br><span class="line">//    后序：考察到一个节点后，将其暂存，遍历完左右子树后，再输出该节点的值。(左右根)</span><br><span class="line">    //中序</span><br><span class="line">    void dfs0(TreeNode* root, vector&lt;int&gt; &amp;res)&#123;</span><br><span class="line">        if(root == nullptr)</span><br><span class="line">            return;</span><br><span class="line">        dfs(root-&gt;left, res);   //中序的输出顺序是左子树的值、根节点的值、右子树的值</span><br><span class="line">        res.emplace_back(root-&gt;val);</span><br><span class="line">        dfs(root-&gt;right, res);</span><br><span class="line">//        res.emplace_back(root-&gt;val);  //这里会出现放了两次数字的情况</span><br><span class="line">    &#125;</span><br><span class="line">    //先序</span><br><span class="line">    void dfs1(TreeNode* root, vector&lt;int&gt; &amp;res)&#123;</span><br><span class="line">        if(root == nullptr) //先序的输出顺序是根节点的值、左子树的值、右子树的值</span><br><span class="line">            return;</span><br><span class="line">        res.emplace_back(root-&gt;val);    //先放根节点的值</span><br><span class="line">        dfs(root-&gt;left, res);</span><br><span class="line">        dfs(root-&gt;right, res);</span><br><span class="line">    &#125;</span><br><span class="line">    //后序</span><br><span class="line">    void dfs(TreeNode* root, vector&lt;int&gt; &amp;res)&#123;</span><br><span class="line">        if(root == nullptr) //先序的输出顺序是左子树的值、右子树的值、根节点的值</span><br><span class="line">            return;</span><br><span class="line">        dfs(root-&gt;left, res);</span><br><span class="line">        dfs(root-&gt;right, res);</span><br><span class="line">        res.emplace_back(root-&gt;val);    //最后放根节点的值</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        dfs(root, res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    auto *root = new TreeNode(1);</span><br><span class="line">    root-&gt;left = new TreeNode(2);</span><br><span class="line">    root-&gt;right = new TreeNode(3);</span><br><span class="line">    root-&gt;left-&gt;left = new TreeNode(4);</span><br><span class="line">    root-&gt;left-&gt;left-&gt;right = new TreeNode(6);</span><br><span class="line">    root-&gt;left-&gt;left-&gt;right-&gt;left = new TreeNode(7);</span><br><span class="line">    root-&gt;left-&gt;left-&gt;right-&gt;right = new TreeNode(8);</span><br><span class="line">    root-&gt;right-&gt;right = new TreeNode(5);</span><br><span class="line"></span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;int&gt; res = solution.inorderTraversal(root);</span><br><span class="line">    for(const auto &amp;r : res)</span><br><span class="line">        cout &lt;&lt; r &lt;&lt; &quot; &quot;;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="95-不同的二叉搜索树-II"><a href="#95-不同的二叉搜索树-II" class="headerlink" title="95_不同的二叉搜索树_II"></a>95_不同的二叉搜索树_II</h2><ul>
<li>注意审题，结构不同，与数字的顺序无关</li>
<li>错了错了，二叉搜索树关键的性质是根节点的值大于左子树所有节点的值，小于右子树所有节点的值，且左子树和右子树也同样为二叉搜索树。</li>
<li>虽然想到用递归但是，就算解出来也是错的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void dfs_cout(TreeNode* root)&#123;</span><br><span class="line">    if(root == nullptr)</span><br><span class="line">        return;</span><br><span class="line">    dfs_cout(root-&gt;left);</span><br><span class="line">    cout &lt;&lt; root-&gt;val &lt;&lt; &quot; &quot;;</span><br><span class="line">    dfs_cout(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;TreeNode*&gt; generateTrees(int start, int end) &#123;</span><br><span class="line">        if (start &gt; end)</span><br><span class="line">            return &#123; nullptr &#125;; //这里返回nullptr,而不是&#123;&#125;</span><br><span class="line">        vector&lt;TreeNode*&gt; allTrees;</span><br><span class="line">        // 枚举可行根节点</span><br><span class="line">        for (int i = start; i &lt;= end; i++) &#123;</span><br><span class="line">            // 获得所有可行的左子树集合</span><br><span class="line">            vector&lt;TreeNode*&gt; leftTrees = generateTrees(start, i - 1);</span><br><span class="line">            // 获得所有可行的右子树集合</span><br><span class="line">            vector&lt;TreeNode*&gt; rightTrees = generateTrees(i + 1, end);</span><br><span class="line">            // 从左子树集合中选出一棵左子树，从右子树集合中选出一棵右子树，拼接到根节点上</span><br><span class="line">            for (auto&amp; left : leftTrees) &#123;</span><br><span class="line">                for (auto&amp; right : rightTrees) &#123;</span><br><span class="line">                    TreeNode* currTree = new TreeNode(i);</span><br><span class="line">                    currTree-&gt;left = left;</span><br><span class="line">                    currTree-&gt;right = right;</span><br><span class="line">                    allTrees.emplace_back(currTree);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return allTrees;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;TreeNode*&gt; generateTrees(int n) &#123;</span><br><span class="line">        if (!n)</span><br><span class="line">            return &#123;&#125;;</span><br><span class="line">        return generateTrees(1, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;TreeNode*&gt; res = solution.generateTrees(3);</span><br><span class="line">    //输出二叉树就用之前的先序遍历吧</span><br><span class="line">    for(auto r : res)&#123;</span><br><span class="line">        cout &lt;&lt; &quot;r.val = &quot; &lt;&lt; r-&gt;val &lt;&lt; &quot; &quot; &lt;&lt; (r-&gt;right == nullptr) &lt;&lt; endl;</span><br><span class="line">        dfs_cout(r);</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96_不同的二叉搜索树"></a>96_不同的二叉搜索树</h2><ul>
<li>这题还是上题的灵感，但是超出时间限制了…算出来的答案应该没问题</li>
<li>用动态规划可以大幅缩减时间；总结规律很重要</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int numTrees(int n) &#123;</span><br><span class="line">        vector&lt;int&gt; dp(n + 1, 0);</span><br><span class="line">        dp[0] = 1; dp[1] = 1;</span><br><span class="line">        for(int i = 2; i &lt;= n; ++i)&#123;</span><br><span class="line">            for(int j = 1; j &lt;= i; ++j)&#123;</span><br><span class="line">                dp[i] += dp[j - 1] * dp[i - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.numTrees(3) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98_验证二叉搜索树"></a>98_验证二叉搜索树</h2><ul>
<li>看了答案才知道递归要有两个值，</li>
<li>一开始是直接判断子节点是否是二叉搜索树，后来发现所有的左子树节点都要小于跟节点的值，右边那就是都要大于，不能等于；取巧了下，将二叉树中序遍历出来，得到一维数组，并且这个数组是严格升序的，还是题解更好</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void dfs(vector&lt;int&gt; &amp;nums, TreeNode* root)&#123;</span><br><span class="line">        if(root == nullptr) return;</span><br><span class="line">        dfs(nums, root-&gt;left);</span><br><span class="line">        nums.emplace_back(root-&gt;val);</span><br><span class="line">        dfs(nums, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool isValidBST(TreeNode* root) &#123;</span><br><span class="line">        if(root == nullptr) return true;</span><br><span class="line">        bool flag = true;</span><br><span class="line">        vector&lt;int&gt; nums;</span><br><span class="line">        dfs(nums, root);</span><br><span class="line">        int tmp = nums[0];</span><br><span class="line">        for(int i = 0; i &lt; nums.size(); ++i)&#123;</span><br><span class="line">            if(i == 0) continue;</span><br><span class="line">            if(tmp &gt;= nums[i])&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                tmp = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    //TODO</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="99-恢复二叉搜索树"><a href="#99-恢复二叉搜索树" class="headerlink" title="99_恢复二叉搜索树"></a>99_恢复二叉搜索树</h2><ul>
<li>这题忘了容器<code>vector</code>是可以存放<code>Treenode*</code>类型的，思维僵化；不过题解还是用的<code>int</code>类型</li>
<li>这题就不写输入输出了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void dfs(vector&lt;TreeNode*&gt; &amp;ans, TreeNode* root)&#123;</span><br><span class="line">        if(!root) return;</span><br><span class="line">        dfs(ans, root-&gt;left);</span><br><span class="line">        ans.emplace_back(root);</span><br><span class="line">        dfs(ans, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    void recoverTree(TreeNode* root) &#123;</span><br><span class="line">       vector&lt;TreeNode*&gt; ans;</span><br><span class="line">        dfs(ans, root);</span><br><span class="line">        for(const auto &amp;a : ans)&#123;</span><br><span class="line">            cout &lt;&lt; a-&gt;val &lt;&lt; &quot; &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        int prev = -1, curr = -1;</span><br><span class="line">        for(int i = 0; i &lt; ans.size() - 1; ++i)&#123;</span><br><span class="line">            if(ans[i]-&gt;val &gt; ans[i + 1]-&gt;val)&#123;</span><br><span class="line">                prev = prev &lt; 0 ? i : prev;</span><br><span class="line">                curr = (curr &lt; 0 &amp;&amp; prev != i) ? i : curr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(prev &lt; 0 &amp;&amp; curr &lt; 0) return;</span><br><span class="line">        if(prev &gt;= 0 &amp;&amp; curr &gt;= 0)&#123;</span><br><span class="line">            int tmp = ans[prev]-&gt;val;</span><br><span class="line">            ans[prev]-&gt;val = ans[curr + 1]-&gt;val;</span><br><span class="line">            ans[curr + 1]-&gt;val = tmp;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">             int tmp = ans[prev]-&gt;val;</span><br><span class="line">             ans[prev]-&gt;val = ans[prev + 1]-&gt;val;</span><br><span class="line">             ans[prev + 1]-&gt;val = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100_相同的树"></a>100_相同的树</h2><ul>
<li>思路应该很简单；中序在手，天下我有</li>
<li>还是要认真看题解，这种方法叫做深度优先搜索，仔细看才知道直接用本函数就可以递归</li>
<li>再学习下广度优先搜索</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool dfs(TreeNode* p, TreeNode* q)&#123;</span><br><span class="line">        if(p == nullptr &amp;&amp; q == nullptr) return true;</span><br><span class="line">        if((p != nullptr &amp;&amp; q == nullptr) || (p == nullptr &amp;&amp; q != nullptr))&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(p-&gt;val != q-&gt;val) return false;</span><br><span class="line">        return dfs(p-&gt;left, q-&gt;left) &amp;&amp; dfs(p-&gt;right, q-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool isSameTree(TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        return dfs(p,q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101_对称二叉树"></a>101_对称二叉树</h2><ul>
<li>这题应该用广度优先搜索；不递归，维护两个队列，不停的将节点放入队列再弹出，最后判断两个都是否为空；在<code>whlie</code>循环内，先判断节点值是否相等，再判断左右子节点，不为空就分别放入两个队列中，注意顺序</li>
<li>我还是想的复杂了，题解的递归写的很简洁</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isSymmetric(TreeNode* root) &#123;</span><br><span class="line">        if(root == nullptr)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;else if(root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;else if(root-&gt;left == nullptr || root-&gt;right == nullptr)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; r1,r2;</span><br><span class="line">        r1.push(root-&gt;left);</span><br><span class="line">        r2.push(root-&gt;right);</span><br><span class="line">        while(!r1.empty() &amp;&amp; !r2.empty())&#123;</span><br><span class="line">            auto l = r1.front();</span><br><span class="line">            r1.pop();</span><br><span class="line">            auto r = r2.front();</span><br><span class="line">            r2.pop();</span><br><span class="line">            if(l-&gt;val != r-&gt;val)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            auto left1 = l-&gt;left, right1 = l-&gt;right;</span><br><span class="line">            auto left2 = r-&gt;left, right2 = r-&gt;right;</span><br><span class="line">            if((left1 == nullptr &amp;&amp; right2 != nullptr) || (left1 != nullptr &amp;&amp; right2 == nullptr) )</span><br><span class="line">                return false;</span><br><span class="line">            if((left2 == nullptr &amp;&amp; right1 != nullptr) || (left2 != nullptr &amp;&amp; right1 == nullptr) )</span><br><span class="line">                return false;</span><br><span class="line"></span><br><span class="line">            if (left1 != nullptr) &#123;</span><br><span class="line">                r1.push(left1);</span><br><span class="line">            &#125;</span><br><span class="line">            if (right1 != nullptr) &#123;</span><br><span class="line">                r1.push(right1);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if (right2 != nullptr) &#123;</span><br><span class="line">                r2.push(right2);</span><br><span class="line">            &#125;</span><br><span class="line">            if (left2 != nullptr) &#123;</span><br><span class="line">                r2.push(left2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return r1.empty() &amp;&amp; r2.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution_ &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isSymmetric(TreeNode* r1, TreeNode* r2)&#123;</span><br><span class="line">        if(!r1 &amp;&amp; !r2) return true;</span><br><span class="line">        if(!r1 || !r2) return false;</span><br><span class="line"></span><br><span class="line">        return r1-&gt;val == r2-&gt;val &amp;&amp; isSymmetric(r1-&gt;left, r2-&gt;right) &amp;&amp; isSymmetric(r2-&gt;left, r1-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    bool isSymmetric(TreeNode* root) &#123;</span><br><span class="line">        return isSymmetric(root, root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102_二叉树的层序遍历"></a>102_二叉树的层序遍历</h2><ul>
<li>刚开始想用递归来着，后来觉得应该用广度优先搜索，维护一个队列</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return &#123;&#125;;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        vector&lt;int&gt; tmp;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            int n = q.size();</span><br><span class="line">            while(n &gt; 0)&#123;</span><br><span class="line">                //cout &lt;&lt; &quot;n = &quot; &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">                auto r = q.front();</span><br><span class="line">                tmp.emplace_back(r-&gt;val);</span><br><span class="line">                q.pop();</span><br><span class="line">                if(r-&gt;left)&#123;</span><br><span class="line">                    q.push(r-&gt;left);</span><br><span class="line">                    //cout &lt;&lt; &quot;r-&gt;left = &quot; &lt;&lt; r-&gt;left-&gt;val &lt;&lt; endl; </span><br><span class="line">                &#125; </span><br><span class="line">                if(r-&gt;right)&#123;</span><br><span class="line">                    //cout &lt;&lt; &quot;r-&gt;right = &quot; &lt;&lt; r-&gt;right-&gt;val &lt;&lt; endl; </span><br><span class="line">                    q.push(r-&gt;right);</span><br><span class="line">                &#125; </span><br><span class="line">                --n;</span><br><span class="line">                //cout &lt;&lt; &quot;--n = &quot; &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">            tmp.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="103-二叉树的锯齿形层序遍历"><a href="#103-二叉树的锯齿形层序遍历" class="headerlink" title="103_二叉树的锯齿形层序遍历"></a>103_二叉树的锯齿形层序遍历</h2><ul>
<li>有点纳闷，为啥二叉树题都放一起了</li>
<li>暂时还没了解二叉树是如何手动删除的，所以就没有在IDE上输入输出</li>
<li>这题思路应该上题差不多，目测需要一个方向布尔值，取反注意逻辑取反和按位取反</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void reverse(vector&lt;int&gt; &amp;tmp)&#123;</span><br><span class="line">        int prev = 0, curr = tmp.size();</span><br><span class="line">        --curr;</span><br><span class="line">        while(prev &lt; curr)&#123;</span><br><span class="line">            int ans = tmp[prev];</span><br><span class="line">            tmp[prev] = tmp[curr];</span><br><span class="line">            tmp[curr] = ans;</span><br><span class="line">            ++prev;</span><br><span class="line">            --curr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return &#123;&#125;;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        vector&lt;int&gt; tmp;</span><br><span class="line">        bool flag = false;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            int n = q.size();</span><br><span class="line">            while(n &gt; 0)&#123;</span><br><span class="line">                auto r = q.front();</span><br><span class="line">                tmp.emplace_back(r-&gt;val);</span><br><span class="line">                q.pop();</span><br><span class="line">                if(r-&gt;left) q.push(r-&gt;left);</span><br><span class="line">                if(r-&gt;right) q.push(r-&gt;right);</span><br><span class="line">                --n;</span><br><span class="line">            &#125;</span><br><span class="line">            //cout &lt;&lt; tmp[0] &lt;&lt; &quot;----&quot; &lt;&lt; endl;</span><br><span class="line">            if(flag)&#123;   //一开始是1，无需反转</span><br><span class="line">                //cout &lt;&lt; flag &lt;&lt; endl;</span><br><span class="line">                reverse(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            flag = !flag;</span><br><span class="line">            </span><br><span class="line">            //cout &lt;&lt; flag &lt;&lt; endl;</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">            tmp.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104_二叉树的最大深度"></a>104_二叉树的最大深度</h2><ul>
<li>BFS永远的神</li>
<li>看了题解才知道，小丑竟是我自己,递归就两行代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxDepth(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return 0;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            int n = q.size();</span><br><span class="line">            while(n &gt; 0)&#123;</span><br><span class="line">                auto r = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                if(r-&gt;left) q.push(r-&gt;left);</span><br><span class="line">                if(r-&gt;right) q.push(r-&gt;right);</span><br><span class="line">                --n;</span><br><span class="line">            &#125;</span><br><span class="line">            ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105_从前序与中序遍历序列构造二叉树"></a>105_从前序与中序遍历序列构造二叉树</h2><ul>
<li>这题虽然用递归做出来了，但时间和内存消耗都很低，都是5%多一点</li>
<li>学习下题解是怎么做的，第一个方法思路一样，第二个是迭代</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;</span><br><span class="line">        //preorder第一个数是根节点</span><br><span class="line">        //inorder第一个数是左子树尽头的节点</span><br><span class="line">        if(preorder.empty() || inorder.empty()) return nullptr;</span><br><span class="line">        TreeNode* root = new TreeNode(preorder[0]); //根节点</span><br><span class="line">        </span><br><span class="line">        vector&lt;int&gt; pre, ino;</span><br><span class="line">        int pos = 0;</span><br><span class="line">        for(; pos &lt; preorder.size(); ++pos)&#123;</span><br><span class="line">            if(pos &gt; 0)</span><br><span class="line">                pre.push_back(preorder[pos]);</span><br><span class="line">            if(root-&gt;val == inorder[pos])</span><br><span class="line">                break;</span><br><span class="line">            ino.push_back(inorder[pos]);</span><br><span class="line">        &#125;</span><br><span class="line">        preorder.erase(preorder.begin(), preorder.begin() + pos + 1);</span><br><span class="line">        inorder.erase(inorder.begin(), inorder.begin() + pos + 1);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        root-&gt;left = buildTree(pre, ino);</span><br><span class="line">        root-&gt;right = buildTree(preorder, inorder);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106_从中序与后序遍历序列构造二叉树"></a>106_从中序与后序遍历序列构造二叉树</h2><ul>
<li>这题解法跟上题一样，就是有些细节需要注意</li>
<li>试了下迭代的算法，，，赶紧学习下，看不懂也要看！！</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123;</span><br><span class="line">        if(postorder.empty() || inorder.empty()) return nullptr;</span><br><span class="line">        int n = postorder.size();</span><br><span class="line">        TreeNode* root = new TreeNode(postorder[n - 1]); //根节点</span><br><span class="line">        </span><br><span class="line">        vector&lt;int&gt; pre, ino;</span><br><span class="line">        int pos = 0;</span><br><span class="line">        for(; pos &lt; n; ++pos)&#123;</span><br><span class="line">            if(root-&gt;val == inorder[pos])</span><br><span class="line">                break;</span><br><span class="line">            pre.push_back(inorder[pos]);</span><br><span class="line">            ino.push_back(postorder[pos]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        inorder.erase(inorder.begin(), inorder.begin() + pos + 1);</span><br><span class="line">        postorder.erase(postorder.begin(), postorder.begin() + pos);</span><br><span class="line">        postorder.pop_back();</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        root-&gt;left = buildTree(pre, ino);</span><br><span class="line">        root-&gt;right = buildTree(inorder, postorder);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="107-二叉树的层序遍历-II"><a href="#107-二叉树的层序遍历-II" class="headerlink" title="107-二叉树的层序遍历 II"></a>107-二叉树的层序遍历 II</h2><ul>
<li>这题虽然与l一样，但消耗不够看；得认真看下题解</li>
<li>淦，直接用<code>reverse(res.begin(), res.end());</code>函数在头文件<code>#include &lt;algorithm&gt;</code>中，，，，这消耗真是天壤之别</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return &#123;&#125;;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        vector&lt;int&gt; tmp;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            int n = q.size();</span><br><span class="line">            while(n &gt; 0)&#123;</span><br><span class="line">                auto r = q.front();</span><br><span class="line">                tmp.emplace_back(r-&gt;val);</span><br><span class="line">                q.pop();</span><br><span class="line">                if(r-&gt;left)&#123;</span><br><span class="line">                    q.push(r-&gt;left);</span><br><span class="line">                &#125; </span><br><span class="line">                if(r-&gt;right)&#123;</span><br><span class="line">                    q.push(r-&gt;right);</span><br><span class="line">                &#125; </span><br><span class="line">                --n;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">            tmp.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(res.begin(), res.end());</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108_将有序数组转换为二叉搜索树"></a>108_将有序数组转换为二叉搜索树</h2><ul>
<li>这题比较简单，但消耗中等偏下</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if(nums.empty()) return nullptr;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        int mid = n / 2;</span><br><span class="line">        TreeNode *root = new TreeNode(nums[mid]);</span><br><span class="line">        vector&lt;int&gt; pre;</span><br><span class="line">        for(int i = 0; i &lt; mid; ++i)</span><br><span class="line">            pre.push_back(nums[i]);</span><br><span class="line">        nums.erase(nums.begin(), nums.begin() + mid + 1);</span><br><span class="line">        root-&gt;left = sortedArrayToBST(pre);</span><br><span class="line">        root-&gt;right = sortedArrayToBST(nums);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="109-有序链表转换二叉搜索树"><a href="#109-有序链表转换二叉搜索树" class="headerlink" title="109_有序链表转换二叉搜索树"></a>109_有序链表转换二叉搜索树</h2><ul>
<li>有点小问题，在计算链表的长度时，我说呢<code>while(!carry)</code>的意思是当他是空的时候，找中位数的时候也可以用两个指针，快指针每次移动两格，慢指针每次移动一格</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line">    ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* sortedListToBST(ListNode* head) &#123;</span><br><span class="line">        if(!head) return nullptr;</span><br><span class="line">        int len = 1;</span><br><span class="line">        auto carry = head, mid = head;</span><br><span class="line">        while(carry-&gt;next)&#123;</span><br><span class="line">            carry = carry-&gt;next;</span><br><span class="line">            ++len;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(len == 1) return new TreeNode(head-&gt;val);</span><br><span class="line">        int m = len / 2;</span><br><span class="line">        while(m &gt; 0)&#123;</span><br><span class="line">            carry = mid;</span><br><span class="line">            mid = mid-&gt; next;</span><br><span class="line">            --m;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* root = new TreeNode(mid-&gt;val);</span><br><span class="line">        root-&gt;right = sortedListToBST(mid-&gt;next);</span><br><span class="line">        </span><br><span class="line">        carry-&gt;next = nullptr;</span><br><span class="line">        root-&gt;left = sortedListToBST(head);</span><br><span class="line">        </span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110_平衡二叉树"></a>110_平衡二叉树</h2><ul>
<li>这次用深度优先搜索来计算二叉树的层数，之前的一题题解里有参考，默写下，就当复习了！</li>
<li>思路还是很清晰的，最主要的是计算最大深度，然后每个递归每个节点，也就是每个节点都要计算最大深度</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int nums(TreeNode* root)&#123;   </span><br><span class="line">        if(!root) return 0;</span><br><span class="line">        return max(nums(root-&gt;left), nums(root-&gt;right)) + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool deep(TreeNode* root)&#123;</span><br><span class="line">        if(!root) return true;</span><br><span class="line">        int l = nums(root-&gt;left);</span><br><span class="line">        int r = nums(root-&gt;right);</span><br><span class="line">        bool flag = false;</span><br><span class="line">        if(abs(l - r) &lt;= 1)</span><br><span class="line">            flag = true;</span><br><span class="line">        return flag &amp;&amp; deep(root-&gt;left) &amp;&amp; deep(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool isBalanced(TreeNode* root) &#123;</span><br><span class="line">        return deep(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111_二叉树的最小深度"></a>111_二叉树的最小深度</h2><ul>
<li>最小深度如果出现根节点的一个子树为空，那就考虑另一边的最小长度再加一；之后逻辑就跟最大深度一样，只不过要用<code>min()</code>函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minDepth(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return 0;</span><br><span class="line">        if(!root-&gt;left) </span><br><span class="line">            return minDepth(root-&gt;right) + 1;</span><br><span class="line">        else if(!root-&gt;right)</span><br><span class="line">            return minDepth(root-&gt;left) + 1;</span><br><span class="line">        else    </span><br><span class="line">            return min(minDepth(root-&gt;left), minDepth(root-&gt;right)) + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112_路径总和"></a>112_路径总和</h2><ul>
<li>主要是要考虑特殊情况，即一开始就是空节点和0，这种情况下是<code>false</code></li>
<li>对，这题用深度优先搜索</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool hasPathSum(TreeNode* root, int targetSum) &#123;</span><br><span class="line">        if(!root) </span><br><span class="line">            return false;</span><br><span class="line">        else if(!root-&gt;left &amp;&amp; !root-&gt;right)&#123;</span><br><span class="line">            if(targetSum - root-&gt;val == 0)</span><br><span class="line">                return true;</span><br><span class="line">            else</span><br><span class="line">                return false;</span><br><span class="line">        &#125; </span><br><span class="line">        return hasPathSum(root-&gt;left, targetSum - root-&gt;val) || hasPathSum(root-&gt;right, targetSum - root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="113-路径总和-II"><a href="#113-路径总和-II" class="headerlink" title="113_路径总和_II"></a>113_路径总和_II</h2><ul>
<li>这个是要找出所有的路径，这题思路和以前某题很像，方法叫做回溯加剪枝来着，复习下</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void dfs(vector&lt;vector&lt;int&gt;&gt; &amp;res, vector&lt;int&gt; &amp;tmp, TreeNode* root, int targetSum)&#123;</span><br><span class="line">        if(!root)</span><br><span class="line">            return;</span><br><span class="line">        tmp.push_back(root-&gt;val);</span><br><span class="line">        dfs(res, tmp, root-&gt;left, targetSum - root-&gt;val);    </span><br><span class="line">        dfs(res, tmp, root-&gt;right, targetSum - root-&gt;val);</span><br><span class="line">        if(!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; targetSum == root-&gt;val)//到达最后一个节点时，不应该判断是否为0，而是判断是否相等</span><br><span class="line">                res.push_back(tmp);</span><br><span class="line">        tmp.pop_back();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        vector&lt;int&gt; tmp;</span><br><span class="line">        dfs(res, tmp, root, targetSum);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114_二叉树展开为链表"></a>114_二叉树展开为链表</h2><ul>
<li>有点奇怪，节点不能相互赋予么</li>
<li>那就先一个数组保存先序遍历的节点，再遍历数组逐步生成新的节点</li>
<li>再学习下新的方法，不用数组维护，直接在原二叉树嫁接</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void dfs(TreeNode* root, vector&lt;int&gt; &amp;tmp) &#123;</span><br><span class="line">        if(!root) return;</span><br><span class="line">        tmp.emplace_back(root-&gt;val);</span><br><span class="line">        dfs(root-&gt;left, tmp);</span><br><span class="line">        dfs(root-&gt;right, tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void flatten(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return;</span><br><span class="line">        vector&lt;int&gt; tmp;</span><br><span class="line">        dfs(root, tmp);</span><br><span class="line">        root-&gt;left = nullptr;</span><br><span class="line">        root-&gt;right = nullptr;</span><br><span class="line">        tmp.erase(tmp.begin());</span><br><span class="line">        auto carry = root;</span><br><span class="line">        for(auto t : tmp)&#123;</span><br><span class="line">            carry-&gt;right = new TreeNode(t);</span><br><span class="line">            carry = carry-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>法二</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void flatten(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return;</span><br><span class="line">        auto curr = root;</span><br><span class="line">        while(curr)&#123;</span><br><span class="line">            if(curr-&gt;left)&#123;</span><br><span class="line">                auto next = curr-&gt;left;</span><br><span class="line">            auto prev = next;</span><br><span class="line">            while(prev-&gt;right)&#123;</span><br><span class="line">                prev = prev-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            prev-&gt;right = curr-&gt;right;</span><br><span class="line">            curr-&gt;left = nullptr;</span><br><span class="line">            curr-&gt;right = next;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116_填充每个节点的下一个右侧节点指针"></a>116_填充每个节点的下一个右侧节点指针</h2><ul>
<li>这题我用了广度优先搜索（使用队列来保存每一层的节点，每一层最后一个节点需要注意不能连到下一层的起始节点），但是使用的额外空间不是常量级，学习下题解</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//广度有限搜索</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    Node* connect(Node* root) &#123;</span><br><span class="line">        if(!root) return nullptr;</span><br><span class="line">        queue&lt;Node*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            int n = q.size();</span><br><span class="line">            while(n &gt; 0)&#123;</span><br><span class="line">                auto r = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                r-&gt;next = n == 1 ? nullptr : q.front();</span><br><span class="line">                --n;</span><br><span class="line">                if(r-&gt;left) q.push(r-&gt;left);</span><br><span class="line">                if(r-&gt;right) q.push(r-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//常量级额外空间</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    Node* connect(Node* root) &#123;</span><br><span class="line">        if(!root) return nullptr;</span><br><span class="line">        auto h = root;</span><br><span class="line">        while(h-&gt;left)&#123;</span><br><span class="line">            auto head = h;</span><br><span class="line">            while(head)&#123;</span><br><span class="line">                head-&gt;left-&gt;next = head-&gt;right;</span><br><span class="line">                if(head-&gt;next)</span><br><span class="line">                    head-&gt;right-&gt;next = head-&gt;next-&gt;left;</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            h = h-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="117-填充每个节点的下一个右侧节点指针-ll"><a href="#117-填充每个节点的下一个右侧节点指针-ll" class="headerlink" title="117_填充每个节点的下一个右侧节点指针_ll"></a>117_填充每个节点的下一个右侧节点指针_ll</h2><ul>
<li>这题是普通的二叉树，不是完全二叉树；使用广度优先搜索的话，代码无需任何改变，再试试第二种方法，额，第二种方法属实有点繁琐</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//广度优先搜索代码同上</span><br></pre></td></tr></table></figure>

<h2 id="124-二叉树中的最大路径和"><a href="#124-二叉树中的最大路径和" class="headerlink" title="124_二叉树中的最大路径和"></a>124_二叉树中的最大路径和</h2><ul>
<li>最大流算法作业还没写呢</li>
<li>这题我完全没有思路，但题解评论好多都说简单…难点在于根节点并不一定经过，目前来看，对二叉树的处理无非是广度优先和深度优先，但这两个方法都需要从根节点开始，每次只有选择左边或者右边这两种情况，这就是矛盾所在，如何转化矛盾，二叉树的最小构造-二叉树单元；根节点上方连着父节点（如果有的话），还有左节点和右节点。</li>
<li>除了两种情况，还有第三种情况，那就是左右一起选，这三种情况都连着根节点，所以只需递归比较左右两边的最大值，再加上判断根节点的值</li>
<li>有位大佬写的很清晰：枚举节点</li>
</ul>
<p><img src="/pictrues/%E4%BA%8C%E5%8F%89%E6%A0%911.png" alt="二叉树" title="二叉树"><br><img src="/pictrues/%E4%BA%8C%E5%8F%89%E6%A0%912.png" alt="二叉树" title="二叉树"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    int maxSum = INT_MIN;</span><br><span class="line">public:</span><br><span class="line">    int maxGain(TreeNode* node) &#123;</span><br><span class="line">        if(!node) return 0;</span><br><span class="line">        int l = max(maxGain(node-&gt;left), 0);</span><br><span class="line">        int r = max(maxGain(node-&gt;right), 0);</span><br><span class="line"></span><br><span class="line">        int path = l + r + node-&gt;val;</span><br><span class="line">        maxSum = max(maxSum, path);</span><br><span class="line">        return max(l, r) + node-&gt;val;//当前根节点下，只能返回两条路的一条</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int maxPathSum(TreeNode* root) &#123;</span><br><span class="line">        maxGain(root);</span><br><span class="line">        return maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="129-求根节点到叶节点数字之和"><a href="#129-求根节点到叶节点数字之和" class="headerlink" title="129_求根节点到叶节点数字之和"></a>129_求根节点到叶节点数字之和</h2><ul>
<li>这题题目考虑了整数范围，所以写代码的时候可以不用考虑整数边界的问题，应该吧，</li>
<li>这题我用了深度优先搜索，就是回溯的时候要对<code>tmp</code>进行恢复；还有就是不一定在节点为空的时候所得的和就是符合条件的答案</li>
<li>如果是将<code>tmp</code>为形参的话，可以不用恢复，因为回溯后还是原来的值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void dfs(TreeNode* root)&#123;</span><br><span class="line">        if(!root) return;</span><br><span class="line">        tmp = tmp * 10 + root-&gt;val;</span><br><span class="line">        //cout &lt;&lt; tmp &lt;&lt; endl;</span><br><span class="line">        dfs(root-&gt;left);</span><br><span class="line">        dfs(root-&gt;right);</span><br><span class="line">        if(!root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class="line">            ans += tmp;</span><br><span class="line">        tmp = (tmp - root-&gt;val) / 10;</span><br><span class="line">        //cout &lt;&lt; &quot;--- &quot; &lt;&lt; tmp &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int sumNumbers(TreeNode* root) &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    int ans = 0;</span><br><span class="line">    int tmp = 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144_二叉树的前序遍历"></a>144_二叉树的前序遍历</h2><ul>
<li>他来了他来了</li>
<li>学习下迭代的算法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void dfs(TreeNode* root)&#123;</span><br><span class="line">        if(!root) return;</span><br><span class="line">        res.emplace_back(root-&gt;val);</span><br><span class="line">        dfs(root-&gt;left);</span><br><span class="line">        dfs(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line">&#125;;</span><br><span class="line">//迭代</span><br><span class="line">class Solution_ &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        if (root == nullptr) &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        TreeNode* node = root;</span><br><span class="line">        while (!stk.empty() || node != nullptr) &#123;</span><br><span class="line">            while (node != nullptr) &#123;</span><br><span class="line">                res.emplace_back(node-&gt;val);</span><br><span class="line">                stk.emplace(node);</span><br><span class="line">                node = node-&gt;left;  //先一路往左</span><br><span class="line">            &#125;</span><br><span class="line">            node = stk.top();//弹出节点</span><br><span class="line">            stk.pop();</span><br><span class="line">            node = node-&gt;right; //再往右</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145_二叉树的后序遍历"></a>145_二叉树的后序遍历</h2><ul>
<li>正好默写下迭代的算法</li>
<li>…不会写…</li>
<li>一开始把<code>res.emplace_back(node-&gt;val);</code>改成<code>res.insert(res.begin(), node-&gt;val);</code>根节点的位置对了，但是左右位置反了；机智的我又改了下遍历顺序，先右再左；居然对了</li>
<li>但是这么写，属于旁门左道；而且c++的vector从头部添加时间复杂度O(n)</li>
<li>回过头来，再看看中序是如何迭代的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; postorderTraversal(TreeNode *root) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        if (root == nullptr) &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack&lt;TreeNode *&gt; stk;</span><br><span class="line">        TreeNode *prev = nullptr;   //判断节点的右边是不是已访问过</span><br><span class="line">        while (root != nullptr || !stk.empty()) &#123;</span><br><span class="line">            while (root != nullptr) &#123;</span><br><span class="line">                stk.emplace(root);</span><br><span class="line">                root = root-&gt;left;  //与前序一样都是先往左</span><br><span class="line">            &#125;</span><br><span class="line">            root = stk.top();</span><br><span class="line">            stk.pop();  //然后弹出</span><br><span class="line">            //之后就要开始判断了，何时放入数组</span><br><span class="line">            if (root-&gt;right == nullptr || root-&gt;right == prev) &#123;</span><br><span class="line">                res.emplace_back(root-&gt;val);</span><br><span class="line">                prev = root;</span><br><span class="line">                root = nullptr; //这一步是为了弹出栈顶元素，返回上一层</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                stk.emplace(root);</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//中序遍历</span><br><span class="line">class Solution_ &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        if (root == nullptr) &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        stack&lt;TreeNode *&gt; stk;</span><br><span class="line"></span><br><span class="line">        while (root != nullptr || !stk.empty()) &#123;</span><br><span class="line">            while (root != nullptr) &#123;</span><br><span class="line">                stk.emplace(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">            res.emplace_back(root-&gt;val);</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="173-二叉搜索树迭代器"><a href="#173-二叉搜索树迭代器" class="headerlink" title="173_二叉搜索树迭代器"></a>173_二叉搜索树迭代器</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int i = -1;</span><br><span class="line">vector&lt;int&gt;::size_type s = 0;</span><br><span class="line">std::cout &lt;&lt; (i &lt; s) &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面这个会显示0，因为类型不一样</li>
<li>用了<code>vector</code>在构造函数里就将中序序列保存在数组里，内存消耗排倒数….</li>
<li>迭代还是永远的神！——模拟栈，复习下怎么迭代的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class BSTIterator &#123;</span><br><span class="line">public:</span><br><span class="line">    BSTIterator(TreeNode* root) &#123;</span><br><span class="line">        r = root;</span><br><span class="line">        i = -1;</span><br><span class="line">        tmp_init(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int next() &#123;</span><br><span class="line">        ++i;</span><br><span class="line">        return i &lt; tmp.size() ? tmp[i]-&gt;val : -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool hasNext() &#123;</span><br><span class="line">        return i &lt; tmp.size() - 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void tmp_init(TreeNode* root)&#123;</span><br><span class="line">        if(!root) return;</span><br><span class="line">        tmp_init(root-&gt;left);</span><br><span class="line">        tmp.push_back(root);</span><br><span class="line">        tmp_init(r-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    TreeNode* r;</span><br><span class="line">    int i;</span><br><span class="line">    vector&lt;TreeNode*&gt; tmp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class BSTIterator_ &#123;</span><br><span class="line">public:</span><br><span class="line">    BSTIterator_(TreeNode* root) &#123;</span><br><span class="line">        cur = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int next() &#123;</span><br><span class="line">        while (cur != nullptr)&#123;</span><br><span class="line">            stk.push(cur);</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = stk.top();</span><br><span class="line">        stk.pop();</span><br><span class="line">        int tmp = cur-&gt;val;</span><br><span class="line">        cur = cur-&gt;right;</span><br><span class="line">        return tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool hasNext() &#123;</span><br><span class="line">        //如果是模拟栈，该怎么判断是否还有下一个节点呢</span><br><span class="line">        return cur != nullptr || !stk.empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    stack&lt;TreeNode*&gt; stk;</span><br><span class="line">    TreeNode* cur;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your BSTIterator object will be instantiated and called as such:</span><br><span class="line"> * BSTIterator* obj = new BSTIterator(root);</span><br><span class="line"> * int param_1 = obj-&gt;next();</span><br><span class="line"> * bool param_2 = obj-&gt;hasNext();</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">/*    int i = -1;</span><br><span class="line">    vector&lt;int&gt;::size_type s = 0;</span><br><span class="line">    std::cout &lt;&lt; (i &lt; s) &lt;&lt; std::endl;*/</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199_二叉树的右视图"></a>199_二叉树的右视图</h2><ul>
<li>一次通过，广度优先搜索，记录下每层的最后一个元素。</li>
<li>题解也用了深度优先搜索，要先访问右边子节点</li>
<li>还是忍不住又刷了一题…</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//dfs</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; ans;</span><br><span class="line">    void dfs(TreeNode* root, int d)&#123;</span><br><span class="line">        if(!root)return;</span><br><span class="line">        //d是深度，也防止回溯时（回到左孩子节点）添加不符合条件的左边的值</span><br><span class="line">        if(ans.size() &lt; d)ans.push_back(root-&gt;val);</span><br><span class="line">        dfs(root-&gt;right, d+1);</span><br><span class="line">        dfs(root-&gt;left, d+1);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt; rightSideView(TreeNode* root) &#123;</span><br><span class="line">        dfs(root, 1);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//bfs, 可以先放右孩子这样每一层第一个节点就是要找的值</span><br><span class="line">class Solution1 &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; rightSideView(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return &#123;&#125;;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            int n = q.size();</span><br><span class="line">            int tmp = 0;</span><br><span class="line">            while(n &gt; 0)&#123;</span><br><span class="line">                auto r = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                tmp = r-&gt;val;</span><br><span class="line">                if(r-&gt;left != nullptr)</span><br><span class="line">                    q.push(r-&gt;left);</span><br><span class="line">                if(r-&gt;right != nullptr)</span><br><span class="line">                    q.push(r-&gt;right);</span><br><span class="line">                --n;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="208-实现Trie-前缀树"><a href="#208-实现Trie-前缀树" class="headerlink" title="208_实现Trie(前缀树)"></a>208_实现Trie(前缀树)</h2><ul>
<li>这题看不懂</li>
<li>字典树，是一棵有根树；这题面试会问到</li>
<li>题解用的数组，每个数组存放</li>
<li>26个指向Trie的指针；原来的类至始至终都是根节点？</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Trie &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;Trie*&gt; children;</span><br><span class="line">    bool isEnd;</span><br><span class="line"></span><br><span class="line">    Trie* searchPrefix(string prefix) &#123;</span><br><span class="line">        Trie* node = this;</span><br><span class="line">        for (char ch : prefix) &#123;</span><br><span class="line">            ch -= &apos;a&apos;;</span><br><span class="line">            if (node-&gt;children[ch] == nullptr) &#123;</span><br><span class="line">                return nullptr;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;children[ch];</span><br><span class="line">        &#125;</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    Trie() : children(26), isEnd(false) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    void insert(string word) &#123;</span><br><span class="line">        Trie* node = this;</span><br><span class="line">        //对于字符串的每个字母</span><br><span class="line">        for (char ch : word) &#123;</span><br><span class="line">            //每次循坏都会将node更新到对应的字母上</span><br><span class="line">            ch -= &apos;a&apos;;</span><br><span class="line">            if (node-&gt;children[ch] == nullptr) &#123;</span><br><span class="line">                node-&gt;children[ch] = new Trie();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;children[ch];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;isEnd = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool search(string word) &#123;</span><br><span class="line">        Trie* node = this-&gt;searchPrefix(word);</span><br><span class="line">        return node != nullptr &amp;&amp; node-&gt;isEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool startsWith(string prefix) &#123;</span><br><span class="line">        return this-&gt;searchPrefix(prefix) != nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="211-添加与搜索单词-数据结构设计"><a href="#211-添加与搜索单词-数据结构设计" class="headerlink" title="211_添加与搜索单词 - 数据结构设计"></a>211_添加与搜索单词 - 数据结构设计</h2><ul>
<li>想不通，为什么<code>.</code>不能搜索到；难道是只能有一个字母么</li>
<li><code>.</code>的话，要继续搜索不为空的<code>dic</code>，继续递归；回溯的时候，要判断最终结果是否为真，因为只需找到一个就可以了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class WordDictionary &#123;</span><br><span class="line">public:</span><br><span class="line">    /** Initialize your data structure here. */</span><br><span class="line">    WordDictionary() :  dic(26, nullptr), is_end(false) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void addWord(string word) &#123;</span><br><span class="line">        WordDictionary *node = this;</span><br><span class="line">        for (char c : word) &#123;</span><br><span class="line">            auto pos = c - &apos;a&apos;;</span><br><span class="line">            if (node-&gt;dic[pos] == nullptr)</span><br><span class="line">                node-&gt;dic[pos] = new WordDictionary;</span><br><span class="line">            node = node-&gt;dic[pos];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;is_end = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool search(string word) &#123;</span><br><span class="line">        bool result = false;</span><br><span class="line">        search(this, 0, word, result);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void search(WordDictionary *root, int start, string &amp;word, bool &amp;result) &#123;</span><br><span class="line">        if (start == word.size()) &#123;</span><br><span class="line">            if (root-&gt;is_end)</span><br><span class="line">                result = true;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //记录初始位置的参数，比substr好多了</span><br><span class="line">        char ch = word[start];</span><br><span class="line">        ++start;</span><br><span class="line">        if (ch != &apos;.&apos;) &#123;</span><br><span class="line">            // 当前层的字符不是通配符, 只检查当前字符是否存在</span><br><span class="line">            WordDictionary *node = root-&gt;dic[ch - &apos;a&apos;];</span><br><span class="line">            if (node != nullptr)</span><br><span class="line">                search(node, start, word, result);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            auto candicates = root-&gt;dic;</span><br><span class="line">            // 当前层是通配符, 所以需要把dic中不为空的都尝试一遍</span><br><span class="line">            for (auto candicate : candicates) &#123;</span><br><span class="line">                if (candicate != nullptr) &#123;</span><br><span class="line">                    search(candicate, start, word, result); // 搜索下一层</span><br><span class="line">                    if (result) // 找到一个即可退出</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;WordDictionary *&gt; dic;</span><br><span class="line">    bool is_end;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="212-单词搜索-II"><a href="#212-单词搜索-II" class="headerlink" title="212_单词搜索_II"></a>212_单词搜索_II</h2><ul>
<li>这其实也是一个前缀树；我不会举一反三0.0</li>
<li>这里代码是将字母临时更改为<code>#</code>，然后在回溯的时候恢复</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct Trie &#123;</span><br><span class="line">    Trie* next[26];</span><br><span class="line">//    注意在这里是字符串而不是布尔值</span><br><span class="line">    string word;</span><br><span class="line"></span><br><span class="line">    Trie() &#123;</span><br><span class="line">        for (auto &amp; i : next) &#123;</span><br><span class="line">            i = nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        word = &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    Trie root;</span><br><span class="line">    int m = 0;</span><br><span class="line">    int n = 0;</span><br><span class="line">    int d[4][2] = &#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    void insert(string &amp;word) &#123;</span><br><span class="line">        Trie* cur = &amp;root;</span><br><span class="line"></span><br><span class="line">        for (char c : word) &#123;</span><br><span class="line">            if (cur-&gt;next[c - &apos;a&apos;] == nullptr) &#123;</span><br><span class="line">                cur-&gt;next[c - &apos;a&apos;] = new Trie();</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next[c - &apos;a&apos;];</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;word = word;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void dfs(vector&lt;string&gt;&amp; ans, vector&lt;vector&lt;char&gt;&gt;&amp; board, int x, int y, Trie* r) &#123;</span><br><span class="line">        char c = board[x][y];</span><br><span class="line">        if (c == &apos;#&apos;) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (r-&gt;next[c - &apos;a&apos;] == nullptr) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        r = r-&gt;next[c - &apos;a&apos;];</span><br><span class="line">        if (!r-&gt;word.empty()) &#123;</span><br><span class="line">            ans.push_back(r-&gt;word);</span><br><span class="line">            r-&gt;word = &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        board[x][y] = &apos;#&apos;;</span><br><span class="line"></span><br><span class="line">        for (auto &amp; i : d) &#123;</span><br><span class="line">            int newx = x + i[0];</span><br><span class="line">            int newy = y + i[1];</span><br><span class="line"></span><br><span class="line">            if (newx &gt;= 0 &amp;&amp; newx &lt; m &amp;&amp; newy &gt;= 0 &amp;&amp; newy &lt; n &amp;&amp; board[newx][newy] != &apos;#&apos;) &#123;</span><br><span class="line">                dfs(ans, board, newx, newy, r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        board[x][y] = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;string&gt; findWords(vector&lt;vector&lt;char&gt;&gt;&amp; board, vector&lt;string&gt;&amp; words) &#123;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        m = static_cast&lt;int&gt;(board.size());</span><br><span class="line">        n = static_cast&lt;int&gt;(board[0].size());</span><br><span class="line"></span><br><span class="line">        //在这里是先对所有的提供的单词建立前缀树</span><br><span class="line">        for (auto &amp;word : words) &#123;</span><br><span class="line">            insert(word);</span><br><span class="line">        &#125;</span><br><span class="line">        //然后根据前缀树搜索，妙啊</span><br><span class="line">        for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">                dfs(ans, board, i, j, &amp;root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222_完全二叉树的节点个数"></a>222_完全二叉树的节点个数</h2><ul>
<li>什么叫做完全二叉树？</li>
<li>一棵深度为<code>k</code>的有<code>n</code>个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为<code>i（1≤i≤n）</code>的结点与满二叉树中编号为<code>i</code>的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。</li>
<li>完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2^h 个节点。</li>
<li>二分法我是没想到的</li>
</ul>
<p><img src="/pictrues/222.png" alt="二进制" title="如何二分"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//BFS</span><br><span class="line">class Solution1 &#123;</span><br><span class="line">public:</span><br><span class="line">    int countNodes(TreeNode* root) &#123;</span><br><span class="line">        if(!root)</span><br><span class="line">            return 0;</span><br><span class="line">        //所以这题是计算出层数+最后一层的节点数？</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        int ans = 1;</span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            int n = q.size();</span><br><span class="line">            while(n &gt; 0)&#123;</span><br><span class="line">                auto node = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                if(node-&gt;left != nullptr)&#123;</span><br><span class="line">                    ++ans;</span><br><span class="line">                    q.push(node-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                if(node-&gt;right != nullptr)&#123;</span><br><span class="line">                    ++ans;</span><br><span class="line">                    q.push(node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">                --n;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//DFS</span><br><span class="line">class Solution2 &#123;</span><br><span class="line">public:</span><br><span class="line">   void dfs(int &amp;depth, int &amp;last, int tmp, TreeNode* root)&#123;</span><br><span class="line">       if(!root)</span><br><span class="line">           return;</span><br><span class="line">       depth = max(depth, tmp);</span><br><span class="line">       if(!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; depth == tmp)&#123;</span><br><span class="line">           //说明这是最后一个节点，而且深度必须是最后一层</span><br><span class="line">           ++last;</span><br><span class="line">       &#125;</span><br><span class="line">       dfs(depth, last, tmp + 1, root-&gt;left);</span><br><span class="line">       dfs(depth, last, tmp + 1, root-&gt;right);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   int countNodes(TreeNode* root) &#123;</span><br><span class="line">       if(!root)</span><br><span class="line">           return 0;</span><br><span class="line">       int depth = 0, last = 0;</span><br><span class="line">       dfs(depth, last, 0, root);</span><br><span class="line">       //cout &lt;&lt; &quot;depth = &quot; &lt;&lt; depth &lt;&lt; &quot; last = &quot; &lt;&lt; last &lt;&lt; endl;</span><br><span class="line">       return static_cast&lt;int&gt;(pow(2, depth) - 1 + last);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int countNodes(TreeNode* root) &#123;</span><br><span class="line">        if (root == nullptr) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int level = 0;</span><br><span class="line">        TreeNode* node = root;</span><br><span class="line">        while (node-&gt;left != nullptr) &#123;</span><br><span class="line">            //这里深度只需一直判断左节点是什么为空即可</span><br><span class="line">            level++;</span><br><span class="line">            node = node-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        int low = 1 &lt;&lt; level, high = (1 &lt;&lt; (level + 1)) - 1;</span><br><span class="line">        while (low &lt; high) &#123;</span><br><span class="line">            int mid = (high - low + 1) / 2 + low;</span><br><span class="line">            if (exists(root, level, mid)) &#123;</span><br><span class="line">                low = mid;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                high = mid - 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return low;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool exists(TreeNode* root, int level, int k) &#123;</span><br><span class="line">        int bits = 1 &lt;&lt; (level - 1);</span><br><span class="line">        TreeNode* node = root;</span><br><span class="line">        while (node != nullptr &amp;&amp; bits &gt; 0) &#123;</span><br><span class="line">            if (!(bits &amp; k)) &#123;</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                node = node-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            bits &gt;&gt;= 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return node != nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226_翻转二叉树"></a>226_翻转二叉树</h2><ul>
<li>师兄说了，这个题目别用递归，让我再想想；那就…再想想</li>
<li>递归、BFS、DFS（迭代），完了迭代有点不会写了…要把之前的前序、中序、后序遍历都得好好复习</li>
<li>不太对，栈模拟跟队列极为相似</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//dfs和递归有点区别，这个方法应该是递归</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* invertTree(TreeNode* root) &#123;</span><br><span class="line">        if(!root)</span><br><span class="line">            return nullptr;</span><br><span class="line"></span><br><span class="line">        auto tmp = root-&gt;left;</span><br><span class="line">        root-&gt;left = root-&gt;right;</span><br><span class="line">        root-&gt;right = tmp;</span><br><span class="line">        root-&gt;left = invertTree(root-&gt;left);</span><br><span class="line">        root-&gt;right = invertTree(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//bfs</span><br><span class="line">class Solution1 &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* invertTree(TreeNode* root) &#123;</span><br><span class="line">        if(!root)</span><br><span class="line">            return nullptr;</span><br><span class="line">        //不改变指针，只改变数值？不知是否可行，不行，空指针无法改变值</span><br><span class="line">        //反转只能改变指针</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            int n = q.size();</span><br><span class="line">            while(n &gt; 0)&#123;</span><br><span class="line">                auto node = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                auto l = node-&gt;left;</span><br><span class="line">                node-&gt;left = node-&gt;right;</span><br><span class="line">                node-&gt;right = l;</span><br><span class="line">                if(l != nullptr)&#123;</span><br><span class="line">                    q.push(l);</span><br><span class="line">                &#125;</span><br><span class="line">                if(node-&gt;left != nullptr)&#123;</span><br><span class="line">                    q.push(node-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                --n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="230-二叉搜索树中第K小的元素"><a href="#230-二叉搜索树中第K小的元素" class="headerlink" title="230_二叉搜索树中第K小的元素"></a>230_二叉搜索树中第K小的元素</h2><ul>
<li>复习下前序遍历，递归+迭代、还好，前序迭代还没忘</li>
<li>不愧是大佬，可以进行剪枝进行优化</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//递归</span><br><span class="line">class Solution1 &#123;</span><br><span class="line">public:</span><br><span class="line">    void dfs(TreeNode* root)&#123;</span><br><span class="line">        if(!root)</span><br><span class="line">            return;</span><br><span class="line">        dfs(root-&gt;left);</span><br><span class="line">        ans.emplace_back(root-&gt;val);</span><br><span class="line">        dfs(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int kthSmallest(TreeNode* root, int k) &#123;</span><br><span class="line">        //进阶感觉我想不出来，还是先复习下前序遍历吧</span><br><span class="line">        dfs(root);</span><br><span class="line">        return ans[k - 1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    vector&lt;int&gt; ans;</span><br><span class="line">&#125;;</span><br><span class="line">//迭代</span><br><span class="line">class Solution2 &#123;</span><br><span class="line">public:</span><br><span class="line">    int kthSmallest(TreeNode* root, int k) &#123;</span><br><span class="line">        vector&lt;int&gt; ans;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        stk.push(root);</span><br><span class="line">        auto node = root-&gt;left;</span><br><span class="line">        while(!stk.empty() || node != nullptr)&#123;</span><br><span class="line">            while (node != nullptr)&#123;</span><br><span class="line">                stk.push(node);</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            //这里node为空</span><br><span class="line">            node = stk.top();</span><br><span class="line">            ans.emplace_back(node-&gt;val);</span><br><span class="line">            stk.pop();</span><br><span class="line">            //这里向右</span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans[k - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//递归剪枝——不用数组，直接进行计数；除了n以外，还需要tmp来记录第k个最小的元素</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void dfs(TreeNode* root, int k)&#123;</span><br><span class="line">        if(!root || n &gt; k)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root-&gt;left, k);</span><br><span class="line">        ++n;</span><br><span class="line">        if(n == k)</span><br><span class="line">            ans = root-&gt;val;</span><br><span class="line">        dfs(root-&gt;right, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int kthSmallest(TreeNode* root, int k) &#123;</span><br><span class="line">        dfs(root, k);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int n = 0;</span><br><span class="line">    int ans = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235_二叉搜索树的最近公共祖先"></a>235_二叉搜索树的最近公共祖先</h2><ul>
<li>递归！</li>
<li>因为是二叉搜索树！如果一个小于等于根节点，另一个大于等于根节点，那最近公共祖先就是根节点</li>
<li>注意的是，给的参数不一定是分左右的；要先区分下；不能直接更换节点的值</li>
<li>题解是直接遍历的，那这里就献丑了：）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        auto l = p-&gt;val &gt; q-&gt;val ? q : p;</span><br><span class="line">        auto r = p-&gt;val &gt; q-&gt;val ? p : q;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        if(root-&gt;val &gt;= l-&gt;val &amp;&amp; root-&gt;val &lt;= r-&gt;val)&#123;</span><br><span class="line">            return root;</span><br><span class="line">        &#125;else if(root-&gt;val &lt; l-&gt;val &amp;&amp; root-&gt;val &lt; r-&gt;val)&#123;</span><br><span class="line">            return lowestCommonAncestor(root-&gt;right, l, r);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return lowestCommonAncestor(root-&gt;left, l, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236_二叉树的最近公共祖先"></a>236_二叉树的最近公共祖先</h2><ul>
<li>这就不是二叉搜索树了</li>
<li>用递归可以写出来，从上倒下存储父节点，还用了三个数组…；题解的两个方法都是从下到上，一个是条件判断，一个是用了哈希</li>
</ul>
<p><img src="/pictrues/236.png" alt="回溯" title="回溯"></p>
<ul>
<li>我还是太菜了，从下到上遍历，应该是回溯</li>
<li>就是这个判断条件不容易想到，，，</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//自己手撕</span><br><span class="line">class Solution1 &#123;</span><br><span class="line">public:</span><br><span class="line">    void dfs(TreeNode* root, TreeNode* p, TreeNode* q)&#123;</span><br><span class="line">        if(!root || (!t1.empty() &amp;&amp; !t2.empty()))&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp.emplace_back(root);</span><br><span class="line">        if(root-&gt;val == p-&gt;val)&#123;</span><br><span class="line">            t1 = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        if(root-&gt;val == q-&gt;val)&#123;</span><br><span class="line">            t2 = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root-&gt;left, p, q);</span><br><span class="line">        dfs(root-&gt;right, p, q);</span><br><span class="line">        tmp.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        dfs(root, p, q);</span><br><span class="line">        //同时遍历两个数组，共同祖先都是根节点</span><br><span class="line">        int n1 = t1.size(), n2 = t2.size();</span><br><span class="line">        int n = min(n1, n2);</span><br><span class="line">        TreeNode* ans = nullptr;</span><br><span class="line">        for(int i = 0; i &lt; n; ++i)&#123;</span><br><span class="line">            if(t1[i]-&gt;val == t2[i]-&gt;val)&#123;</span><br><span class="line">                ans = t1[i];</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    vector&lt;TreeNode*&gt; t1;</span><br><span class="line">    vector&lt;TreeNode*&gt; t2;</span><br><span class="line">    vector&lt;TreeNode*&gt; tmp;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//题解1</span><br><span class="line">class Solution2 &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* ans = nullptr;</span><br><span class="line">    //这里是返回布尔值！</span><br><span class="line">    bool dfs(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        //这里出口是!root，那么会全部递归一边，可以剪个枝来优化下</span><br><span class="line">        if(!root || ans != nullptr)</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        //可以这样理解，这两条代码放在一起，就是话不多说，先递归到最左边的一个节点，这时再往下（无论左右）都是空指针，都会返回false</span><br><span class="line">        bool lson = dfs(root-&gt;left, p, q);</span><br><span class="line">        bool rson = dfs(root-&gt;right, p, q);</span><br><span class="line"></span><br><span class="line">        if ((lson &amp;&amp; rson) || ((root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val) &amp;&amp; (lson || rson))) &#123;</span><br><span class="line">            ans = root;</span><br><span class="line">        &#125;</span><br><span class="line">        return lson || rson || (root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        dfs(root, p, q);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//题解2</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    unordered_map&lt;int, TreeNode*&gt; fa;</span><br><span class="line">    unordered_map&lt;int, bool&gt; vis;</span><br><span class="line">    void dfs(TreeNode* root)&#123;</span><br><span class="line">        if (root-&gt;left != nullptr) &#123;</span><br><span class="line">            fa[root-&gt;left-&gt;val] = root;</span><br><span class="line">            dfs(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        if (root-&gt;right != nullptr) &#123;</span><br><span class="line">            fa[root-&gt;right-&gt;val] = root;</span><br><span class="line">            dfs(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        //根节点的父节点为空</span><br><span class="line">        fa[root-&gt;val] = nullptr;</span><br><span class="line">        //这个dfs是用来存储每个节点的父节点</span><br><span class="line">        dfs(root);</span><br><span class="line"></span><br><span class="line">        while (p != nullptr) &#123;</span><br><span class="line">            vis[p-&gt;val] = true;</span><br><span class="line">            //存储的好处是，可以直接访问p的父节点</span><br><span class="line">            p = fa[p-&gt;val];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (q != nullptr) &#123;</span><br><span class="line">            if (vis[q-&gt;val])</span><br><span class="line">                return q;</span><br><span class="line"></span><br><span class="line">            q = fa[q-&gt;val];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257_二叉树的所有路径"></a>257_二叉树的所有路径</h2><ul>
<li>这题采用分治递归的思路，没有用<code>void dfs(...)</code></li>
<li>有个注意点，就是<code>if else</code>，有的条件就算写了也达不到，因为必须要让上面的<code>if else</code>都不成立才行，容易漏掉情况，之后改成了三个<code>if</code></li>
<li>也可以用广度优先搜索</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//dfs</span><br><span class="line">class Solution1 &#123;</span><br><span class="line">public:</span><br><span class="line">    //这里换个递归思路，参考昨天的分治递归</span><br><span class="line">    vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123;</span><br><span class="line">        if(!root)</span><br><span class="line">            return vector&lt;string&gt;();</span><br><span class="line"></span><br><span class="line">        string s = to_string(root-&gt;val);</span><br><span class="line">        vector&lt;string&gt; l(binaryTreePaths(root-&gt;left));</span><br><span class="line">        vector&lt;string&gt; r(binaryTreePaths(root-&gt;right));</span><br><span class="line"></span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        //这里两个都必须为空才行</span><br><span class="line">        if(l.empty() &amp;&amp; r.empty())&#123;</span><br><span class="line">            ans.emplace_back(s);</span><br><span class="line">        &#125;</span><br><span class="line">        if(!l.empty())&#123;</span><br><span class="line">            for(const auto&amp; tmp : l)&#123;</span><br><span class="line">                ans.emplace_back(s + &quot;-&gt;&quot; + tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!r.empty())&#123;</span><br><span class="line">            for(const auto&amp; tmp : r)&#123;</span><br><span class="line">                ans.emplace_back(s + &quot;-&gt;&quot; + tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//bfs</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;string&gt; paths;</span><br><span class="line">        if (root == nullptr) &#123;</span><br><span class="line">            return paths;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; node_queue;</span><br><span class="line">        queue&lt;string&gt; path_queue;</span><br><span class="line"></span><br><span class="line">        node_queue.push(root);</span><br><span class="line">        path_queue.push(to_string(root-&gt;val));</span><br><span class="line"></span><br><span class="line">        while (!node_queue.empty()) &#123;</span><br><span class="line">            TreeNode* node = node_queue.front();</span><br><span class="line">            string path = path_queue.front();</span><br><span class="line">            node_queue.pop();</span><br><span class="line">            path_queue.pop();</span><br><span class="line"></span><br><span class="line">            if (node-&gt;left == nullptr &amp;&amp; node-&gt;right == nullptr) &#123;</span><br><span class="line">                paths.push_back(path);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (node-&gt;left != nullptr) &#123;</span><br><span class="line">                    node_queue.push(node-&gt;left);</span><br><span class="line">                    path_queue.push(path + &quot;-&gt;&quot; + to_string(node-&gt;left-&gt;val));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (node-&gt;right != nullptr) &#123;</span><br><span class="line">                    node_queue.push(node-&gt;right);</span><br><span class="line">                    path_queue.push(path + &quot;-&gt;&quot; + to_string(node-&gt;right-&gt;val));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return paths;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="297-二叉树的序列化与反序列化"><a href="#297-二叉树的序列化与反序列化" class="headerlink" title="297_二叉树的序列化与反序列化"></a>297_二叉树的序列化与反序列化</h2><ul>
<li><p>昨天刚做过剑指Offer37题，哈哈，今天再复习下</p>
<ul>
<li>就用字符串、链表的形式来吧</li>
<li>还可以，一次过——看看哪里再优化下</li>
<li>题解将字符串转为链表是，用了一个临时字符串<code>str</code>，每次遇到<code>&#39;,&#39;</code>，就先放入链表，再清空；最后循环结束，也要判断字符串<code>str</code>是否不为空，以免遗漏</li>
<li>跟题解消耗差不多，就不放题解了！</li>
</ul>
</li>
<li><p>做完发现，</p>
</li>
<li><p>中位数那题还没有整理好！！</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//手撕版</span><br><span class="line">class Codec &#123;</span><br><span class="line">public:</span><br><span class="line">    string serialize(TreeNode* root) &#123;</span><br><span class="line">        if(!root)&#123;</span><br><span class="line">            return &quot;n,&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        string s;</span><br><span class="line">        s += to_string(root-&gt;val);</span><br><span class="line">        s.push_back(&apos;,&apos;);</span><br><span class="line"></span><br><span class="line">        s += serialize(root-&gt;left);</span><br><span class="line">        s += serialize(root-&gt;right);</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode* deserialize(string data) &#123;</span><br><span class="line">        //先转为双向链表</span><br><span class="line">        list&lt;string&gt; l(convert(data));</span><br><span class="line">        return deserialize(l);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    list&lt;string&gt; convert(string&amp; data)&#123;</span><br><span class="line">        //字符串中的数字或者n都是以&apos;,&apos;分隔的</span><br><span class="line">        list&lt;string&gt; l;</span><br><span class="line">        //这里应该用while循环比较好</span><br><span class="line">        int i = 0;</span><br><span class="line">        while(i &lt; data.size())&#123;</span><br><span class="line">            if(data[i] == &apos;n&apos;)&#123;</span><br><span class="line">                l.emplace_back(&quot;n&quot;);</span><br><span class="line">            &#125;else if(data[i] == &apos;-&apos; || isdigit(data[i]))&#123;</span><br><span class="line">                int j = i + 1;</span><br><span class="line">                while(isdigit(data[j]))&#123;</span><br><span class="line">                    ++j;</span><br><span class="line">                &#125;</span><br><span class="line">                //循环结束j指向的应是逗号</span><br><span class="line">                l.emplace_back(data.substr(i, j - i));</span><br><span class="line">                //更新下标</span><br><span class="line">                i = j;</span><br><span class="line">            &#125;</span><br><span class="line">            //若是逗号，直接跳过</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        return l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode* deserialize(list&lt;string&gt;&amp; l)&#123;</span><br><span class="line">        //这个链表都是一个一个数字，每次都要删除开头的数字</span><br><span class="line">        if(l.empty() || *l.begin() == &quot;n&quot;)&#123;</span><br><span class="line">            if(!l.empty()) l.erase(l.begin());</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        //生成二叉树</span><br><span class="line">        TreeNode* head = new TreeNode(stoi(*l.begin()));</span><br><span class="line">        //进入下一个递归，要删除第一个，出口也是一样，用一个扔一个</span><br><span class="line">        l.erase(l.begin());</span><br><span class="line">        head-&gt;left = deserialize(l);</span><br><span class="line">        //这边回溯回来后，已经删除了</span><br><span class="line">        head-&gt;right = deserialize(l);</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="897-递增顺序搜索树"><a href="#897-递增顺序搜索树" class="headerlink" title="897_递增顺序搜索树"></a>897_递增顺序搜索树</h2><ul>
<li>这题感觉做过，正好复习下中序的递归和迭代</li>
<li>迭代的话，应该是后序比较复杂；已经忘了怎么写了，判断条件写的不对</li>
<li>题解还有一次遍历原地更改指针的方法，学习下</li>
<li>后序迭代需要一个指针来记录访问过的右节点，如果没有访问那就入栈，并更新当前节点为右节点；若是以访问过或者为空，更新记录的节点，并令当前节点为空</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution_ &#123;</span><br><span class="line">public:</span><br><span class="line">    void bst(TreeNode* root)&#123;</span><br><span class="line">        if(!root) return;</span><br><span class="line">        bst(root-&gt;left);</span><br><span class="line">        head-&gt;right = new TreeNode(root-&gt;val);</span><br><span class="line">        head = head-&gt;right;</span><br><span class="line">        bst(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode* increasingBST(TreeNode* root) &#123;</span><br><span class="line">        auto res = head;</span><br><span class="line">        bst(root);</span><br><span class="line">        return res-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    TreeNode* head = new TreeNode();// 初始化，如果不写，为什么不会调用TreeNode的构造函数呢；因为默认构造！！指针默认初始化为nullptr</span><br><span class="line">&#125;;</span><br><span class="line">//迭代</span><br><span class="line">class Solution1 &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* increasingBST(TreeNode* root) &#123;</span><br><span class="line">        TreeNode* head = new TreeNode();</span><br><span class="line">        auto carry = head;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        //判断条件还要再加上一句</span><br><span class="line">        while (!stk.empty() || root != nullptr)&#123;</span><br><span class="line">            while (root != nullptr)&#123;</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">                stk.push(root);</span><br><span class="line">            &#125;</span><br><span class="line">            //root为nullptr，这样写的话根节点弹出后，栈为空就结束了，之前是怎么写来着？</span><br><span class="line">            root = stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">            head-&gt;right = new TreeNode(root-&gt;val);</span><br><span class="line">            head = head-&gt;right;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        return carry -&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">//原地修改</span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    TreeNode *resNode;</span><br><span class="line">public:</span><br><span class="line">    void inorder(TreeNode *node) &#123;</span><br><span class="line">        if (node == nullptr) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(node-&gt;left);</span><br><span class="line"></span><br><span class="line">        // 在中序遍历的过程中修改节点指向</span><br><span class="line">        resNode-&gt;right = node;</span><br><span class="line">        node-&gt;left = nullptr;</span><br><span class="line">        resNode = node;</span><br><span class="line"></span><br><span class="line">        inorder(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode *increasingBST(TreeNode *root) &#123;</span><br><span class="line">        TreeNode *dummyNode = new TreeNode(-1);</span><br><span class="line">        resNode = dummyNode;</span><br><span class="line">        inorder(root);</span><br><span class="line">        return dummyNode-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="938-二叉搜索树的范围和"><a href="#938-二叉搜索树的范围和" class="headerlink" title="938_二叉搜索树的范围和"></a>938_二叉搜索树的范围和</h2><ul>
<li>感觉就是边遍历边判断条件</li>
<li>但还有个二叉搜索树这个条件，二叉搜索树右子树上所有节点的值均大于根节点的值；二叉搜索树左子树上所有节点的值均小于根节点的值</li>
<li>直接全部遍历会浪费一些不必要的时间，结果来看，时间只减小了一部分</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">/*class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int rangeSumBST(TreeNode* root, int low, int high) &#123;</span><br><span class="line">        if(!root) return 0;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        if(root-&gt;val &gt;= low &amp;&amp; root-&gt;val &lt;= high)&#123;</span><br><span class="line">            //cout &lt;&lt; &quot;root-&gt;val = &quot; &lt;&lt; root-&gt;val &lt;&lt; endl;</span><br><span class="line">            ans += root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += rangeSumBST(root-&gt;left, low, high);</span><br><span class="line">        ans += rangeSumBST(root-&gt;right, low, high);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">/*class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int rangeSumBST(TreeNode *root, int low, int high) &#123;</span><br><span class="line">        if (root == nullptr) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (root-&gt;val &gt; high) &#123;</span><br><span class="line">            return rangeSumBST(root-&gt;left, low, high);</span><br><span class="line">        &#125;</span><br><span class="line">        if (root-&gt;val &lt; low) &#123;</span><br><span class="line">            return rangeSumBST(root-&gt;right, low, high);</span><br><span class="line">        &#125;</span><br><span class="line">        return root-&gt;val + rangeSumBST(root-&gt;left, low, high) + rangeSumBST(root-&gt;right, low, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int rangeSumBST(TreeNode *root, int low, int high) &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        queue&lt;TreeNode*&gt; q(&#123;root&#125;);</span><br><span class="line">        while (!q.empty()) &#123;</span><br><span class="line">            auto node = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            if (node == nullptr) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if (node-&gt;val &gt; high) &#123;</span><br><span class="line">                q.push(node-&gt;left);</span><br><span class="line">            &#125; else if (node-&gt;val &lt; low) &#123;</span><br><span class="line">                q.push(node-&gt;right);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                sum += node-&gt;val;</span><br><span class="line">                q.push(node-&gt;left);</span><br><span class="line">                q.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="133-克隆图"><a href="#133-克隆图" class="headerlink" title="133_克隆图"></a>133_克隆图</h2><ul>
<li>无向连通图、深拷贝</li>
<li>深拷贝不能拷贝节点列表吗，这题有点心力憔悴，不知道哪里除了问题</li>
<li>我知道了，这题不能用<code>set</code>，因为<code>set</code>只能存储一个关键字信息，不能重复，存放的是<code>res</code>，所以在递归作比较的时候，应该比较的是原来的节点之间，而不是和<code>res</code>作比较，因为此时 <code>res</code>的邻居节点容器为空，所以肯定找不到<code>set.find(node)</code>，会一直无限循环下去</li>
<li>广度优先搜索还是离不开队列啊</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Node &#123;</span><br><span class="line">public:</span><br><span class="line">    int val;</span><br><span class="line">    vector&lt;Node*&gt; neighbors;</span><br><span class="line">    Node() &#123;</span><br><span class="line">        val = 0;</span><br><span class="line">        neighbors = vector&lt;Node*&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    Node(int _val) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        neighbors = vector&lt;Node*&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    Node(int _val, vector&lt;Node*&gt; _neighbors) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        neighbors = _neighbors;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    unordered_map&lt;Node*, Node*&gt; visited;</span><br><span class="line">    Node* cloneGraph(Node* node) &#123;</span><br><span class="line">        if (node == nullptr)</span><br><span class="line">            return node;</span><br><span class="line">        // 如果该节点已经被访问过了，则直接从哈希表中取出对应的克隆节点返回</span><br><span class="line">        if (visited.find(node) != visited.end())</span><br><span class="line">            return visited[node];</span><br><span class="line">        // 克隆节点，注意到为了深拷贝我们不会克隆它的邻居的列表</span><br><span class="line">        Node* cloneNode = new Node(node-&gt;val);</span><br><span class="line">        // 哈希表存储</span><br><span class="line">        visited[node] = cloneNode;</span><br><span class="line">        // 遍历该节点的邻居并更新克隆节点的邻居列表</span><br><span class="line">        for (auto&amp; neighbor: node-&gt;neighbors)</span><br><span class="line">            cloneNode-&gt;neighbors.emplace_back(cloneGraph(neighbor));</span><br><span class="line"></span><br><span class="line">        return cloneNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207_课程表"></a>207_课程表</h2><ul>
<li>我猜这是判断有向图是否有环</li>
<li>没有出现在图中的数字，可以不用管他，因为肯定可以学完</li>
<li>无从下手，学习下拓扑排序：对于图G中的任意一条有向边 (u, v)，u在排列中都出现在v的前面。</li>
<li>深度优先搜索，是将状态分为三个部分，而不是两个；虽然说是栈，但在实现的时候，用的都是数组</li>
<li>在广度优先搜索中，主要是找出队首的点</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//深度优先搜索</span><br><span class="line">class Solution_ &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; edges;</span><br><span class="line">    vector&lt;int&gt; visited;</span><br><span class="line">    bool valid = true;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    void dfs(int u) &#123;</span><br><span class="line">        //u是对应的课程</span><br><span class="line">        visited[u] = 1;         //标记已访问——搜索中</span><br><span class="line">        for (int v: edges[u]) &#123;</span><br><span class="line">            if (visited[v] == 0) &#123;</span><br><span class="line">                dfs(v);</span><br><span class="line">                if (!valid) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (visited[v] == 1) &#123;</span><br><span class="line">                valid = false;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[u] = 2;     //标记已访问——搜索结束</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123;</span><br><span class="line">        edges.resize(numCourses);</span><br><span class="line">        visited.resize(numCourses);</span><br><span class="line">        for (const auto&amp; info: prerequisites) &#123;</span><br><span class="line">            //这里对应的索引对应课程</span><br><span class="line">            edges[info[1]].push_back(info[0]);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; numCourses &amp;&amp; valid; ++i) &#123;</span><br><span class="line">            if (!visited[i]) &#123;</span><br><span class="line">                dfs(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return valid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//广度优先搜索</span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; edges;</span><br><span class="line">    vector&lt;int&gt; indeg;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123;</span><br><span class="line">        edges.resize(numCourses);</span><br><span class="line">        indeg.resize(numCourses);</span><br><span class="line">        for (const auto&amp; info: prerequisites) &#123;</span><br><span class="line">            edges[info[1]].push_back(info[0]);</span><br><span class="line">            //这里是对应的个数，而不是对应的课程号</span><br><span class="line">            ++indeg[info[0]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue&lt;int&gt; q;</span><br><span class="line">        for (int i = 0; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            //先放入没有边的节点，不太对，这里是图的起点</span><br><span class="line">            if (indeg[i] == 0) &#123;</span><br><span class="line">                q.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int visited = 0;</span><br><span class="line">        while (!q.empty()) &#123;</span><br><span class="line">            ++visited;</span><br><span class="line">            int u = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            for (int v: edges[u]) &#123;</span><br><span class="line">                --indeg[v];</span><br><span class="line">                if (indeg[v] == 0) &#123;</span><br><span class="line">                    q.push(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return visited == numCourses;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; prerequisites(</span><br><span class="line">            &#123;</span><br><span class="line">                    &#123;1,4&#125;,</span><br><span class="line">                    &#123;2,4&#125;,</span><br><span class="line">                    &#123;3,1&#125;,</span><br><span class="line">                    &#123;3,2&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            );</span><br><span class="line">    int numCourses = 5;</span><br><span class="line">    Solution solution;</span><br><span class="line">    auto ans = solution.canFinish(numCourses, prerequisites);</span><br><span class="line">    cout &lt;&lt; &quot;ans = &quot; &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="210-课程表-II"><a href="#210-课程表-II" class="headerlink" title="210_课程表_II"></a>210_课程表_II</h2><ul>
<li>完了，课程表I已经忘了怎么写了…</li>
<li>应该先找出图的根节点，然后反向广度搜索输出答案，当然图的根节点可能有多个</li>
<li>给<code>vector</code>设置大小时，可以直接用<code>resize()</code>，参数是一个数</li>
<li>淦！把拓扑排序给忘了…</li>
<li>之前那题是无需数据结构记录，如果要用数据结构记录我觉得得用队列，方便在头部添加元素</li>
<li>题解用的栈…存储所有已访问的节点；对图进行一遍深度优先搜索。当每个节点进行回溯的时候，我们把该节点放入栈中。最终从栈顶到栈底的序列就是一种拓扑排序。学到了，回溯的时候放入栈中；虽说是用栈，但还是用的<code>vector</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;iterator&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//dfs</span><br><span class="line">class Solution_ &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; edges;</span><br><span class="line">    vector&lt;int&gt; visited;</span><br><span class="line">    vector&lt;int&gt; ans;</span><br><span class="line">    bool valid = true;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    void dfs(int u)&#123;</span><br><span class="line">        visited[u] = 1;</span><br><span class="line">        for(auto v : edges[u])&#123;</span><br><span class="line">            if(visited[v] == 0)&#123;</span><br><span class="line">                dfs(v);</span><br><span class="line">                if(!valid)</span><br><span class="line">                    return;</span><br><span class="line">            &#125; else if(visited[v] == 1)&#123;</span><br><span class="line">                valid = false;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[u] = 2;</span><br><span class="line">        ans.push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; findOrder(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123;</span><br><span class="line">        //应该先判断是否有环，在判断的过程中，找出根节点，之后用bfs，最后还要考虑单独的课程</span><br><span class="line">        //之前的dfs无法判断出哪个是根节点，得用bfs</span><br><span class="line">        //回溯的时候，如果没有相邻节点，那么就是根节点，最后再反转一下即可</span><br><span class="line">        edges.resize(numCourses);</span><br><span class="line">        for(const auto &amp;p : prerequisites)&#123;</span><br><span class="line">            edges[p[1]].push_back(p[0]);</span><br><span class="line">        &#125;</span><br><span class="line">        visited.resize(numCourses);</span><br><span class="line">        for(int i = 0; i &lt; numCourses; ++i)&#123;</span><br><span class="line">            if(visited[i] == 0)&#123;</span><br><span class="line">                dfs(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!valid)&#123;</span><br><span class="line">            return vector&lt;int&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(ans.begin(), ans.end());</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//bfs</span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    // 存储有向图</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; edges;</span><br><span class="line">    // 存储每个节点的入度</span><br><span class="line">    vector&lt;int&gt; indeg;</span><br><span class="line">    // 存储答案</span><br><span class="line">    vector&lt;int&gt; result;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; findOrder(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123;</span><br><span class="line">        edges.resize(numCourses);</span><br><span class="line">        indeg.resize(numCourses);</span><br><span class="line">        for (const auto&amp; info: prerequisites) &#123;</span><br><span class="line">            edges[info[1]].push_back(info[0]);</span><br><span class="line">            //对应课程有几个依赖</span><br><span class="line">            ++indeg[info[0]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue&lt;int&gt; q;</span><br><span class="line">        // 将所有入度为 0 的节点放入队列中</span><br><span class="line">        for (int i = 0; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            if (indeg[i] == 0) &#123;</span><br><span class="line">                q.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (!q.empty()) &#123;</span><br><span class="line">            // 从队首取出一个节点</span><br><span class="line">            int u = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            // 放入答案中</span><br><span class="line">            result.push_back(u);</span><br><span class="line">            for (int v: edges[u]) &#123;</span><br><span class="line">                --indeg[v];</span><br><span class="line">                // 如果相邻节点 v 的入度为 0，就可以选 v 对应的课程了</span><br><span class="line">                if (indeg[v] == 0) &#123;</span><br><span class="line">                    q.push(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (result.size() != numCourses) &#123;</span><br><span class="line">            return &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; prerequisites(&#123;&#123;1,0&#125;,&#123;2,0&#125;,&#123;3,1&#125;,&#123;3,2&#125;&#125;);</span><br><span class="line">    int numCourses = 4;</span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;int&gt; ans = solution.findOrder(numCourses, prerequisites);</span><br><span class="line">    copy(ans.begin(), ans.end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot;));</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h1><h2 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155_最小栈"></a>155_最小栈</h2><ul>
<li>寻找最小数要常数时间，难道又要建立一个双向链表吗，最小的放在最前面？试试</li>
<li>雾草，每个元素 a 与其相应的最小值 m 时刻保持一一对应。绝了…</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class MinStack &#123;</span><br><span class="line">    stack&lt;int&gt; x_stack;</span><br><span class="line">    stack&lt;int&gt; min_stack;</span><br><span class="line">public:</span><br><span class="line">    MinStack() &#123;</span><br><span class="line">        min_stack.push(INT_MAX);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void push(int x) &#123;</span><br><span class="line">        x_stack.push(x);</span><br><span class="line">        min_stack.push(min(min_stack.top(), x));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void pop() &#123;</span><br><span class="line">        x_stack.pop();</span><br><span class="line">        min_stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int top() &#123;</span><br><span class="line">        return x_stack.top();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int getMin() &#123;</span><br><span class="line">        return min_stack.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225_用队列实现栈"></a>225_用队列实现栈</h2><ul>
<li>虽然写出来了，但是感觉比较笨，就是不停地将一个队列放到另一个队列里，来回放；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class MyStack &#123;</span><br><span class="line">public:</span><br><span class="line">    /** Initialize your data structure here. */</span><br><span class="line">    MyStack() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** Push element x onto stack. */</span><br><span class="line">    void push(int x) &#123;</span><br><span class="line">        if(q1.empty())&#123;</span><br><span class="line">            q2.push(x);</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">            q1.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** Removes the element on top of the stack and returns that element. */</span><br><span class="line">    int pop() &#123;</span><br><span class="line">        //原来pop是有返回值的啊</span><br><span class="line">        int tmp = 0;</span><br><span class="line">        if(q1.empty())&#123;</span><br><span class="line">            while (!q2.empty())&#123;</span><br><span class="line">                if(q2.size() != 1)&#123;</span><br><span class="line">                    q1.push(q2.front());</span><br><span class="line">                &#125; else&#123;</span><br><span class="line">                    tmp = q2.front();</span><br><span class="line">                &#125;</span><br><span class="line">                q2.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">            while (!q1.empty())&#123;</span><br><span class="line">                if(q1.size() != 1)&#123;</span><br><span class="line">                    q2.push(q1.front());</span><br><span class="line">                &#125; else&#123;</span><br><span class="line">                    tmp = q1.front();</span><br><span class="line">                &#125;</span><br><span class="line">                q1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** Get the top element. */</span><br><span class="line">    int top() &#123;</span><br><span class="line">        if(q1.empty())&#123;</span><br><span class="line">            return q2.back();</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">            return q1.back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** Returns whether the stack is empty. */</span><br><span class="line">    bool empty() &#123;</span><br><span class="line">        return q1.empty() &amp;&amp; q2.empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    queue&lt;int&gt; q1;</span><br><span class="line">    queue&lt;int&gt; q2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your MyStack object will be instantiated and called as such:</span><br><span class="line"> * MyStack* obj = new MyStack();</span><br><span class="line"> * obj-&gt;push(x);</span><br><span class="line"> * int param_2 = obj-&gt;pop();</span><br><span class="line"> * int param_3 = obj-&gt;top();</span><br><span class="line"> * bool param_4 = obj-&gt;empty();</span><br><span class="line"> */</span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232_用栈实现队列"></a>232_用栈实现队列</h2><ul>
<li>有好多细节需要注意，比如另一个栈是用来缓冲的，那就要考虑到（在恢复时数据时）是否为空</li>
<li>还有判断是否是队列的第一个数字时，直接判断主栈是否为空！！</li>
<li>题解有个优点——不用每次都倒来倒去！！</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class MyQueue &#123;</span><br><span class="line">private:</span><br><span class="line">    stack&lt;int&gt; inStack, outStack;</span><br><span class="line"></span><br><span class="line">    void in2out() &#123;</span><br><span class="line">        while (!inStack.empty()) &#123;</span><br><span class="line">            outStack.push(inStack.top());</span><br><span class="line">            inStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    MyQueue() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    void push(int x) &#123;</span><br><span class="line">        inStack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int pop() &#123;</span><br><span class="line">        if (outStack.empty()) &#123;</span><br><span class="line">            in2out();</span><br><span class="line">        &#125;</span><br><span class="line">        int x = outStack.top();</span><br><span class="line">        outStack.pop();</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int peek() &#123;</span><br><span class="line">        if (outStack.empty()) &#123;</span><br><span class="line">            in2out();</span><br><span class="line">        &#125;</span><br><span class="line">        return outStack.top();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool empty() &#123;</span><br><span class="line">        return inStack.empty() &amp;&amp; outStack.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><ul>
<li>是先跳过SQL题目；还是学习下？</li>
<li>本地运行需要环境，直接在网页运行吧</li>
</ul>
<h2 id="175-组合两个表"><a href="#175-组合两个表" class="headerlink" title="175_组合两个表"></a>175_组合两个表</h2><ul>
<li></li>
</ul>
<h2 id="176-第二高的薪水"><a href="#176-第二高的薪水" class="headerlink" title="176_第二高的薪水"></a>176_第二高的薪水</h2><ul>
<li></li>
</ul>
<hr>
<h1 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h1><ul>
<li>bash脚本</li>
</ul>
<h2 id="192-统计词频"><a href="#192-统计词频" class="headerlink" title="192_统计词频"></a>192_统计词频</h2><ul>
<li></li>
</ul>
<hr>
<h1 id="整数边界"><a href="#整数边界" class="headerlink" title="整数边界"></a>整数边界</h1><ul>
<li>注意<font color="#FF0000">int</font>是否溢出，<code>INT32_MAX</code>、<code>INT32_MIN</code></li>
<li><code>if(add &lt; INT32_MAX / 10 || (add == INT32_MAX / 10 &amp;&amp; (int)(l[i] - &#39;0&#39;) &lt; 8))</code></li>
<li><code>if(add &gt; INT32_MIN / 10 || (add == INT32_MIN / 10 &amp;&amp; (int)(l[i] - &#39;0&#39;) &lt; 9))</code></li>
<li>回文数要考虑是否溢出</li>
</ul>
<h2 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="7_整数反转"></a>7_整数反转</h2><ul>
<li>给出一个32位的有符号整数，<code>123</code></li>
<li>输出<code>321</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int reverse(int x) &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        int s = x;</span><br><span class="line">        x = abs(x);</span><br><span class="line">        while (x &gt; 0) &#123;</span><br><span class="line">            if(sum &gt; INT32_MAX / 10 || (sum == INT32_MAX / 10 &amp;&amp; x &gt; 7))&#123;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">            sum = sum * 10 + x % 10;    // sum乘以10之前，先判断是否会溢出</span><br><span class="line">            x /= 10;</span><br><span class="line">        &#125;</span><br><span class="line">        if(s &gt;= 0)&#123;</span><br><span class="line">            return sum;</span><br><span class="line">        &#125; else return sum * (-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int x = 153;</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.reverse(x) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9_回文数"></a>9_回文数</h2><ul>
<li>输入121，输出true</li>
<li>输入-121，输出false</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isPalindrome(int x) &#123;</span><br><span class="line">        if(x &lt; 0)&#123;return false;&#125;</span><br><span class="line">        int y = 0, z = x;</span><br><span class="line">        while (z &gt; 0)&#123;</span><br><span class="line">	// 判断是否溢出</span><br><span class="line">            if(y &gt; INT32_MAX / 10 || (y == INT32_MAX / 10 &amp;&amp; z % 10 &gt; 7))&#123;return false;&#125;</span><br><span class="line">            y = y * 10 + z % 10;</span><br><span class="line">            z = z / 10;</span><br><span class="line">        &#125;</span><br><span class="line">        if(x != y)&#123;return false;&#125; else return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int x = 998765432;</span><br><span class="line">    Solution solution;</span><br><span class="line">    std::cout &lt;&lt; solution.isPalindrome(x) &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="29-两数相除"><a href="#29-两数相除" class="headerlink" title="29_两数相除"></a>29_两数相除</h2><ul>
<li>核心思路是不停的相减，直到减不动为止，但不是一个一个减，而是<font color="#FF0000">成倍</font>地减<code>divisor</code></li>
<li><code>ans = divisor</code>、<code>ans += ans</code></li>
<li>考虑整数<font color="#FF0000">溢出</font>，并且正数边界比较麻烦，改用负数来算</li>
<li>在<code>while</code>循环中，要考虑<code>ans+ans</code>不能小于<code>INT32_MIN</code>、<code>res</code>我这里用的是正数，<code>res+res</code>不能小大于<code>INT32_MAX</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int divide(int dividend, int divisor) &#123;</span><br><span class="line">        // 正数边界问题比较麻烦，改用负数计算</span><br><span class="line">        if(dividend == 0)&#123;return 0;&#125;</span><br><span class="line">        if(dividend == INT32_MIN &amp;&amp; divisor == -1)&#123;return INT32_MAX;&#125;</span><br><span class="line">        int sign = ((dividend &gt; 0 &amp;&amp; divisor &gt; 0) || dividend &lt; 0 &amp;&amp; divisor &lt; 0) ? 1 : -1;</span><br><span class="line">        dividend = dividend &gt; 0 ? -dividend : dividend;</span><br><span class="line">        divisor = divisor &gt; 0 ? -divisor : divisor;</span><br><span class="line">        if(dividend &gt; divisor)&#123;return 0;&#125;   // 递归出口</span><br><span class="line">        int ans = divisor, res = 1;</span><br><span class="line">        while (ans &gt;= (INT32_MIN &gt;&gt; 1) &amp;&amp; dividend &lt;= ans + ans)&#123;  // 直接翻倍判断</span><br><span class="line">            ans += ans;</span><br><span class="line">            if(res &gt; (INT32_MAX &gt;&gt; 1))&#123;return INT32_MIN;&#125;</span><br><span class="line">            res += res;</span><br><span class="line">        &#125;</span><br><span class="line">        res += divide(dividend - ans, divisor);</span><br><span class="line">        return sign &gt; 0 ? res : -res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int dividend = 10, divisor = 3;</span><br><span class="line">    Solution solution;</span><br><span class="line">    std::cout &lt;&lt; solution.divide(dividend, divisor) &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="50-Pow-x-n"><a href="#50-Pow-x-n" class="headerlink" title="50_Pow(x,n)"></a>50_Pow(x,n)</h2><ul>
<li>递归，跟加法题差不多，不是每次都乘x，而是将上一次的结果直接平方，要考虑<code>n</code>的奇偶性，这题我没有做出来</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    double quickMul(double x, long long N) &#123;</span><br><span class="line">        if (N == 0) &#123;</span><br><span class="line">            return 1.0;</span><br><span class="line">        &#125;</span><br><span class="line">        double y = quickMul(x, N / 2);</span><br><span class="line">        return N % 2 == 0 ? y * y : y * y * x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    double myPow(double x, int n) &#123;</span><br><span class="line">        long long N = n;</span><br><span class="line">        return N &gt;= 0 ? quickMul(x, N) : 1.0 / quickMul(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    double x = 99;</span><br><span class="line">    int n = 5;</span><br><span class="line">    Solution solution;</span><br><span class="line">    double res = solution.myPow(x, n);</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; &quot; &quot; &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62_不同路径"></a>62_不同路径</h2><ul>
<li>这是比较典型的一道排列组合题目，可直接计算出结果(m+n-2)!/(m-1)!(n-1)!，但是计算过程会超出整数<code>int</code>边界，得优化下，边化简边计算</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int uniquePaths(int m, int n) &#123;</span><br><span class="line">        long long den = 1, mol = 1;</span><br><span class="line">        int ma = max(m, n), mi = min(m, n);</span><br><span class="line">        while (mi - 1 &gt; 0)&#123;</span><br><span class="line">            den *= ma + mi - 2;   //分母</span><br><span class="line">            mol *= mi - 1;   //分子</span><br><span class="line">            mi--;</span><br><span class="line">        &#125;</span><br><span class="line">        return den / mol;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.uniquePaths(10, 10) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="69-x的平方根"><a href="#69-x的平方根" class="headerlink" title="69_x的平方根"></a>69_x的平方根</h2><ul>
<li>一开始是想从1开始遍历，每次都将上一个值翻倍，然后判断其平方是否小于x</li>
<li>还是二分法好用，超出整数边界用<code>long long</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int mySqrt(int x) &#123;</span><br><span class="line">        int l = 0, r = x, ans;</span><br><span class="line">        while (l &lt;= r)&#123;</span><br><span class="line">            long long mid = (l + r) / 2;</span><br><span class="line">            if(mid * mid &gt; x)&#123;</span><br><span class="line">                r = mid - 1;</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                l = mid + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.mySqrt(2147395600);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70_爬楼梯"></a>70_爬楼梯</h2><ul>
<li>思路很简单，先算2的个数和1的个数有几种情况，然后每种情况都要排列组合，最后一起加起来</li>
<li>用到62_不同路径的阶乘函数，还是要注意整数边界问题</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int uniquePaths(int m, int n) &#123;</span><br><span class="line">        if(m == 0 || n == 0)&#123;return 1;&#125;</span><br><span class="line">        unsigned long long den = 1, mol = 1;</span><br><span class="line">        int ma = max(m, n), mi = min(m, n);</span><br><span class="line">        while (mi &gt; 0)&#123;</span><br><span class="line">            den *= ma + mi;   //分母</span><br><span class="line">            mol *= mi;   //分子</span><br><span class="line">            while (den % 2 == 0 &amp;&amp; mol % 2 == 0)&#123;</span><br><span class="line">                den /= 2;</span><br><span class="line">                mol /= 2;</span><br><span class="line">            &#125;</span><br><span class="line">            while (den % 3 == 0 &amp;&amp; mol % 3 == 0)&#123;</span><br><span class="line">                den /= 3;</span><br><span class="line">                mol /= 3;</span><br><span class="line">            &#125;</span><br><span class="line">            while (den % 5 == 0 &amp;&amp; mol % 5 == 0)&#123;</span><br><span class="line">                den /= 5;</span><br><span class="line">                mol /= 5;</span><br><span class="line">            &#125;</span><br><span class="line">            while (den % 7 == 0 &amp;&amp; mol % 7 == 0)&#123;</span><br><span class="line">                den /= 7;</span><br><span class="line">                mol /= 7;</span><br><span class="line">            &#125;</span><br><span class="line">            mi--;</span><br><span class="line">        &#125;</span><br><span class="line">        return den / mol;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int climbStairs(int n) &#123;</span><br><span class="line">        if(n &lt; 2)&#123;return n;&#125;</span><br><span class="line">        int res = 0, two_n = n / 2, one_n = n % 2 == 0 ? 0 : 1;</span><br><span class="line">        for(int i = 0; i &lt;= two_n; i++)&#123;</span><br><span class="line">            if(i &gt; 0)&#123;one_n += 2;&#125;</span><br><span class="line">            res += uniquePaths(two_n - i, one_n);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.climbStairs(45) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="172-阶乘后的零"><a href="#172-阶乘后的零" class="headerlink" title="172_阶乘后的零"></a>172_阶乘后的零</h2><ul>
<li>不用想了，肯定会超出整数边界、但也不一定要计算出结果</li>
<li>完美！不用计算最终结果，而是直接考虑5的倍数还有10的倍数</li>
<li>小丑竟是我自己，只要考虑5即可</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int trailingZeroes(int n) &#123;</span><br><span class="line">        //如果同时有2和5、或者他俩最小公倍数的倍数</span><br><span class="line">        //也相当于一串连续数组，有多少个10的倍数</span><br><span class="line">//        if(n &lt; 5) return 0;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        for(int i = 5; i &lt; n + 1; i += 5)&#123;</span><br><span class="line">            int tmp = i;</span><br><span class="line">            /*if(tmp % 10 == 0)&#123;</span><br><span class="line">                while (tmp % 10 == 0)&#123;</span><br><span class="line">                    ++ans;</span><br><span class="line">                    tmp /= 10;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;*/</span><br><span class="line">            if(tmp % 5 == 0)&#123;</span><br><span class="line">                //这里不用考虑2的个数，因为偶数肯定一大把</span><br><span class="line">                while (tmp % 5 == 0)&#123;</span><br><span class="line">                    ++ans;</span><br><span class="line">                    tmp /= 5;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="204-计数质数"><a href="#204-计数质数" class="headerlink" title="204_计数质数"></a>204_计数质数</h2><ul>
<li>这题好像和整数边界没什么关系，得了解如何判定一个质数</li>
<li>不对，有关系</li>
<li>质数首先个位数只能是奇数，之后要排除3、5、7、…的倍数，不对，还有11、13…</li>
<li>所以题解第一种方法就是枚举法，先枚举所有范围里的数，再判断是否为质数；判断质数的时候，也要从2开始判断能否整除….这里可以优化下，x能整除、那么y/x也能整除，两者取小</li>
<li>厄拉多塞筛法，简称埃氏筛：如果x是质数，那么大于x的x的倍数2x,3x,… 一定不是质数，</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution_ &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isPrime(int x) &#123;</span><br><span class="line">        for (int i = 2; i * i &lt;= x; ++i) &#123;</span><br><span class="line">            if (x % i == 0) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int countPrimes(int n) &#123;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        for (int i = 2; i &lt; n; ++i) &#123;</span><br><span class="line">            ans += isPrime(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int countPrimes(int n) &#123;</span><br><span class="line">        //动态规划，无需另外函数来判断是否为质数</span><br><span class="line">        vector&lt;int&gt; isPrime(n, 1);</span><br><span class="line">        int ans = 0;</span><br><span class="line">        for (int i = 2; i &lt; n; ++i) &#123;</span><br><span class="line">            if (isPrime[i]) &#123;</span><br><span class="line">                ans += 1;</span><br><span class="line">                if ((long long)i * i &lt; n) &#123;</span><br><span class="line">                    for (int j = i * i; j &lt; n; j += i) &#123;</span><br><span class="line">                        isPrime[j] = 0;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n = 5000000; //ans = 348513</span><br><span class="line">    Solution solution;</span><br><span class="line">    int ans = solution.countPrimes(n);</span><br><span class="line">    cout &lt;&lt; &quot;ans = &quot; &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="233-数字-1-的个数"><a href="#233-数字-1-的个数" class="headerlink" title="233_数字 1 的个数"></a>233_数字 1 的个数</h2><ul>
<li>这题真的是…绞尽脑汁；要考虑的情况太多</li>
<li>这题没有超出整数边界，放在位运算也不太好，还是放在整数边界吧；毕竟不停的除以十</li>
<li>看了题解发现，，，我是谁，我在哪儿，，，我在做什么</li>
</ul>
<p><img src="/pictrues/233.png" alt="1的个数" title="1的个数"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution1 &#123;</span><br><span class="line">public:</span><br><span class="line">    int countDigitOne(int n) &#123;</span><br><span class="line">        //要考虑很多种情况，比较繁琐</span><br><span class="line">        if(n &lt; 1)</span><br><span class="line">            return 0;</span><br><span class="line"></span><br><span class="line">        /*这几行还是注释掉，不然显得我的代码不够鲁棒:)</span><br><span class="line">        if(n &gt; 0 &amp;&amp; n &lt; 10)</span><br><span class="line">            return 1;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">        //有点思路了；从低到高或者从高到低，计算出每一位是1的个数，比如个位数是1的情况有几种，十位数等等；</span><br><span class="line">        //最终算出来的，有重复的就是最终答案；有一点需要注意，就是xx1yy，yy的范围可能是00-99；也可能是00-zz</span><br><span class="line">        int ans = 0;</span><br><span class="line">        int i = 0, later = 0;</span><br><span class="line"></span><br><span class="line">        while (n &gt; 0)&#123;</span><br><span class="line">            //从个位数开始</span><br><span class="line">            int tmp = n % 10, former = n / 10;</span><br><span class="line"></span><br><span class="line">            if(tmp == 0)&#123;</span><br><span class="line">                //说明former得减一；不然令这位为1，会大于原来的数字；这里former肯定不为0； 而且，后面有几位就是10的几次方</span><br><span class="line">                ans += (former * static_cast&lt;int&gt;(pow(10, i)));</span><br><span class="line"></span><br><span class="line">            &#125; else if(tmp == 1)&#123;</span><br><span class="line"></span><br><span class="line">                //加later之前，得看后面是否没有数字  latter在former减1前，是不能大于原来的数的，还要考虑0</span><br><span class="line">                if(former == 0) &#123;</span><br><span class="line">                    //前不着村，后不着店</span><br><span class="line">                    ans += (i == 0 ? 1 : later + 1);</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    //前面的不受约束；0——former-1都可；但是，这里有问题；(i == 0 ? 0 : later + 1)</span><br><span class="line"></span><br><span class="line">                    ans += (former * static_cast&lt;int&gt;(pow(10, i)) + (i == 0 ? 1 : later + 1));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                ans += ((former + 1) * static_cast&lt;int&gt;(pow(10, i)));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            n = former;</span><br><span class="line">            later += tmp * static_cast&lt;int&gt;(pow(10, i));</span><br><span class="line">            ++i;</span><br><span class="line">            cout &lt;&lt; &quot;ans = &quot; &lt;&lt; ans &lt;&lt; &quot; n = &quot; &lt;&lt; n &lt;&lt; &quot; later = &quot; &lt;&lt; later &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//题解</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int countDigitOne(int n)</span><br><span class="line">    &#123;</span><br><span class="line">        int countr = 0;</span><br><span class="line">        for (long long i = 1; i &lt;= n; i *= 10) &#123;</span><br><span class="line">            long long divider = i * 10;</span><br><span class="line">            countr += (n / divider) * i + min(max(n % divider - i + 1, 0LL), i);</span><br><span class="line">        &#125;</span><br><span class="line">        return countr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n = 11;    //234——154个1</span><br><span class="line">    Solution solution;</span><br><span class="line">    int ans = solution.countDigitOne(n);</span><br><span class="line">    cout &lt;&lt; &quot;ans = &quot; &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="263-丑数"><a href="#263-丑数" class="headerlink" title="263_丑数"></a>263_丑数</h2><ul>
<li>要不要另辟一个归类？数学…这题，我不知道该放哪儿了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isUgly(int n) &#123;</span><br><span class="line">        //不停地取余？最后查看余数是否为1</span><br><span class="line">        //先都转成负数——雾草，丑数是正整数！！！</span><br><span class="line">        if(n &lt; 1)</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        while(n % 5 == 0)&#123;</span><br><span class="line">            n /= 5;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while(n % 3 == 0)&#123;</span><br><span class="line">            n /= 3;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while(n % 2 == 0)&#123;</span><br><span class="line">            n /= 2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return n == 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="264-丑数-II"><a href="#264-丑数-II" class="headerlink" title="264_丑数_II"></a>264_丑数_II</h2><ul>
<li>每次都判断是否为丑数，这么做超时了！…</li>
<li>学习下最小堆、动态规划！——最小堆是优先级队列嘛、那是不是也叫做最小根？<ul>
<li>原来最小堆还能这么用！！学到了，每次只弹出一个，那么最后弹出的就是答案！</li>
<li>动态规划的状态转移方程，情理之中、意料之外——<code>dp[i]=min(dp[p2]×2,dp[p3]×3,dp[p5]×5)</code></li>
</ul>
</li>
<li>这里动规，截下大佬的解释</li>
</ul>
<p><img src="/pictrues/264.png" alt title="动态规划"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;unordered_set&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//最小堆</span><br><span class="line">class Solution1 &#123;</span><br><span class="line">public:</span><br><span class="line">    int nthUglyNumber(int n) &#123;</span><br><span class="line">        vector&lt;int&gt; factors = &#123;2, 3, 5&#125;;</span><br><span class="line">        unordered_set&lt;long&gt; seen;</span><br><span class="line"></span><br><span class="line">        //最小堆是从小到大</span><br><span class="line">        priority_queue&lt;long, vector&lt;long&gt;, greater&lt;&gt;&gt; heap;</span><br><span class="line">        seen.insert(1L);</span><br><span class="line">        heap.push(1L);</span><br><span class="line">        int ugly = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            long curr = heap.top();</span><br><span class="line"></span><br><span class="line">            heap.pop();</span><br><span class="line">            ugly = (int)curr;</span><br><span class="line">            //因为要让最小堆的最前面是答案，所以不管放了多少个，我每次都只弹出一个！</span><br><span class="line">            //这里哈希是防止重复放进元素！！</span><br><span class="line">            for (int factor : factors) &#123;</span><br><span class="line">                long next = curr * factor;</span><br><span class="line">                if (!seen.count(next)) &#123;</span><br><span class="line">                    seen.insert(next);</span><br><span class="line">                    heap.push(next);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ugly;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//动态规划</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int nthUglyNumber(int n) &#123;</span><br><span class="line">        vector&lt;int&gt; dp(n + 1);</span><br><span class="line">        dp[1] = 1;</span><br><span class="line">        int p2 = 1, p3 = 1, p5 = 1;</span><br><span class="line">        for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">            int num2 = dp[p2] * 2, num3 = dp[p3] * 3, num5 = dp[p5] * 5;</span><br><span class="line">            dp[i] = min(min(num2, num3), num5);</span><br><span class="line">            if (dp[i] == num2) &#123;</span><br><span class="line">                p2++;</span><br><span class="line">            &#125;</span><br><span class="line">            if (dp[i] == num3) &#123;</span><br><span class="line">                p3++;</span><br><span class="line">            &#125;</span><br><span class="line">            if (dp[i] == num5) &#123;</span><br><span class="line">                p5++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="633-平方数之和"><a href="#633-平方数之和" class="headerlink" title="633_平方数之和"></a>633_平方数之和</h2><ul>
<li>超出整数边界报错…</li>
<li>这题用了双指针，，看看题解，一样，还有种数学方法</li>
<li>费马平方和定理：一个非负整数c如果能够表示为两个整数的平方和，当且仅当c的所有形如4k+3的质因子的幂均为偶数。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool judgeSquareSum(int c) &#123;</span><br><span class="line">        auto r = static_cast&lt;long long&gt;(sqrt(c));</span><br><span class="line">        long long l = 0;</span><br><span class="line">        while (l &lt;= r)&#123;</span><br><span class="line">            if(r * r + l * l &lt;= INT32_MAX &amp;&amp; r * r + l * l == c)</span><br><span class="line">                return true;</span><br><span class="line">            else if(r * r + l * l &lt; c)&#123;</span><br><span class="line">                ++l;</span><br><span class="line">            &#125; else</span><br><span class="line">                --r;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><ul>
<li>这里还是单独列出来吧</li>
</ul>
<h2 id="190-颠倒二进制位"><a href="#190-颠倒二进制位" class="headerlink" title="190_颠倒二进制位"></a>190_颠倒二进制位</h2><ul>
<li>递归…自底向上，那还叫递归么，认真学习下</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution1 &#123;</span><br><span class="line">public:</span><br><span class="line">    uint32_t reverseBits(uint32_t n) &#123;</span><br><span class="line">        uint32_t rev = 0;</span><br><span class="line">        for (int i = 0; i &lt; 32 &amp;&amp; n &gt; 0; ++i) &#123;</span><br><span class="line">            rev |= (n &amp; 1) &lt;&lt; (31 - i); //(n &amp; 1)应该是转化成二进制；rev |= xx 确保了rev位数也是32位</span><br><span class="line">            n &gt;&gt;= 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return rev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    const uint32_t M1 = 0x55555555; // 01010101010101010101010101010101</span><br><span class="line">    const uint32_t M2 = 0x33333333; // 00110011001100110011001100110011</span><br><span class="line">    const uint32_t M4 = 0x0f0f0f0f; // 00001111000011110000111100001111</span><br><span class="line">    const uint32_t M8 = 0x00ff00ff; // 00000000111111110000000011111111</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    uint32_t reverseBits(uint32_t n) &#123;</span><br><span class="line">        n = n &gt;&gt; 1 &amp; M1 | (n &amp; M1) &lt;&lt; 1;</span><br><span class="line">        n = n &gt;&gt; 2 &amp; M2 | (n &amp; M2) &lt;&lt; 2;</span><br><span class="line">        n = n &gt;&gt; 4 &amp; M4 | (n &amp; M4) &lt;&lt; 4;</span><br><span class="line">        n = n &gt;&gt; 8 &amp; M8 | (n &amp; M8) &lt;&lt; 8;</span><br><span class="line">        return n &gt;&gt; 16 | n &lt;&lt; 16;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution2 &#123;</span><br><span class="line">public:</span><br><span class="line">    uint32_t reverseBits(uint32_t n) &#123;</span><br><span class="line">        //32位二进制</span><br><span class="line">        uint32_t ans = 0;</span><br><span class="line">        int i = 0;</span><br><span class="line">        while(n &gt; 0)&#123;</span><br><span class="line">            auto tmp = n % 2;</span><br><span class="line">            //cout &lt;&lt; &quot; &quot; &lt;&lt; tmp &lt;&lt; &quot; &quot;;</span><br><span class="line">            ans = ans * 2 + tmp;</span><br><span class="line">            n = (n - tmp) / 2;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        //cout &lt;&lt; endl;</span><br><span class="line">        while(i &lt; 32)&#123;</span><br><span class="line">            ans *= 2;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="191-位1的个数"><a href="#191-位1的个数" class="headerlink" title="191_位1的个数"></a>191_位1的个数</h2><ul>
<li>还是循环了</li>
<li>递归分治没想出来；不过优化真的厉害，不断地将n与n-1做与运算，可以不断地将最低位的1变成0</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//题解</span><br><span class="line">class Solution1 &#123;</span><br><span class="line">public:</span><br><span class="line">    int hammingWeight(uint32_t n) &#123;</span><br><span class="line">        int ret = 0;</span><br><span class="line">        for (int i = 0; i &lt; 32; i++) &#123;</span><br><span class="line">            if (n &amp; (1 &lt;&lt; i)) &#123;</span><br><span class="line">                ret++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution_ &#123;</span><br><span class="line">public:</span><br><span class="line">    int hammingWeight(uint32_t n) &#123;</span><br><span class="line">        //还是循环32次？</span><br><span class="line">        int ans = 0;</span><br><span class="line">        while(n &gt; 0)&#123;</span><br><span class="line">            if(n % 2 == 1)</span><br><span class="line">                ++ans;</span><br><span class="line">            n &gt;&gt;= 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int hammingWeight(uint32_t n) &#123;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        while (n)&#123;</span><br><span class="line">            n &amp;= (n - 1);</span><br><span class="line">            ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="201-数字范围按位与"><a href="#201-数字范围按位与" class="headerlink" title="201_数字范围按位与"></a>201_数字范围按位与</h2><ul>
<li>审题不清，明明只能整数、正整数；但思路还是可以的</li>
<li>看了题解之后…自己还是菜；题目要理解为找公共前缀</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution1 &#123;</span><br><span class="line">public:</span><br><span class="line">    int rangeBitwiseAnd(int left, int right) &#123;</span><br><span class="line">        if(left &lt; 1) return 0;</span><br><span class="line">        int n = 0;</span><br><span class="line">        auto tmp = pow(2, n);</span><br><span class="line">        //这一步复杂度，就可以解出答案</span><br><span class="line">        while (tmp &lt;= left)&#123;</span><br><span class="line">            ++n;</span><br><span class="line">            tmp = pow(2, n);</span><br><span class="line">        &#125;</span><br><span class="line">        if(right &gt;= pow(2, n))</span><br><span class="line">            return 0;</span><br><span class="line">        //更新left、right；到这一步说明两者在同一个级别大小</span><br><span class="line">        int ans = 0;</span><br><span class="line">        left -= pow(2, n - 1);</span><br><span class="line">        right -= pow(2, n - 1);</span><br><span class="line">        ans += pow(2, n - 1);</span><br><span class="line">//        cout &lt;&lt; &quot;ans = &quot; &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">        return ans + rangeBitwiseAnd(left, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//移位，找相同前缀</span><br><span class="line">class Solution2 &#123;</span><br><span class="line">public:</span><br><span class="line">    int rangeBitwiseAnd(int m, int n) &#123;</span><br><span class="line">        int shift = 0;</span><br><span class="line">        // 找到公共前缀</span><br><span class="line">        while (m &lt; n) &#123;</span><br><span class="line">            m &gt;&gt;= 1;</span><br><span class="line">            n &gt;&gt;= 1;</span><br><span class="line">            ++shift;</span><br><span class="line">        &#125;</span><br><span class="line">        return m &lt;&lt; shift;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//连续数字相乘可以消除末位1 Brian Kernighan 算法</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int rangeBitwiseAnd(int m, int n) &#123;</span><br><span class="line">        while (m &lt; n) &#123;</span><br><span class="line">            // 抹去最右边的 1</span><br><span class="line">            n = n &amp; (n - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int left = 519, right = 1023;</span><br><span class="line">    Solution solution;</span><br><span class="line">    int ans = solution.rangeBitwiseAnd(left, right);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="231-2-的幂"><a href="#231-2-的幂" class="headerlink" title="231_2 的幂"></a>231_2 的幂</h2><ul>
<li>2的0次方也是幂！！！这题每日一题做过，就当复习了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution2 &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isPowerOfTwo(int n) &#123;</span><br><span class="line">        //二进制1的个数只能是一个，但是要考虑正负号</span><br><span class="line">        if(n &lt; 0)</span><br><span class="line">            return false;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        while(n)&#123;</span><br><span class="line">            n &amp;= (n - 1);</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans == 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//这个方法是直接判断约数</span><br><span class="line">class Solution1 &#123;</span><br><span class="line">private:</span><br><span class="line">    static constexpr int BIG = 1 &lt;&lt; 30;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    bool isPowerOfTwo(int n) &#123;</span><br><span class="line">        return n &gt; 0 &amp;&amp; BIG % n == 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isPowerOfTwo(int n) &#123;</span><br><span class="line">        if(n &lt; 2)</span><br><span class="line">            return false;</span><br><span class="line">        //2的幂，不是2的倍数</span><br><span class="line">        for(int i = 1; i &lt; 32; ++i)&#123;</span><br><span class="line">            if((n &amp; (~(1 &lt;&lt; i))) == 0)&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="258-各位相加"><a href="#258-各位相加" class="headerlink" title="258_各位相加"></a>258_各位相加</h2><ul>
<li>这其实应该算数学！</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int addDigits(int num) &#123;</span><br><span class="line">        //总感觉这一题做过，因为有个极限值，会坍缩！31位，每位都是数字9，加起来279</span><br><span class="line">        //不使用循环或者递归，且在 O(1) 时间复杂度内解决这个问题，那只能用数学方法了</span><br><span class="line">        //x*100+y*10+z=x*99+y*9+x+y+z这个是真的牛皮！！</span><br><span class="line">        return (num - 1) % 9 + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="会员专属"><a href="#会员专属" class="headerlink" title="会员专属"></a>会员专属</h1><ul>
<li>别看了，这些题要会员；贫穷限制了我…</li>
</ul>
<h2 id="156-上下翻转二叉树"><a href="#156-上下翻转二叉树" class="headerlink" title="156_上下翻转二叉树"></a>156_上下翻转二叉树</h2><ul>
<li>给定一个二叉树，其中所有右节点都是具有同级的叶节点（共享相同父节点的左节点）或为空，将其上下翻转并将其变成树，其中原始的右节点变为左叶节点 。 返回新的根。</li>
</ul>
<p><img src="/pictrues/156.png" alt="156" title="156题"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="157-用Read4读取N个字符"><a href="#157-用Read4读取N个字符" class="headerlink" title="157_用Read4读取N个字符"></a>157_用Read4读取N个字符</h2><h2 id="158-用Read4读取N个字符-ll"><a href="#158-用Read4读取N个字符-ll" class="headerlink" title="158_用Read4读取N个字符_ll"></a>158_用Read4读取N个字符_ll</h2><h2 id="159-至多包含两个不同字符的最长子串"><a href="#159-至多包含两个不同字符的最长子串" class="headerlink" title="159_至多包含两个不同字符的最长子串"></a>159_至多包含两个不同字符的最长子串</h2><h2 id="161-相隔为1的编辑距离"><a href="#161-相隔为1的编辑距离" class="headerlink" title="161_相隔为1的编辑距离"></a>161_相隔为1的编辑距离</h2><h2 id="163-缺失的区间"><a href="#163-缺失的区间" class="headerlink" title="163_缺失的区间"></a>163_缺失的区间</h2><h2 id="170-两数之和-lll-数据结构设计"><a href="#170-两数之和-lll-数据结构设计" class="headerlink" title="170_两数之和_lll-数据结构设计"></a>170_两数之和_lll-数据结构设计</h2><h2 id="186-翻转字符串里的单词-ll"><a href="#186-翻转字符串里的单词-ll" class="headerlink" title="186_翻转字符串里的单词_ll"></a>186_翻转字符串里的单词_ll</h2><h2 id="243-最短单词距离"><a href="#243-最短单词距离" class="headerlink" title="243_最短单词距离"></a>243_最短单词距离</h2><h2 id="244-最短单词距离-II"><a href="#244-最短单词距离-II" class="headerlink" title="244_最短单词距离_II"></a>244_最短单词距离_II</h2><h2 id="245-最短单词距离-III"><a href="#245-最短单词距离-III" class="headerlink" title="245_最短单词距离_III"></a>245_最短单词距离_III</h2><h2 id="246-中心对称数"><a href="#246-中心对称数" class="headerlink" title="246_中心对称数"></a>246_中心对称数</h2><h2 id="247-中心对称数-II"><a href="#247-中心对称数-II" class="headerlink" title="247_中心对称数_II"></a>247_中心对称数_II</h2><h2 id="248-中心对称数-III"><a href="#248-中心对称数-III" class="headerlink" title="248_中心对称数_III"></a>248_中心对称数_III</h2><h2 id="249-移位字符串分组"><a href="#249-移位字符串分组" class="headerlink" title="249_移位字符串分组"></a>249_移位字符串分组</h2><h2 id="250-统计同值子树"><a href="#250-统计同值子树" class="headerlink" title="250_统计同值子树"></a>250_统计同值子树</h2><h2 id="251-展开二维向量"><a href="#251-展开二维向量" class="headerlink" title="251_展开二维向量"></a>251_展开二维向量</h2><h2 id="252-会议室"><a href="#252-会议室" class="headerlink" title="252_会议室"></a>252_会议室</h2><h2 id="253-会议室-II"><a href="#253-会议室-II" class="headerlink" title="253_会议室_II"></a>253_会议室_II</h2><h2 id="254-因子的组合"><a href="#254-因子的组合" class="headerlink" title="254_因子的组合"></a>254_因子的组合</h2><h2 id="255-验证前序遍历序列二叉搜索树"><a href="#255-验证前序遍历序列二叉搜索树" class="headerlink" title="255_验证前序遍历序列二叉搜索树"></a>255_验证前序遍历序列二叉搜索树</h2><h2 id="256-粉刷房子"><a href="#256-粉刷房子" class="headerlink" title="256_粉刷房子"></a>256_粉刷房子</h2><h2 id="259-较小的三数之和"><a href="#259-较小的三数之和" class="headerlink" title="259_较小的三数之和"></a>259_较小的三数之和</h2><h2 id="261-以图判树"><a href="#261-以图判树" class="headerlink" title="261_以图判树"></a>261_以图判树</h2><h2 id="265-粉刷房子-II"><a href="#265-粉刷房子-II" class="headerlink" title="265_粉刷房子_II"></a>265_粉刷房子_II</h2><h2 id="266-回文排列"><a href="#266-回文排列" class="headerlink" title="266_回文排列"></a>266_回文排列</h2><h2 id="267-回文排列-II"><a href="#267-回文排列-II" class="headerlink" title="267_回文排列_II"></a>267_回文排列_II</h2><h2 id="269-火星词典"><a href="#269-火星词典" class="headerlink" title="269_火星词典"></a>269_火星词典</h2><h2 id="270-最接近的二叉搜索树值"><a href="#270-最接近的二叉搜索树值" class="headerlink" title="270_最接近的二叉搜索树值"></a>270_最接近的二叉搜索树值</h2><h2 id="271-字符串的编码与解码"><a href="#271-字符串的编码与解码" class="headerlink" title="271_字符串的编码与解码"></a>271_字符串的编码与解码</h2><h2 id="272-最接近的二叉搜索树值-II"><a href="#272-最接近的二叉搜索树值-II" class="headerlink" title="272_最接近的二叉搜索树值_II"></a>272_最接近的二叉搜索树值_II</h2><h2 id="276-栅栏涂色"><a href="#276-栅栏涂色" class="headerlink" title="276_栅栏涂色"></a>276_栅栏涂色</h2><h2 id="277-搜寻名人"><a href="#277-搜寻名人" class="headerlink" title="277_搜寻名人"></a>277_搜寻名人</h2><h2 id="280-摆动排序"><a href="#280-摆动排序" class="headerlink" title="280_摆动排序"></a>280_摆动排序</h2><h2 id="281-锯齿迭代器"><a href="#281-锯齿迭代器" class="headerlink" title="281_锯齿迭代器"></a>281_锯齿迭代器</h2><h2 id="285-二叉搜索树中的中序后继"><a href="#285-二叉搜索树中的中序后继" class="headerlink" title="285_二叉搜索树中的中序后继"></a>285_二叉搜索树中的中序后继</h2><h2 id="286-墙与门"><a href="#286-墙与门" class="headerlink" title="286_墙与门"></a>286_墙与门</h2><h2 id="288-单词的唯一缩写"><a href="#288-单词的唯一缩写" class="headerlink" title="288_单词的唯一缩写"></a>288_单词的唯一缩写</h2><h2 id="291-单词规律-II"><a href="#291-单词规律-II" class="headerlink" title="291_单词规律_II"></a>291_单词规律_II</h2><h2 id="293-翻转游戏"><a href="#293-翻转游戏" class="headerlink" title="293_翻转游戏"></a>293_翻转游戏</h2><h2 id="294-翻转游戏-II"><a href="#294-翻转游戏-II" class="headerlink" title="294_翻转游戏_II"></a>294_翻转游戏_II</h2><h2 id="296-最佳的碰头地点"><a href="#296-最佳的碰头地点" class="headerlink" title="296_最佳的碰头地点"></a>296_最佳的碰头地点</h2><h2 id="298-二叉树最长连续序列"><a href="#298-二叉树最长连续序列" class="headerlink" title="298_二叉树最长连续序列"></a>298_二叉树最长连续序列</h2><h2 id="302-包括全部黑色像素的最小矩形"><a href="#302-包括全部黑色像素的最小矩形" class="headerlink" title="302_包括全部黑色像素的最小矩形"></a>302_包括全部黑色像素的最小矩形</h2><h2 id="305-岛屿数量-II"><a href="#305-岛屿数量-II" class="headerlink" title="305_岛屿数量 II"></a>305_岛屿数量 II</h2><hr>
<h1 id="先后手"><a href="#先后手" class="headerlink" title="先后手"></a>先后手</h1><h2 id="292-Nim-游戏"><a href="#292-Nim-游戏" class="headerlink" title="292_Nim 游戏"></a>292_Nim 游戏</h2><ul>
<li>之前也做过类似的题，但是这跟数组没有多大关系，除非用动态规划</li>
<li>那么这一题，就正式放入新的类别</li>
<li>仔细思考了下<ul>
<li>如果一开始就是4的倍数，那铁定必输，因为对方只要拿的个数和你加起来是4就行，最后永远被对方拿走！</li>
<li>那么相反，如果是<code>4k+1</code>、<code>4k+2</code>、<code>4k+3</code>，那肯定稳赢，只要把多余的数拿走，把稳输的局面留给对方</li>
<li>代码可以再优化下</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool canWinNim(int n) &#123;</span><br><span class="line">        return (n % 4 != 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="LCP"><a href="#LCP" class="headerlink" title="LCP"></a>LCP</h1><ul>
<li>LCP是什么？</li>
<li>在每日一题里面遇到了…<ul>
<li>发现LCP在力扣1917最后面…</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
